<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>注解Annotation的浅析</title>
      <link href="/2019/03/22/zhu-jie-annotation-de-qian-xi/"/>
      <url>/2019/03/22/zhu-jie-annotation-de-qian-xi/</url>
      
        <content type="html"><![CDATA[<p>在我们使用Spring的时候，会使用很多注解，但是对于注解是什么，却还是一知半解，今天就带大家来学习一下java中的元注解。<br><a id="more"></a></p><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>对于很多初次接触的开发者来说应该都会有这个疑惑？<code>annotation</code> 是java5开始引入的新特征，中文名称叫做注解。</p><p>它提供了一种安全的类似注解的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更名了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。</p><p><code>Annotation</code> 像一个修饰符一样，应用于包、类、构造方法、成员方法、成员变量、参数以及本地变量的声明语句中。</p><p>Java注解是附加在代码中的一些元信息。用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在<code>java.lang.annotation</code>包中。</p><h3 id="注解的用处"><a href="#注解的用处" class="headerlink" title="注解的用处"></a>注解的用处</h3><p>1、生成文档。这是最常见的，也是java最早提供的注解。常用的用<code>@Param @return</code>等</p><p>2、跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2 依赖注入，未来java 开发，将大量注解配置，具有很大用处。</p><p>3、在编译时进行格式检查。如<code>@override</code> 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</p><h3 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h3><p>注解本质是一个继承了<code>Annotation 的特殊接口</code>，其具体实现类是Java 运行时生成的动态代理类。而我们通过<code>反射</code>获取注解时，返回的是Java 运行时生成的动态代理对象<code>$Proxy1</code>。通过代理对象调用自定义注解（接口）的方法，会最终调用<code>AnnotationInvocationHandler</code> 的<code>invoke方法</code>。该方法会从<code>memberValues</code> 这个Map 中索引出对应的值。而<code>memberValues</code>的来源是Java 常量池。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><code>java.lang.annotation</code>:提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p><p><code>@Documented</code> 注解是否将包含在JavaDoc中</p><p><code>@Retention</code> 什么时候使用该注解</p><p><code>@Target</code> 注解用于什么地方</p><p><code>@Inherited</code> 是否允许子类继承该注解</p><hr><h4 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h4><p>表示什么时候使用该注解，可用 RetentionPolicy 参数包括。</p><p><code>RetentionPolicy.SOURCE</code>: 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings 都属于这类注解。</p><p><code>RetentionPolicy.CLASS</code>: 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。</p><p><code>RetentionPolicy.RUNTIME</code>：始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p><hr><h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p>表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用 ElementType 参数包括。</p><p><code>ElementType.PACKAGE</code>: 用于描述包</p><p><code>ElementType.TYPE</code>: 用于描述类、接口(包括注解类型) 或enum声明</p><p><code>ElementType.CONSTRUCTOR</code>: 用于描述构造器</p><p><code>ElementType.FIELD</code> : 成员变量、对象、属性（包括enum实例）</p><p><code>ElementType.METHOD</code> : 用于描述方法</p><p><code>ElementType.PARAMETER</code>: 用于描述参数</p><p><code>ElementType.LOCAL_VARIABLE</code> : 用于描述局部变量</p><hr><h4 id="Documented"><a href="#Documented" class="headerlink" title="Documented"></a>Documented</h4><p>一个简单的Annotations 标记注解，表示是否将注解信息添加在java 文档中。</p><hr><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="Inherited"></a>Inherited</h4><p>定义该注释和子类的关系。</p><p><code>@Inherited</code> 元注解是一个标记注解，<code>@Inherited</code> 阐述了某个被标注的类型是被继承的。如果一个使用了<code>@Inherited</code> 修饰的 <code>annotation</code> 类型被用于一个<code>class</code>，则这个<code>annotation</code> 将被用于该<strong><code>class 的子类</code></strong>。</p><hr><h3 id="常见标准的Annotation"><a href="#常见标准的Annotation" class="headerlink" title="常见标准的Annotation"></a>常见标准的Annotation</h3><ol><li>Override</li></ol><p><code>java.lang.Override</code>是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。</p><ol start="2"><li>Deprecated</li></ol><p><code>Deprecated</code> 也是一种标记类型注解。当一个类型或者类型成员使用<code>@Deprecated</code> 修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为<code>@Deprecated</code>，但编译器仍然要报警。</p><ol start="3"><li>SuppressWarnings</li></ol><p><code>SuppressWarning</code> 不是一个标记类型注解。它有一个类型为String[] 的成员，这个成员的值为被禁止的警告名。对于javac 编译器来讲，被-Xlint 选项有效的警告名也同样对<code>@SuppressWarings</code> 有效，同时编译器忽略掉无法识别的警告名。</p><p><code>@SuppressWarnings(&quot;unchecked&quot;)</code></p><hr><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>自定义注解类编写的一些规则:</p><p>Annotation 型定义为<code>@interface</code>, 所有的<code>Annotation</code> 会自动继承<code>java.lang.Annotation</code>这一接口,并且不能再去继承别的类或是接口.</p><p>参数成员只能用public 或默认(default) 这两个访问权修饰.</p><p>参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</p><p>要获取类方法和字段的注解信息，必须通过<font color="red">Java的反射技术</font>来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法.</p><p>注解也可以没有定义成员，不过这样注解就没啥用了.</p><hr><h3 id="自定义注解实例"><a href="#自定义注解实例" class="headerlink" title="自定义注解实例"></a>自定义注解实例</h3><p><code>FruitName.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 水果名称注解 */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>FIELD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">FruitName</span> <span class="token punctuation">{</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>FruitColor.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 水果颜色注解 */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>FIELD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">FruitColor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 颜色枚举     */</span>    <span class="token keyword">public</span> <span class="token keyword">enum</span> Color<span class="token punctuation">{</span> BLUE<span class="token punctuation">,</span>RED<span class="token punctuation">,</span>GREEN<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 颜色属性     */</span>    Color <span class="token function">fruitColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>FruitProvider.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 水果供应者注解 */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>FIELD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">FruitProvider</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 供应商编号     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 供应商名称     */</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 供应商地址     */</span>    <span class="token keyword">public</span> String <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>FruitInfoUtil.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 注解处理器 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FruitInfoUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getFruitInfo</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz<span class="token punctuation">)</span><span class="token punctuation">{</span>        String strFruitName<span class="token operator">=</span><span class="token string">" 水果名称："</span><span class="token punctuation">;</span>        String strFruitColor<span class="token operator">=</span><span class="token string">" 水果颜色："</span><span class="token punctuation">;</span>        String strFruitProvicer<span class="token operator">=</span><span class="token string">"供应商信息："</span><span class="token punctuation">;</span>        Field<span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Field field <span class="token operator">:</span>fields<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>FruitName<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                FruitName fruitName <span class="token operator">=</span> <span class="token punctuation">(</span>FruitName<span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>FruitName<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                strFruitName<span class="token operator">=</span>strFruitName<span class="token operator">+</span>fruitName<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strFruitName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>FruitColor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                FruitColor fruitColor<span class="token operator">=</span> <span class="token punctuation">(</span>FruitColor<span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>FruitColor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                strFruitColor<span class="token operator">=</span>strFruitColor<span class="token operator">+</span>fruitColor<span class="token punctuation">.</span><span class="token function">fruitColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strFruitColor<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>FruitProvider<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                FruitProvider fruitProvider<span class="token operator">=</span> <span class="token punctuation">(</span>FruitProvider<span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>FruitProvider<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                strFruitProvicer<span class="token operator">=</span><span class="token string">" 供应商编号："</span><span class="token operator">+</span>fruitProvider<span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 供应商名称："</span><span class="token operator">+</span>fruitProvider<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 供应商地址："</span><span class="token operator">+</span>fruitProvider<span class="token punctuation">.</span><span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strFruitProvicer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Apple.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> test<span class="token punctuation">.</span>FruitColor<span class="token punctuation">.</span>Color<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 注解使用 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@FruitName</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String appleName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@FruitColor</span><span class="token punctuation">(</span>fruitColor<span class="token operator">=</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">)</span>    <span class="token keyword">private</span> String appleColor<span class="token punctuation">;</span>    <span class="token annotation punctuation">@FruitProvider</span><span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">"陕西红富士集团"</span><span class="token punctuation">,</span>address<span class="token operator">=</span><span class="token string">"陕西省西安市延安路89号红富士大厦"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String appleProvider<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAppleColor</span><span class="token punctuation">(</span>String appleColor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>appleColor <span class="token operator">=</span> appleColor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getAppleColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> appleColor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAppleName</span><span class="token punctuation">(</span>String appleName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>appleName <span class="token operator">=</span> appleName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getAppleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> appleName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAppleProvider</span><span class="token punctuation">(</span>String appleProvider<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>appleProvider <span class="token operator">=</span> appleProvider<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getAppleProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> appleProvider<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">displayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"水果的名字是：苹果"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>FruitRun.java</code></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 输出结果 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FruitRun</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FruitInfoUtil<span class="token punctuation">.</span><span class="token function">getFruitInfo</span><span class="token punctuation">(</span>Apple<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><p>水果名称：Apple<br>水果颜色：RED<br>供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延安路89号红富士大厦</p>]]></content>
      
      
      <categories>
          
          <category> 注解 </category>
          
          <category> annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
            <tag> annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis代码生成器</title>
      <link href="/2019/03/17/mybatis-dai-ma-sheng-cheng-qi/"/>
      <url>/2019/03/17/mybatis-dai-ma-sheng-cheng-qi/</url>
      
        <content type="html"><![CDATA[<p>MyBatis Generator：代码生成器，帮助我们自动生成基本的增、删、改、查的代码，方便我们开发，减少不必要的体力活动。<br><a id="more"></a></p><p>当数据库表的字段比较少的时候，写起来还能接受，一旦字段过多或者需要在很多表中写这些基本方法时，就会很麻烦，不仅需要很大的代码量，而且字段过多时很容易出现错误。</p><p>作为一个优秀的程序员，”懒”是很重要的优点。我们不仅要会写代码，还要会利用工具生成代码。Mybatis的开发团队提供了一个很强大的代码生成器——MyBatis Generator，后文中使用缩写MBG来代替。</p><p>MBG通过丰富的配置可以生成不同类型的代码，代码包含了数据库表对应的实体类、Mapper接口类、MapperXML文件和Example对象等，这些代码文件中几乎包含了全部的单表操作方法，使用MBG可以极大程度上方便我们使用MyBatis，还可以减少很多重复操作。</p><p>官方文档：<a href="http://www.mybatis.org/generator/" target="_blank" rel="noopener">http://www.mybatis.org/generator/</a></p><hr><h3 id="非图形化方式"><a href="#非图形化方式" class="headerlink" title="非图形化方式"></a>非图形化方式</h3><p>首先，我讲解官方推出的方式，<a href="https://github.com/mybatis/generator" target="_blank" rel="noopener">mybatis-generator</a>有三种用法：命令行、eclipse插件、maven插件。个人觉得maven插件最方便，可以在eclipse/intellij idea等ide上可以通用。</p><p>不管哪种方式，都需要学会MBG的xml配置文件，下面，我们来学习一下吧~~~</p><h4 id="XML配置详解"><a href="#XML配置详解" class="headerlink" title="XML配置详解"></a>XML配置详解</h4><p>首先按照MBG的要求添加XML的文件头：</p><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;!DOCTYPE generatorConfiguration          PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;          &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</code></pre><p>在文件头之后，需要加上XML文件的根节点：<code>generatorConfiguration</code></p><pre><code>&lt;generatorConfiguration&gt;    &lt;!--其他配置内容--&gt;&lt;/generatorConfiguration&gt;</code></pre><p>以上两部分内容是MBG必备的基本信息，后面是MBG中的自定义配置部分。下面介绍 generatorConfiguration 标签下的 3 个子级标签</p><p>分别是：<code>properties</code>、<code>classPathEntry</code> 和 <code>context</code>。在配置这三个标签时，注意它们的顺序，必须和这里列举的顺序一致才行！！！</p><hr><p>第一个是properties标签。这个标签用来指定外部的属性元素，最多可以配置一个，也可以不配置。</p><p>properties标签用于指定一个需要在配置中解析使用的外部属性文件，引入属性文件后，可以在配置中使用 <code>${property}</code> 这种形式的引用，通过这种方式引用属性文件中的属性值，对于后面需要配置的JDBC信息会很有用。</p><p>properties标签包括 resource 和 url 两个属性，只能使用其中一个属性来指定，同时出现则会报错。</p><ul><li><p>resource：指定classpath下的属性文件，类似：com/liuzhuo/mybatis/generatorConfig.properties 这样的属性值。</p></li><li><p>url：指定文件系统上的特定位置，例如：file:///E:/myfolder/generatorConfig.properties</p></li></ul><hr><p>第二个是 classPathEntry 标签。这个标签可以配置多个，也可以不配置。</p><p>classPathEntry标签最常见的用法是通过属性 location指定驱动的路径，代码如下：</p><p><code>&lt;classPathEntry location=&quot;E:\mysql\mysql-connector-java-5.1.29.jar&quot;/&gt;</code></p><hr><p>第三个是 context 标签。这个标签是要重点讲解的，该标签至少配置一个，可以配置多个。</p><p>context标签用于指定生成一组对象的环境。例如指定要连接的数据库，要生成对象的类型和要处理的数据库中的表。运行MBG的时候还可以指定要运行的context。</p><p>context标签只有一个必选属性id，用来唯一确定该标签，该id属性可以运行MBG时使用。此外还有几个可选属性：</p><ul><li>defaultModelType：这个属性很重要，定义了MBG如何生成实体类。该属性可选值有：</li></ul><p>（1）conditional：默认值，和下面的 hierarchical 类似，如果一个表的主键只有一个字段，那么不会为该字段生成单独的实体类，而是会将该字段合并到基本实体类中。</p><p>（2）flat：该模型只为每张表生成一个实体类。这个实体类包含表中的所有字段。这种模型最简单，推荐使用。</p><p>（3）hierarchical：如果表有主键，那么该模型会产生一个单独的主键实体类，如果表还有BLOB字段，则会为表生成一个包含所有BLOB字段的单独的实体类，然后为所有其他的字段另外生成一个单独的实体类。MBG会在所有生成的实体类之间维护一个继承关系。</p><ul><li>targetRuntime：此属性用于指定生成的代码的运行环境，支持以下可选值</li></ul><p>（1）MyBatis3：默认值</p><p>（2）MyBatis3Simple：这种情况不会生成与Example相关的方法。</p><ul><li>introspecedColumnImpl：该参数可以指定扩展 org.mybatis.generator.api.Introspected Column类的实现类。</li></ul><hr><p>一般情况下，使用如下配置即可。</p><p><code>&lt;context id=&quot;Mysql&quot; defaultModeType=&quot;flat&quot;&gt;</code></p><hr><p>MBG配置中的其他几个标签基本上都是 context的子标签，这些子标签（有严格的配置顺序）包括以下几个：</p><ul><li><p>property（0个或多个）</p></li><li><p>plugin（0个或多个）</p></li><li><p>commentGenerator（0个或多个）</p></li><li><p>jdbcConnection（1个）</p></li><li><p>javaTypeResolver（0个或多个）</p></li><li><p>javaModelGenerator（1个）</p></li><li><p>sqlMapGenerator（0个或多个）</p></li><li><p>javaClientGenerator（0个或多个）</p></li><li><p>table（1个或多个）</p></li></ul><p>下面逐条介绍这些重要的标签。</p><hr><h5 id="property标签"><a href="#property标签" class="headerlink" title="property标签"></a>property标签</h5><p>在介绍property标签之前，先来了解一下数据库中的<strong>分隔符</strong>。</p><p>举一个简单的例子，假设数据库中有一个表，名为 <code>user info</code> ，注意这个名字，user 和 info 中间存在一个空格。如果直接写如下查询，在数据库执行这个查询时会报错。</p><p><code>select * from user info</code></p><p>可能会提示 <code>user</code> 表不存在或者user附件有语法错误，这种情况下该怎么写 <code>user info</code>表呢？</p><p>这时，就会用到<strong>分隔符</strong>了，在MySQL中可以使用反单引号 “ ` “ 作为分隔符，例如：</p><pre><code>`user info`</code></pre><p>在SQL Server中则是 [user info]。通过分隔符可以将其中的内容作为一个整体的字符串进行处理，当SQL中有数据库关键字时，使用反单引号括住关键字，可以避免数据库产生错误。</p><p>之所以先介绍分隔符，就是因为property标签中包含以下3个和分隔符相关的属性。</p><ul><li><p>autoDelimitKeywords</p></li><li><p>beginningDelimiter</p></li><li><p>endingDelimiter</p></li></ul><p>从名字可以看出，第一个是自动给关键字添加分隔符的属性。MBG中维护了一个关键字列表，当数据库中的字段或表与这些关键字一样时，MBG会自动给这些字段或表添加分隔符。关键字列表可以查看MBG中的 org.mybatis.generator.internal.db.SqlReservedWords类。</p><p>后面两个属性很简单，一个是配置前置分隔符的属性，一个是配置后置分隔符的属性。在MySQL中，两个分隔符都是 “ ` “，在SQL Server中分别为 “ [ “ 和 “ ] “。</p><p>MySQL中的property配置写法如下：</p><pre><code>&lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;   &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt;   &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;   &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;   &lt;!--其他配置--&gt;&lt;/context&gt;</code></pre><p>除了上面3个和分隔符相关的属性外，还有以下3个属性。</p><ul><li><p>javaFileEncoding</p></li><li><p>javaFormatter</p></li><li><p>xmlFormatter</p></li></ul><p>属性 javaFileEncoding 设置要使用的Java文件的编码，例如 GBK 或 UTF-8。默认使用当前运行环境的编码。后面的不常用，就不介绍了。</p><hr><h5 id="plugin标签"><a href="#plugin标签" class="headerlink" title="plugin标签"></a>plugin标签</h5><p>plugin标签可以配置0个或多个，个数不受限制。</p><p>plugin标签用来定义一个插件，用于扩展或修改通过MBG生成的代码。该插件将按照在配置中的顺序执行。MBG插件使用的情况并不多，如果对开发插件有兴趣，可以参考MBG文档，或者参考下面要介绍的缓存插件的例子，这个例子包含在MBG插件中。</p><p>下面要介绍的缓存插件的全限定名称为： org.mybatis.generator.plugins.CachePlugin。</p><p>这个插件可以在生成的SQL XML映射文件中增加一个 cache 标签。只有当targetRuntime 为 MyBatis3时，该插件才有效。</p><p>该插件接受下列可选属性。</p><ul><li><p>cache_eviction</p></li><li><p>cache_flushInterval</p></li><li><p>cache_readOnly</p></li><li><p>cache_size</p></li><li><p>cache_type</p></li></ul><p>配置方法如下：</p><pre><code>&lt;plugin type=&quot;org.mybatis.generator.plugins.CachePlugin&quot;&gt;   &lt;property name=&quot;cache_eviction&quot; value=&quot;LRU&quot;/&gt;   &lt;property name=&quot;cache_size&quot; value=&quot;1024&quot;/&gt;&lt;/plugin&gt;</code></pre><p>添加这个配置后，生成的Mapper.xml文件中会增加如下的缓存相关配置。</p><pre><code>&lt;cache eviction=&quot;LRU&quot; size=&quot;1024&quot;&gt;&lt;/cache&gt;</code></pre><hr><h5 id="commentGenerator标签"><a href="#commentGenerator标签" class="headerlink" title="commentGenerator标签"></a>commentGenerator标签</h5><p>该标签用来配置如何生成注释信息，最多可以配置1个。</p><p>该标签有一个可选属性 type，可以指定用户的实现类，该类需要实现 org.mybatis.generator.api.CommentGenerator接口，而且必有一个默认空的构造方法。</p><p>type属性接收默认的特殊值：DEFAULT，使用默认的实现类 org.mybatis.generator.internal.DefaultCommentGenerator。</p><p>默认的实现类中提供了三个可选属性，需要通过property属性进行配置。</p><ul><li><p>suppressAllComments：阻止生成注释，默认为false。</p></li><li><p>suppressDate：阻止生成的注解包含时间戳，默认为false。</p></li><li><p>addRemarkComments：注释是否添加数据库表的备注信息，默认为false。</p></li></ul><p>一般情况下，由于MBG生成的注解信息没有任何价值，而且时间戳的情况下每次生成的注释都不一样，使用版本控制的时候每次都会提交，因而一般情况下都会屏蔽注释信息，可以如下配置：</p><pre><code>&lt;commentGenerator&gt;   &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;   &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;&lt;/commentGenerator&gt;</code></pre><h5 id="jdbcConnection标签"><a href="#jdbcConnection标签" class="headerlink" title="jdbcConnection标签"></a>jdbcConnection标签</h5><p>jdbcConnection标签用于指定MBG要连接的数据库信息，该标签必选，并且只能有一个。</p><p>配置该标签需要注意，如果JDBC驱动不在classpath下，就要通过 classPathEntry 标签引入 jar 包，这里推荐将jar包放到classpath下，或者参考前面classPathEntry配置的JDBC驱动的方法。</p><p>该标签有两个必选属性。</p><ul><li><p>driverClass：访问数据库的JDBC驱动程序的完全限定类名。</p></li><li><p>connectionURL：访问数据库的JDBC连接URL。</p></li></ul><p>该标签还有两个可选属性。</p><ul><li><p>userId：访问数据库的用户ID。</p></li><li><p>password：访问数据库的密码。</p></li></ul><p>此外，该标签还可以接受多个property子标签，这里配置的property属性都会添加到JDBC驱动的属性中（使用property标签的name属性反射赋值）。</p><p>这个标签配置起来非常容易，基本配置如下：</p><pre><code>&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot;                userId=&quot;root&quot;                password=&quot;&quot;&gt;&lt;/jdbcConnection&gt;</code></pre><p>Oracle的配置：</p><pre><code>&lt;jdbcConnection driverClass=&quot;oracle.jdbc.driver.OracleDriver&quot;                connectionURL=&quot;jdbc:oracle:thin:@//localhost:1521/oracle&quot;                userId=&quot;mybatis&quot;                password=&quot;mybatis&quot;&gt;    &lt;property name=&quot;remarksReporting&quot; value=&quot;true&quot;/&gt;&lt;/jdbcConnection&gt;</code></pre><h5 id="javaTypeResolver标签"><a href="#javaTypeResolver标签" class="headerlink" title="javaTypeResolver标签"></a>javaTypeResolver标签</h5><p>该标签的配置用来指定 <code>JDBC类型</code> 和 <code>Java类型</code> 如何转换，最多可以配置一个。</p><p>该标签提供了一个可选的属性type。另外，和commentGenerator类似，该标签提供了默认的实现 DEFAULT ，一般情况下使用默认即可，需要特殊处理的情况可以通过其他标签配置来解决，不建议修改该属性。</p><p>该属性还有一个可以配置的property标签，可以配置的属性为：<code>forceBigDecimals</code>，该属性可以控制是否强制将 DECIMAL 和 NUMERIC 类型的JDBC 字段转换为JAVA类型的java.math.BigDecimal，默认值为false，一般不需要配置。</p><p>默认情况下的转换规则如下：</p><ul><li><p>如果精度 &gt; 0 或者 长度 &gt; 18 ，就使用 java.math.BigDecimal。</p></li><li><p>如果精度 = 0 并且 10&lt;=长度&lt;=18，就使用 java.lang.Long。</p></li><li><p>如果精度 = 0 并且 5&lt;=长度&lt;=9，就使用 java.lang.Integer。</p></li><li><p>如果精度 = 0 并且 长度&lt;5，就使用 java.lang.Short。</p></li></ul><p>如果将 forceBigDecimals 设置为 true，那么一定会使用 java.math.BigDecimal类型。</p><pre><code>&lt;javaTyepResolver&gt;   &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;&lt;/javaTyepResolver&gt;</code></pre><h5 id="javaModelGenerator标签"><a href="#javaModelGenerator标签" class="headerlink" title="javaModelGenerator标签"></a>javaModelGenerator标签</h5><p>该标签用来控制生成的实体类，根据context标签中配置的 defaultModelType属性值的不同，一个表可能会对应生成多个不同的实体类。一个表对应多个类时使用并不方便，所以前面推荐使用 flat，保证一个表对应一个实体类。该标签必须配置一个，并且最多配置一个。</p><p>该标签只有两个必选属性。</p><ul><li><p>targetPackage：生成实体类存放的包名。一般就是放在该包下，实际还会受到其他配置的影响。</p></li><li><p>targetProject：指定目标项目路径，可以使用相对路径或绝对路径。</p></li></ul><p>该标签还支持以下几个property子标签属性。</p><ul><li><p>constructorBased：该属性只对 <code>MyBatis3</code> 有效，如果为 true就会使用构造方法入参，如果为 false就会使用setter方式。默认为false。</p></li><li><p>enableSubPackages：如果为true，MBG会根据 catalog 和 schema 来生成子包。如果为 false 就会直接使用 targetPackage属性。默认为false。</p></li><li><p>immutable：用来配置实体类属性是否可变。如果设置为 true，那么constructorBased不管设置成什么，都会使用构成方法入参，并且不会生成setter方法。如果false，实体类属性就可以改变。默认为false。</p></li><li><p>rootClass：设置所有实体类的基类。如果设置，则需要使用类的全限定名称。并且，如果MBG能够加载 rootClass（可以通过classPathEntry引入jar包，或者classpath方式），那么MBG不会覆盖和父类中完全匹配的属性。匹配规则如下：</p></li></ul><p>（1）属性名完全相同</p><p>（2）属性类型相同</p><p>（3）属性有getter方法</p><p>（4）属性有setter方法</p><ul><li>trimStrings：判断是否对数据库查询结果进行trim操作，默认值为false。如果设置为 true就会生成如下代码：<pre><code>public void setUsername(String username){  this.username = username == null ? null : username.trim();}</code></pre></li></ul><p>javaModelGenerator配置如下：</p><pre><code>&lt;javaModelGenerator targetPackage=&quot;com.liuzhuo.model&quot;                    targetProject=&quot;src\main\java&quot; &gt;  &lt;!--相对路径--&gt;     &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;     &lt;property name=&quot;trimStrings&quot; values=&quot;false&quot; /&gt;&lt;/javaModelGenerator&gt;</code></pre><h5 id="sqlMapGenerator标签"><a href="#sqlMapGenerator标签" class="headerlink" title="sqlMapGenerator标签"></a>sqlMapGenerator标签</h5><p>该标签用于配置SQL映射生成器（Mapper.xml文件）的属性，该标签可选，最多配置一个。</p><p>如果targetRuntime设置为MyBatis3，则只有当javaClientGenerator配置需要XML时，该标签才必须配置一个。如果没有配置：javaClientGenerator，则使用以下规则。</p><ul><li><p>如果指定了一个sqlMapGenerator，那么MBG将只生成XML的SQL映射文件和实体类。</p></li><li><p>如果没有指定sqlMapGenerator，那么MBG将只生成实体类。</p></li></ul><p>该标签只有两个必选属性。</p><ul><li><p>targetPackage：生成SQL映射文件（XML文件）存放的包名。一般就是放在该包下，实际还会受到其他配置的影响。</p></li><li><p>targetProject：指定目标项目路径，可以使用相对路径或绝对路径。</p></li></ul><p>该标签还有一个可选的property子标签属性：enableSubPackages，如果为true，MBG会根据catalog和schema来生成子包。如果为false就会直接用targetPackage属性，默认为false。</p><p>sqlMapGenerator配置如下：</p><pre><code>&lt;sqlMapGenerator targetPackage=&quot;com.liuzhuo.mapper&quot;                 targetProject=&quot;E:\Myproject\src\main\resources&quot;&gt;  &lt;!--绝对路径--&gt;      &lt;property name=&quot;enableSubPackages&quot; values=&quot;false&quot; /&gt;&lt;/sqlMapGenerator&gt;</code></pre><h5 id="javaClientGenerator标签"><a href="#javaClientGenerator标签" class="headerlink" title="javaClientGenerator标签"></a>javaClientGenerator标签</h5><p>该标签用于配置Java客户端生成器（Mapper接口）的属性，该标签可选，最多配置一个。如果不配置该标签，就不会生成Mapper接口。</p><p>该标签有以下3个必选属性。</p><ul><li>type：用于选择客户端代码（Mapper接口）的属性，用户可以自定义实现，需要继承 org.mybatis.generator.codegen.AbstractJavaClientGenerator类，必须有一个默认空的构造方法。该属性提供了以下预设的代码生成器，首先根据context的targetRuntime分成两类（不考虑iBATIS）。</li></ul><p>（1）MyBatis3</p><pre><code>ANNOTATEDMAPPER: 基于注解的Mapper接口，不会有对应的XML映射文件。MIXEDMAPPER：    XML和注解的混合模式，上面这种情况中的SQL Provider注解方法会被XML方式替代。XMLMAPPER：      所有方法都在XML中，接口调用依赖XML文件。</code></pre><p>（2）MyBatis3Simple</p><pre><code>ANNOTATEDMAPPER: 基于注解的Mapper接口，不会有对应的XML映射文件。XMLMAPPER：      所有方法都在XML中，接口调用依赖XML文件。</code></pre><ul><li><p>targePackage：生成Mapper接口存放的包名。一般就是放在该包下，实际还会受到其他配置的影响。</p></li><li><p>targetProject：指定目标项目路径，可以使用相对路径或绝对路径。</p></li></ul><p>javaClientGenerator标签配置：</p><pre><code>&lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.liuzhuo.mapper&quot;                     targetProject=&quot;src\main\java&quot; /&gt;    &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;&lt;/javaClientGenerator&gt;</code></pre><h5 id="table标签"><a href="#table标签" class="headerlink" title="table标签"></a>table标签</h5><p>table标签是最重要的一个标签，该标签用于配置需要通过内省数据库的表，只有在table中配置过的表，才能经过上述其他配置生成最终的代码，该标签至少要配置一个，可以配置多个。</p><p>table标签有一个必选属性 <code>tableName</code> ，该属性指定要生成的表名，可以使用SQL通配符匹配多个表。</p><p>例如要生成全部的表，可以配置如下：</p><p><code>&lt;table tableName=&quot;%&quot; /&gt;</code></p><p>table标签包含多个可选属性。</p><ul><li><p>schema：数据库的schema，可以使用SQL通配符匹配。如果设置了该值，生成SQL的表名会变成如 schema.tableName的形式。</p></li><li><p>catalog：数据库的catalog，如果设置了该值，生成SQL的表名会变成如：catalog.tableName的形式。</p></li><li><p>alias：如果指定，这个值会用在生成的 select 查询SQL表的别名和列名上，例如 alias_actualColumnName（别名_实际列名）。</p></li><li><p>domainObjectName：生成对象的基本名称。如果没有指定，MBG会自动根据表名来生成名称。</p></li><li><p>enableXXX：XXX代表多种SQL方法，该属性用来指定是否生成对应的XXX语句。</p></li><li><p>selectByPrimaryKeyQueryId：DBA跟踪工具中会用到，具体请参考详细文档。</p></li><li><p>selectByExampleQueryid：DBA跟踪工具中会用到，具体请参考详细文档。</p></li><li><p>modelType：和context的defaultModelType含义一样，这里可以针对表进行配置，胡覆盖defaultModelType的配置。</p></li><li><p>escapeWildcards：表示查询列是否对 schema和表名中的SQL通配符（ _ 和 % ）进行转义。对于某些驱动，当 schema或表名中包含SQL通配符时，转义是必须的。有一些驱动则需要将下画线进行转义，例如：MY_TABLE。默认值是 false。</p></li><li><p>delimitidentifiers：是否给标识符增加分隔符。默认是false。当 catalog、schema、tableName中包含空白时，默认为true。</p></li><li><p>delimitAllColumns：是否对所有列添加分隔符。默认为 false。</p></li></ul><hr><p>除了 property 子标签外， table 还包含以下子标签。</p><ul><li><p>generatedKey （0个或 多个）</p></li><li><p>columnRenamingRule（0 个或 多个）</p></li><li><p>columnOverride （0个或多个）</p></li><li><p>ignoreColumn （0个或多个）</p></li></ul><hr><p>generatedKey：该标签用来指定自动生成主键的属性。</p><p>该标签包含以下两个必选属性。</p><ul><li><p>column：生成列的列名</p></li><li><p>sqlStatement：返回新值的SQL语句。如果这是一个identity列，则可以使用其中一个预定义的特殊值，预定义值如下：</p></li></ul><p>（1） Cloudscape </p><p>（2）DB2</p><p>（3）DB2_MF</p><p>（4）Derby </p><p>（5）HSQLDB</p><p>（6）Informix</p><p>（7）MySQL</p><p>（8）SQL Server</p><p>（9）SYBASE</p><p>（10）JDBC：使用该值时，Mybatis会使用JDBC标准接口来获取值，这是一个独立于数据库获取标识列中的值的方法。</p><p>该标签还包含两个可选属性。</p><ul><li><p>identity：当设置为 true 时，该列会被标记为 identity 井且 selectKey标签会被插入在 insert后面；当设置为 false时，selectKey标签会被插入在 insert前面面。</p></li><li><p>type： type = post 且 identity=true 时，生成的 selectKey 中 order=AFTER；当type=pre时，identity只能为false，生成selectKey中的 order=BEFORE。</p></li></ul><hr><p>table的示例：</p><pre><code>&lt;table tableName=&quot;user login info&quot; domainObjectName= &quot;UserLogininfo&quot;&gt;       &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; /&gt;&lt;/table&gt; </code></pre><p>改配置生成的对应的insert方法如下：</p><pre><code>&lt;insert id=&quot;insert&quot; parameterType=&quot;com.liuzhuo.model.UserLogininfo&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;            SELECT LAST INSERT ID ()     &lt;/selectKey&gt;     insert into `user login info` (Id, username , logindate , loginip)     values (#{id,jdbcType=INTEGER} , #{username , jdbcType=VARCHAR} ,             #{logindate,jdbcType=TIMESTAMP}            #{loginip,jdbcType=VARCHAR}) &lt;/ insert&gt; </code></pre><hr><h4 id="完整的配置"><a href="#完整的配置" class="headerlink" title="完整的配置"></a>完整的配置</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;classPathEntry            location=&quot;D:\mysql-connect-jar\mysql-connector-java-5.1.39.jar&quot;/&gt;    &lt;context id=&quot;mySqlContext&quot; targetRuntime=&quot;MyBatis3&quot;              defaultModelType=&quot;flat&quot;&gt;        &lt;property name=&quot;begnningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot;                        userId=&quot;root&quot;                        password=&quot;&quot;/&gt;        &lt;javaModelGenerator targetPackage=&quot;com.liuzhuo.entity&quot;                            targetProject=&quot;src\main\java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.liuzhuo.mapper&quot;                         targetProject=&quot;src\main\resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;javaClientGenerator targetPackage=&quot;com.liuzhuo.mapper&quot;                             targetProject=&quot;src\main\java&quot;                             type=&quot;MIXEDMAPPER&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;!--&lt;table tableName=&quot;T_FEE_AGTBILL&quot; domainObjectName=&quot;FeeAgentBill&quot;               enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;               enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;               selectByExampleQueryId=&quot;false&quot;/&gt;--&gt;        &lt;table tableName=&quot;student&quot; domainObjectName=&quot;Student&quot;&gt;              &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>有关配置有几点重要说明。</p><p>（1）context属性 targetRuntime 设置为 MyBatis3Simple，可以避免生成与Example相关的代码和方法，如果需要Example相关的代码，则设置为：MyBatis3.</p><p>（2）context属性 defaultModelType 设置为 flat，目的是使每个表只生成一个实体类，当没有复杂的类继承时，使用起来更方便。</p><p>（3）因为此处使用的数据库为MySQL，所以前后分隔符都设置为 “ ` “。</p><hr><h4 id="运行MyBatis-Generator"><a href="#运行MyBatis-Generator" class="headerlink" title="运行MyBatis Generator"></a>运行MyBatis Generator</h4><p>MBG提供了很多种运行方式，常用的有以下几种：</p><ul><li><p>使用java编写代码运行</p></li><li><p>从命令提示符运行</p></li><li><p>使用 Maven Plugin运行</p></li><li><p>使用 Eclipse插件运行</p></li></ul><hr><h5 id="使用java编写方式"><a href="#使用java编写方式" class="headerlink" title="使用java编写方式"></a>使用java编写方式</h5><p>在写代码之前，需要先把MBG的jar包添加到项目当中。</p><p>第一种方式是，从地址：<a href="https://github.com/mybatis/generator/releases" target="_blank" rel="noopener">https://github.com/mybatis/generator/releases</a> 下载jar包。</p><p>第二种方式是，使用Maven方式直接引入依赖，在pom.xml中添加如下依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator&lt;/artifactId&gt;    &lt;version&gt;1.3.7&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>在MyBatis项目中添加 <code>com.mybatis.generator</code>包，创建Generator.java类。</p><pre><code>public class Generator {   public static void main(String[] args) throws Exception{    //MBG执行过程中的警告信息    List&lt;String&gt; warning = new ArrayList&lt;String&gt;();    //当生成的代码重复时，覆盖原代码    boolean overwrite = true;    //读取MBG配置文件    InputStream is = Generator.class.getResourceAsStream(&quot;/generator/generatorConfig.xml&quot;);    ConfigurationParser cp = new ConfigurationParser(warnings);    Configuration config = cp.parseConfiguration(is);    is.close();    DefaultShellCallback callback =  new DefaultShellCallback(overwrite);   //创建MBG   MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,callback,warnings);   //执行生成代码   myBatisGenerator.generate(null);   //输出警告信息   for(Strng warning : warnings) {        System.out.println(warning);      }  }}</code></pre><p>使用Java编码方式运行的好处是，generatorConfig.xml配置的一些特殊的类（如commentGenerator 标签中 type 属性配置的 MyCommentGenerator 类）只要在当前项目中，或者在当前项目的 classpath 中， 就可以直接使用。使用其他方式时都需要特别配置才能在MBG执行过程中找到 MyCommentGenerator 类并实例化，否则都会由于找不到这个类而抛出异常。</p><h5 id="从命令提示符运行"><a href="#从命令提示符运行" class="headerlink" title="从命令提示符运行"></a>从命令提示符运行</h5><p>从命令提示符运行就必须使用 jar包，将这个jar包与generatorConfig.xml文件放在一起。从这里就可以体会到为什么说这种配置方式不方便了，因为需要修改generatorConfig.xml配置文件。</p><p>将 MySQL JDBC 驱动 （如 mysql-connector java-5.1.38.jar ）放到当前目录中，然后在配置文件中添加classPathEntry：</p><pre><code>&lt;generatorConfiguration&gt;&lt;classPathEntry location=&quot;mysql-connector java-5.1.38.jar&quot;/&gt;&lt;context id=&quot;MySqlContext&quot; defaultModelTyp=&quot;flat&quot;&gt;  &lt;!--其他原有配置--&gt;&lt;/context&gt;&lt;/generatorConfiguration&gt; </code></pre><p>除此之外，在当前目录中添加src文件夹，在src中再添加 main文件夹，main文件夹中添加 java 和 resources文件夹。<br><img src="/images/mybatis/QQ截图20190317175506.png" style="width:50%"></p><p>下面介绍一下MBG命令行可以接受的几个参数：</p><ul><li><p>-configfile fileName ：指定配置文件的名称。</p></li><li><p>-overwrite(可选)：指定了该参数后，如果生成的java文件已经存在同名的文件，新生成的文件则会覆盖原有的文件。否则，会新生成一个唯一的名字。</p></li><li><p>-verbose（可选）：指定该参数，执行过程中会输出到控制台。</p></li><li><p>-forceJavaLogging（可选）：指定该参数，MBG将会使用Java日志记录而不会使用Log4J，即使Log4J在运行时的类路径中。</p></li><li><p>contextids context1,context2,···(可选)：指定该参数，逗号隔开这些的context会被执行。</p></li><li><p>tables table1,table2,···(可选)：指定该参数，逗号隔开的这些表会被运行。</p></li></ul><hr><pre><code>java -jar mybatis-generator-core-1.3.3.jar -configfile generatorConfig.xmljava -Dfile.encoding=UTF-8 -jar mybatis-generator-core-1.3.3.jar -configfile generatorConfig.xml -overwrite</code></pre><hr><h5 id="使用Maven-Plugin运行"><a href="#使用Maven-Plugin运行" class="headerlink" title="使用Maven Plugin运行"></a>使用Maven Plugin运行</h5><p>使用 Maven Plugin 插件方式和 java编码方式类似，都是和项目绑定在一起的，当需要引用其他类时，需要给 Maven插件添加依赖，否则找不到类。</p><p>在pom.xml文件中添加插件配置：</p><pre><code>    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;            &lt;groupid&gt;org.mybatis.generator&lt;/groupid&gt;             &lt;artifactid&gt;mybatis-generator-maven-plugin&lt;/artifactid&gt;             &lt;version&gt;l.3.3&lt;/version&gt;             &lt;configuration&gt;                  &lt;configurationFile&gt;                           ${basedir}/src/main/resources/generator/generatorConfig.xml                  &lt;/configurationFile&gt;                  &lt;overwrite&gt;true&lt;/overwrite&gt;                 &lt;verbose&gt;true&lt;/verbose&gt;             &lt;/configuration&gt;             &lt;dependencies&gt;                  &lt;dependency&gt;                      &lt;groupid&gt;mysql&lt;/groupid&gt;                      &lt;artifactid&gt;mysql-connector-java&lt;/artifactid&gt;                      &lt;version&gt;5.l.38&lt;/version&gt;                  &lt;/dependency&gt;                  &lt;dependency&gt;                      &lt;groupid&gt;com.liuzhuo&lt;/groupid&gt;                      &lt;artifactid&gt;mybatis&lt;/artifactid&gt;                      &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;                   &lt;/dependency&gt;             &lt;/dependencies&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>这里<code>&lt;configuration&gt;</code>就和命令行的参数一样，不用讲了，特殊之处在于插件中的<code>&lt;dependencies&gt;</code>，在generatorConfig.xml配置文件中，没有通过classPathEntry方式配置 JDBC驱动了，这里通过添加依赖将 JDBC驱动添加到了MBG的classpath中，另外还添加了当前项目的依赖。</p><p><strong>需要特别注意的是：</strong>当前项目必须执行 mvn install（通过Maven命令将当前项目安装到本地仓库），否则会找不到当前项目的依赖。</p><p>配置好插件后，可以执行：</p><p><code>mvn mybatis-generator:generate</code></p><hr><h5 id="Eclipse插件方式"><a href="#Eclipse插件方式" class="headerlink" title="Eclipse插件方式"></a>Eclipse插件方式</h5><p>（1）安装Eclipse插件：</p><p>从MBG的发布页面 <a href="https://github.com/mybatis/generator/releases" target="_blank" rel="noopener">https://github.com/mybatis/generator/releases</a> 中下载插件：</p><p><code>org.mybatis.generator.eclipse.site-1.3.7.201807042148.zip</code><br><img src="/images/mybatis/QQ截图20190317182045.png"></p><p>下载好插件后，在Eclipse中选中菜单 Help 中的 Install New Software：</p><p>点击Add按钮，在弹出的窗口中选择 Archive，选择下载完成的 MBG 插件，输入 Name MBG后，点击OK。</p><p>从下拉列表中选择全部的 MyBatis Generator，点击Next，一步步完成安装，安装完成后重启Eclipse。</p><p>（2）使用Eclipse插件</p><p>Eclipse 插件的运行方式有点特殊， JDBC 驱动需要通过 classPathEntry 进行配置，其他定制类只要在当前项目或当前项目classpath中即可使用。</p><pre><code>&lt;generatorConfiguration&gt;    &lt;classPathEntry            location=&quot;D:\mysql-connect-jar\mysql-connector-java-5.1.39.jar&quot;/&gt;    &lt;context id=&quot;mySqlContext&quot; targetRuntime=&quot;MyBatis3&quot;              defaultModelType=&quot;flat&quot;&gt;        &lt;property name=&quot;begnningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;!--其他配置--&gt;&lt;/generatorConfiguration&gt;</code></pre><p>(3) 运行</p><p>完成上述修改后，在配置文件中单击鼠标右键，选择：<code>Generate MyBatis/iBATIS Artifacts</code></p><p>点击 Generate MyBatis 后就会自动生成代码。</p><hr><h5 id="使用IDEA的方式"><a href="#使用IDEA的方式" class="headerlink" title="使用IDEA的方式"></a>使用IDEA的方式</h5><p>我自己使用的是IDEA的方式。</p><p>随便创建一个 Springboot的web项目：</p><p>我填写的是：<br>groupId：com.generator<br>artifactId：mybatis</p><p>项目结构：<br><img src="/images/mybatis/QQ截图20190317183413.png"></p><p>pom.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;mybatis&lt;/name&gt;    &lt;description&gt;generator-mybatis&lt;/description&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;mysql&lt;/groupId&gt;                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                        &lt;version&gt;5.1.39&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>在resources中，添加：generator.properties 文件：</p><pre><code>jdbc.driverClass=com.mysql.jdbc.Driverjdbc.connectionURL=jdbc:mysql://localhost:3306/mybatisjdbc.userId=rootjdbc.password=123456jdbc.database=mybatis</code></pre><p>generatorConfig.xml文件中：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--导入属性配置 --&gt;    &lt;properties resource=&quot;generator.properties&quot;&gt;&lt;/properties&gt;    &lt;!--指定特定数据库的jdbc驱动jar包的位置 --&gt;    &lt;!--&lt;classPathEntry location=&quot;${jdbc.driverLocation}&quot;/&gt;--&gt;    &lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;!--jdbc的数据库连接 --&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection                driverClass=&quot;${jdbc.driverClass}&quot;                connectionURL=&quot;${jdbc.connectionURL}&quot;                userId=&quot;${jdbc.userId}&quot;                password=&quot;${jdbc.password}&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类            targetPackage     指定生成的model生成所在的包名            targetProject     指定在该项目下所在的路径        --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.liuzhuo.model.student&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- 是否对model添加 构造函数 --&gt;            &lt;property name=&quot;constructorBased&quot; value=&quot;true&quot;/&gt;            &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;            &lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;            &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.liuzhuo.mapper.student&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码                type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和 基于注解的Mapper对象                type=&quot;MIXEDMAPPER&quot;,生成基于注解的Java Model 和相应的Mapper对象                type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口        --&gt;        &lt;javaClientGenerator targetPackage=&quot;com.liuzhuo.mapper.student&quot; targetProject=&quot;src/main/java&quot;                             type=&quot;MIXEDMAPPER&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;!--                    定义Maper.java 源代码中的ByExample() 方法的可视性，可选的值有：                    public;                    private;                    protected;                    default                    注意：如果 targetRuntime=&quot;MyBatis3&quot;,此参数被忽略             --&gt;            &lt;property name=&quot;exampleMethodVisibility&quot; value=&quot;public&quot;/&gt;            &lt;!--              方法名计数器              Important note: this property is ignored if the target runtime is MyBatis3.            &lt;property name=&quot;methodNameCalculator&quot; value=&quot;&quot;/&gt;             --&gt;            &lt;!--                  为生成的接口添加父接口            &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;            --&gt;        &lt;/javaClientGenerator&gt;        &lt;!--tableName:表名            schema:数据库名            domainObjectName:实体类的名字        --&gt;        &lt;!--详细的表--&gt;        &lt;!--       &lt;table tableName=&quot;tbl_file_permission_map&quot; schema=&quot;${jdbc.database}&quot;               domainObjectName=&quot;FilePermissionMap&quot;               enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;               enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;               selectByExampleQueryId=&quot;false&quot;&gt;               optional , only for mybatis3 runtime               自动生成的键值（identity,或者序列值）               如果指定此元素，MBG将会生成&lt;selectKey&gt;元素，然后将此元素插入到SQL Map的&lt;insert&gt; 元素之中               sqlStatement 的语句将会返回新的值               如果是一个自增主键的话，你可以使用预定义的语句,或者添加自定义的SQL语句. 预定义的值如下:                  Cloudscape    This will translate to: VALUES IDENTITY_VAL_LOCAL()                  DB2:      VALUES IDENTITY_VAL_LOCAL()                  DB2_MF:       SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1                  Derby:        VALUES IDENTITY_VAL_LOCAL()                  HSQLDB:   CALL IDENTITY()                  Informix:     select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid=1                  MySql:        SELECT LAST_INSERT_ID()                  SqlServer:    SELECT SCOPE_IDENTITY()                  SYBASE:   SELECT @@IDENTITY                  JDBC:     This will configure MBG to generate code for MyBatis3 suport of JDBC standard generated keys. This is a database independent method of obtaining the value from identity columns.                  identity: 自增主键  If true, then the column is flagged as an identity column and the generated &lt;selectKey&gt; element will be placed after the insert (for an identity column). If false, then the generated &lt;selectKey&gt; will be placed before the insert (typically for a sequence).            &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot; identity=&quot;&quot; type=&quot;&quot;/&gt;            optional.                     列的命名规则：                     MBG使用 &lt;columnRenamingRule&gt; 元素在计算列名的对应 名称之前，先对列名进行重命名，                     作用：一般需要对BUSI_CLIENT_NO 前的BUSI_进行过滤                     支持正在表达式                     searchString 表示要被换掉的字符串                     replaceString 则是要换成的字符串，默认情况下为空字符串，可选            &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;            optional.告诉 MBG 忽略某一列                    column，需要忽略的列                    delimitedColumnName:true ,匹配column的值和数据库列的名称 大小写完全匹配，false 忽略大小写匹配                    是否限定表的列名，即固定表列在Model中的名称            &lt;ignoreColumn column=&quot;&quot; delimitedColumnName=&quot;&quot;/&gt;            optional.覆盖MBG对Model 的生成规则                 column: 数据库的列名                 javaType: 对应的Java数据类型的完全限定名                 在必要的时候可以覆盖由JavaTypeResolver计算得到的java数据类型. For some databases, this is necessary to handle &quot;odd&quot; database types (e.g. MySql&#39;s unsigned bigint type should be mapped to java.lang.Object).                 jdbcType:该列的JDBC数据类型(INTEGER, DECIMAL, NUMERIC, VARCHAR, etc.)，该列可以覆盖由JavaTypeResolver计算得到的Jdbc类型，对某些数据库而言，对于处理特定的JDBC 驱动癖好 很有必要(e.g. DB2&#39;s LONGVARCHAR type should be mapped to VARCHAR for iBATIS).                 typeHandler:            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; jdbcType=&quot;&quot; typeHandler=&quot;&quot; delimitedColumnName=&quot;&quot;/&gt;        &lt;/table&gt;        --&gt;        &lt;!--其他表的简单配置--&gt;        &lt;table tableName=&quot;student&quot; domainObjectName=&quot;Student&quot;               enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;               enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;               selectByExampleQueryId=&quot;false&quot;&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>resources目录结构：<br><img src="/images/mybatis/QQ截图20190317190500.png"></p><hr><p>使用 Maven 插件运行：<br><img src="/images/mybatis/QQ截图20190317190650.png" style="width:50%"></p><p>运行后的结果：<br><img src="/images/mybatis/QQ截图20190317190809.png"></p><hr><h3 id="图像化方式"><a href="#图像化方式" class="headerlink" title="图像化方式"></a>图像化方式</h3><p>mybatis-generator-gui是基于mybatis generator开发一款界面工具, 本工具可以使你非常容易及快速生成Mybatis的Java POJO文件及数据库Mapping文件。</p><p>地址是：<a href="https://github.com/zouzg/mybatis-generator-gui" target="_blank" rel="noopener">https://github.com/zouzg/mybatis-generator-gui</a></p><p>要求：本工具由于使用了Java 8的众多特性，所以要求JDK 1.8.0.60以上版本，另外JDK 1.9暂时还不支持。</p><hr><h4 id="方式一下载软件"><a href="#方式一下载软件" class="headerlink" title="方式一下载软件"></a>方式一下载软件</h4><p>直接下载软件： <a href="http://tools.mingzhi.ink" target="_blank" rel="noopener">http://tools.mingzhi.ink</a></p><p>（1）下载完成后，直接运行该软件（前提，你的本机的java环境变量要配置为：JDK 1.8.0.60以上版本）。<br><img src="/images/mybatis/QQ截图20190317215847.png"></p><p>（2）点击保存后：<br><img src="/images/mybatis/QQ截图20190317220231.png"></p><p>（3）点击代码生成：<br><img src="/images/mybatis/QQ截图20190317220414.png"></p><h4 id="方式二下载源码启动"><a href="#方式二下载源码启动" class="headerlink" title="方式二下载源码启动"></a>方式二下载源码启动</h4><h5 id="两种方式下载源码"><a href="#两种方式下载源码" class="headerlink" title="两种方式下载源码"></a>两种方式下载源码</h5><ul><li><p>直接下载源码：<br><img src="/images/mybatis/QQ截图20190318092300.png"></p></li><li><p>使用git工具：<code>git clone https://github.com/zouzg/mybatis-generator-gui</code></p></li></ul><h5 id="两种方式启动"><a href="#两种方式启动" class="headerlink" title="两种方式启动"></a>两种方式启动</h5><ul><li>直接进入下载好的源码目录</li></ul><p>直接下载的目录为：<code>mybatis-generator-gui-master</code> ，git后的目录为：<code>mybatis-generator-gui</code></p><p>(1)在根目录下，启动 <code>cmd</code></p><p>然后输入：<code>mvn jfx:jar</code><br><img src="/images/mybatis/QQ截图20190318092931.png"></p><p>注意：你的本机要先安装好 maven，并配置好相关的环境变量。</p><p>输入命令后，会开始下载相关的jar包：<br><img src="/images/mybatis/QQ截图20190318093145.png"></p><p>(2) 进入target/jfx/app/目录下</p><p>输入：<code>cd target/jfx/app/</code></p><p>然后输入：<code>java -jar mybatis-generator-gui.jar</code><br><img src="/images/mybatis/QQ截图20190318093422.png"></p><p>回车后，就会弹出界面系统：<br><img src="/images/mybatis/QQ截图20190318093506.png"></p><hr><ul><li>使用Eclipse或IDEA启动下载好的源代码</li></ul><p>要求，你的IDE配置的JDK必须大于：1.8.0.40。</p><p>在 com.zzg.mybatis.generator下，找到：<code>MainUI</code> 主类：</p><p><img src="/images/mybatis/QQ截图20190318093945.png"></p><p>运行主类即可：<br><img src="/images/mybatis/QQ截图20190318094150.png"></p><hr><font color="red"><br><strong>注意事项</strong><br><br>(1) 本自动生成代码工具只适合生成单表的增删改查，对于需要做数据库联合查询的，请自行写新的XML与Mapper；<br><br>(2) 部分系统在中文输入方法时输入框中无法输入文字，请切换成英文输入法；<br><br>(3) 如果不明白对应字段或选项是什么意思的时候，把光标放在对应字段或Label上停留一会然后如果有解释会出现解释；<br><br></font><hr><p>还有一款图形化生成器：<a href="https://github.com/spawpaw/mybatis-generator-gui-extension" target="_blank" rel="noopener">https://github.com/spawpaw/mybatis-generator-gui-extension</a></p><p>大家可以自行尝试，运行。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的动态SQL</title>
      <link href="/2019/03/16/mybatis-zhong-de-dong-tai-sql/"/>
      <url>/2019/03/16/mybatis-zhong-de-dong-tai-sql/</url>
      
        <content type="html"><![CDATA[<p>Mybatis的强大特性之一便是它的动态SQL。使用过JDBC或其他类似的框架的人都会知道，根据不同条件拼接SQL语句时不仅不能忘记必要的空格，还有注意省略掉列名列表最后的逗号，处理方式麻烦且凌乱。Mybatis的动态SQL则能帮我们摆脱这种痛苦。<br><a id="more"></a></p><p>在Mybatis 3 之前的版本中，使用动态SQL需要学习和了解非常多的标签，现在Mybatis采用功能强大的 OGNL 表达式语言消除了许多其他标签，以下是Mybatis的动态SQL在XML中支持的几种标签：</p><ul><li><p>if：判断语句，单条件分支判断</p></li><li><p>choose(when、otherwise)：相当于java中的switch语句，多条件分支判断</p></li><li><p>trim(where、set)：辅助元素，用于处理一些SQL拼装问题</p></li><li><p>foreach：循环语句，在in语句等列举条件中常用</p></li><li><p>bind：绑定元素，就像一个变量一样，提前定义，后面使用</p></li></ul><hr><h3 id="if用法"><a href="#if用法" class="headerlink" title="if用法"></a>if用法</h3><p>if元素是我们最常用的判断语句，相当于Java中的if语句，它常常与 <code>test</code> 属性联合使用。</p><p>if标签通常用于where语句中，通过判断参数值来决定是否使用某个查询条件，它也经常用于update语句中判断是否更新某一个字段，还可以在insert语句中用来判断是否插入某一个字段的值。</p><h4 id="在where条件中使用if"><a href="#在where条件中使用if" class="headerlink" title="在where条件中使用if"></a>在where条件中使用if</h4><p>假设，现在我们要根据 学生id 和 学生的姓名 来查询学生的信息：</p><pre><code>    &lt;select id=&quot;selectByStu&quot; resultType=&quot;student&quot;&gt;        select        s.id,        s.stu_name as &#39;stuName&#39; ,        s.stu_sex as &#39;stuSex&#39;,        s.stu_id as &#39;stuId&#39;        from student as s        where         s.id = #{id}        and         s.stu_name like concat(&#39;%&#39;,#{stuName},&#39;%&#39;)    &lt;/select&gt;</code></pre><p>当同时输入 <code>id</code> 和 <code>stuName</code> 这两个条件时，能查出正确的结果，但是当只提供id参数时，stuName默认是null，就会导致stuName = null 也成为查询条件，因此查不到正确的结果。这时可以使用 if标签 来解决这个问题。</p><pre><code>    &lt;select id=&quot;selectByStu&quot; resultType=&quot;student&quot;&gt;        select        s.id,        s.stu_name as &#39;stuName&#39; ,        s.stu_sex as &#39;stuSex&#39;,        s.stu_id as &#39;stuId&#39;        from student as s        where         1 = 1        &lt;if test=&quot;id != null&quot;&gt;        and s.id = #{id}        &lt;/if&gt;        &lt;if test=&quot;stuName != null and stuName != &#39;&#39;&quot;&gt;        and s.stu_name like concat(&#39;%&#39;,#{stuName},&#39;%&#39;)        &lt;/if&gt;    &lt;/select&gt;</code></pre><p>if标签有一个必填的属性：<code>test</code> ，test属性值是一个符合OGNL要求的表达式，表达式的结果可以是 true 或 false，除此之外所有的非0值都为 true，只有0为：false。为了方便理解，在表达式中，建议只有：true 或 false 作为结果。OGNL的详细用法，后面会提及到。</p><ul><li><p>判断条件 <code>property != null 或 property == null</code>：适用于任何类型的字段，用于判断属性值是否为空。</p></li><li><p>判断条件 <code>property != &#39;&#39; 或 property == &#39;&#39;</code>：仅适合于String类型的字段，用于判断是否为空字符串。</p></li><li><p>and 和 or：当有多个判断条件时，使用 and 或 or 进行连接，嵌套的判断可以使用小括号分组，and相当于java中的&amp;&amp;，or相当于||</p></li></ul><hr><p>上面的条件属性类型有的是String，对字符串的判断和Java中的判断类似，首先需要判断字段是否为 null，然后再去判断是否为空（在OGNL表达式中，这两个判断的顺序不会影响到结果，也不会有空指针异常）。</p><p>虽然上面可以完成需求，但是在XML中仍然需要注意两个地方：</p><ul><li>注意SQL中where关键字后面的条件</li></ul><p><code>where 1=1</code></p><p>由于两个条件都是动态的，所以如果没有 1=1 这个默认的条件，当两个if判断都不满足时，最后生成的SQL语句就会以 <code>where 结束</code>，这样不符合SQL语句规范，因此会报错。加上 1=1 这个条件，就可以避免SQL语句错误导致的异常。这种写法并不完美，后面我们会使用更好的方式来替代这个写法。</p><ul><li>注意条件中的 and（or）</li></ul><p><code>and id =#{id}</code></p><p>这里的 and（或 or）需要手动添加，当这部分条件拼接到 where 1=1 后面时任然是合法的SQL。因为有默认的 1 = 1 这个条件，我们不需要判断第一个动态条件是否需要加上 and（或 or），因为这种情况下 and（or）是必须有的。</p><hr><h4 id="在update更新列中使用if"><a href="#在update更新列中使用if" class="headerlink" title="在update更新列中使用if"></a>在update更新列中使用if</h4><p>现在，需要实现这样一个功能：只更新有变化的字段，需要注意的是，更新的时候不能将原来有值但没有发生变化的字段更新为 空 或 null。</p><pre><code>&lt;update id=&quot;updateByIdSelective&quot;&gt;    update student    set        &lt;if test=&quot;stuName !=null and stuName !=&#39;&#39;&quot;&gt;        stu_name = #{stuName},        &lt;/if&gt;        &lt;if test=&quot;stuSex !=null&quot;&gt;        stu_sex = #{stuSex},        &lt;/if&gt;        &lt;if test=&quot;stuNumber != null and stuNumber != &#39;&#39;&quot;&gt;        stu_number = #{stuNumber},        &lt;/if&gt;        id = #{id}    where    id = #{id}&lt;/update&gt;</code></pre><p>需要注意的两个点：</p><p>第一个是：每个if元素里面的SQL语句后面都有逗号</p><p>第二个是：where关键字前面的 id = #{id} 这个条件。</p><hr><ul><li>当全部条件都是 null 或者 空。</li></ul><p>如果有 id = #{id} 这个条件，最终的SQL语句：</p><p><code>update student set id = #{id} where id = #{id}</code></p><p>如果没有 id = #{id} 这个条件，最终的SQL语句：</p><p><code>update student set where id = #{id}</code></p><p>这个SQL很明显是错误的，set 关键字后面没有内容，直接是where关键字，不符合SQL语句规范。</p><ul><li>查询条件只有一个不是null也不是空（假设是stu_name）</li></ul><p>如果有 id =#{id}这个条件，最终的SQL语句：</p><p><code>update student set stu_name =#{stuName}, id = #{id} where id = #{id}</code></p><p>如果没有 id = #{id} 这个条件，最终的SQL语句：</p><p><code>update student set stu_name =#{stuName}, where id = #{id}</code></p><p>where关键字前面直接就是一个逗号，这个SQL语句也是错误的。</p><p>从上面两种情况来看，id = #{id} 这个条件可以最大限度保证方法不出错。除了使用这种方式外，还可以结合业务层的逻辑判断调整XML文件中的SQL来确保最终的SQL语句的正确性，也可以通过 where 和 set 标签来解决这个问题。</p><hr><h4 id="在insert动态插入列中使用if"><a href="#在insert动态插入列中使用if" class="headerlink" title="在insert动态插入列中使用if"></a>在insert动态插入列中使用if</h4><p>在数据库表中插入数据的时候，如果某一列的参数值不为空，就使用传入的值，如果传入参数为空，就使用数据库中的默认值（通常是空），而不使用传入的空值。使用if就可以实现这种动态插入列的功能。</p><pre><code>&lt;insert id =&quot;insertStu&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into student(    &lt;if test=&quot;stuName != null and stuName != &#39;&#39;&quot;&gt;    stu_name,    &lt;/if&gt;    stu_sex,    stu_number)    values(    &lt;if test=&quot;stuName != null and stuName != &#39;&#39;&quot;&gt;    #{stuName},    &lt;/if&gt;    #{stuSex},    #{stuNumber})&lt;/insert&gt;</code></pre><p>需要注意的是，若在列的部分增加了 if条件，则在values的部分也要增加相同的 if条件，必须保证上下可以互相对应，完全匹配。</p><hr><h3 id="choose用法"><a href="#choose用法" class="headerlink" title="choose用法"></a>choose用法</h3><p>上一节的 if标签 提供了基本的条件判断，但是它无法实现 if···else、if···else···的逻辑，要想实现这样的逻辑，就需要用到 choose when otherwise 标签。choose标签：包含 when 和 otherwise 两个标签，一个 choose中至少有一个when，有0个或者1个otherwise。在已知的student表中，除了主键id外，我们认为stu_name（学生名）也是唯一的，所有的用户名都不可以重复。</p><p>现在，进行如下查询：当参数 id 有值的时候，优先使用 id查询，当id没有值时就去判断用户名是否有值，如果有值就用用户名查询，如果用户名也没有值，就使用SQL查询无结果。</p><pre><code>&lt;select id=&quot;selectByStu&quot; resultType=&quot;student&quot;&gt;    select    s.id,    s.stu_name as &#39;stuName&#39; ,    s.stu_sex as &#39;stuSex&#39;,    s.stu_id as &#39;stuId&#39;    from student as s    where 1 = 1    &lt;choose&gt;      &lt;when test=&quot;id != null&quot;&gt;         and s.id = #{id}      &lt;/when&gt;      &lt;when test=&quot;stuName != null and stuName != &#39;&#39;&quot;&gt;         and s.stu_name like concat(&#39;%&#39;,#{stuName},&#39;%&#39;)      &lt;/when&gt;      &lt;otherwise&gt;         and 1 = 2      &lt;/otherwise&gt;    &lt;/choose&gt;&lt;/select&gt;</code></pre><p>使用choose when otherwise 的时候逻辑要严密，避免由于某些值出现问题导致SQL出错。</p><font color="red"><br>提示：上述查询中，如果没有 otherwise的话，所有用户都会查询出来，因为我们在对应的接口方法中使用了Student作为返回值，所以当实际查询结果是多个就会报错。<br></font><hr><h3 id="trim、where、set用法"><a href="#trim、where、set用法" class="headerlink" title="trim、where、set用法"></a>trim、where、set用法</h3><p>这个三个标签解决类似的问题，并且where 和 set 都属于 trim的一种具体用法。</p><h4 id="where用法"><a href="#where用法" class="headerlink" title="where用法"></a>where用法</h4><p>where标签的作用：如果该标签包含的元素中有返回值，就插入一个where；如果where后面的字符串是以 and 和 or 开头的，就将它们剔除。</p><pre><code>    &lt;select id=&quot;selectByStu&quot; resultType=&quot;student&quot;&gt;        select        s.id,        s.stu_name as &#39;stuName&#39; ,        s.stu_sex as &#39;stuSex&#39;,        s.stu_id as &#39;stuId&#39;        from student as s        &lt;where&gt;            &lt;if test=&quot;id != null&quot;&gt;              and s.id = #{id}           &lt;/if&gt;           &lt;if test=&quot;stuName != null and stuName != &#39;&#39;&quot;&gt;              and s.stu_name like concat(&#39;%&#39;,#{stuName},&#39;%&#39;)           &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><p>看到，我去掉了 1 = 1 这个条件，当 if条件都不满足的时候，where元素中没有内容，所以在SQL中不会出现 where；也就不存在 之前在 if动态用法中的问题。</p><p>如果 if条件满足，where元素的内容就是以：and 开头的条件，where会自动去掉开头的 and，这也保证了where条件正确。</p><h4 id="set用法"><a href="#set用法" class="headerlink" title="set用法"></a>set用法</h4><p>set标签的作用：如果该标签包含的元素中有返回值，就插入一个set；如果set后面的字符串是以逗号结尾的，就将这个逗号剔除。</p><pre><code>&lt;update id=&quot;updateByIdSelective&quot;&gt;    update student    &lt;set&gt;        &lt;if test=&quot;stuName !=null and stuName !=&#39;&#39;&quot;&gt;        stu_name = #{stuName},        &lt;/if&gt;        &lt;if test=&quot;stuSex !=null&quot;&gt;        stu_sex = #{stuSex},        &lt;/if&gt;        &lt;if test=&quot;stuNumber != null and stuNumber != &#39;&#39;&quot;&gt;        stu_number = #{stuNumber},        &lt;/if&gt;        id = #{id},    &lt;/set&gt;    where    id = #{id}&lt;/update&gt;</code></pre><p>在set标签的用法中，SQL后面的逗号没有问题了，但是如果set元素中没有内容，照样会出现SQL错误，所以为了避免错误产生，类似 id = #{id} 这样必然存在的赋值仍然有保留的必要。从这个点看，set标签并没有解决全部的问题，使用时仍然需要注意。</p><hr><h4 id="trim用法"><a href="#trim用法" class="headerlink" title="trim用法"></a>trim用法</h4><p>where 和 set 标签的功能都可以使用 trim 标签来实现，并且在底层就是通过 <code>TrimSqlNode</code>实现的。</p><p>where标签对应的 trim的实现如下：</p><pre><code>&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;···&lt;/trim&gt;</code></pre><font color="red"><br>提示：这里的AND 和 OR后面的空格不能省略，为了避免匹配到 andes、orders等单词。<br><br>实际上prefixOverrides 包含 “AND”、”OR”、”AND\n”、”OR\n”、”AND\r”、”OR\r”、”AND\t”、”OR\t”，不仅仅是上面提到的两个带空格的前缀。<br></font><hr><p>set标签对应的trim实现如下：</p><pre><code>&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;···&lt;/trim&gt;</code></pre><hr><p>trim标签有如下属性：</p><ul><li><p>prefix：当trim元素内包含内容时，会给内容增加prefix指定的前缀。</p></li><li><p>prefixOverrs：当trim元素内包含内容时，会把内容中匹配的前缀字符串去掉。</p></li><li><p>suffix：当trim元素内包含内容时，会给内容增加suffix指定的后缀。</p></li><li><p>suffixOverrs：当trim元素内包含内容时，会把内容中匹配的后缀字符串去掉。</p></li></ul><hr><h3 id="foreach用法"><a href="#foreach用法" class="headerlink" title="foreach用法"></a>foreach用法</h3><p>SQL语句中有时会使用 <code>IN</code> 关键字，例如 id in（1,2,3）。可以使用 <code>${ids}</code> 方式直接获取值，但这种写法不能防止SQL注入，想避免SQL注入就需要要 <code>#{}</code>的方式，这时就要配合使用 <code>foreach</code> 标签来满足需求。</p><p>foreach 可以对数组、Map或实现了 Iterable接口（如 List、Set）的对象进行遍历。数组在处理时会转换为List对象，因此foreach遍历的对象可以分为两大类：<code>Iterable类型</code> 和 <code>Map类型</code>。</p><hr><h4 id="foreach实现-in-集合"><a href="#foreach实现-in-集合" class="headerlink" title="foreach实现 in 集合"></a>foreach实现 in 集合</h4><p>foreach实现 in 集合（或数组）是最简单和最常用的一种情况，下面介绍如何根据传入的学生id集合查询出所有的学生。</p><pre><code>List&lt;Student&gt; selectByIdList(List&lt;Long&gt; idList);</code></pre><pre><code>&lt;select id=&quot;selectByStu&quot; resultType=&quot;student&quot;&gt;    select    s.id,    s.stu_name as &#39;stuName&#39; ,    s.stu_sex as &#39;stuSex&#39;,    s.stu_id as &#39;stuId&#39;    from student as s    where     id in    &lt;foreach collection=&quot;list&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; item=&quot;id&quot; index=&quot;i&quot;&gt;    #{id}    &lt;/foreach&gt;&lt;/select&gt;</code></pre><p>foreach 包含以下属性：</p><ul><li><p>collection：必填，值为要迭代循环的属性名，这个属性值的情况很多。</p></li><li><p>item：变量名，值为从迭代对象中取出的每一个值。</p></li><li><p>index：索引的属性名，在集合数组情况下，值为当前索引的值，当迭代循环对象是Map类型时，这个值为Map的 Key（键值）。</p></li><li><p>open：整个循环内容开头的字符串</p></li><li><p>close：整个循环内容结尾的字符串</p></li><li><p>separator：每次循环的分隔符</p></li></ul><hr><p>collection的属性要如何设置呢？来看一下Mybatis是如何处理这种类型的参数的。</p><p>（1）只有一个数组参数或集合参数</p><p>以下代码是 DefaultSqlSession中的方法，也是默认情况下的处理逻辑：</p><pre><code>  private Object wrapCollection(final Object object) {    if (object instanceof Collection) {      StrictMap&lt;Object&gt; map = new StrictMap&lt;Object&gt;();      map.put(&quot;collection&quot;, object);      if (object instanceof List) {        map.put(&quot;list&quot;, object);      }      return map;    } else if (object != null &amp;&amp; object.getClass().isArray()) {      StrictMap&lt;Object&gt; map = new StrictMap&lt;Object&gt;();      map.put(&quot;array&quot;, object);      return map;    }    return object;  }</code></pre><p>当参数类型为集合的时候，默认会转换为Map类型，并添加一个key为 “collection” 的值，如果参数类型是List集合，那么会继续添加一个key为 “list”的值，这样，当collection = “list” 时，就能得到这个集合，并对它进行循环操作。</p><p>当参数类型为数组的时候，也会转换为Map类型，默认的key为 “array”。当采用如下方法使用数组时，就需要把foreach标签中的collection属性值设置为：array。</p><pre><code>List&lt;Student&gt; selectByIdList(Long[] idArray);</code></pre><p>（2）有多个参数</p><p>之前的博客讲过，当有多个参数的时候，要使用<code>@param注解</code>给每个参数指定一个名字，否则在SQL中使用参数时就会不方便，因此将collection设置为<code>@param注解</code>指定的名字即可。</p><p>（3）参数是Map类型</p><p>使用Map和使用@param注解方式类似，将collection指定为对应的Map中的key即可。如果要循环所传入的Map，推荐使用@param注解指定名字，此时可将collection设置为指定的名字，如果不想指定名字，就使用默认值<code>_parameter</code>。</p><p>（4）参数是一个对象</p><p>这个情况下指定为对象的属性名即可。当使用对象内多层嵌套的对象时，使用 <code>属性.属性（集合和数组可以使用下标）</code>的方式可以指定深层的属性值。</p><hr><h4 id="foreach实现批量插入"><a href="#foreach实现批量插入" class="headerlink" title="foreach实现批量插入"></a>foreach实现批量插入</h4><p>如果数据库支持批量插入，就可以通过foreach来实现。批量插入是SQL-92新增的特性，目前支持的数据库有DB2、SQL Server2008及以上版本、PostgreSQL8.2及以上版本、MySQL、SQLite3.7.11及以上版本、H2。批量插入的语法如下：</p><pre><code>INSERT INTO tablename (column-a,[column-b,···])VALUES (&#39;value-1a&#39;,[&#39;value-1b&#39;,···]),       (&#39;value-2a&#39;,[&#39;value-2b&#39;,···]),       ···</code></pre><p>从待处理部分可以看出，后面是一个值的循环，因此可以通过foreach实现循环插入。</p><pre><code>int insertList(List&lt;Student&gt; userList);&lt;insert id =&quot;insertList&quot;&gt;    insert into student(       stu_name,stu_sex,stu_number)    values    &lt;foreach collection=&quot;list&quot; item=&quot;stu&quot; separator=&quot;,&quot;&gt;      (        #{stu.stuName},#{stu.stuSex},#{stu.stuNumber}      )    &lt;/foreach&gt;&lt;/insert&gt;</code></pre><font color="red"><br>注意：通过item指定了循环变量名后，在引用值的时候使用的是 “属性.属性” 的方式，如：stu.stuName。<br></font><p>从Mybatis 3.3.1版本开始，Mybatis开始支持批量新增回写主键值的功能，这个功能首先要求数据库主键值为自增类型，同时还要求该数据库提供的JDBC驱动可以支持返回批量插入的主键值（JDBC提供了接口，但并不是所有数据库都完美实现了该接口），因此到目前为止，<font color="red"><strong>可以完美支持该功能的仅有MySQL数据库。</strong></font></p><p>如果要在MySQL中实现批量插入返回自增主键值，只需要在原来代码基础上进行如下修改：</p><pre><code>&lt;insert id =&quot;insertList&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</code></pre><p>和单表一样，此处增加了 useGeneratedKeys 和 keyProperty 两个属性。</p><hr><h4 id="foreach实现动态update"><a href="#foreach实现动态update" class="headerlink" title="foreach实现动态update"></a>foreach实现动态update</h4><pre><code>&lt;update id=&quot;updateByMap&quot;&gt;    update student      set      &lt;foreach collection=&quot;_parameter&quot; index=&quot;key&quot; item=&quot;val&quot; separator=&quot;,&quot;&gt;        ${key} = #{val}      &lt;/foreach&gt;      where id = #{id}&lt;/update&gt;</code></pre><p>这里的Key作为列名，对应的值作为该列的值，通过foreach将需要更新的字段拼接在SQL语句中。</p><pre><code>int updateByMap(Map&lt;String,Object&gt; map);</code></pre><p>这里没有通过@param注解指定参数名，因而Mybatis在内部的上下文中使用了默认 <code>_parameter</code>作为该参数的key，所以在XML中也使用了<code>_parameter</code>。</p><hr><h3 id="bind用法"><a href="#bind用法" class="headerlink" title="bind用法"></a>bind用法</h3><p>bind元素的作用是通过OGNL表达式去自定义一个上下文变量，这样更方便我们使用。在我们进行模糊查询的时候，如果是MySQL数据库，我们常常用到的是一个concat用”%” 和 参数相连接。然而在Oracle数据库则是用连接符合 “||”，这样SQL就需要提供两种形式去实现了。但是有了bind元素，我们就完全不必使用数据库的语言，只要使用Mybatis的语言即可与所需参数相连。</p><p>比如我们要按角色名称进行模糊查询，我们可以把映射文件写成如下：</p><pre><code>&lt;select id=&quot;findStudent&quot; resultTpe=&quot;student&quot;&gt;    &lt;bind name=&quot;pattern&quot; value=&quot;&#39;%&#39; + stuName + &#39;%&#39;&quot; /&gt;    select id , stu_name, stu_sex, stu_number    from student    where id =#{id} and stu_name like #{pattern}&lt;/select&gt;</code></pre><p>这里的 <code>stuName</code> 代表的就是传递进来的参数，它和通配符连接后，赋给了pattern，我们就可以在select语句中使用这个变量进行模糊查询了，不管是MySQL数据库还是Oracle数据库都可以使用这样的语句，提高了其可移植性。</p><hr><p>我们传递的参数往往不止一个，我们可以传递多个参数。</p><pre><code>public List&lt;Student&gt; findStu(@Param(&quot;stuName&quot;) String stuName,@Param(&quot;note&quot;) String note);&lt;select id=&quot;findStudent&quot; resultTpe=&quot;student&quot;&gt;    &lt;bind name=&quot;stuNameLike&quot; value=&quot;&#39;%&#39; + stuName + &#39;%&#39;&quot; /&gt;    &lt;bind name=&quot;noteLike&quot; value=&quot;&#39;%&#39; + note + &#39;%&#39;&quot; /&gt;    select id , stu_name, stu_sex, stu_number,note    from student    where id =#{id} and stu_name like #{stuNameLike} and note like #{noteLike}&lt;/select&gt;</code></pre><h3 id="OGNL用法"><a href="#OGNL用法" class="headerlink" title="OGNL用法"></a>OGNL用法</h3><p>在Mybatis的动态SQL和 ${} 形式的参数中都用到了OGNL表达式，所以我们有必要了解一下OGNL的简单用法。</p><p>（1）e1 <code>or</code> e2</p><p>（2）e1 <code>and</code> e2</p><p>（3）e1 <code>==</code> e2 或 e1 <code>eq</code> e2</p><p>（4）e1 <code>!=</code> e2 或 e1 <code>neq</code> e2</p><p>（5）e1 <code>lt</code> e2：小于</p><p>（6）e1 <code>lte</code> e2：小于等于，其他表示为：<code>gt</code>（大于）、<code>gte</code>（大于等于）</p><p>（7）e1 + e2、e1 * e2、e1/e2、e1-e2、e1%e2</p><p>（8）!e 或 not e：非，取反</p><p>（9）e.method(args)：调用方法</p><p>（10）e.property：对象属性值</p><p>（11）e1[e2]：按索引取值（List、数组和Map）</p><p>（12）@class@method(args)：调用类的静态方法</p><p>（13）@class@field：调用类的静态字段值</p><hr><p>Mybatis使用XML时，不可避免会使用到一些对XML来说是特殊的字符，比如：&lt;：小于号，当你使用时，在XML中它也标签的符合，所以为了区别，该怎么解决呢？</p><p>方法一：</p><p>使用转义字符</p><pre><code>&lt;：&amp;lt;&gt;: &amp;gt;&amp;：&amp;amp;&#39;(单引号）：&amp;apos;&quot;(双引号)：&amp;quot;</code></pre><hr><p>方法二：</p><p>使用 CDATA 部件</p><pre><code>   &lt;![CDATA[···]]&gt;其中的：···部分，使用特殊符号时，不起作用。</code></pre>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的缓存</title>
      <link href="/2019/03/15/mybatis-zhong-de-huan-cun/"/>
      <url>/2019/03/15/mybatis-zhong-de-huan-cun/</url>
      
        <content type="html"><![CDATA[<p>使用缓存可以使应用更快地获取数据，避免频繁的与数据库交互 ，尤其是在查询越多 、缓存命中率越高的情况下，使用缓存的作用就越明显。MyBatis 作为持久化框架提供了非常强大的查询缓存特性，可以非常方便地配置和定制使用。<br><a id="more"></a></p><p>一般提到Mybatis的缓存都是指二级缓存。一级缓存（也叫本地缓存）默认会启动，并且不能控制，因此很少会提到。首先，我会简单的介绍一下Mybatis的一级缓存，了解Mybatis的一级缓存可以避免产生一些难以发现的错误。其次，我会全面介绍Mybatis的二级缓存，包括二级缓存的基本配置用法，还有一些常用的缓存框架和缓存数据库的结合。</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><h4 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h4><p>我们来看一个简单的例子：</p><pre><code>    public void testSelectStudent() {        SqlSession sqlSession = sqlSessionFactory.openSession();        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);        Student student = studentMapper.findStudentById(1L);        System.out.println(&quot;使用同一个SqlSession再执行一次同样的方法&quot;);        Student student2 = studentMapper.findStudentById(1L);        sqlSession.commit();        //开启一个新的SqlSession        SqlSession sqlSession2 = sqlSessionFactory.openSession();        StudentMapper studentMapper2 = sqlSession.getMapper(StudentMapper.class);        System.out.println(&quot;开启一个新的SqlSession再执行一次：&quot;);        Student student3 = studentMapper.findStudentById(1L);        sqlSession2.commit();        try {        } finally {            //不要忘记关闭SqlSession            sqlSession.close();            sqlSession2.close();        }    }</code></pre><p>注意：这里要调用：sqlSession.commit()，才会启动缓存。</p><p>运行结果如下：<br><img src="/images/mybatis/QQ截图20190315154304.png"></p><p>发现，Mybatis的一级缓存存在于：<font color="red">SqlSession的生命周期中</font>，在同一个SqlSession中查询时，Mybatis会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map对象中。如果同一个SqlSession中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当Map缓存对象中已经存在了该键值时，则会返回缓存中的对象。</p><hr><h4 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h4><p>再看一个例子：</p><pre><code>    public void testSelectStudent() {        SqlSession sqlSession = sqlSessionFactory.openSession();        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);        Student student = studentMapper.findStudentById(1L);        System.out.println(student);        //修改student中的Name属性        student.setStuName(&quot;dj&quot;);        System.out.println(&quot;使用同一个SqlSession再执行一次同样的方法&quot;);        Student student2 = studentMapper.findStudentById(1L);        System.out.println(student2);        sqlSession.commit();        //开启一个新的SqlSession        SqlSession sqlSession2 = sqlSessionFactory.openSession();        StudentMapper studentMapper2 = sqlSession.getMapper(StudentMapper.class);        System.out.println(&quot;开启一个新的SqlSession再执行一次：&quot;);        Student student3 = studentMapper.findStudentById(1L);        System.out.println(student3);        sqlSession2.commit();        try {        } finally {            //不要忘记关闭SqlSession            sqlSession.close();            sqlSession2.close();        }    }</code></pre><p>运行结果：<br><img src="/images/mybatis/QQ截图20190315155617.png"></p><p>我们可以看到的是，当我获取 <code>id=1</code> 的 student学生后，修改它的姓名，然后再次调用同样的方法，获取 <code>id=1</code> 的学生，它的姓名也跟着发生了改变。说明此时，student2 和 student 是同一个对象，都是从缓存中获取的，所以会发生上面的问题。开启一个新的SqlSession后，获取 <code>id=1</code> 的学生，又会从数据库中重新获取了。</p><hr><p>如果不想让该方法使用一级缓存的话，可以添加：<code>flushCache=true</code> ，表示，每次调用该方法，都会重新发送SQL语句，从数据库中获取最新的数据。</p><pre><code>    &lt;select id=&quot;findStudentById&quot;  flushCache=&quot;true&quot; resultMap=&quot;studentMap&quot;&gt;         select * from student where id = #{id}     &lt;/select&gt;</code></pre><p><code>flushCache=true</code> ，这个属性配置为：true后，会在查询数据前清空当前的一级缓存，因此该方法每次都会重新从数据库中查询数据，此时的student和student2就会变成两个不同的实例，可以避免上面的问题。</p><p>但是由于这个方法清空了一级缓存，<strong><code>会影响到当前SqlSession中所有的缓存的查询</code></strong>，因此在需要反复查询获取只读数据的情况下，会增加数据库的查询次数，所以要避免这么使用。</p><font color="red">注意：调用 flushCache=true 的方法后，一级缓存会被清空，即之前的所有方法的调用缓存都会被清空，不仅仅是指：flushCache=true 的方法</font><hr><h4 id="第三个例子"><a href="#第三个例子" class="headerlink" title="第三个例子"></a>第三个例子</h4><pre><code>    public void testSelectStudent() {        SqlSession sqlSession = sqlSessionFactory.openSession();        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);        System.out.println(&quot;第一次调用&quot;);        Student student = studentMapper.findStudentById(1L);        System.out.println(&quot;第二次调用&quot;);        Student student2 = studentMapper.findStudentById(1L);        System.out.println(&quot;两个对象是否相等：&quot; + (student == student2));        sqlSession.commit();        System.out.println(&quot;====================================&quot;);        //开启一个新的SqlSession        SqlSession sqlSession2 = sqlSessionFactory.openSession();        StudentMapper studentMapper2 = sqlSession.getMapper(StudentMapper.class);        System.out.println(&quot;开启一个新的SqlSession再执行一次：&quot;);        Student student3 = studentMapper.findStudentById(1L);        //执行删除操作        studentMapper2.deleteById(3L);        System.out.println(&quot;执行删除操作后，再调用一次&quot;);        Student student4 = studentMapper.findStudentById(1L);        sqlSession2.commit();        try {        } finally {            //不要忘记关闭SqlSession            sqlSession.close();            sqlSession2.close();        }    }</code></pre><p>前提：删除 findStudentById 方法：<code>flushCache=true</code>。</p><p>执行之后的结果如下：<br><img src="/images/mybatis/QQ截图20190315162557.png"></p><p>发现，在同一个SqlSession的情况下，只要执行了：insert、update、delete操作，都会清空一级缓存，所以查询 student4 时由于缓存不存在，就会再次发送SQL语句去执行数据库的查询操作。</p><hr><p>以上就是Mybatis中的一级缓存的各种情况了，由于一级缓存是在默默地工作，因此要避免在使用的过程中由于不了解而发生察觉不到的错误。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>Mybatis的二级缓存非常强大，它不同于一级缓存只存在于SqlSession的生命周期中，而是可以理解为存在于：SqlSessionFactory的生命周期中。虽然目前还没有接触过同时存在多个SqlSessionFactory的情况，但可以知道，当存在多个SqlSessionFactory时，它们的缓存都是绑定在各自对象上的，缓存数据在一般情况下是不相通的。只有在使用如Redis这样的缓存数据库时，才可以共享缓存。</p><h4 id="配置二级缓存"><a href="#配置二级缓存" class="headerlink" title="配置二级缓存"></a>配置二级缓存</h4><p>在Mybatis的全局配置settings中有一个参数为：<code>cacheEnabled</code>，这个参数是二级缓存的全局开关。默认值是：true，所以不必配置，如果想要配置，可以在：mybatis-config.xml中添加：</p><pre><code>    &lt;settings&gt;        &lt;!--其他setting配置--&gt;        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;</code></pre><p>二级缓存是和命名空间绑定的，即二级缓存需要配置在<code>Mapper.xml</code>映射文件中，或者配置在Mapper.java接口中。在映射文件中，命名空间就是XML根节点mapper的namespace属性。在Mapper接口中，命名空间就是接口的全限定名。</p><h5 id="Mapper-xml中配置二级缓存"><a href="#Mapper-xml中配置二级缓存" class="headerlink" title="Mapper.xml中配置二级缓存"></a>Mapper.xml中配置二级缓存</h5><p>在保证二级缓存的全局配置开启的情况下，给 <code>StudentMapper.xml</code> 开启二级缓存只需要添加：<code>&lt;cache/&gt;</code> 标签即可：</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;&gt;    &lt;cache/&gt;    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot;/&gt;    &lt;/resultMap&gt;    &lt;!--其他配置--&gt;&lt;/mapper&gt;</code></pre><p>默认的二级缓存会有如下效果：</p><ul><li><p>映射语句文件中的所有select语句将会被缓存。</p></li><li><p>映射语句文件中的所有insert、update、delete语句会刷新缓存。</p></li><li><p>缓存会使用 LRU（最近最少使用）算法来回收。</p></li><li><p>根据时间表，比如 No Flush Interval（没有刷新间隔），缓存不会以任何时间顺序来刷新。</p></li><li><p>缓存会存储集合或对象的1024个引用</p></li><li><p>缓存会被视为 read/write（可读/可写）的，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</p></li></ul><hr><p>所有的这些属性都可以通过缓存元素的属性来修改：</p><pre><code>    &lt;cache        eviction=&quot;FIFO&quot;        flushInterval=&quot;60000&quot;        size=&quot;512&quot;        readOnly=&quot;true&quot;/&gt;</code></pre><p>这个更高级的配置，创建了一个FIFO缓存，并每隔60秒刷新一次，存储集合或对象的512个引用，而且返回的对象被认为是只读的，因此在不同线程中的调用者之间修改它们会导致冲突。</p><p>cache可以配置的属性如下：</p><ul><li>eviction（回收策略）</li></ul><p>（1）LRU（最近最少使用）：移除最长时间不被使用的对象，这是默认值。</p><p>（2）FIFO（先进先出）：按对象进入缓存的顺序来移除它们。</p><p>（3）SOFT（软引用）：移除基于垃圾回收器状态和软引用规则的对象。</p><p>（4）WEAK（弱引用）：更积极地移除基于垃圾回收器状态和弱引用规则的对象。</p><ul><li><p>flushInterval（刷新间隔）：可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式的时间段。默认情况不设置，即没有刷新间隔，缓存仅仅在调用语句时刷新。</p></li><li><p>size（引用数目）：可以被设置为任意的正整数，要记住缓存的对象数目和运行环境的可用内存资源数目。默认值是：1024.</p></li><li><p>readOnly（只读）：属性可以被设置为：true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。默认值是：false，允许修改。</p></li></ul><h5 id="Mapper接口中设置二级缓存"><a href="#Mapper接口中设置二级缓存" class="headerlink" title="Mapper接口中设置二级缓存"></a>Mapper接口中设置二级缓存</h5><p>在使用注解方式时，如果想对注解方法启用二级缓存，还需要在Mapper接口中进行配置，如果Mapper接口也存在对应的XML映射文件，两者同时开启缓存时，还需要特殊配置。</p><p>(1)当只使用注解方式配置二级缓存时，如果在 <code>StudentMapper</code>接口中，则需要增加如下配置。</p><pre><code>@CacheNamespacepublic interface StudentMapper {    //接口方法}</code></pre><p>只需增加该注解即可，该注解还可以配置各项属性：</p><pre><code>@CacheNamespace(        eviction = FifoCache.class,        flushInterval = 600000,        size = 512,        readWrite = true)public interface StudentMapper {    //接口方法}</code></pre><hr><p>(2)当同时使用注解方式和XML映射文件时，如果同时配置了上述的二级缓存，就会抛出如下异常：</p><pre><code>Caches collection already contains value for com.liuzhuo.mapper.StudentMapper</code></pre><p><img src="/images/mybatis/QQ截图20190315171320.png"></p><p>这是因为Mapper接口和对应的XML文件是相同的命名空间，想使用二级缓存，两者必须同时配置（如果接口不存在使用注解方式的方法，可以只在XML中配置），因此按照上面的方式进行配置就会出错，这个时候应该使用参数缓存。在Mapper接口中，参照缓存配置如下：</p><pre><code>@CacheNamespaceRef(StudentMapper.class)public interface StudentMapper {}</code></pre><p>注意使用的注解是：<code>@CacheNamespaceRef</code> 多了Ref的后缀！！！</p><p>因为想让StudentMapper接口中的注解方法和XML中的方法使用相同的缓存，因此使用参数缓存配置 StudentMapper.class，这样就会使用命名空间 com.liuzhuo.mapper.StudentMapper的缓存配置，即：StudentMapper.xml中配置的缓存。</p><p>Mapper接口可以通过注解引用XML映射文件或者其他接口的缓存，在XML中也可以配置参数缓存，如在 StudentMapper.xml中：</p><pre><code>&lt;cache-ref namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;/&gt;</code></pre><p>这样配置后，XML就会引用Mapper接口中配置的二级缓存，同样可以避免同时配置二级缓存导致的冲突。</p><hr><p>Mybatis中很少会同时使用Mapper接口注解方式和XML映射文件，所以参照缓存并不是为了解决这个问题而设计的。参照缓存除了能够通过引用其他缓存减少配置外，主要的作用是解决脏读。</p><p>为了保持后续测试一致，对 StudentMapper 接口和XML映射文件进行如下配置。</p><pre><code>@CacheNamespaceRef(StudentMapper.class)public interface StudentMapper {}&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;&gt;    &lt;cache        eviction=&quot;FIFO&quot;        flushInterval=&quot;60000&quot;        size=&quot;512&quot;        readOnly=&quot;false&quot;/&gt;&lt;/mapper&gt;</code></pre><hr><h4 id="使用二级缓存"><a href="#使用二级缓存" class="headerlink" title="使用二级缓存"></a>使用二级缓存</h4><p>上面讲到了二级缓存的配置，现在开始讲解二级缓存的使用，当调用 StudentMapper的所有select查询方法时，二级缓存就已经开始起作用了。需要注意的是，由于配置的是可读写的缓存，而Mybatis使用 <code>SerializedCache</code> 序列化缓存来实现可读写缓存类，并通过序列化和反序列化来保证通过缓存获取数据时，得到的是一个新的实例。因此，如果配置为只读缓存时，Mybatis就会使用Map来存储缓存值，这种情况下，从缓存中获取的对象就是同一个实例。</p><p>因为使用可读写缓存，可以使用  <code>SerializedCache</code> 序列化缓存。这个缓存类要求所有被序列化的对象必须实现 <code>Serializable</code> 接口，所以还需要修改Student对象。</p><pre><code>public class Student implements Serializable {    private static final long serializableUID = 7483479274923474792L;    //其他属性和set、get方法}</code></pre><hr><p>编写测试方法：</p><pre><code>    public void testSelectStudent() {        SqlSession sqlSession = sqlSessionFactory.openSession();        Student student = null;        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            System.out.println(&quot;第一次调用&quot;);            student = studentMapper.findStudentById(1L);            System.out.println(student);            student.setStuName(&quot;dj&quot;);            System.out.println(&quot;第二次调用&quot;);            Student student2 = studentMapper.findStudentById(1L);            System.out.println(student2);            System.out.println(&quot;两个对象是否相等：&quot; + (student == student2));        } finally {            sqlSession.close();        }        System.out.println(&quot;开启新的Sqlsession~~~~&quot;);        //开启一个新的SqlSession        sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper2 = sqlSession.getMapper(StudentMapper.class);            System.out.println(&quot;开启一个新的SqlSession后，执行第一次：&quot;);            Student student3 = studentMapper2.findStudentById(1L);            System.out.println(student3);            System.out.println(&quot;开启一个新的SqlSession后，执行第二次：&quot;);            Student student4 = studentMapper2.findStudentById(1L);            System.out.println(student4);            System.out.println(&quot;两个对象是否相等：&quot; + (student3 == student4));            sqlSession.commit();        } finally {            //不要忘记关闭SqlSession            sqlSession.close();        }    }</code></pre><p>运行结果：<br><img src="/images/mybatis/QQ截图20190315180036.png"></p><p>日志中：出现的以：<code>Cache Hit Ratio</code> 开头的语句，这行语句后面输出的值为当前执行方法的缓存命中率（二级缓存的，不包括一级缓存）。</p><p>在测试第一部分中，第一次查询student时由于没有缓存，所以执行了数据库查询，在第二次查询获取student2时，student和student2是完全相同的实例，这里是使用了一级缓存，所以返回的是同一个实例，此时的命中率还是：0。</p><p>当调用SqlSession.close（）后，SqlSession才会保存查询数据到二级缓存中。在这之后二级缓存才有了缓存数据。所以可以看到在第一部分的两次查询时，命中率都是：0。</p><p>在第二部分测试代码中，再次获取student3对象时，日志中并没有输出数据库查询，而是输出了命中率，这时的命中率是：0.33333333333。这是第三次查询，并且得到了二级缓存中的数据，因此该方法一共被请求了3次，有一次命中，所以命中率就是三分之。后面再获取student4时，就是4次请求，2次命中，命中率为：0.5。并且因为是读写缓存的缘故，student3 和student4 都是反序列化得到的结果，所以它们不是相同的实例。在这一部分，这两个实例是读写安全的，其属性不会互相影响。</p><hr><font color="red"><strong>提示：</strong></font><p>在这个例子中并没有实现真正的读写安全，为啥？</p><p>因为这个测试中加入了一段不该有的代码，即：<code>student.setStuName(&quot;dj&quot;);</code> 这里修改了：student的属性后，按照常理应该更新数据到数据库中，更新后会清空一级、二级缓存，这样第二部分代码中就不出现查询结果的 stuName 都是 <code>&#39;dj&#39;</code> 的情况了。所以想要安全使用，需要避免毫无意义的修改，这样可以避免人为产生的脏数据，避免缓存和数据库的数据不一致的情况。</p><hr><p>Mybatis默认提供的缓存实现都是基于Map实现的内存缓存，已经可以满足基本的应用。但是当需要缓存大量的数据时，不能仅仅通过提高内存来使用Mybatis的二级缓存，还可以选择一些类似 <code>EhCache</code>的缓存框架或 <code>Redis</code>缓存数据库等工具来保存Mybatis的二级缓存数据。</p><hr><h3 id="集成EhCache缓存"><a href="#集成EhCache缓存" class="headerlink" title="集成EhCache缓存"></a>集成EhCache缓存</h3><p>EhCache是一个纯粹的Java进程内的缓存框架，具有快速、精干等特点。具体来说，EhCache主要的特性如下。</p><ul><li><p>快速</p></li><li><p>简单</p></li><li><p>多种缓存策略</p></li><li><p>缓存数据有内存和磁盘两级，无须担心容量问题</p></li><li><p>缓存数据会在虚拟机重启的过程中写入磁盘</p></li><li><p>可以通过RMI、可插入API等方式进行分布式缓存</p></li><li><p>具体缓存和缓存管理器的侦听接口</p></li></ul><p>因为以上诸多优点，Mybatis项目开发者最早提供了EhCache的Mybatis二级缓存实现，该项目名为 <code>ehcache-cache</code></p><p>地址是：<a href="https://github.com/mybatis/ehcache-cache" target="_blank" rel="noopener">https://github.com/mybatis/ehcache-cache</a></p><hr><p>（1）添加项目依赖</p><p>在pom.xml中添加如下的依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>（2）配置EhCache</p><p>在 src/main/resources 目录下新增 <code>ehcache.xml</code>文件。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;    &lt;!-- 磁盘缓存位置 --&gt;    &lt;diskStore path=&quot;E:\DEV_ENV\ehcache&quot;/&gt;    &lt;!-- 默认缓存 --&gt;    &lt;defaultCache            maxEntriesLocalHeap=&quot;10000&quot;            eternal=&quot;false&quot;            copyOnRead=&quot;true&quot;            copyOnWrite=&quot;true&quot;            timeToIdleSeconds=&quot;120&quot;            timeToLiveSeconds=&quot;120&quot;            maxEntriesLocalDisk=&quot;10000000&quot;            diskExpiryThreadIntervalSeconds=&quot;120&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;        &lt;persistence strategy=&quot;localTempSwap&quot;/&gt;    &lt;/defaultCache&gt;&lt;/ehcache&gt;</code></pre><p>有关EhCache的详细配置可以参考地址：<a href="http://www.ehcache.org/ehcache.xml" target="_blank" rel="noopener">http://www.ehcache.org/ehcache.xml</a></p><p>在上面的配置中重点要看两个属性，<code>copyOnRead</code> 和 <code>copyOnWrite</code> 属性。这两个属性的配置会对后面使用二级缓存产生很大影响。</p><p><code>copyOnRead的含义：</code> 判断从缓存中读取数据时是返回对象的引用还是复制一个对象返回。默认情况下是false，即返回数据的引用，这种情况下返回的都是相同的对象，和Mybatis默认缓存中的只读对象是相同的。如果设置为：true，那就是可读写缓存，每次读取缓存时都会复制一个新的实例。</p><p><code>copyOnWrite的含义：</code> 判断写入缓存时是直接缓存对象的引用还是复制一个对象，然后缓存，默认也是false。如果想使用可读写缓存，就需要将这两个属性配置为true，如果使用只读缓存，可以不配置这两个属性，使用默认值false即可。</p><hr><p>（3）修改StudentMapper.xml中的缓存配置</p><p>ehcache-cache提供了如下2个可选的缓存实现。</p><ul><li><p>org.mybatis.caches.ehcache.EhcacheCache</p></li><li><p>org.mybatis.caches.ehcache.LoggingEhcache</p></li></ul><p>这两个缓存中，第二个是带日志的缓存，由于Mybatis初始化缓存时，如果Cache不是继承自LoggingEhcache(org.mybatis.caches.ehcache.LoggingEhcache)，Mybatis便会使用Logging Ehcache 装饰代理缓存，所以上面两个缓存使用时并没有区别，都会输出缓存命中率的日志。</p><p>修改 StudentMapper.xml 中的配置：</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;&gt;    &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;    &lt;!--其他配置--&gt;&lt;/mapper&gt;</code></pre><p>只通过设置type属性就可以使用EhCache缓存了，这时cache的其他属性都不会起到任何作用，针对缓存的配置都在ehcache.xml中进行。在ehcache.xml配置文件中，只有一个默认的缓存配置，所以配置使用EhCache缓存的Mapper映射文件都会有一个以映射文件命名空间命名的缓存。如果想针对某一个命名空间进行配置，需要在ehcache.xml中添加一个和映射文件命名空间一致的缓存配置，例如针对：StudentMapper，可以进行如下配置：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;    &lt;!-- 磁盘缓存位置 --&gt;    &lt;diskStore path=&quot;E:\DEV_ENV\ehcache&quot;/&gt;    &lt;!-- 默认缓存 --&gt;    &lt;defaultCache            maxEntriesLocalHeap=&quot;10000&quot;            eternal=&quot;false&quot;            copyOnRead=&quot;true&quot;            copyOnWrite=&quot;true&quot;            timeToIdleSeconds=&quot;120&quot;            timeToLiveSeconds=&quot;120&quot;            maxEntriesLocalDisk=&quot;10000000&quot;            diskExpiryThreadIntervalSeconds=&quot;120&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;        &lt;persistence strategy=&quot;localTempSwap&quot;/&gt;    &lt;/defaultCache&gt;    &lt;!-- StudentMapper缓存 --&gt;    &lt;cache            name=&quot;com.liuzhuo.mapper.StudentMapper&quot;            maxElementsInMemory=&quot;1000&quot;            eternal=&quot;false&quot;            copyOnRead=&quot;true&quot;            copyOnWrite=&quot;true&quot;            timeToIdleSeconds=&quot;5000&quot;            timeToLiveSeconds=&quot;5000&quot;            diskPersistent=&quot;true&quot;            overflowToDisk=&quot;false&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;&lt;/ehcache&gt;</code></pre><hr><p>执行之前的测试方法，会发现：<code>E:\DEV_ENV\ehcache</code>目录下会多出几个文件：<br><img src="/images/mybatis/QQ截图20190315201938.png"></p><hr><h3 id="集成Redis缓存"><a href="#集成Redis缓存" class="headerlink" title="集成Redis缓存"></a>集成Redis缓存</h3><p>Redis是一个高性能的 key-value 数据库，之前的博客中有一系列的Redis讲解，大家可以去看看，回顾一下。</p><p>Mybatis项目开发者提供了Redis的Mybatis二级缓存实现，该项目名为：<code>redis-cache</code>，目前只有beta版，项目地址是：</p><p><a href="https://github.com/mybatis/redis-cache" target="_blank" rel="noopener">https://github.com/mybatis/redis-cache</a></p><hr><p>（1）添加项目依赖</p><p>在pom.xml文件中添加如下依赖：</p><pre><code>  &lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-redis&lt;/artifactId&gt;    &lt;version&gt;1.0.0-beta2&lt;/version&gt;  &lt;/dependency&gt;</code></pre><p>mybatis-redis 目前只有beta版本。</p><p>（2）配置Redis</p><p>使用Redis前，必须有一个Redis服务，有关Redis安装启动的相关内容，请看我之前的博客。</p><p>参考地址：<a href="https://redis.io/topics/quickstart" target="_blank" rel="noopener">https://redis.io/topics/quickstart</a></p><p>Redis服务启动后，在 src/main/resources 目录下新增redis.properties文件。</p><pre><code>host=localhostport=6379connectionTimeout=5000soTimeout=5000password=database=0clientName=</code></pre><p>上面这几项是redis-cache项目提供的可以配置的参数，这里配置了服务器地址、端口号和超时时间。</p><p>（3）修改StudentMapper.xml中的缓存配置</p><p>redis-cache 提供了1个 MyBatis 缓存实现， <code>org.mybatis.caches.redis.RedisCache</code>。</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;&gt;    &lt;cache type=&quot;org.mybatis.caches.redis.RedisCache&quot;/&gt;    &lt;!--其他配置--&gt;&lt;/mapper&gt;</code></pre><p>配置很简单，RedisCache在保存缓存数据和获取缓存数据时，使用了Java的序列化和反序列化，因此还需要保证被缓存的对象必须实现Serializable接口。</p><p>Redis缓存并不会因为应用的关闭而失效。</p><hr><p>当需要分布式部署应用时，如果使用Mybatis自带缓存或基础的EhCache缓存，分布式应用会各自拥有自己的缓存，它们之间不会共享缓存，这种方式会消耗更多的服务器资源。如果使用类似Redis的缓存服务，就可以将分布式应用连接到同一个缓存服务器，实现分布式应用间的缓存共享。</p><hr><h3 id="二级缓存适用场景"><a href="#二级缓存适用场景" class="headerlink" title="二级缓存适用场景"></a>二级缓存适用场景</h3><p>二级缓存虽然好处很多，但并不是什么时候都可以使用。在以下场景中，推荐使用二级缓存。</p><ul><li><p>以查询为主的应用中，只有尽可能少的增、删、改操作。</p></li><li><p>绝大多数以单表操作存在时，由于很少存在互相关联的情况，因此不会出现脏数据。</p></li><li><p>可以按业务划分对表进行分组时，如关联的表比较少时，可以通过参照缓存进行配置。</p></li></ul><p>除了推荐使用的情况，如果脏读对系统没有影响，也可以考虑使用。在无法保证数据不出现脏读的情况下，建议在业务层使用可控制的缓存代替二级缓存。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的高级查询</title>
      <link href="/2019/03/13/mybatis-zhong-de-gao-ji-cha-xun/"/>
      <url>/2019/03/13/mybatis-zhong-de-gao-ji-cha-xun/</url>
      
        <content type="html"><![CDATA[<p>通过前面几篇博客的学习，我们已经了解了 MyBatis 中最常用的部分。基本的增、删、改、查操作己经可以满足我们大部分的需求，今天将会对除上述内容之外的知识点进行详细介绍。<br><a id="more"></a></p><p>本篇博客主要包含的内容为MyBatis的高级结果映射，主要处理数据库一对一、一对多的查询，另外就是在 MyBtis 中使用存储过程的方法，处理存储过程的入参和出参方法。</p><hr><h3 id="高级映射"><a href="#高级映射" class="headerlink" title="高级映射"></a>高级映射</h3><p>在关系型数据库中，我们经常要处理 一对一、一对多 的关系 例如， 一辆汽车需要有引擎，这是一对一的关系。 一辆汽车有4个或更多个轮子，这是一对多的关系。</p><p>在Mybatis中使用3种方式来操作级联：</p><ul><li><p>association，代表一对一的关系，比如中国公民和身份证是一对一的关系。</p></li><li><p>collection，代表一对多的关系，比如班级和学生是一对多的关系，一个班级有多个学生。</p></li><li><p>discriminator，是鉴别器，它可以根据实际情况，选择采用哪个类作为实例，允许你根据特定的条件去关联不同的结果集。</p></li></ul><hr><p>为了方便讲解，我们来创建一系列的数据库表，它们的模型关系，如下所示：<br><img src="/images/mybatis/QQ截图20190313130557.png"></p><p>学生表为核心，学生表与学生证表是一对一的关系；学生表与课程成绩表是一对多的关系，一个学生有多门课；课程表与课程成绩表也是一对多的关系。</p><p>学生有男生与女生，所以健康项目不一样，这里我就列举了一个不同点，简化一下。根据学生的性别不同来决定使用哪个表，而鉴别性别就需要使用鉴别器了。</p><hr><p>这里，大家可能会想到，数据库中不是还有多对多的关系嘛？为啥这里没有体现呢？</p><p>这是因为在实际中，多对多的关系应用不多，因为它比较复杂，会增加理解和关联的复杂性，推荐的方法是，使用一对多的关系把它分解为双向关系，以降低关系的复杂度，简化程序。</p><hr><p>根据上述的数据库表的描述，生成相应的表，然后创建新的maven工程。</p><p>（1）生成Mybatis数据库：<br><img src="/images/mybatis/QQ截图20190313131616.png"></p><p>（2）创建相关的表：</p><pre><code>use mybatis;drop table if exists student;drop table if exists student_selfcard;drop table if exists lecture;drop table if exists student_lecture;drop table if exists student_female_health;drop table if exists student_male_health;create table student( id  INT(20) not null auto_increment COMMENT &#39;学生编号&#39;, stu_name VARCHAR(60) not null comment &#39;学生姓名&#39;, stu_sex TINYINT(4) not null comment &#39;性别&#39;, stu_id int(20) not NULL COMMENT &#39;学生证号&#39;, PRIMARY key(id));create table student_selfcard( id INT(20) not null auto_increment COMMENT &#39;编号&#39;, stu_number int(20) not null COMMENT &#39;学生证号&#39;, stu_birthplace VARCHAR(60) COMMENT &#39;籍贯&#39;, stu_start_time date COMMENT &#39;发证日期&#39;, stu_end_time date COMMENT &#39;结束日期&#39;, primary key(id));create table lecture( id int(20) not null comment &#39;编号&#39;, lecture_name varchar(60) not null comment &#39;课程名称&#39;, primary key(id));create table student_lecture( id int(20) not null auto_increment comment &#39;编号&#39;, stu_id int(20) not null comment &#39;学生编号&#39;, lecture_id int(20) not null comment &#39;课程编号&#39;, grade DECIMAL(16,2) not null comment &#39;课程成绩&#39;, primary key(id));create table student_female_health( id int(20) not null auto_increment comment &#39;编号&#39;, stu_id int(20) not null comment &#39;学生编号&#39;, check_date date not null comment &#39;检查日期&#39;, heart varchar(60) not null comment &#39;心&#39;, uterus varchar(60) not null comment &#39;子宫&#39;, primary key(id));create table student_male_health( id int(20) not null auto_increment comment &#39;编号&#39;, stu_id int(20) not null comment &#39;学生编号&#39;, check_date date not null comment &#39;检查日期&#39;, heart varchar(60) not null comment &#39;心&#39;, prostate varchar(60) not null comment &#39;前列腺&#39;, primary key(id));</code></pre><p><img src="/images/mybatis/QQ截图20190313135537.png"></p><p>(3) 创建新的maven工程</p><p>项目的整体结构：<br><img src="/images/mybatis/QQ截图20190313145410.png"></p><p>entities：<br><img src="/images/mybatis/QQ截图20190313145502.png"></p><p>mappers：<br><img src="/images/mybatis/QQ截图20190313145550.png"></p><p>typeHanler：<br><img src="/images/mybatis/QQ截图20190313145813.png"></p><p>pom.xml:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.liuzhuo&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;        &lt;!--配置即使xml不在resources中，也能读取到xml文件--&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>jdbc.properties：</p><pre><code>jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8jdbc.username=rootjdbc.password=123456</code></pre><p>log4j.properties:</p><pre><code>#全局配置log4j.rootLogger=ERROR,stdout#MyBatis日志配置log4j.logger.com.liuzhuo=TRACE#控制台输出配置log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%5p] [%t] - %m %x %n</code></pre><p>mybatis-config.xml:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties resource=&quot;jdbc.properties&quot;&gt;    &lt;/properties&gt;    &lt;settings&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;    &lt;/settings&gt;    &lt;!--别名--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.liuzhuo.entities&quot;/&gt;    &lt;/typeAliases&gt;    &lt;typeHandlers&gt;        &lt;typeHandler handler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot; javaType=&quot;com.liuzhuo.enums.Sex&quot;/&gt;    &lt;/typeHandlers&gt;    &lt;!--定义数据库信息，默认使用development数据库构建环境--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!--采用JDBC事务管理--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;            &lt;/transactionManager&gt;            &lt;!--配置数据源的信息--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.liuzhuo.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>entities中的POJO，我就不列出来了，大家自行解决。</p><p>Sex:</p><pre><code>public enum Sex {    MALE(1, &quot;男&quot;), FEMALE(2, &quot;女&quot;);    private int id;    private String name;    private Sex(int id, String name) {        this.id = id;        this.name = name;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public static Sex getSex(int id) {        if (id == 1) {            return MALE;        } else if (id == 2) {            return FEMALE;        }        return null;    }}</code></pre><p>SexEnumTypeHandler:</p><pre><code>public class SexEnumTypeHandler extends BaseTypeHandler&lt;Sex&gt; {    @Override    public void setNonNullParameter(PreparedStatement ps, int i, Sex parameter, JdbcType jdbcType) throws SQLException {        System.out.println(&quot;自定义的枚举类型，set&quot;);        ps.setInt(i, parameter.getId());    }    @Override    public Sex getNullableResult(ResultSet rs, String columnName) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = rs.getInt(columnName);        return Sex.getSex(id);    }    @Override    public Sex getNullableResult(ResultSet rs, int columnIndex) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = rs.getInt(columnIndex);        return Sex.getSex(id);    }    @Override    public Sex getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = cs.getInt(columnIndex);        return Sex.getSex(id);    }}</code></pre><p>StudentMapper.xml:</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;&gt;    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;!--新添加的字段--&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;findStudentById&quot; resultMap=&quot;studentMap&quot;&gt;         select * from student where id = #{id}     &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>test:</p><pre><code>public class MainTest {    private static SqlSessionFactory sqlSessionFactory;    @BeforeClass    public static void init() {        try {            String mybatisConfig = &quot;mybatis-config.xml&quot;;            InputStream inputStream = Resources.getResourceAsStream(mybatisConfig);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);            inputStream.close();        } catch (IOException e) {            e.printStackTrace();        }    }    @Test    public void testSelectStudent() {        SqlSession sqlSession = sqlSessionFactory.openSession();            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            Student student = studentMapper.findStudentById(1L);            System.out.println(student);            try {        } finally {            //不要忘记关闭SqlSession            sqlSession.close();        }    }}</code></pre><p><img src="/images/mybatis/QQ截图20190313150007.png"></p><hr><p>运行测试：<br><img src="/images/mybatis/QQ截图20190313150123.png"></p><p><strong>数据库中的数据，自己随意添加呀，没有要求的。</strong></p><p>以上就是我们的新的项目工程，现在已经能够运行了，下面，我们开始讲解Mybatis中的高级映射功能。</p><h3 id="一对一映射"><a href="#一对一映射" class="headerlink" title="一对一映射"></a>一对一映射</h3><p>一个学生对应一个学生证，属于一对一映射。</p><h4 id="使用自动映射处理一对一映射"><a href="#使用自动映射处理一对一映射" class="headerlink" title="使用自动映射处理一对一映射"></a>使用自动映射处理一对一映射</h4><p>添加新的POJO对象：StudentAndSelfcard类：</p><pre><code>public class StudentAndSelfcard extends Student {    private StudentSelfcard studentSelfcard;    public StudentSelfcard getStudentSelfcard() {        return studentSelfcard;    }    public void setStudentSelfcard(StudentSelfcard studentSelfcard) {        this.studentSelfcard = studentSelfcard;    }    @Override    public String toString() {        return super.toString() +                &quot; + StudentAndSelfcard{ &quot; +                &quot;studentSelfcard=&quot; + studentSelfcard +                &#39;}&#39;;    }}</code></pre><p>该类就是一个Student类中添加一个StudentSelfcard属性。</p><p>修改：StudentMapper.xml</p><p>添加一个新的<code>selectStudentAndSelfcardById</code> select 标签：</p><pre><code>    &lt;select id=&quot;selectStudentAndSelfcardById&quot; resultType=&quot;studentAndSelfcard&quot;&gt;        select        s.id,        s.stu_name as &#39;stuName&#39; ,        s.stu_sex as &#39;stuSex&#39;,        s.stu_id as &#39;stuId&#39; ,        ss.id as &#39;studentSelfcard.id&#39;,        ss.stu_number as &#39;studentSelfcard.stuNumber&#39;,        ss.stu_birthplace as &#39;studentSelfcard.stuBirthplace&#39;,        ss.stu_start_time as &#39;studentSelfcard.stuStartTime&#39;,        ss.stu_end_time as &#39;studentSelfcard.stuEndTime&#39;        from student as s        JOIN student_selfcard as ss on s.stu_id = ss.stu_number        where s.id = #{id}    &lt;/select&gt;</code></pre><p>注意上面，因为使用的是Mybatis的自动映射，所以，从student_selfcard表中获取的数据，在使用别名时，都加上了<code>studentSelfcard</code>前缀，通过这种方式将student_selfcard表中的数据映射到StudentAndSelfcard类中的studentSelfcard属性中。</p><hr><p>在StudentMapper中添加新的方法：<code>selectStudentAndSelfcardById</code></p><pre><code>public interface StudentMapper {    public Student findStudentById(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById(Long id);}</code></pre><hr><p>在MainTest中添加新的测试方法：</p><pre><code>    @Test    public void testSelectStudentAndSelfcardById() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            StudentAndSelfcard studentAndSelfcard = studentMapper.selectStudentAndSelfcardById(1L);            //student不为空            Assert.assertNotNull(studentAndSelfcard);            //studentSelfcard不为空            Assert.assertNotNull(studentAndSelfcard.getStudentSelfcard());            System.out.println(studentAndSelfcard);        } finally {            sqlSession.close();        }    }</code></pre><p><img src="/images/mybatis/QQ截图20190313154824.png"></p><p>可以看到映射成功，通过 SQL 日志可以看到已经查询出的一条数据， Mybatis 将这条数据映射到了两个类中。</p><p>像这样通过一次查询，将结果映射到不同对象的方式，称之为：<strong><font color="red">关联的嵌套结果映射。</font></strong></p><p>关联 嵌套结果 映射 ，需要关联多张表，将所有需要的值一次性查询出来。这种方式的好处是减少数据库查询次数 ，减轻数据库的压力， 缺点是要写很复杂的 SQL，并且当嵌套结果更复杂时， 不容易一次写正确 ，由于要在应用服务器上将结果映射到不同的类上。 因此 ，会增加应用服务器的压力。当一定要使用 嵌套结果 并且整个复杂的 SQL 执行速度很快时 ，建议使用关联的嵌套结果映射。</p><hr><h4 id="resultMap处理一对一映射"><a href="#resultMap处理一对一映射" class="headerlink" title="resultMap处理一对一映射"></a>resultMap处理一对一映射</h4><p>除了使用Mybatis的自动映射来处理一对一嵌套外，还可以在XML映射文件中配置结果映射。</p><p>使用resultMap来实现与上一节相同的效果。</p><p>在 <code>StudentMapper.xml</code> 文件中：</p><p>添加新的resultMap：</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap&quot; type=&quot;studentAndSelfcard&quot;&gt;        &lt;!--student的映射--&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;        &lt;!--studentselfcard的映射--&gt;        &lt;result column=&quot;studentSelfcard_id&quot; property=&quot;studentSelfcard.id&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_number&quot; property=&quot;studentSelfcard.stuNumber&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_birthplace&quot; property=&quot;studentSelfcard.stuBirthplace&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_start_time&quot; property=&quot;studentSelfcard.stuStartTime&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_end_time&quot; property=&quot;studentSelfcard.stuEndTime&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>在映射studentSelfcard表时，列名我都加上了 <code>studentSelfcard_</code> 的前缀了，为了防止与student中有相同的列名。</p><p>添加新的select：</p><pre><code>    &lt;select id=&quot;selectStudentAndSelfcardById02&quot; resultMap=&quot;studentSelfcardMap&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id,        ss.id as &#39;studentSelfcard_id&#39;,        ss.stu_number as &#39;studentSelfcard_stu_number&#39;,        ss.stu_birthplace as &#39;studentSelfcard_stu_birthplace&#39;,        ss.stu_start_time as &#39;studentSelfcard_stu_start_time&#39;,        ss.stu_end_time as &#39;studentSelfcard_stu_end_time&#39;        from student as s        JOIN student_selfcard as ss on s.stu_id = ss.stu_number        where s.id = #{id}    &lt;/select&gt;</code></pre><p>看到，查询student时，我们都没有使用别名，因为此时，我们在resultMap中配置了，此时查询出来的列名要与resultMap中的<code>column</code>同名才行。</p><p>所以，查询student_selfcard表时，我们都使用了<code>studentSelfcard_</code>前缀的别名，来与resultMap中的<code>column</code>同名。</p><font color="red">此时，是不是已经看出了与自动映射的区别了，在自动映射中，列名的别名是对应着POJO的属性名，而使用resultMap的话，select中查询出来的列名的别名，要与resultMap中的column的属性值一模一样！！！</font><p><strong>此时在select标签中，使用的是resultMap元素，而不是resultType元素了。select标签中的resultMap元素等于resultMap标签中的id元素值。</strong></p><hr><p>在StudentMapper接口中添加:<code>selectStudentAndSelfcardById02</code></p><pre><code>public interface StudentMapper {    public Student findStudentById(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById02(Long id);}</code></pre><hr><p>在MainTest中添加新的测试方法：</p><pre><code>    @Test    public void testSelectStudentAndSelfcardById02() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            StudentAndSelfcard studentAndSelfcard = studentMapper.selectStudentAndSelfcardById02(1L);            //student不为空            Assert.assertNotNull(studentAndSelfcard);            //studentSelfcard不为空            Assert.assertNotNull(studentAndSelfcard.getStudentSelfcard());            System.out.println(studentAndSelfcard);        } finally {            sqlSession.close();        }    }</code></pre><p>运行结果：<br><img src="/images/mybatis/QQ截图20190313162728.png"></p><p>结果和使用自动映射的效果一模一样，但是，大家肯定会觉得这样岂不是更加麻烦了，还多写了一个resultMap标签来映射，不仅没有方便开发，还增加了工作量。</p><p>下面就使用resultMap的继承功能：</p><h5 id="resultMap的继承功能"><a href="#resultMap的继承功能" class="headerlink" title="resultMap的继承功能"></a>resultMap的继承功能</h5><p>在我们的 xxxMapper.xml中都会有一个基本的xxxtMap的resultMap映射，这个映射可以使用 <strong><code>MyBatis的代码生成器生成</code></strong>，所以可以省略手动工作。</p><p>关于MyBatis的代码生成器生成，后面我会讲到，大家不要急，现在只需要知道就行。</p><hr><p>在我们的 StudentMapper.xml 中的基类resultMap为：</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>只映射了student的属性。</p><p>添加新的resultMap标签：（studentSelfcardMap02）</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;studentSelfcardMap02&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;!--studentselfcard的映射--&gt;        &lt;result column=&quot;studentSelfcard_id&quot; property=&quot;studentSelfcard.id&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_number&quot; property=&quot;studentSelfcard.stuNumber&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_birthplace&quot; property=&quot;studentSelfcard.stuBirthplace&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_start_time&quot; property=&quot;studentSelfcard.stuStartTime&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_end_time&quot; property=&quot;studentSelfcard.stuEndTime&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>可以看到新的<code>studentSelfcardMap02</code> 中使用 <code>extends</code>关键字继承了 <code>studentMap</code>。</p><p>此时只需要书写：studentSelfcard的相关属性即可，简化了我们的书写。</p><p>而且如果要修改：student表的话，我们只需要修改：studentMap一次即可，不需要修改多个resultMap。</p><p>将 <code>select id=selectStudentAndSelfcardById02</code>的 <strong><code>resultMap</code></strong> 改为：<code>selectStudentAndSelfcardById02</code>,然后运行<code>testSelectStudentAndSelfcardById02</code></p><p>发现运行还是成功的。</p><hr><h4 id="使用resultMap的association"><a href="#使用resultMap的association" class="headerlink" title="使用resultMap的association"></a>使用resultMap的association</h4><p>添加新的resultMap标签：</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap03&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;!--studentselfcard的映射--&gt;        &lt;association property=&quot;studentSelfcard&quot; columnPrefix=&quot;studentSelfcard_&quot; javaType=&quot;studentSelfcard&quot;&gt;            &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;            &lt;result property=&quot;stuNumber&quot; column=&quot;stu_number&quot;/&gt;            &lt;result property=&quot;stuBirthplace&quot; column=&quot;stu_stu_birthplace&quot;/&gt;            &lt;result property=&quot;stuStartTime&quot; column=&quot;stu_start_time&quot;/&gt;            &lt;result property=&quot;stuEndTime&quot; column=&quot;stu_end_time&quot;/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;</code></pre><p>association标签包含以下属性：</p><ul><li><p>property：对应POJO中的属性名，必须填</p></li><li><p>javaType：属性对应的Java类型（可以使用别名）</p></li><li><p>resultMap：可以直接使用现有的resultMap，然后就不要在这里配置了。</p></li><li><p>columnPrefix：查询列的前缀，在子标签配置result的column时可以省略前缀。</p></li></ul><p>还有其他的属性，此处不做过多的介绍了。</p><p>然后运行，结果会是一样的，这里就不演示了。</p><hr><p>使用association配置时，还可以使用resultMap配置一个已经存在的resultMap映射，一般情况下，如果使用了Mybatis代码生成器，都会生成每个表对应实体的resultMap配置，也可以手动写一个resultMap。</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardBaseMap&quot; type=&quot;studentSelfcard&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_number&quot; property=&quot;stuNumber&quot;/&gt;        &lt;result column=&quot;stu_birthplace&quot; property=&quot;stuBirthplace&quot;/&gt;        &lt;result column=&quot;stu_start_time&quot; property=&quot;stuStartTime&quot;/&gt;        &lt;result column=&quot;stu_end_time&quot; property=&quot;stuEndTime&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>添加新的resultMap：</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap04&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentSelfcard&quot; columnPrefix=&quot;studentSelfcard_&quot;  resultMap=&quot;studentSelfcardBaseMap&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>此时，就很简单了，看起来很清爽了。</p><p>需要注意的是，<code>studentSelfcardBaseMap</code>：现在是写在：<code>StudentMapper.xml</code>中的，但是实际开发中，<code>studentSelfcardBaseMap</code>应该在<code>StudentSelfcardMapper.xml</code>文件中，此时，<code>studentSelfcardMap04</code>就不能简单的直接使用: <code>resultMap=studentSelfcardBaseMap</code>了，必须要加上 namespace命名空间。</p><p>如下：</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap04&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentSelfcard&quot; columnPrefix=&quot;studentSelfcard_&quot;  resultMap=&quot;com.liuzhuo.mapper.StudentSelfcardMapper.studentSelfcardBaseMap&quot;/&gt;    &lt;/resultMap&gt;</code></pre><hr><h4 id="association标签的嵌套查询"><a href="#association标签的嵌套查询" class="headerlink" title="association标签的嵌套查询"></a>association标签的嵌套查询</h4><p>除了前面3种通过复杂的SQL查询获取结果外，还可以利用简单的SQL通过多次查询转换为我们需要的结果，这种方式与根据业务逻辑手动执行多次SQL的方式相像，最后将结果组合成一个对象。</p><p>association标签的嵌套查询常用的属性：</p><ul><li><p>select：另一个映射查询的id，Mybatis会额外执行这个查询获取嵌套对象的结果。</p></li><li><p>column：列名（或别名），将主查询中列的结果作为嵌套查询的参数，配置方式如：<code>column={prop1=col1,prop2=col2}</code>,其中prop1和prop2将作为嵌套查询的参数，就像#{prop1}一样，col1和col2就是主查询出来的列名。</p></li><li><p>fetchType：数据加载方式，可选值为：<code>lazy</code> 和 <code>eager</code>，分别为延迟加载和积极加载，这个配置会覆盖全局的lazyLoadingEnabled配置。</p></li></ul><hr><p>使用嵌套查询的方式配置一个和前面功能一样的方法，首先在 <code>StudentMapper.xml</code> 中：</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap05&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentSelfcard&quot; column=&quot;stuNumber=stu_id&quot;                     select=&quot;com.liuzhuo.mapper.StudentSelfcardMapper.selectStudentSelfcardBystuNumber&quot;&gt;        &lt;/association&gt;    &lt;/resultMap&gt;</code></pre><p>然后创建一个select标签：</p><pre><code>    &lt;select id=&quot;selectStudentAndSelfcardById03&quot; resultMap=&quot;studentSelfcardMap05&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id,        from student as s        where s.id = #{id}    &lt;/select&gt;</code></pre><p>注意关联中已经没有了 <code>studentSelfcard</code>了 ，因为我们不再是通过一个SQL语句来获取全部的信息了，学生证表的信息是通过配置的<code>select=&quot;com.liuzhuo.mapper.StudentSelfcardMapper.selectStudentSelfcardBystuNumber&quot;</code> 来查询的，这个方法写在 <code>StudentSelfcardMapper.xml</code>中。</p><p><img src="/images/mybatis/QQ截图20190313173138.png"></p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentSelfcardMapper&quot;&gt;    &lt;resultMap id=&quot;studentSelfcard&quot; type=&quot;studentSelfcard&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_number&quot; property=&quot;stuNumber&quot;/&gt;        &lt;result column=&quot;stu_birthplace&quot; property=&quot;stuBirthplace&quot;/&gt;        &lt;result column=&quot;stu_start_time&quot; property=&quot;stuStartTime&quot;/&gt;        &lt;result column=&quot;stu_end_time&quot; property=&quot;stuEndTime&quot;/&gt;    &lt;/resultMap&gt;   &lt;select id=&quot;selectStudentSelfcardBystuNumber&quot; resultMap=&quot;studentSelfcard&quot;&gt;        select        ss.id,        ss.stu_number as &#39;stuNumber&#39;,        ss.stu_birthplace as &#39;stuBirthplace&#39;,        ss.stu_start_time as &#39;stuStartTime&#39;,        ss.stu_end_time as &#39;stuEndTime&#39;        from student_selfcard as ss        where ss.stu_number = #{stuNumber}   &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>注意，可用的参数是通过上面的 <code>column=&quot;{stuNumber=stu_id}&quot;</code>进行配置的，因此在嵌套的SQL中只能使用#{stuNumber}参数，当需要多个参数的时候，可用配置多个，使用逗号隔开即可，例如：</p><p> <code>column=&quot;{id = id,stuNumber=stu_id}&quot;</code>。</p><hr><p>针对上面的方法，在MainTest中编写测试的方法：</p><pre><code>    @Test    public void testSelectStudentAndSelfcardById03() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            StudentAndSelfcard studentAndSelfcard = studentMapper.selectStudentAndSelfcardById03(1L);            //student不为空            Assert.assertNotNull(studentAndSelfcard);            //studentSelfcard不为空            Assert.assertNotNull(studentAndSelfcard.getStudentSelfcard());            System.out.println(studentAndSelfcard);        } finally {            sqlSession.close();        }    }</code></pre><p>运行：<br><img src="/images/mybatis/QQ截图20190313174148.png"></p><p>结果和我们想的一致，因为第一条SQL语句的查询结果只有一条，所以根据这一条数据的 <code>stu_id</code> 来关联另一个查询，因此执行了两次SQL。</p><p>这种配置方式符合开始预期的结果，但是由于嵌套查询会执行多条SQL语句，所以还要考虑更多的情况。在这个例子中，是否一定会用到<code>StudentSelfcard</code>呢？</p><p>如果查询出来并没有使用，那不就是白白浪费了一次查询吗？如果查询的不是1条数据，而是N条数据，那就会出现 N+1 的问题，主SQL会查询一次，查询出N条结果，这N条结果，那就需要进行N此查询。如何解决这个问题呢？</p><p>在上面在介绍：association标签的属性时，介绍了<code>fetchType</code>数据加载方式，这个方式可以帮我们实现延迟加载，解决 N+1 的问题。</p><p>按照上面的介绍，需要把 <code>fetchType</code> 设置为：lazy，这样设置后，只有当调用：<code>studentAndSelfcard.getStudentSelfcard()</code>方法获取：StudentSelfcard的时候，Mybatis才会执行嵌套查询去获取数据。</p><p>首先修改：<code>studentSelfcardMap05</code></p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap05&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentSelfcard&quot; column=&quot;stuNumber=stu_id&quot;                     select=&quot;com.liuzhuo.mapper.StudentSelfcardMapper.selectStudentSelfcardBystuNumber&quot;                     fetchType=&quot;lazy&quot;&gt;        &lt;/association&gt;    &lt;/resultMap&gt;</code></pre><p>添加了：<code>fetchType=&quot;lazy&quot;</code></p><p>然后修改测试方法，在调用<code>studentAndSelfcard.getStudentSelfcard()</code>方法之前增加一行输出：</p><pre><code>    //student不为空    Assert.assertNotNull(studentAndSelfcard);    System.out.println(&quot;调用studentAndSelfcard.getStudentSelfcard()&quot;);    //studentSelfcard不为空    Assert.assertNotNull(studentAndSelfcard.getStudentSelfcard());</code></pre><p>再运行测试方法：<br><img src="/images/mybatis/QQ截图20190313175722.png"></p><p>发现，现在是按需加载了。</p><p>现在将 <code>Assert.assertNotNull(studentAndSelfcard.getStudentSelfcard());</code> 注释掉，再测试：<br><img src="/images/mybatis/QQ截图20190313175940.png"></p><hr><p>我们在把 <code>fetchType</code> 去掉后，再测试：<br><img src="/images/mybatis/QQ截图20190313180224.png"></p><hr><p>现在最新的Mybatis中，只需要把 <code>fetchType=lazy</code> 就可以实现按需执行SQL语句了。</p><p>如果你的不是最新的Mybatis的话，还需要配置一个全局的参数 <code>aggressiveLazyLoading</code>。</p><p>这个参数的含义是，当参数设置为：true时，对任意延迟属性的调用，会使带有延迟加载属性的对象<strong><code>完整加载</code></strong>，反之，每种属性都将按需加载。</p><p>以前版本默认是：true。所以即使你配置了：<code>fetchType=lazy</code>，也会全部加载！！！</p><p>需要在mybatis-config.xml中配置：</p><pre><code>    &lt;settings&gt;        &lt;!--其他配置--&gt;        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;/settings&gt;</code></pre><p>增加这个配合后，再次执行测试，就会和新版的一样了。</p><hr><font color="red"><br>注意：<br><br>许多对延迟加载原理不太熟悉的朋友会经常遇到一些莫名其妙的问题：有些时候延迟加载可以得到数据，有些时候延迟加载就会报错，为什么会出现这种情况呢？<br><br>Mybatis延迟加载是通过动态代理实现的，当调用配置为延迟加载的属性方法时，动态代理的操作会被触发，这些额外的操作就是通过Mybatis的SqlSession去执行嵌套SQl的。<br><br>由于在和某些框架集成的时候，SqlSession的生命周期交给了框架管理，因为当对象超出SqlSession生命周期调用时，会由于链接关闭等问题而抛出异常。在和Spring集成时，要确保只能在Service层延迟加载属性。当结果从Service层返回至Controller层时，如果获取延迟加载的属性值时，会因为SqlSession已经关闭而抛出异常。<br></font><hr><h3 id="一对多映射"><a href="#一对多映射" class="headerlink" title="一对多映射"></a>一对多映射</h3><p>在上一节中，我们使用了4种方式实现了一对一映射。这一节中，<font color="red"><strong>一对多映射只有两种配置方式，都是使用collection标签进行的</strong></font>，下面来看看具体的介绍。</p><h4 id="collection集合的嵌套结果映射"><a href="#collection集合的嵌套结果映射" class="headerlink" title="collection集合的嵌套结果映射"></a>collection集合的嵌套结果映射</h4><p>和association类似，集合的嵌套结果映射就是指通过一次SQl语句，查询出所有的结果，然后通过配置的结果映射，将数据映射到不同的对象中。在一对多的关系中，主表的一条数据会对应关联表中的多条数据，因此一般查询时会查询出多个结果，按照一对多的数据结构存储数据的时候，最终的结果数会小于等于查询的总记录数。</p><hr><p>在我们的数据库中，有两个级联关系，一个是学生和课程成绩的级联，这是一对多的关系，另一个是课程成绩与课程的级联，这是一对一的关系。</p><p>现在我们首先来看一对多的关系，学生与课程成绩的关系。</p><p>创建一个新的POJO对象：StudentBean</p><pre><code>public class StudentBean extends Student {    List&lt;StudentLecture&gt; studentLectureList;    public List&lt;StudentLecture&gt; getStudentLectureList() {        return studentLectureList;    }    public void setStudentLectureList(List&lt;StudentLecture&gt; studentLectureList) {        this.studentLectureList = studentLectureList;    }}</code></pre><p>使用List集合来对应：一对多中的多的一方。在这里就是<code>List&lt;StudentLecture&gt;</code>。</p><hr><p>打开：StudentMapper.xml，添加新的resultMap：</p><pre><code>    &lt;resultMap id=&quot;studentBeanMap&quot; type=&quot;studentBean&quot;&gt;        &lt;!--student的基本信息--&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;        &lt;!--studentLecture--&gt;        &lt;collection property=&quot;studentLectureList&quot; columnPrefix=&quot;studentLecture_&quot; ofType=&quot;studentLecture&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;            &lt;result property=&quot;stuId&quot; column=&quot;stu_id&quot;/&gt;            &lt;result property=&quot;lectureId&quot; column=&quot;lecture_id&quot;/&gt;            &lt;result property=&quot;grade&quot; column=&quot;grade&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><font color="red"><strong>注意：在collection中，ofType：为List中的java类型，此时不是使用javaType，javaType是在association中使用的，注意差别！！！</strong></font><hr><p>select标签：</p><pre><code>    &lt;select id=&quot;selectStudentBeanById&quot; resultMap=&quot;studentBeanMap&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id,        sl.id as &#39;studentLecture_id&#39;,        sl.stu_id as &#39;studentLecture_stu_id&#39;,        sl.lecture_id as &#39;studentLecture_lecture_id&#39;,        sl.grade as &#39;studentLecture_grade&#39;        from student as s join student_lecture as sl on s.stu_id = sl.stu_id        where s.id = #{id}    &lt;/select&gt;</code></pre><hr><p>StudentMapper接口：</p><pre><code>public interface StudentMapper {    public Student findStudentById(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById02(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById03(Long id);    //增加的新的方法    public StudentBean selectStudentBeanById(Long id);}</code></pre><hr><p>MainTest：</p><pre><code>    @Test    public void testSelectStudentBeanById() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            StudentBean studentBean = studentMapper.selectStudentBeanById(1L);            Assert.assertNotNull(studentBean);            List&lt;StudentLecture&gt; studentLectureList = studentBean.getStudentLectureList();            System.out.println(studentBean.getStuName() + &quot; : 选修了：&quot; + studentLectureList.size() + &quot; 门功课!&quot;);            for (StudentLecture studentLecture : studentLectureList) {                System.out.println(studentLecture);            }        } finally {            sqlSession.close();        }    }</code></pre><hr><p>运行结果：<br><img src="/images/mybatis/QQ截图20190314160845.png"></p><p>一条SQL语句，查询出所有的结果，然后Mybatis帮我们组合起来。</p><hr><p>然后，我们还能简化，在collection中，还可以使用已存在的resultMap。</p><p>在 StudentLectureMapper.xml中：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentLectureMapper&quot;&gt;    &lt;resultMap id=&quot;studentLectureMap&quot; type=&quot;studentLecture&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;lecture_id&quot; property=&quot;lectureId&quot;/&gt;        &lt;result column=&quot;grade&quot; property=&quot;grade&quot;/&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;</code></pre><p>有一个基本的 <code>studentLectureMap</code> 映射配置</p><hr><p>在 StudentMapper.xml中：</p><pre><code>    &lt;resultMap id=&quot;studentBeanMap02&quot; type=&quot;studentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;collection property=&quot;studentLectureList&quot; columnPrefix=&quot;studentLecture_&quot; resultMap=&quot;com.liuzhuo.mapper.StudentLectureMapper.studentLectureMap&quot;&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><p>首先，第一个resultMap，使用 extends 继承了 studentMap 了，所以此时student的映射就不需要写了。</p><p>然后，在collection中，使用resultMap等于StudentLectureMapper.xml中的studentLectureMap，来映射studentLecture，此时ofType就不需要写了！！！</p><hr><p>现在测试，发现结果也是好使的。</p><hr><p>现在，我们往数据库中，添加一些新的数据：<br><img src="/images/mybatis/QQ截图20190314162837.png"></p><p><img src="/images/mybatis/QQ截图20190314162915.png"></p><p>能看到，jack有三条课程成绩数据，gakki有两条课程成绩数据，应该会有五条记录。</p><p>在 StudentMapper.xml中添加新的select标签：</p><pre><code>    &lt;select id=&quot;selectStudentBeanAll&quot; resultMap=&quot;studentBeanMap02&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id,        sl.id as &#39;studentLecture_id&#39;,        sl.stu_id as &#39;studentLecture_stu_id&#39;,        sl.lecture_id as &#39;studentLecture_lecture_id&#39;,        sl.grade as &#39;studentLecture_grade&#39;        from student as s join student_lecture as sl on s.stu_id = sl.stu_id    &lt;/select&gt;</code></pre><hr><p>在StudentMapper接口添加新的接口：</p><pre><code>public List&lt;StudentBean&gt; selectStudentBeanAll();</code></pre><p>在MainTest中：</p><pre><code>    @Test    public void testSelectStudentBeanAll() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            List&lt;StudentBean&gt; studentBeanList = studentMapper.selectStudentBeanAll();            System.out.println(&quot;有:&quot; + studentBeanList.size() + &quot;个学生&quot;);            for (StudentBean studentBean : studentBeanList) {                System.out.println(&quot;学生名：&quot; + studentBean.getStuName());                for (StudentLecture studentLecture : studentBean.getStudentLectureList()) {                    System.out.println(&quot;课程Id：&quot; + studentLecture.getLectureId());                }            }        } finally {            sqlSession.close();        }    }</code></pre><p>执行测试方法，验证一下：<br><img src="/images/mybatis/QQ截图20190314164045.png"></p><hr><p>通过日志可以清楚地看出，SQL执行的结果数有5条，后面输出的学生数是2，也就说本来查询出来的5条结果经过Mybatis对collection数据的处理后，变成了两条。</p><p>我们都知道，因为第一个学生有三门课程，所以转换为一对多的数据结构后就变成了三条结果。那么Mybatis是怎么知道将5条数据中的哪三条给第一个学生呢？</p><p>理解Mybatis处理的规则对使用一对多配置是非常重要的，如果只是一知半解，很容易就会遇到各种莫名其妙的问题，所以针对Mybatis处理中的要点，下面进行一个详细的阐述。</p><p>Mybatis在处理结果的时候，会判断结果是否相同，如果是相同的的结果，则只会保留第一结果，所以这个问题的关键点就是Mybatis如何判断结果是否相同。</p><p>Mybatis判断是否相同时，最简单的情况就是在映射配置中至少有一个id标签，在studentMap中配置如下：</p><pre><code>&lt;id property=&#39;id&#39; column=&#39;id&#39;/&gt;</code></pre><p>我们对id（构造方法中为idArg）的理解一般是，它配置的字段为表的主键（联合主键时可以配置多个id标签），因为Mybatis的resultMap只用于配置结果如何映射，并不知道这个表具体如何。<font color="red">id的唯一作用就是嵌套的映射配置时判断数据是否相同</font>，当配置id标签时，Mybatis只需要比较所有数据中id标签配置字段值是否相同即可。在配置嵌套结果查询时，配置id标签可以提高处理效率。</p><p>这样一来，上面的查询就不难理解了。因为前三条数据的studentMap部分的id相同，所以它们属于同一个学生，因此这条数据会合并到同一个学生中。</p><p>为了让大家更清楚的理解id的作用，可以临时对studentMap的映射进行如下的修改：</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;!--&lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;--&gt;        &lt;id column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;!--&lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;--&gt;    &lt;/resultMap&gt;</code></pre><p>将stu_sex 设置为id元素，然后将数据库中的两个学生的stu_sex字段设置为相同的值。</p><p>然后执行测试：</p><p><img src="/images/mybatis/QQ截图20190314171115.png"></p><hr><p>我们能看到，变成了一个学生！！！学生信息保留的是第一个学生的信息，因此学生姓名为jack。</p><p>大家通过这个简单的例子应该明白id的作用了。需要注意的是，很有可能会出现一种没有配置id的情况。没有配置id时，Mybatis就会把resultMap中配置的所有字段进行比较，如果所有字段的值都相同就合并，只要有一个字段值不同，就不合并。</p><font color="red"><strong>提示：在嵌套结果配置时id属性时，如果查询语句中没有查询id属性配置的列，就会导致id对应的值为null。这种情况下，所有值的id都相同，因此会使嵌套的集合中只有一条数据。所以在配置id列时，查询语句中必须包含该列。</strong></font><hr><p>可以对studentMap再次修改，将id标签改为result：</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;!--&lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;--&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;!--&lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;--&gt;    &lt;/resultMap&gt;</code></pre><p>此时，已经不存id标签了，执行测试方法：</p><p><img src="/images/mybatis/QQ截图20190314172153.png"></p><p>发现此时的结果，与配置id标签时的结果相同。因为学生在studentMap这部分配置的属性都相同，因此合并。</p><p>虽然结果相同，但是由于Mybatis要对所有字段进行比较，因此字段数为M时，如果查询结果又N条，就需要进行M * N 次比较，相比配置id时的N次比较，效率相差更多，所以要尽可能配置id标签！！！</p><p>在studentMap比较完毕后，会接着比较studentLecture，如果不多，就会增加一个studentLecture对象，如果两个studentLecture相同就保留一个。假设studentLecture还有下一级，仍然按照该规则去比较。</p><hr><p>上面就是学生与课程成绩的一对多的映射配置，我们还有一个课程表与课程成绩表是一对一的映射，现在我们将这个映射也加上。</p><p>添加的POJO类：StudentLectureBean</p><pre><code>public class StudentLectureBean extends StudentLecture {    private Lecture lecture;    public Lecture getLecture() {        return lecture;    }    public void setLecture(Lecture lecture) {        this.lecture = lecture;    }}</code></pre><p>修改：StudentBean</p><pre><code>public class StudentBean extends Student {    //将List中类型修改为我们添加的POJO对象    List&lt;StudentLectureBean&gt; studentLectureList;    public List&lt;StudentLectureBean&gt; getStudentLectureList() {        return studentLectureList;    }    public void setStudentLectureList(List&lt;StudentLectureBean&gt; studentLectureList) {        this.studentLectureList = studentLectureList;    }}</code></pre><p>添加：LectureMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.mapper.LectureMapper&quot;&gt;    &lt;resultMap id=&quot;lectureMap&quot; type=&quot;lecture&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;lecture_name&quot; property=&quot;lectureName&quot;/&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;</code></pre><p>在：StudentLectureMapper.xml 添加新的映射配置：</p><pre><code>    &lt;resultMap id=&quot;studentLectureMap02&quot; type=&quot;studentLectureBean&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;lecture_id&quot; property=&quot;lectureId&quot;/&gt;        &lt;result column=&quot;grade&quot; property=&quot;grade&quot;/&gt;        &lt;association property=&quot;lecture&quot; columnPrefix=&quot;lecture_&quot;                     resultMap=&quot;com.liuzhuo.mapper.LectureMapper.lectureMap&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>在 StudentMapper.xml 中修改：</p><pre><code>    &lt;resultMap id=&quot;studentBeanMap02&quot; type=&quot;studentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;!--student的基本信息--&gt;        &lt;!--studentLecture--&gt;        &lt;collection property=&quot;studentLectureList&quot; columnPrefix=&quot;studentLecture_&quot;                    resultMap=&quot;com.liuzhuo.mapper.StudentLectureMapper.studentLectureMap02&quot;&gt; &lt;!--修改为02了--&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><p>修改测试方法：</p><pre><code>    public void testSelectStudentBeanAll() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            List&lt;StudentBean&gt; studentBeanList = studentMapper.selectStudentBeanAll();            System.out.println(&quot;有:&quot; + studentBeanList.size() + &quot;个学生&quot;);            for (StudentBean studentBean : studentBeanList) {                System.out.println(&quot;学生名：&quot; + studentBean.getStuName());                for (StudentLectureBean studentLecture : studentBean.getStudentLectureList()) {                    System.out.println(&quot;课程Id：&quot; + studentLecture.getLectureId());                    System.out.println(&quot;课程的名字: &quot; + studentLecture.getLecture().getLectureName());                }            }        } finally {            sqlSession.close();        }    }</code></pre><p>运行结果：</p><p><img src="/images/mybatis/QQ截图20190314180033.png"></p><hr><p>虽然association和collection标签是分开介绍的，但是这两者可以组合使用或者互相嵌套使用，也可以使用符合自己需要的任何数据结构，不需要局限于数据库表之间的关系联系。</p><hr><h4 id="collection集合的嵌套查询"><a href="#collection集合的嵌套查询" class="headerlink" title="collection集合的嵌套查询"></a>collection集合的嵌套查询</h4><p>接着上一节的内容，我们来将上诉的collection嵌套结果映射改为嵌套查询。</p><p>StudentMapper接口：</p><pre><code>public List&lt;StudentBean&gt; selectStudentBeanAll02();</code></pre><p>StudentMapper.xml：</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;studentBeanMap03&quot; type=&quot;studentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;collection property=&quot;studentLectureList&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                    select=&quot;com.liuzhuo.mapper.StudentLectureMapper.selectStudentLectureByStuId&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectStudentBeanAll02&quot; resultMap=&quot;studentBeanMap03&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id        from        student as s    &lt;/select&gt;</code></pre><p>StudentLectureMapper.xml:</p><pre><code>    &lt;resultMap id=&quot;studentLectureMap03&quot; type=&quot;studentLectureBean&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;lecture_id&quot; property=&quot;lectureId&quot;/&gt;        &lt;result column=&quot;grade&quot; property=&quot;grade&quot;/&gt;        &lt;association property=&quot;lecture&quot; fetchType=&quot;lazy&quot; column=&quot;{lectureId = lecture_id}&quot;                     select=&quot;com.liuzhuo.mapper.LectureMapper.selectLectureById&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectStudentLectureByStuId&quot; resultMap=&quot;studentLectureMap03&quot;&gt;         SELECT id , stu_id , lecture_id , grade from student_lecture where stu_id = #{stuId}    &lt;/select&gt;</code></pre><p>LectureMapper.xml:</p><pre><code>    &lt;resultMap id=&quot;lectureMap&quot; type=&quot;lecture&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;lecture_name&quot; property=&quot;lectureName&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectLectureById&quot; resultMap=&quot;lectureMap&quot;&gt;        SELECT id , lecture_name FROM lecture WHERE id = #{lectureId}    &lt;/select&gt;</code></pre><p>testSelectStudentBeanAll02测试方法：</p><pre><code>    public void testSelectStudentBeanAll02() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            List&lt;StudentBean&gt; studentBeanList = studentMapper.selectStudentBeanAll02();            System.out.println(&quot;有:&quot; + studentBeanList.size() + &quot;个学生&quot;);            for (StudentBean studentBean : studentBeanList) {                System.out.println(&quot;学生名：&quot; + studentBean.getStuName());                for (StudentLectureBean studentLecture : studentBean.getStudentLectureList()) {                    System.out.println(&quot;课程Id：&quot; + studentLecture.getLectureId());                    System.out.println(&quot;课程的名字: &quot; + studentLecture.getLecture().getLectureName());                }            }        } finally {            sqlSession.close();        }    }</code></pre><hr><p>运行测试结果：</p><p><img src="/images/mybatis/QQ截图20190314191100.png"><br><img src="/images/mybatis/QQ截图20190314191130.png"><br><img src="/images/mybatis/QQ截图20190314191147.png"></p><p>从结果可以看出，是按需发送SQL语句，然后获取数据的。</p><p>首先只是获取了学生的基本信息。</p><p>然后获取学生的课程成绩时，会发送第二条SQL语句，获取课程的id。</p><p>最后获取学生课程的名称时，会发送第三条SQL语句，获取课程的名称。</p><p>我们也可以发现，当获取第二个学生的时候，只是获取它的课程信息时发送了SQL语句，后面的课程名称没有发送SQL语句，因为在第一个学生那里已经发送过了，Mybatis会自动帮我们缓存，这个缓存的知识点，我们后面会讲到，大家不要急~~~</p><hr><h3 id="discriminator鉴别器"><a href="#discriminator鉴别器" class="headerlink" title="discriminator鉴别器"></a>discriminator鉴别器</h3><p>鉴别器级联是在特定的条件下去使用不同的POJO。比如本例中要了解学生的健康情况，如果是男生总不能去了解他的女性生理指标吧，这样就会闹出笑话了，同样女生也不能去了解男性的生理指标。这个时候就需要使用到鉴别器了。</p><hr><p>我们可以根据学生信息中的性别属性进行判断去关联男性的健康指标或者女性的健康指标，然后进行关联即可，在Mybatis中我们采用的是鉴别器discriminator，由它来处理这些需要鉴别的场景，它相当于Java语言中的switch语句。让我们来看看它是如何实现的。</p><p><code>discriminator</code>标签常用的两个属性如下：</p><ul><li><p>column：该属性用于设置要进行鉴别比较值的列。</p></li><li><p>javaType：该属性用于指定列的类型，保证使用相同的java类型来比较值。</p></li></ul><p><code>discriminator</code> 标签可以有1个或多个<code>case标签</code>，case标签包含以下三个属性：</p><ul><li><p>value：该值为discriminator指定column用来匹配的值。</p></li><li><p>resultMap：当column的值和value的值匹配时，可以配置使用resultMap指定的映射，resultMap优先级高于resulType。</p></li><li><p>resultType：当column的值和value的值匹配时，用于配置使用resultType指定的映射。</p></li></ul><p>case标签下面可以包含的标签和resultMap中一样，用法也一样。</p><hr><p>Student类：</p><pre><code>public class Student {    private Long id;  //学生编号    private String stuName; //学生姓名    private Integer stuSex;//性别    private Long stuId;//学生证号    ····省略get、set方法}</code></pre><hr><p>StudentBean类：</p><pre><code>public class StudentBean extends Student {    private List&lt;StudentLectureBean&gt; studentLectureList;    ····省略get、set方法}</code></pre><hr><p>StudentMaleHealth类：</p><pre><code>public class StudentMaleHealth {    private Long id;    private Long stuId;    private Date checkDate;    private String heart;    private String prostate;    ····省略get、set方法}</code></pre><hr><p>StudentFemaleHealth类：</p><pre><code>public class StudentFemaleHealth {    private Long id;    private Long stuId;    private Date checkDate;    private String heart;    private String uterus;    ····省略get、set方法}</code></pre><p><strong>上面的都是之前创建的POJO，现在开始创建新的POJO类：</strong></p><hr><p>MaleStudentBean类：</p><pre><code>public class MaleStudentBean extends StudentBean {    private StudentMaleHealth studentMaleHealth;    ····省略get、set方法}</code></pre><hr><p>FemaleStudentBean类：</p><pre><code>public class FemaleStudentBean extends StudentBean {    private StudentFemaleHealth studentFemaleHealth;    ····省略get、set方法}</code></pre><hr><p>StudentMapper.xml文件：</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot;/&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;studentBeanMap04&quot; type=&quot;studentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;collection property=&quot;studentLectureList&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                    select=&quot;com.liuzhuo.mapper.StudentLectureMapper.selectStudentLectureByStuId&quot;/&gt;        &lt;discriminator javaType=&quot;int&quot; column=&quot;stu_sex&quot;&gt;            &lt;case value=&quot;1&quot; resultMap=&quot;maleStudentMap&quot;/&gt;            &lt;case value=&quot;2&quot; resultMap=&quot;femaleStudentMap&quot;/&gt;        &lt;/discriminator&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;maleStudentMap&quot; type=&quot;maleStudentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentMaleHealth&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                     select=&quot;com.liuzhuo.mapper.StudentMaleHealthMapper.selectStudentMaleHealthByStuId&quot;/&gt;        &lt;collection property=&quot;studentLectureList&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                    select=&quot;com.liuzhuo.mapper.StudentLectureMapper.selectStudentLectureByStuId&quot;/&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;femaleStudentMap&quot; type=&quot;femaleStudentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentFemaleHealth&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                     select=&quot;com.liuzhuo.mapper.StudentFemaleHealthMapper.selectStudentFemaleHealthByStuId&quot;/&gt;        &lt;collection property=&quot;studentLectureList&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                    select=&quot;com.liuzhuo.mapper.StudentLectureMapper.selectStudentLectureByStuId&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectStudentBeanAll03&quot; resultMap=&quot;studentBeanMap04&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id        from        student as s    &lt;/select&gt;</code></pre><hr><p>StudentMaleHealthMapper.xml文件：</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMaleHealthMapper&quot;&gt;    &lt;resultMap id=&quot;studentMaleHealthMap&quot; type=&quot;studentMaleHealth&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;check_date&quot; property=&quot;checkDate&quot;/&gt;        &lt;result column=&quot;heart&quot; property=&quot;heart&quot;/&gt;        &lt;result column=&quot;prostate&quot; property=&quot;prostate&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectStudentMaleHealthByStuId&quot; resultMap=&quot;studentMaleHealthMap&quot;&gt;        SELECT id , stu_id ,check_date,heart,prostate FROM student_male_health WHERE stu_id = #{stuId}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><hr><p>StudentFemaleHealthMapper.xml文件：</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentFemaleHealthMapper&quot;&gt;    &lt;resultMap id=&quot;studentFemaleHealthMap&quot; type=&quot;studentFemaleHealth&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;check_date&quot; property=&quot;checkDate&quot;/&gt;        &lt;result column=&quot;heart&quot; property=&quot;heart&quot;/&gt;        &lt;result column=&quot;uterus&quot; property=&quot;uterus&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectStudentFemaleHealthByStuId&quot; resultMap=&quot;studentFemaleHealthMap&quot;&gt;        SELECT id , stu_id ,check_date,heart,uterus FROM student_female_health WHERE stu_id = #{stuId}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><hr><p>StudentMapper接口：</p><pre><code>public List&lt;StudentBean&gt; selectStudentBeanAll03();</code></pre><p>这里返回的是<code>StudentBean</code>类型，因为 MaleStudentBean、FemaleStudentBean都是它的子类。</p><hr><p>MainTest类：</p><pre><code>    public void testSelectStudentBeanAll03() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            List&lt;StudentBean&gt; studentBeanList = studentMapper.selectStudentBeanAll03();            System.out.println(&quot;有:&quot; + studentBeanList.size() + &quot;个学生&quot;);            for (StudentBean studentBean : studentBeanList) {                System.out.println(&quot;学生名：&quot; + studentBean.getStuName());                System.out.println(&quot;学生的性别：&quot; + studentBean.getStuSex());                //判断是哪个类型的学生类型                if (studentBean instanceof MaleStudentBean) {                    MaleStudentBean maleStudentBean = (MaleStudentBean) studentBean;                    System.out.println(maleStudentBean.getStudentMaleHealth().getHeart());                    System.out.println(maleStudentBean.getStudentMaleHealth().getProstate());                } else if (studentBean instanceof FemaleStudentBean) {                    FemaleStudentBean femaleStudentBean = (FemaleStudentBean) studentBean;                    System.out.println(femaleStudentBean.getStudentFemaleHealth().getHeart());                    System.out.println(femaleStudentBean.getStudentFemaleHealth().getUterus());                } else {                    System.out.println(&quot;没有映射成功!!!&quot;);                }                for (StudentLectureBean studentLecture : studentBean.getStudentLectureList()) {                    System.out.println(&quot;课程Id：&quot; + studentLecture.getLectureId());                    System.out.println(&quot;课程的名字: &quot; + studentLecture.getLecture().getLectureName());                }            }        } finally {            sqlSession.close();        }    }</code></pre><p>上面通过：<code>studentBean instanceof MaleStudentBean</code> 来判断Mybatis帮我们返回的具体类型是哪个。</p><hr><p>测试结果：<br><img src="/images/mybatis/QQ截图20190315110511.png"></p><p>当判断具体是哪个类型时，再发生SQL语句，查询具体的信息：<br><img src="/images/mybatis/QQ截图20190315110619.png"></p><p>当要获取学生的课程成绩时，再发生SQL语句：<br><img src="/images/mybatis/QQ截图20190315110738.png"></p><p>当要获取学生的课程名是，再发生SQL语句：<br><img src="/images/mybatis/QQ截图20190315110819.png"></p><p>接下来就是类似的操作了：<br><img src="/images/mybatis/QQ截图20190315110934.png"></p><p><img src="/images/mybatis/QQ截图20190315110953.png"></p><hr><font color="red">鉴别器是一种很少使用的方式，在使用之前一定要完全掌握，没有把握的情况下尽可能避免使用。</font>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的resultMap</title>
      <link href="/2019/03/13/mybatis-zhong-de-resultmap/"/>
      <url>/2019/03/13/mybatis-zhong-de-resultmap/</url>
      
        <content type="html"><![CDATA[<p>resultMap是Mybatis里面最为复杂的元素，所以单独来讲解。<br><a id="more"></a></p><p>resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来, 并在一些情形下允许你做一些 JDBC 不支持的事情。 实际上，在对复杂语句进行联合映射的时候，它很可能可以代替数千行的同等功能的代码。 ResultMap 的设计思想是，简单的语句不需要明确的结果映射，而复杂一点的语句只需要描述它们的关系就行了。</p><hr><h3 id="resultMap元素构成"><a href="#resultMap元素构成" class="headerlink" title="resultMap元素构成"></a>resultMap元素构成</h3><p>resultMap元素里面还有以下的元素：</p><pre><code>&lt;resultMap&gt;    &lt;constructor&gt;    &lt;idArg/&gt;    &lt;arg/&gt;    &lt;/constructor&gt;    &lt;id/&gt;    &lt;result/&gt;    &lt;association/&gt;    &lt;collection/&gt;    &lt;discriminator&gt;        &lt;case/&gt;    &lt;/discriminator&gt;&lt;/resultMap&gt;</code></pre><p>resultMap元素的属性：<br><img src="/images/mybatis/QQ截图20190313100156.png"></p><p>下一部分将详细说明每个元素。</p><hr><p> constructor</p><p>其中 constructor 元素用于配置构造方法。</p><p><strong><code>一个POJO可能不存在没有参数的构造方法，这个时候我们就需要使用 constructor 进行配置。</code></strong></p><p>假设角色类RoleBean不存在没有参数的构成方法，它的构造方法声明为 <code>public RoleBean(Integer id,String roleName)</code></p><p>那么，我们需要配置如下的 resultMap：</p><pre><code>&lt;resultMap&gt;    &lt;constructor&gt;        &lt;idArg column = &quot;id&quot; javaType=&quot;int&quot;/&gt;        &lt;arg column=&quot;role_name&quot; javaType=&quot;string&quot;/&gt;    &lt;/constructor&gt;&lt;/resultMap&gt;</code></pre><p>这样Mybatis就知道需要使用这个构造方法来构造POJO了。</p><p><code>idArg</code>: 表示哪个列是主键，<code>arg</code>：表示普通列表元素。</p><hr><h4 id="id和result"><a href="#id和result" class="headerlink" title="id和result"></a>id和result</h4><p><code>id</code>元素是表示哪个列是主键，允许有多个主键，多个主键则称为联合主键。</p><p><code>result</code>元素是配置其他的SQL列名到POJO的映射关系。</p><p>两者的一些属性：<br><img src="/images/mybatis/QQ截图20190313095715.png"></p><hr><p>此外的 <code>&lt;association/&gt;、&lt;collection/&gt;、&lt;discriminator&gt;</code> 这些元素，我们在级联那里详细介绍。</p><hr><h3 id="使用map存储结果集"><a href="#使用map存储结果集" class="headerlink" title="使用map存储结果集"></a>使用map存储结果集</h3><p>一般而言，任何的select语句都可以使用map存储，如下：</p><pre><code>&lt;select id=&quot;findColorByNote&quot; parameterType=&quot;string&quot; reslutMap=&quot;map&quot;&gt;     select id ,color,note from t_color where note like concat(&#39;%&#39;,#{note},&#39;%&#39;)&lt;/select&gt;</code></pre><p>使用map原则上是可以匹配所有结果集的，但是使用map接口就意味着可读性下降，所以这不是一种推荐的方式。更多的时候我们使用的是POJO的方式。</p><hr><h3 id="使用POJO存储结果集"><a href="#使用POJO存储结果集" class="headerlink" title="使用POJO存储结果集"></a>使用POJO存储结果集</h3><p>POJO是我们常用的方式，也是我们推荐的方式。</p><p>一方面我们可以使用自动映射，正如 select 语句里论述的一样。</p><p>另一方面，我们还可以使用 select 语句的属性 resultMap配置映射集合，只是使用前需要配置类似的resultMap。</p><pre><code>&lt;resultMap id=&quot;roleResultMap&quot; type=&quot;role&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>resultMap元素的属性 id 代表这个 resultMap的标识，type代表着你需要映射的POJO（可以使用定义好的别名）。</p><p>映射关系中，id 元素：表示这个对象的主键，property代表着POJO的属性名称，column表示数据库SQL的列名，于是POJO就和数据库SQL的结果一一对应起来了。</p><p>接着在 select元素 里面使用即可：</p><pre><code>&lt;select id=&quot;getRole&quot; parameterType=&quot;long&quot; reslutMap=&quot;roleResultMap&quot;&gt;     select id , role_name , note from t_role where id = #{id}&lt;/select&gt;</code></pre><p>我们可以发现<code>SQL语句的列名</code> 和 <code>roleResultMap的column</code> 是一一对应的。</p><p>使用XML配置的结果集，还可以配置 typeHandler、javaType、jdbcType。</p><font color="red">但是这条语句配置了resultMap，就不要配置resultType。</font>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的Mapper映射器</title>
      <link href="/2019/03/11/mybatis-zhong-de-mapper-ying-she-qi/"/>
      <url>/2019/03/11/mybatis-zhong-de-mapper-ying-she-qi/</url>
      
        <content type="html"><![CDATA[<p>映射器是Mybatis最强大的工具，也是我们使用Mybatis时用得最多的工具，因此熟练掌握它十分必要。<br><a id="more"></a></p><p>MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。</p><p>SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p><ul><li><p>cache – 给定命名空间的缓存配置。</p></li><li><p>cache-ref – 其他命名空间缓存配置的引用。</p></li><li><p>resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</p></li><li><p>parameterMap – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。</p></li><li><p>sql – 可被其他语句引用的可重用语句块。</p></li><li><p>insert – 映射插入语句</p></li><li><p>update – 映射更新语句</p></li><li><p>delete – 映射删除语句</p></li><li><p>select – 映射查询语句</p></li></ul><p>下一部分将从语句本身开始来描述每个元素的细节。</p><hr><h3 id="select元素"><a href="#select元素" class="headerlink" title="select元素"></a>select元素</h3><p>查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。简单查询的 select 元素是非常简单的。比如：</p><pre><code>&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;  SELECT * FROM PERSON WHERE ID = #{id}&lt;/select&gt;</code></pre><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：<br><code>#{id}</code></p><p>这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p><pre><code>// Similar JDBC code, NOT MyBatis…String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id);</code></pre><p>当然，这需要很多单独的 JDBC 的代码来提取结果并将它们映射到对象实例中，这就是 MyBatis 节省你时间的地方。我们需要深入了解参数和结果映射，细节部分我们下面来了解。</p><p>select 元素有很多属性允许你配置，来决定每条语句的作用细节。</p><pre><code>&lt;select  id=&quot;selectPerson&quot;  parameterType=&quot;int&quot;  parameterMap=&quot;deprecated&quot;  resultType=&quot;hashmap&quot;  resultMap=&quot;personResultMap&quot;  flushCache=&quot;false&quot;  useCache=&quot;true&quot;  timeout=&quot;10000&quot;  fetchSize=&quot;256&quot;  statementType=&quot;PREPARED&quot;  resultSetType=&quot;FORWARD_ONLY&quot;&gt;</code></pre><p><img src="/images/mybatis/QQ截图20190311135926.png"></p><h4 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h4><p>在简单的场景下，MyBatis可以替你自动映射查询结果。如果遇到复杂的场景，你需要构建一个resultMap，resultMap之后介绍。</p><p>有这样一个参数autoMappingBehavior，当它不设置为NONE的时候，只要返回的SQL列名和POJO对象的属性名一致（忽略大小写），Mybatis就会帮助我们回填这些字段而无需任何配置，它可以在很大程度上简化我们的配置工作。</p><p>在实际工作中，大部分数据库规范都是要求大写单词命名，单词间用下划线分隔，而java则是使用驼峰命名法，于是可以使用列的别名来使得Mybatis自动映射，或者直接在配置文件中开启驼峰命名方式。</p><p>让我们来看一个简单的例子，体验一下自动映射的好处。</p><p>javaBean:</p><pre><code>public class Role{   private Long id;   private String roleName;   private String note;   ···set、get、toString方法}</code></pre><p>数据库表（T_ROLE）</p><pre><code>字段        类型ID          INT(20)ROLE_NAME   VACHAR(60)NOTE        VARCHAR(1024)</code></pre><p>让我们编写Mapper的映射语句：</p><pre><code>&lt;select id=&quot;getRole&quot; parameterType=&quot;long&quot; resultType=&quot;role&quot;&gt;     select id, role_name as roleName, note from t_role where id = #{id}&lt;/select&gt;</code></pre><p>RoleMapper接口：</p><pre><code>public Role getRole(Long id);</code></pre><p>虽然数据中的列名和javaBean的属性名不是一一对应，但是我们在查询语句中使用了 <code>as</code> 别名，让它们一致了，所以Mybatis会自动帮我们映射。</p><hr><p>自动映射可以在 <code>settings元素</code> 中配置 autoMapperBehavior属性值来设置其策略，它含有三个值：</p><ul><li><p>NONE，取消自动映射。仅设置手动映射属性。</p></li><li><p>PARTIAL，只会自动映射，没有定义嵌套结果映射的结果集</p></li><li><p>FULL，会自动映射任意复杂的结果集（无论是否嵌套）</p></li></ul><p><strong>默认值是PARTIAL</strong>，当使用FULL时，自动映射会在处理join结果时执行，并且join取得若干相同行的不同实体数据，因此这可能导致非预期的映射。</p><p>下面的例子将展示这种风险：</p><pre><code>&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;  select    B.id,    B.title,    A.username,  from Blog B left outer join Author A on B.author_id = A.id  where B.id = #{id}&lt;/select&gt;</code></pre><pre><code>&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;  &lt;association property=&quot;author&quot; resultMap=&quot;authorResult&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;  &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>在结果中Blog和Author均将自动映射。但是注意Author有一个id属性，在ResultSet中有一个列名为id， 所以Author的id将被填充为Blog的id，这不是你所期待的。所以需要谨慎使用FULL。</p><p>通过添加autoMapping属性可以忽略自动映射等级配置，你可以启用或者禁用自动映射指定的ResultMap。</p><pre><code>&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot; autoMapping=&quot;false&quot;&gt;  &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;&lt;/resultMap&gt;</code></pre><hr><p>如果你的数据库是规范命名的，即每个单词之间用下划线隔开，javaBean采用驼峰命名法，那么你可以使用设置 <code>mapUnderscoreToCamelCase = true</code>,这样不用使用 <code>as</code>来重新命名列名 , Mybatis也会帮我们自动映射的。</p><h4 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h4><p>之前的例子，我们都是传递一个参数，但是，更多的时候我们需要传递多个参数给映射器。</p><h5 id="使用Map传递多个参数"><a href="#使用Map传递多个参数" class="headerlink" title="使用Map传递多个参数"></a>使用Map传递多个参数</h5><pre><code>    &lt;select id=&quot;selectByMap&quot; parameterType=&quot;map&quot; resultMap=&quot;userMap&quot;&gt;        select userId,user_age ,user_name ,user_sex  from user where userId = #{id} and user_age=#{userAge}    &lt;/select&gt;</code></pre><p>这里，parameterType = “map”，说明参数是Map类型的。</p><pre><code>public interface UserMapper {    User selectByMap(Map&lt;String,String&gt; map);}</code></pre><pre><code>    sqlSession = SqlSessionFactoryUtil.openSqlSession();    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    Map&lt;String ,String &gt; userMap = new HashMap&lt;&gt;();    userMap.put(&quot;id&quot;,&quot;1&quot;);    userMap.put(&quot;userAge&quot;,&quot;18&quot;);    User user = userMapper.selectByMap(userMap);    System.out.println(user);</code></pre><p><img src="/images/mybatis/QQ截图20190311144413.png"></p><p>使用Map来传递多个参数的话，<font color="red">Map中的键名，必须和SQL语句中的：#{XXX}中的XXX一致才行。</font></p><p>这里就是 id 和 userAge，现在我们修改一下，传递给Map的键名，将 userAge 变成 user_age.<br><img src="/images/mybatis/QQ截图20190311144942.png"></p><hr><p>使用Map传递多个参数的缺点：因为参数是封装在Map中的，由于业务关联性不强，你需要深入到程序中看代码，造成可读性下降。</p><h5 id="使用注解的方式"><a href="#使用注解的方式" class="headerlink" title="使用注解的方式"></a>使用注解的方式</h5><p>我们需要使用Mybatis的参数注解@Param(org.apache.ibatis.annotations.Param)来实现想要的功能。</p><pre><code>User selectByAnnotation(@Param(&quot;id&quot;) String userId, @Param(&quot;userAge&quot;) long useAge);</code></pre><pre><code>&lt;select id=&quot;selectByMap&quot; parameterType=&quot;map&quot; resultMap=&quot;userMap&quot;&gt;    select userId,user_age ,user_name ,user_sex  from user     where userId = #{id} and user_age = #{userAge}&lt;/select&gt;</code></pre><p>这样，Mybatis会把 @Param(“xxx”) 代表的值，传递给 SQL语句中的 #{xxx}.</p><p>这样可读性性增强了，但是当需要传递的参数过多的时候，那么我们会写很多的@Param注解，麻烦。</p><h5 id="使用javaBean的方式"><a href="#使用javaBean的方式" class="headerlink" title="使用javaBean的方式"></a>使用javaBean的方式</h5><p>当参数过多的时候，Mybatis允许组织一个JavaBean，通过简单的 setter 和 getter 方法设置参数，这样就可以提高我们的可读性。</p><p>首先定义一个javaBean对象：</p><pre><code>public class User {    private String userId;    private Long userAge;    private String userName;    private Sex userSex;    ····set、get方法}</code></pre><pre><code>&lt;select id=&quot;selectByMap&quot; parameterType=&quot;com.liuzhuo.entities.User&quot; resultMap=&quot;userMap&quot;&gt;    select userId,user_age ,user_name ,user_sex  from user     where userId = #{id} and user_age = #{userAge}&lt;/select&gt;</code></pre><p>这里，parameterType为javaBean的全限定名，如果你配置了别名的话，就直接使用别名也行，更方便。</p><pre><code>public User selectByUser(User user);</code></pre><hr><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><p>使用Map传递参数。因为Map导致业务可读性差，从而导致后续扩展和维护的困难，我们应该在实际开发中废弃这样的方式</p></li><li><p>使用@Param注解，这个方式适合于参数不多的情况下（参数&lt;=5）</p></li><li><p>javaB的方式，适合于参数过多的情况</p></li></ul><hr><h4 id="resultMap映射结果集"><a href="#resultMap映射结果集" class="headerlink" title="resultMap映射结果集"></a>resultMap映射结果集</h4><p>在自动映射章节，我们使用的是 <code>resultType=javaBean的全限定名</code> 来完成自动映射的，但是某些时候，我们需要处理更多复杂的映射。</p><p>resultMap为我们提供了这样的模式，使用resultMap之前，我们需要首先定义它：</p><pre><code>    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;        &lt;id column=&quot;userId&quot; property=&quot;userId&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result column=&quot;user_age&quot; property=&quot;userAge&quot;/&gt;        &lt;!--定义结果类型转化器标识，才能使用类型转换器--&gt;        &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; typeHandler=&quot;com.liuzhuo.typehandler.MyStringTypehandler&quot;/&gt;        &lt;!--新添加的字段--&gt;        &lt;result column=&quot;user_sex&quot; property=&quot;userSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot;&gt;        select userId,user_age ,user_name ,user_sex  from user where userId = #{id}    &lt;/select&gt;</code></pre><p><strong><code>使用&lt;resultMap&gt;标签来定义，然后在&lt;select&gt;标签中使用 resultMap = 在&lt;resultMap&gt;中定义的id 即可</code>。</strong></p><p>解释一下resultMap的配置：</p><ul><li><p>id是resultMap的唯一标识，用type属性去定义它对应的是哪个javaBean（可以使用别名）</p></li><li><p>通过<code>&lt;id&gt;元素</code>定义这个对象的主键，column：列名，property：属性名</p></li><li><p>通过<code>&lt;result&gt;元素</code>定义普通列的映射关系，column：列名，property：属性名</p></li><li><p>这样select语句就不再需要使用自动映射规则了，直接使用resultMap属性指定的userMap即可，这样Mybatis就会使用这个自定义的映射规则了。</p></li></ul><p>javaType，jdbcType，typeHandler是用来指定TypeHandler的，之前我们就讲过，现在应该有点感觉了吧~~~</p><p>resultMap是映射器中最为复杂的元素，它一般用于复杂、级联这些关联的配置，后面会单独来讲解，这样就简单了解一下。</p><hr><h3 id="insert元素"><a href="#insert元素" class="headerlink" title="insert元素"></a>insert元素</h3><p>insert元素，相对于select元素而言简单许多了。Mybatis执行insert后会返回一个整数，代表插入到数据库的行数。<br>update、delete类似。</p><pre><code>&lt;insert  id=&quot;insertAuthor&quot;  parameterType=&quot;domain.blog.Author&quot;  flushCache=&quot;true&quot;  statementType=&quot;PREPARED&quot;  keyProperty=&quot;&quot;  keyColumn=&quot;&quot;  useGeneratedKeys=&quot;&quot;  timeout=&quot;20&quot;&gt;&lt;update  id=&quot;updateAuthor&quot;  parameterType=&quot;domain.blog.Author&quot;  flushCache=&quot;true&quot;  statementType=&quot;PREPARED&quot;  timeout=&quot;20&quot;&gt;&lt;delete  id=&quot;deleteAuthor&quot;  parameterType=&quot;domain.blog.Author&quot;  flushCache=&quot;true&quot;  statementType=&quot;PREPARED&quot;  timeout=&quot;20&quot;&gt;</code></pre><p>详细介绍：<br><img src="/images/mybatis/QQ截图20190311153037.png"></p><font color="red">注意：keyProperty 和 keyColumn不能同时使用，keyProperty表示以哪个列名作为属性的主键，keyColumn是表示哪一列，接受的是整数！！</font><hr><p>简单使用：</p><pre><code>    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt;        INSERT INTO user(userId,user_age,user_name,user_sex)        VALUES (#{userId},#{userAge},#{userName},#{userSex,typeHandler=com.liuzhuo.typehandler.SexEnumTypeHandler})    &lt;/insert&gt;</code></pre><hr><h4 id="主键回填和自定义"><a href="#主键回填和自定义" class="headerlink" title="主键回填和自定义"></a>主键回填和自定义</h4><p>现实中有许多我们需要处理的问题，例如，主键自增字段；MySql里面的主键需要根据一些特殊的规则去生成，在插入后我们往往需要获取到这个主键，以便未来的操作，而Mybatis提供了实现的方法。</p><p>首先，我们可以使用 keyProperty 属性指定哪个是主键字段，同时使用 useGeneratedKeys属性告诉Mybatis这个主键是否使用数据库内置策略生成。</p><pre><code>    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;            useGeneratedKeys=&quot;true&quot; keyColumn=&quot;userId&quot;&gt;        INSERT INTO user(user_age,user_name,user_sex)        VALUES (#{userAge},#{userName},#{userSex,typeHandler=com.liuzhuo.typehandler.SexEnumTypeHandler})    &lt;/insert&gt;</code></pre><p>这样，我们传入的user对象，就不需要设置userId的值了，Mybatis会用数据库的设置进行处理。这样做的好处是在Mybatis插入的时候，它会回填javaBean的id值。</p><p><strong>以上成功的前提是数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server）</strong></p><hr><p>对于不支持自动生成类型的数据库或可能不支持自动生成主键的 JDBC 驱动，MyBatis 有另外一种方法来生成主键。</p><p>这里有一个简单示例，表中没有记录 id就为 1，否则为最大的 id + 2：</p><pre><code>&lt;insert id=&quot;inserUser&quot; parameterType=&quot;user&quot; keyColumn=&quot;userId&quot;&gt;  &lt;selectKey keyProperty=&quot;userId&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;    select if( max(user_id) is null , 1 , max(user_id) + 2 ) as newId from user  &lt;/selectKey&gt;  insert into user    (user_id, user_name, user_age,user_sex)  values    (#{userId}, #{userName}, #{userAge}, #{userSex})&lt;/insert&gt;</code></pre><p>在上面的示例中，selectKey 元素将会首先运行，User 的 userId 会被设值，然后插入语句会被调用。这给你了一个和数据库中来处理自动生成的主键类似的行为，避免了使 Java 代码变得复杂。</p><hr><p>selectKey 元素描述如下：</p><pre><code>&lt;selectKey  keyProperty=&quot;id&quot;  resultType=&quot;int&quot;  order=&quot;BEFORE&quot;  statementType=&quot;PREPARED&quot;&gt;</code></pre><p><img src="/images/mybatis/QQ截图20190311155900.png"></p><hr><h3 id="update-delete"><a href="#update-delete" class="headerlink" title="update/delete"></a>update/delete</h3><p>这个两个元素比较简单，所以放在一起讨论，和insert元素一样，Mybatis执行update、delete元素后会返回一个整数，标出执行后影响的记录条数。</p><pre><code>&lt;update id=&quot;updateUser&quot;&gt;  update user set    user_name = #{userName},    user_age = #{userAge},  where id = #{id}&lt;/update&gt;&lt;delete id=&quot;deleteUser&quot;&gt;  delete from user where user_id = #{userId}&lt;/delete&gt;</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>正如你所见，我们可以传入一个简单的参数，比如int、double等，也可以传入javaBean，这些我们都讨论过了，有时候我们需要处理一个特殊的情况，我们可以指定特定的类型，以确定使用哪个typeHandler处理它们，以便我们进行特殊的处理。</p><pre><code>#{ age, javaType=int , jdbcType = NUMERIC }</code></pre><p>当然，我们还可以指定用哪个typeHandler去处理参数</p><pre><code>#{ age, javaType=int , jdbcType = NUMERIC , typeHandler = MyTypeHandler}</code></pre><p>此外，我们还可以对一些数值型的参数设置其保存的精度</p><pre><code>#{ price , javaType= double , jdbcType = NUMERIC , numericScale = 2}</code></pre><p>可见Mybatis映射器可以通过EL的功能帮助完成我们所需要的多种的功能，使用还是很方便的。</p><hr><h4 id="特殊字符串处理-和"><a href="#特殊字符串处理-和" class="headerlink" title="特殊字符串处理(#和$)"></a>特殊字符串处理(#和$)</h4><p>在Mybatis中，我们常常传递字符串，我们设置的参数 #{name} 在大部分的情况下Mybatis会用创建<strong>预编译的语句</strong>，然后Mybatis为它设值，而有时候我们需要的是传递SQL语句本身，而不是SQL所需要的参数。</p><p>例如，在一些动态表格中，我们需要传递SQL的列名，根据某些列进行排序，或者传递列名给SQL都是比较常见的场景，当然Mybatis也对这样的场景进行了支持，这些是Hibernate难以做到的。</p><p>例如，在程序中传递变量 columns = “ col1 , col2 , col3 …” 给SQL，让其组装成为SQL语句。我们当然不想被Mybatis像处理普通参数一样把它设为” col1.col2,col3…”，那么我们就可以写成如下语句。</p><pre><code> select ${columns} from t tablename</code></pre><p>这样Mybatis就不会帮我们转译 columns，而变为 <strong>直出</strong> ，而不是作为SQL的参数进行设置了。只是这样是对SQL而言是不安全的，Mybatis给了你灵活性的同时，也需要你自己去控制参数以保证SQL运转的正确性和安全性。</p><h3 id="sql元素"><a href="#sql元素" class="headerlink" title="sql元素"></a>sql元素</h3><p>这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如：</p><pre><code>&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id , ${alias}.username , ${alias}.password &lt;/sql&gt;</code></pre><p>这个 SQL 片段可以被包含在其他语句中，例如：</p><pre><code>&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;  select    &lt;include refid=&quot;userColumns&quot;&gt;            &lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;    &lt;/include&gt;,    &lt;include refid=&quot;userColumns&quot;&gt;            &lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;    &lt;/include&gt;  from some_table t1 cross join some_table t2&lt;/select&gt;</code></pre><p>属性值也可以被用在 include 元素的 refid 属性里（</p><p><code>&lt;include refid=&quot;${include_target}&quot;/&gt;</code> )</p><p>或者 include 内部语句中（</p><p><code>${prefix}Table</code> )</p><p>例如：</p><pre><code>&lt;sql id=&quot;sometable&quot;&gt;  ${prefix}Table&lt;/sql&gt;&lt;sql id=&quot;someinclude&quot;&gt;  from    &lt;include refid=&quot;${include_target}&quot;/&gt;&lt;/sql&gt;&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;  select    field1, field2, field3  &lt;include refid=&quot;someinclude&quot;&gt;    &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;    &lt;property name=&quot;include_target&quot; value=&quot;sometable&quot;/&gt;  &lt;/include&gt;&lt;/select&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的主配置文件02</title>
      <link href="/2019/03/10/mybatis-zhong-de-zhu-pei-zhi-wen-jian-02/"/>
      <url>/2019/03/10/mybatis-zhong-de-zhu-pei-zhi-wen-jian-02/</url>
      
        <content type="html"><![CDATA[<p>此篇博客，接着上篇博客的内容，继续讲解Mybatis-config.xml配置文件<br><a id="more"></a></p><h3 id="environments-配置环境"><a href="#environments-配置环境" class="headerlink" title="environments(配置环境)"></a>environments(配置环境)</h3><p>配置环境可以注册多个数据源（dataSource），每个一个数据源又可以分为两大部分：一个是数据库源的配置，另外一个是数据库事务（transactionManager）的配置。</p><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。</p><p><strong>不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。</strong></p><p>所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：</p><p><strong>每个数据库对应一个 SqlSessionFactory 实例</strong></p><p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p><pre><code>SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);</code></pre><p>如果忽略了环境参数，那么默认环境将会被加载，如下所示：</p><pre><code>SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);</code></pre><p>环境元素定义了如何配置环境。</p><pre><code>&lt;environments default=&quot;development&quot;&gt;  &lt;environment id=&quot;development&quot;&gt;    &lt;transactionManager type=&quot;JDBC&quot;&gt;      &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;    &lt;/transactionManager&gt;    &lt;dataSource type=&quot;POOLED&quot;&gt;      &lt;property name=&quot;driver&quot;   value=&quot;${driver}&quot;/&gt;      &lt;property name=&quot;url&quot;      value=&quot;${url}&quot;/&gt;      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;    &lt;/dataSource&gt;  &lt;/environment&gt;&lt;/environments&gt;</code></pre><p>注意这里的关键点：</p><ul><li><p>environments中的属性default，表明了在缺省的情况下，我们将启动哪个数据源配置</p></li><li><p>environment元素是配置一个数据源的开始，属性id是设置这个数据源的标志，以便Mybatis在上下文中使用它</p></li><li><p>transactionManager 配置的是数据库事务</p></li><li><p>dataSource 是配置数据源连接的信息</p></li></ul><h4 id="事务管理器-transactionManager"><a href="#事务管理器-transactionManager" class="headerlink" title="事务管理器(transactionManager)"></a>事务管理器(transactionManager)</h4><p>在 MyBatis 中有两种类型的事务管理器（也就是 type= “ [JDBC|MANAGED] “）：</p><ul><li><p>JDBC，采用的是JDBC方式的管理，直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</p></li><li><p>MANAGED，采用是容器方式管理事务，在JNDI数据源中常用</p></li></ul><p>MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如:</p><pre><code>&lt;transactionManager type=&quot;MANAGED&quot;&gt;  &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt;</code></pre><p>property元素则是可以配置数据源的各类属性，比如配置不自动提交：</p><pre><code>&lt;transactionManager type=&quot;JDBC&quot;&gt;  &lt;property name=&quot;autoCommit&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt;</code></pre><hr><p>这两种事务管理器类型都不需要任何属性。它们不过是类型别名，换句话说，你可以使用 TransactionFactory 接口的实现类的完全限定名或类型别名代替它们。</p><pre><code>public interface TransactionFactory {  void setProperties(Properties props);    Transaction newTransaction(Connection conn);  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);  }</code></pre><p>任何在 XML 中配置的属性在实例化之后将会被传递给 setProperties() 方法。你也需要创建一个 Transaction 接口的实现类，这个接口也很简单：</p><pre><code>public interface Transaction {  Connection getConnection() throws SQLException;  void commit() throws SQLException;  void rollback() throws SQLException;  void close() throws SQLException;  Integer getTimeout() throws SQLException;}</code></pre><p>使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。</p><hr><font color="red">提示，如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用<strong>自带的管理器</strong>来覆盖前面的配置。</font><h4 id="数据源-dataSource"><a href="#数据源-dataSource" class="headerlink" title="数据源(dataSource)"></a>数据源(dataSource)</h4><p>数据库事务 Mybatis是交给 SqlSession 去控制的，我们可以通过SqlSession 提交（commit）或者 回滚（rollback）。</p><p>Mybatis内部为我们提供了3种数据源的实现方式</p><ul><li>UNPOOLED，非连接池。</li></ul><p>这个数据源的实现只是每次被请求时打开和关闭连接。虽然有点慢，但对于在数据库连接可用性方面没有太高要求的简单应用程序来说，是一个很好的选择。 不同的数据库在性能方面的表现也是不一样的，对于某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：</p><pre><code>driver – 这是 JDBC 驱动的 Java 类的完全限定名（并不是 JDBC 驱动中可能包含的数据源类）。url – 这是数据库的 JDBC URL 地址。username – 登录数据库的用户名。password – 登录数据库的密码。defaultTransactionIsolationLevel – 默认的连接事务隔离级别。</code></pre><p>作为可选项，你也可以传递属性给数据库驱动。要这样做，属性的前缀为“driver.”，例如：</p><p><code>driver.encoding=UTF8</code></p><p>这将通过 DriverManager.getConnection(url,driverProperties) 方法传递值为 UTF8 的 encoding 属性给数据库驱动。</p><ul><li>POOLED，连接池。</li></ul><p>这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p><p>除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源：</p><pre><code>poolMaximumActiveConnections – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。poolMaximumCheckoutTime – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）poolTimeToWait – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。poolMaximumLocalBadConnectionTolerance – 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程. 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 poolMaximumIdleConnections 与 poolMaximumLocalBadConnectionTolerance 之和。 默认值：3 (新增于 3.4.5)poolPingQuery – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。poolPingEnabled – 是否启用侦测查询。若开启，需要设置 poolPingQuery 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。poolPingConnectionsNotUsedFor – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。</code></pre><ul><li>JNDI</li></ul><p>这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：</p><pre><code>initial_context – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。data_source – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。</code></pre><p>和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给初始上下文。比如：</p><p><code>env.encoding=UTF8</code></p><p>这就会在初始上下文（InitialContext）实例化时往它的构造方法传递值为 UTF8 的 encoding 属性。</p><hr><p>你可以通过实现接口 org.apache.ibatis.datasource.DataSourceFactory 来使用<strong>第三方数据源：</strong></p><pre><code>public interface DataSourceFactory {  void setProperties(Properties props);  DataSource getDataSource();}</code></pre><p>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory 可被用作父类来构建新的数据源适配器，比如下面这段插入 C3P0 数据源所必需的代码：</p><pre><code>import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;import com.mchange.v2.c3p0.ComboPooledDataSource;public class C3P0DataSourceFactory extends UnpooledDataSourceFactory {  public C3P0DataSourceFactory() {    this.dataSource = new ComboPooledDataSource();  }}</code></pre><p>为了令其工作，记得为每个希望 MyBatis 调用的 setter 方法在配置文件中增加对应的属性。下面是一个可以连接至 PostgreSQL 数据库的例子：</p><pre><code>&lt;dataSource type=&quot;org.myproject.C3P0DataSourceFactory&quot;&gt;  &lt;property name=&quot;driver&quot; value=&quot;org.postgresql.Driver&quot;/&gt;  &lt;property name=&quot;url&quot; value=&quot;jdbc:postgresql:mydb&quot;/&gt;  &lt;property name=&quot;username&quot; value=&quot;postgres&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/dataSource&gt;</code></pre><hr><h3 id="databaseIdProvider"><a href="#databaseIdProvider" class="headerlink" title="databaseIdProvider"></a>databaseIdProvider</h3><p>MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。 为支持多厂商特性只要像下面这样在 mybatis-config.xml 文件中加入 databaseIdProvider 即可：</p><pre><code>&lt;databaseIdProvider type=&quot;DB_VENDOR&quot; /&gt;</code></pre><p>这里的 DB_VENDOR 会通过 DatabaseMetaData#getDatabaseProductName() 返回的字符串进行设置。 由于通常情况下这个字符串都非常长而且相同产品的不同版本会返回不同的值，所以最好通过设置属性别名来使其变短，如下：</p><pre><code>&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;  &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;  &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt;     &lt;property name=&quot;DB2&quot; value=&quot;db2&quot;/&gt;          &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt;&lt;/databaseIdProvider&gt;</code></pre><p>在提供了属性别名时，DB_VENDOR databaseIdProvider 将被设置为第一个能匹配数据库产品名称的属性键对应的值，如果没有匹配的属性将会设置为 “null”。 在这个例子中，如果 getDatabaseProductName() 返回“Oracle (DataDirect)”，databaseId 将被设置为“oracle”。</p><p>我们也可以指定SQL在哪个数据库厂商执行，我们把Mapper的XML配置修改一下，如下：</p><pre><code>    &lt;select id=&quot;selectById&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot; databaseId=&quot;mysql&quot;&gt;        select userId,user_age ,user_name ,user_sex  from user where userId = #{id}    &lt;/select&gt;</code></pre><p>在多一个databaseId属性的情况下，Mybatis将提供如下规则。</p><ul><li><p>如果没有配置databaseIdProvider标签，那么databaseId就会返回null。</p></li><li><p>如果配置了databaseIdProvider标签，Mybatis就会用配置的name值去匹配数据库信息，如果匹配得上就会设置databaseId，否则为null。</p></li><li><p>如果Configuration的databaseId不为空，则它只会找到配置databaseId的SQL语句。</p></li><li><p>Mybatis会加载不带databaseId属性和带有匹配当前数据库databaseId属性的所有语句。如果同时找到带有databaseId和不带databaseId的相同语句，则后者会被舍弃。</p></li></ul><hr><p>Mybatis也提供了规则允许自定义，我们只要实现DatabaseIdProvider接口，并且实现配置即可</p><pre><code>public class MydatabaseIdProvider implements DatabaseIdProvider {    private Properties properties = null;    @Override    public void setProperties(Properties p) {        this.properties = p;    }    @Override    public String getDatabaseId(DataSource dataSource) throws SQLException {        String dbName = dataSource.getConnection().getMetaData().getDatabaseProductName();        String dbId = (String) this.properties.get(dbName);        return dbId;    }}</code></pre><p>其次，注册这个类到Mybatis上下文环境中，我们这样配置databaseIdProvider标签，如下所示：</p><pre><code>&lt;databaseIdProvider type=&quot;com.liuzhuo.databaseIdProvider.MydatabaseIdProvider&quot;&gt;  &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;  &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt;     &lt;property name=&quot;DB2&quot; value=&quot;db2&quot;/&gt;          &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt;&lt;/databaseIdProvider&gt;</code></pre><p>我们把type修改为我们自己实现的类，类里面setProperties方法的参数传递进去的将会是我们在XML配置的信息，我们保存在类的变量properties里，方便以后读出。在方法getDatabaseId中，传递的参数是数据库数据源，我们获取其名称，然后通过properties的键值找到对应的databaseId。</p><hr><h3 id="mapper-映射器"><a href="#mapper-映射器" class="headerlink" title="mapper(映射器)"></a>mapper(映射器)</h3><p>映射器是Mybatis最复杂、最核心的组件。此处只是讨论如何引入映射器，其他的特性放在后面的博客中讲解。</p><p>引入映射器有4中方法：</p><p>（1）用文件路径引入映射器</p><pre><code>&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource=&quot;org/mybatis/builder/authorMapper.xml&quot;/&gt;  &lt;mapper resource=&quot;org/mybatis/builder/blogMapper.xml&quot;/&gt;  &lt;mapper resource=&quot;org/mybatis/builder/postMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><p>(2) 用完全限定资源定位(url)</p><pre><code>&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt;  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;  &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt;  &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><p>(3) 用包名引入映射器</p><pre><code>&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt;</code></pre><p>(4) 用类注册引入映射器</p><pre><code>&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;  &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt;  &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt;</code></pre><font color="red">注意：（1）和（2）是xml的方式，所以填写的是XML的路径，（3）和 （4）是注解的方式，填写的是mapper接口的路径</font><p>（1）和（2）我就不演示了，大家都清楚。</p><p>看看（3）和（4）。</p><p>首先，我们的UserMapper在：com.liuzhuo.dao包下</p><p>然而，我们的userMapper.xml在：com.liuzhuo.mapper包下。<br><img src="/images/mybatis/QQ截图20190310220314.png"></p><p>但是，在mybatis-config.xml中必须配置为mapper接口的包路径：</p><pre><code>    &lt;mappers&gt;        &lt;package name=&quot;com.liuzhuo.dao&quot;/&gt;    &lt;/mappers&gt;</code></pre><p><strong>而且，此时只能使用注解的方式，不能使用xml的方式了。</strong></p><p>现在，在我们的UserMapper中，有两个selectById方法，一个是xml的，一个是注解的，我们分别来演示。</p><pre><code>public interface UserMapper {    User selectById(String id);    @Select(&quot;select userId,user_age as useAge,user_name as userName from user where userId = #{id}&quot;)    User selectById02(String id);    int insertUser(User user);}</code></pre><p>在主函数中调用xml的方法（selectById）<br><img src="/images/mybatis/QQ截图20190310220747.png"></p><p>发现调用失败！！！！</p><p>在主函数中调用注解的方法（selectById02）<br><img src="/images/mybatis/QQ截图20190310220942.png"></p><hr><p><strong>如果想使用非注解的xml配置文件的话，必须将Mapper接口类和xml文件放在同一级目录中，且两种同名！！！</strong></p><p>结构如下：<br><img src="/images/mybatis/QQ截图20190311092826.png" style="width:50%"></p><p>再次运行，如果你的还是出错<br><img src="/images/mybatis/QQ截图20190311100400.png"></p><p>是因为使用IDEA创建的Maven项目中，不在resources创建的xml配置文件是不会读取到的，需要修改一下pom.xml文件。</p><pre><code>    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;        &lt;!--配置即使xml不在resources中，也能读取到xml文件--&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;</code></pre><p>加入上面的<code>&lt;resources&gt;</code>即可。</p><p>此时再次运行项目，就会成功了：<br><img src="/images/mybatis/QQ截图20190311100710.png"></p><p>此时，在target目录下，能看到：com.liuzhuo.dao下的UserMapper.xml文件。<br><img src="/images/mybatis/QQ截图20190311100846.png" style="width:50%"></p><p>没有修改pom.xml文件之前，即使你在src源码目录的:com.liuzhuo.dao中加入UserMapper.xml文件，在target相同的目录下是不会有UserMapper.xml文件。</p><p>这就是出错的原因。</p><p>如果你创建的是web的maven工程，不会出错的，我的这个工程是简单的maven工程才会这样，大家如果出现了同样的问题，可以看看是不是这个原因！！！</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的主配置文件</title>
      <link href="/2019/03/10/mybatis-zhong-de-zhu-pei-zhi-wen-jian/"/>
      <url>/2019/03/10/mybatis-zhong-de-zhu-pei-zhi-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>今天来讲解Mybatis中的主配置文件，Mybatis的配置文件对整个Mybatis体系产生深远的影响。<br><a id="more"></a></p><h3 id="Mybatis配置文件层次结构"><a href="#Mybatis配置文件层次结构" class="headerlink" title="Mybatis配置文件层次结构"></a>Mybatis配置文件层次结构</h3><p>先来看一下MyBatis配置XML文件的层次结构。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!--配置--&gt;    &lt;properties/&gt;&lt;!--属性--&gt;    &lt;settings/&gt;&lt;!--设置--&gt;    &lt;typeAliases/&gt;&lt;!--别名--&gt;    &lt;typeHandlers/&gt;&lt;!--类型处理器--&gt;    &lt;plugins/&gt;&lt;!--插件--&gt;    &lt;environments default=&quot;development&quot;&gt;&lt;!--配置环境--&gt;        &lt;environment id=&quot;development&quot;&gt;&lt;!--环境变量--&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;!--事务管理器--&gt;            &lt;dataSource type=&quot;POOLED&quot;/&gt;&lt;!--数据源--&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;databaseIdProvider/&gt;&lt;!--数据库厂商标识--&gt;    &lt;mappers/&gt;&lt;!--映射器--&gt;&lt;/configuration&gt;</code></pre><font color="red"><strong>注意，这些层次是不能够颠倒顺序的的，如果颠倒顺序，Mybatis在解析XML文件的时候就会出现异常。</strong></font><h3 id="properties元素"><a href="#properties元素" class="headerlink" title="properties元素"></a>properties元素</h3><p>properties是一个配置属性的元素，让我们能在配置文件的上下文中使用它。</p><p>Mybatis提供3种配置方式：</p><ul><li><p>property子元素</p></li><li><p>properties配置文件</p></li><li><p>程序参数传递</p></li></ul><h4 id="property子元素"><a href="#property子元素" class="headerlink" title="property子元素"></a>property子元素</h4><p>property子元素的配置方式如下：</p><pre><code>    &lt;properties&gt;        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/properties&gt;</code></pre><p>这样我们就可以在上下文中使用已经配置好的属性值了。我们在配置数据库的数据源时就可以按照如下进行配置：</p><pre><code>    &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;    &lt;/dataSource&gt;</code></pre><hr><h4 id="properties配置文件"><a href="#properties配置文件" class="headerlink" title="properties配置文件"></a>properties配置文件</h4><p>更多时候，我们希望使用properties配置文件来配置属性值，以方便我们在多个配置文件中重复使用它们，也方便日后维护和随时修改，这些在Mybatis中是很容易做到的，我们先来看一下 properties文件 ( jdbc.properties )，代码如下：</p><pre><code>#数据库配置文件driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatisusername=rootpassword=123456</code></pre><p>我们把这个properties配置文件放在<strong>源码包</strong>下，只要这样引入这个配置文件即可：</p><p><code>&lt;properties resources=&quot;jdbc.properties&quot;/&gt;</code></p><p>如果想要放在自定义的包下，比如：com.liuzhuo.mybatis中就：</p><p><code>&lt;properties resources=&quot;com/liuzhuo/mybatis/jdbc.properties&quot;/&gt;</code></p><hr><h4 id="程序参数传递"><a href="#程序参数传递" class="headerlink" title="程序参数传递"></a>程序参数传递</h4><p>在实际工作中，我们常常遇到这样的问题：系统是由运维人员去配置的，生产数据库的用户密码对于开发者而言是保密的，而且为了安全，运维人员要求对配置文件中的数据库用户密码进行加密，这样我们的配置文件中往往配置的是加密过后的数据库信息，而无法通过加密的字符串去连接数据库，这个时候可以通过编码的形式来满足我们遇到的场景。</p><p>下面假设jdbc.properties文件中的username和password两个属性使用了加密的字符串，这个时候我们需要在生成SqlSessionFactory之前将它转化为明文，而系统已经提供了解密的方法decode(str)，让我们来看看如何使用代码的方式来完成SqlSessionFactory的创建，如下：</p><pre><code>    InputStream cfgStream = null;    Reader cfgReader = null;    InputStream proStream = null;    Reader proReader = null;    Properties properties = null;    try{       //读取配置文件流       cfgStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);       cfgReader = new InputStreamReader(cfgStream);       //读入属性文件       proStream = Resources.getResourceAsStream(&quot;jdbc.properties&quot;);       proReader = new InputStreamReader(proStream);       properties = new Properties();       properties.load(proReader);       //解密为明文       properties.setProperty(&quot;username&quot;,decode(properties.getProperty(&quot;username&quot;)));       properties.setProperty(&quot;password&quot;,decode(properties.getProperty(&quot;password&quot;)));    }catch(IOException ex){      System.out.println(ex.getMessage());    }    Synchronized(CLASS_LOCK){         if(sqlSessionFactory == null){            //使用属性来创建SqlSessionFactory            SqlSessionFactory = new SqlSessionFactoryBuilder().build(cfgReader,properties);         }    }</code></pre><p>这样我们完全可以在jdbc.properties配合密文了，满足对系统安全的要求了。</p><hr><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>Mybatis支持3种配置方式可能同时出现，并且属性还会重复配置。这3种方式是存在优先级的，Mybatis将按照下面的顺序来加载。</p><ol><li><p>在properties元素体内指定的属性首先被读取（property子元素）</p></li><li><p>根据properties元素中的resources属性读取类路径下的.properties文件，或者根据url属性指定的路径读取属性文件，并覆盖也读取的同名属性</p></li><li><p>读取作为方法参数传递的属性，并覆盖也读取的同名属性</p></li></ol><p><strong>因此，通过<code>方法参数传递的属性具有最高优先级</code>，<code>resources属性中指定的配置文件次之</code>，<code>最低优先级的是properties元素中的指定的属性。</code></strong></p><hr><p>因此，在实际操作中，我们需要注意一下3点：</p><ol><li><p>不要混合使用，这样会导致管理混乱</p></li><li><p>首选的方式是使用properties文件</p></li><li><p>如果需要使用加密或者其他加工处理，不妨按照示例的方法来处理，这样做的好处是使得配置都来自于同一个配置文件，就不容易产生没有必要的歧义。</p></li></ol><hr><p>从MyBatis 3.4.2开始，你可以为占位符指定一个默认值。例如：</p><pre><code>&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;!-- ... --&gt;  &lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt; &lt;!-- If &#39;username&#39; property not present, username become &#39;ut_user&#39; --&gt;&lt;/dataSource&gt;</code></pre><p>这个特性默认是关闭的。如果你想为占位符指定一个默认值， 你应该添加一个指定的属性来开启这个特性。例如：</p><pre><code>&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;  &lt;!-- ... --&gt;  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- Enable this feature --&gt;&lt;/properties&gt;</code></pre><p><strong><code>提示：你可以使用 &quot;:&quot; 作为属性键(e.g. db:username) 或者你也可以在sql定义中使用 OGNL 表达式的三元运算符(e.g. ${tableName != null ? tableName : &#39;global_constants&#39;})</code></strong></p><p>你也可以通过增加一个指定的属性来改变分隔键和默认值的字符。例如：</p><pre><code>&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;  &lt;!-- ... --&gt;  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot; value=&quot;?:&quot;/&gt; &lt;!-- Change default value of separator --&gt;&lt;/properties&gt;&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;!-- ... --&gt;  &lt;property name=&quot;username&quot; value=&quot;${db:username?:ut_user}&quot;/&gt;&lt;/dataSource&gt;</code></pre><hr><h3 id="settings设置"><a href="#settings设置" class="headerlink" title="settings设置"></a>settings设置</h3><p>设置（settings）在Mybatis中是最复杂的配置，同时也是最为重要的配置内容之一，它会改变Mybatis运行时的行为。即使不配置settings，Mybatis也可以正常的工作，不过了解settings的配置内容，以及它们的作用仍然十分必要。</p><p>Settings的配置内容如下：<br><img src="/images/mybatis/QQ截图20190310114235.png"><br><img src="/images/mybatis/QQ截图20190310114509.png"><br><img src="/images/mybatis/QQ截图20190310114547.png"></p><p>一个配置完整的 settings 元素的示例如下：</p><pre><code>&lt;settings&gt;  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;  &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;  &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;  &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;  &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;  &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;  &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;  &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;  &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;  &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;  &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;  &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;  &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;  &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt;</code></pre><p>在大部分时候我们不需要去配置它，或者只需要配置少数几项即可。</p><hr><h3 id="typeAliases-别名"><a href="#typeAliases-别名" class="headerlink" title="typeAliases(别名)"></a>typeAliases(别名)</h3><p>别名(typeAliases)是一个指代的名称，因为我们遇到的类的全限定名过长，所以我们希望用一个简短的名称来指代它，而这个名称可以在Mybatis上下文中使用。别名在Mybatis里面分为<strong>系统定义的别名</strong>和<strong>自定义的别名</strong>。注意，在Mybatis中别名是不分大小写的。</p><p>一个typeAliases的实例是在解析配置文件时生成的，然后长期保存在Configuration对象中，当我们使用它时，再把它拿出来，这样就没有必要运行的时候再次生成它的实例了。</p><h4 id="系统别名"><a href="#系统别名" class="headerlink" title="系统别名"></a>系统别名</h4><p>Mybatis系统定义了一些经常使用的类型的别名，比如：数值、字符串、日期和集合等，我们可以在Mybatis中直接使用它们，在使用时不要重复定义把它们给覆盖了。</p><p>如下是系统给我们定义的常用的别名：<br><img src="/images/mybatis/QQ截图20190310115942.png"><br><img src="/images/mybatis/QQ截图20190310120030.png"><br><img src="/images/mybatis/QQ截图20190310120122.png"></p><p>我们可以通过Mybatis的源码 org.apache.ibatis.type.TypeAliasRegistry 可以看出其自定义注册的信息，如下所示：</p><pre><code>  public TypeAliasRegistry() {    registerAlias(&quot;string&quot;, String.class);    registerAlias(&quot;byte&quot;, Byte.class);    registerAlias(&quot;long&quot;, Long.class);    registerAlias(&quot;short&quot;, Short.class);    registerAlias(&quot;int&quot;, Integer.class);    registerAlias(&quot;integer&quot;, Integer.class);    registerAlias(&quot;double&quot;, Double.class);    registerAlias(&quot;float&quot;, Float.class);    registerAlias(&quot;boolean&quot;, Boolean.class);    ·····}</code></pre><p>这些就是Mybatis系统定义的别名，我们无需重复注册它们。</p><h4 id="自定义别名"><a href="#自定义别名" class="headerlink" title="自定义别名"></a>自定义别名</h4><p>系统所定义的别名往往是不够用的，因为不同的应用有着不同的需要，所以Mybatis允许自定义别名。</p><p>代码如下：</p><pre><code>&lt;typeAliases&gt;  &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;  &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;  &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt;  &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt;  &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt;  &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;&lt;/typeAliases&gt;</code></pre><p>当这样配置时，Blog可以用在任何使用domain.blog.Blog的地方。</p><p>如果POJO对象过多的时候，配置也是非常多的。因此允许我们通过包扫描的方式来注册自定义别名，如下：</p><pre><code>&lt;typeAliases&gt;  &lt;package name=&quot;domain.blog&quot;/&gt;&lt;/typeAliases&gt;</code></pre><p>每一个在包 domain.blog 中的 Java Bean，<strong><code>在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</code></strong></p><p>比如 domain.blog.Author 的别名为 author。</p><p>也可以使用注解的方法，自定义别名，如下：</p><pre><code>@Alias(&quot;author&quot;)public class Author {    ...}</code></pre><p>当配合上面的配置，Mybatis就会自动扫描包，将扫描到的类装载到上下文中，以便将来使用。这样就算是多个POJO也可以通过包扫描的方式装载到Mybatis的上下文中。</p><hr><h3 id="typeHandler-类型处理器"><a href="#typeHandler-类型处理器" class="headerlink" title="typeHandler(类型处理器)"></a>typeHandler(类型处理器)</h3><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</p><p>由于数据库可能来自于不同的厂商，不同的厂商设置的参数可能有所不同，同时数据库也可以自定义数据类型，typeHandler允许根据项目的需要自定义设置Java传递到数据库的参数中，或者从数据库读取数据，我们也需要进行特殊的处理，这些都可以在自定义的typeHandler中处理，尤其是在使用枚举的时候，我们常常需要使用typeHandler进行转换。</p><p>typeHandler和别名一样，分为Mybatis系统定义的和用户自定义两种。一般来说，使用Mybatis系统定义的typeHandler就可以实现大部分的功能，如果使用用户自定义的typeHandler，我们在处理的时候务必要小心谨慎，以避免出现不必要的错误。</p><p>typeHandler常用的配置为Java类型（javaType）、JDBC类型（jdbcType）。typeHandler的作用就是将参数从javaType转化为jdbcType，或者从数据库取出数据时把jdbcType转化为javaType。</p><h4 id="系统定义的typeHandler"><a href="#系统定义的typeHandler" class="headerlink" title="系统定义的typeHandler"></a>系统定义的typeHandler</h4><p>Mybatis系统内部定义了一系列的typeHandler，我们可以看看 org.apache.ibatis.type.TypeHandlerRegistry</p><pre><code>  public TypeHandlerRegistry() {    register(Boolean.class, new BooleanTypeHandler());    register(boolean.class, new BooleanTypeHandler());    register(JdbcType.BOOLEAN, new BooleanTypeHandler());    register(JdbcType.BIT, new BooleanTypeHandler());    register(Byte.class, new ByteTypeHandler());    register(byte.class, new ByteTypeHandler());    register(JdbcType.TINYINT, new ByteTypeHandler());    register(Short.class, new ShortTypeHandler());    register(short.class, new ShortTypeHandler());    register(JdbcType.SMALLINT, new ShortTypeHandler());    ····}</code></pre><p>下表描述了一些默认的类型处理器。<br><img src="/images/mybatis/QQ截图20190310123016.png"><br><img src="/images/mybatis/QQ截图20190310123134.png"><br><img src="/images/mybatis/QQ截图20190310123216.png"></p><hr><p>我们需要注意下面几点。</p><ul><li><p>数值类型的精度，数据库 int、double、decimal这些类型 和 java的 精度、长度都是不一样的。</p></li><li><p>时间精度，取数据，精确到日用DateOnlyTypeHandler即可，精确到秒就用SqlTimestampTypeHandler等。</p></li></ul><h4 id="自定义typeHandler"><a href="#自定义typeHandler" class="headerlink" title="自定义typeHandler"></a>自定义typeHandler</h4><p>在我们自定义typeHandler之前，我们先学习一下，Mybatis为我们提供的系统typeHandler，这样我们可以照着标准来自定义我们的typeHandler了。</p><p>我们来看一下最常见的：StringTypeHandler。</p><pre><code>public class StringTypeHandler extends BaseTypeHandler&lt;String&gt; {  @Override  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType)      throws SQLException {    ps.setString(i, parameter);  }  @Override  public String getNullableResult(ResultSet rs, String columnName)      throws SQLException {    return rs.getString(columnName);  }  @Override  public String getNullableResult(ResultSet rs, int columnIndex)      throws SQLException {    return rs.getString(columnIndex);  }  @Override  public String getNullableResult(CallableStatement cs, int columnIndex)      throws SQLException {    return cs.getString(columnIndex);  }}</code></pre><p>简单说明一下上面的代码。</p><p>StringTypeHandler 继承了 BaseTypeHandler。 而 BaseTypeHandler 实现了接口 typeHandler，并且自己定义了4个抽象的方法。所以继承它的时候，正如本例一样需要实现其定义的4个抽象方法，这些方法已经在StringTypeHandler中使用@Override注解注明了。</p><p>setParameter 是 PreparedStatement 对象设置参数，它允许我们自己填写变换的规则。</p><p>getResult 则是ResultSet用列名（columnName）或者使用列下标（columnIndex）来获取结果数据的。其中还包括了用CallableStatement（存储过程）获取结果及数据的方法。</p><hr><p>一般而言，Mybatis系统提供的typeHandler已经能够应付大部分的场景了，但是我们不能排除不够用的情况。首先需要明确两个问题：我们自定义的TypeHandler需要处理什么类型？现有的TypeHandler适合我们使用吗？我们需要特殊的处理java的那些类型（JavaType）和对应处理数据库的那些类型（JdbcType），比如字典项的枚举。</p><p>这里让我们重新覆盖一个字符串参数的TypeHandler，我们首先先配置XML文件，确定我们需要处理什么类型的参数和结果，如下所示：</p><pre><code>&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt;  &lt;typeHandler handler=&quot;com.liuzhuo.typehandler.MyStringTypehandler&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><p>上面定义的数据库类型为VARCHAR型。当java的参数类型为string的时候，我们就可以使用MyStringTypeHandler来处理了，但是只有这个配置，Mybatis不会自动帮你去使用这个TypeHandler去转化的，你需要更多的配置。</p><p>对于MyStringTypehandler，我们需要实现：</p><p><code>org.apache.ibatis.type.TypeHandler</code> 接口，或者是继承：<code>org.apache.ibatis.type.BaseTypeHandler</code>。</p><p>以上就是实现自定义TypeHandler的两种方式（其实BaseTypeHandler就是实现了TypeHandler接口的类）</p><pre><code>@MappedJdbcTypes(JdbcType.VARCHAR)@MappedTypes({String.class})public class MyStringTypehandler extends BaseTypeHandler&lt;String&gt; {  @Override  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {    System.out.println(&quot;使用了我的TypeHandler&quot;);    ps.setString(i, parameter);  }  @Override  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {    System.out.println(&quot;使用了我的TypeHandler，ResultSet列名获取字符串&quot;);    return rs.getString(columnName);  }  @Override  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {    System.out.println(&quot;使用了我的TypeHandler，ResultSet下标获取字符串&quot;);    return rs.getString(columnIndex);  }  @Override  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {    System.out.println(&quot;使用了我的TypeHandler，CallableStatement下标获取字符串&quot;);    return cs.getString(columnIndex);  }}</code></pre><p>自定义的TypeHandler里，使用了注解 @MappedTypes 和 @MappedJdbcTypes 来配置 javaType 和 jdbcType。</p><ul><li><p>@MappedTypes：定义的是JavaType类型，可以指定哪些java类型被拦截</p></li><li><p>@MappedJdbcTypes：定义的是JdbcType类型，它需要满足枚举类型 org.apache.ibatis.type.JdbcType所列的枚举类型。</p></li></ul><font color="red">要注意 MyBatis 不会窥探数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明那是 VARCHAR 类型的字段， 以使其能够绑定到正确的类型处理器上。 这是因为：MyBatis 直到语句被执行才清楚数据类型。</font><hr><p>通过类型处理器的泛型，MyBatis 可以得知该类型处理器处理的 Java 类型，不过这种行为可以通过两种方法改变：</p><ul><li><p>在类型处理器的配置元素（typeHandler element）上增加一个 javaType 属性（比如：javaType=”String”）；</p></li><li><p>在类型处理器的类上（TypeHandler class）增加一个 @MappedTypes 注解来指定与其关联的 Java 类型列表。 如果在 javaType 属性中也同时指定，则注解方式将被忽略。</p></li></ul><p>可以通过两种方式来指定被关联的 JDBC 类型：</p><ul><li><p>在类型处理器的配置元素上增加一个 jdbcType 属性（比如：jdbcType=”VARCHAR”）；</p></li><li><p>在类型处理器的类上（TypeHandler class）增加一个 @MappedJdbcTypes 注解来指定与其关联的 JDBC 类型列表。 如果在 jdbcType 属性中也同时指定，则注解方式将被忽略。</p></li></ul><p>即优先级是：</p><pre><code>&lt;typeHandler handler=&quot;xxx&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;  中的 javaType 和 jdbcType 大于 @MappedTypes 和 @MappedJdbcTypes</code></pre><hr><p>当决定在ResultMap中使用某一TypeHandler时，此时java类型是已知的（从结果类型中获得），但是JDBC类型是未知的。 </p><p>因此Mybatis使用 javaType=[TheJavaType], jdbcType=null 的组合来选择一个TypeHandler。 </p><p>这意味着使用@MappedJdbcTypes注解可以限制TypeHandler的范围，同时除非显式的设置，否则TypeHandler在ResultMap中将是无效的。 </p><p>如果希望在ResultMap中使用TypeHandler，那么设置@MappedJdbcTypes注解的includeNullJdbcType=true即可。 </p><p>然而从Mybatis 3.4.0开始，如果只有一个注册的TypeHandler来处理Java类型，那么它将是ResultMap使用Java类型时的默认值（即使没有includeNullJdbcType=true）。</p><hr><p>最后，类型处理器也可以和别名一样，使用包扫描的方式，注册多个类型处理器</p><pre><code>&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt;  &lt;package name=&quot;org.mybatis.example&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><p>注意在使用自动检索（autodiscovery）功能的时候，只能通过注解方式来指定 JDBC 的类型。（@MappedJdbcTypes）</p><hr><p>到现在，我们还是不能测试，因为还需要去标识哪些参数或者结果类型去用我们自定义的TypeHandler去转化，在没有任何标识的情况下，Mybatis是不会启用你定义的TypeHandler进行转化的，所以还需要给予对应的标识，比如配置jdbcType 和 javaType，或者直接使用typeHandler属性指定，因此还需要修改映射器的XML配置。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.dao.UserMapper&quot;&gt;    &lt;resultMap id=&quot;usermap&quot; type=&quot;user&quot;&gt;&lt;!--因为添加了别名，所以直接使用user--&gt;        &lt;id column=&quot;userId&quot; property=&quot;userId&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result column=&quot;user_age&quot; property=&quot;userAge&quot;/&gt;            &lt;!--定义结果类型转化器标识，才能使用类型转换器--&gt;        &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; typeHandler=&quot;com.liuzhuo.typehandler.MyStringTypehandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;long&quot; resultMap=&quot;usermap&quot;&gt;        select userId,user_name as userName,user_age as userAge from user where userId = #{id}    &lt;/select&gt;    &lt;select id=&quot;selectById03&quot; parameterType=&quot;string&quot; resultMap=&quot;usermap&quot;&gt;        select userId,user_name as userName,user_age as userAge from user where user_name = #{userName,javaType=&quot;string&quot;,jdbcType=&quot;VARCHAR&quot;}    &lt;/select&gt;    &lt;select id=&quot;selectById02&quot; parameterType=&quot;string&quot; resultMap=&quot;usermap&quot;&gt;        select userId,user_name as userName,user_age as userAge from user where user_name = #{userName,typeHandler=&quot;com.liuzhuo.typehandler.MyStringTypehandler}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>我们这里引入了resultMap，它提供了映射规则，这里给出了3种typeHandler的使用方法。</p><ul><li><p>在配置文件里面配置，在结果集的的id定义：javaType 和 jdbcType。只要定义的javaType 和 jdbcType 与我们定义在配置里面的typeHandler是一致的，Mybatis才会知道用我们自定义的类型转化器进行转换。</p></li><li><p>映射集里面直接定义具体的typeHandler，这样就不需要再在配置里面定义了。</p></li><li><p>在参数中制定typeHandler，这样Mybatis就会用对应的typeHandler进行转换，这样也不需要在配置里面定义了。</p></li></ul><hr><p>配置好后，运行我们的项目的MybatisMain主函数，接着上篇博客来写的：<br><img src="/images/mybatis/QQ截图20190310151142.png"></p><p>从结果看，程序运行了我们自定义的typeHandler，输出了打印语句。</p><hr><h4 id="处理枚举类型"><a href="#处理枚举类型" class="headerlink" title="处理枚举类型"></a>处理枚举类型</h4><p>在Mybatis中枚举类型的typeHandler有自己特殊的规则，Mybatis内部提供了两个枚举typeHandler：</p><ul><li><p>EnumTypeHandler </p></li><li><p>EnumOrdinalTypeHandler </p></li></ul><p>EnumTypeHandler 和 EnumOrdinalTypeHandler 都是泛型类型处理器（generic TypeHandlers）</p><p>其中，EnumTypeHandler是使用枚举字符串名称来作为参数的，EnumOrdinalTypeHandler是使用整数下标作为参数的。</p><p><strong>注意 EnumTypeHandler 在某种意义上来说是比较特别的，其他的处理器只针对某个特定的类，而它不同，它会处理任意继承了 Enum 的类。</strong></p><p>然而这两个枚举类型应用却不是那么广泛，更多的时候我们希望使用自定义的typeHandler处理它们。所以在这里我们也会谈及自定义的typeHandler实现枚举映射。</p><h5 id="EnumOrdinalTypeHandler"><a href="#EnumOrdinalTypeHandler" class="headerlink" title="EnumOrdinalTypeHandler"></a>EnumOrdinalTypeHandler</h5><p>下面以性别为例，讲述如何实现枚举类。现在我们有一个性别枚举，它定义了字典：男（male），女（female）。</p><p>在com.liuzhuo.enums包下，创建Sex枚举类</p><pre><code>public enum Sex {    MALE(1, &quot;男&quot;), FEMALE(2, &quot;女&quot;);    private int id;    private String name;    private Sex(int id, String name) {        this.id = id;        this.name = name;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public static Sex getSex(int id) {        if (id == 1) {            return MALE;        } else if (id == 2) {            return FEMALE;        }        return null;    }}</code></pre><p>在没有配置的时候，EnumOrdinalTypeHandler是Mybatis的默认枚举类型的处理器，为了让EnumOrdinalTypeHandler能够处理它，我们在Mybatis中做如下配置：</p><pre><code>    &lt;typeHandlers&gt;        ···        &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;com.liuzhuo.enums.Sex&quot;/&gt;    &lt;/typeHandlers&gt;</code></pre><p>这样当Mybatis遇到这个枚举类时就可以识别这个枚举了，然后修改userMapper.xml文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.dao.UserMapper&quot;&gt;    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;&lt;!--因为添加了别名，所以直接使用user--&gt;        &lt;id column=&quot;userId&quot; property=&quot;userId&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result column=&quot;user_age&quot; property=&quot;userAge&quot;/&gt;        &lt;!--定义结果类型转化器标识，才能使用类型转换器--&gt;        &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; typeHandler=&quot;com.liuzhuo.typehandler.MyStringTypehandler&quot;/&gt;        &lt;!--新添加的字段--&gt;        &lt;result column=&quot;user_sex&quot; property=&quot;userSex&quot; typeHandler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;long&quot; resultMap=&quot;userMap&quot;&gt;        select userId,user_name as userName,user_age as userAge ,user_sex as userSex from user where userId = #{id}    &lt;/select&gt;    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt;        INSERT INTO user(userId,user_age,user_name,user_sex)        VALUES (#{userId},#{userAge},#{userName},#{userSex,typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler})    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><p>主要增加了一个新的字段，userSex 和 一个 insert方法。</p><p>userMapper接口：</p><pre><code>public interface UserMapper {    User selectById(Long id);    @Select(&quot;select userId,user_age as useAge,user_name as userName from user where userId = #{id}&quot;)    User selectById02(Long id);    //新增加的方法    int insertUser(User user);}</code></pre><p>User类：</p><pre><code>public class User {    private String userId;    private Long userAge;    private String userName;    //多的字段    private Sex userSex;      ···省略get、set、toSting方法</code></pre><p>在mysql中，添加新的列，为user_sex<br><img src="/images/mybatis/QQ截图20190310155623.png"></p><p>修改我们的MybatisMain类的main方法：</p><pre><code>        SqlSession sqlSession = null;        try {            sqlSession = SqlSessionFactoryUtil.openSqlSession();            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);            User user = new User();            user.setUserId(UUID.randomUUID().toString());            user.setUserName(&quot;dj&quot;);            user.setUserAge(18L);            user.setUserSex(Sex.FEMALE);//插入新增加的枚举类型            userMapper.insertUser(user);            sqlSession.commit();        } catch (Exception e) {            System.out.println(e.getMessage());            //出现异常，回滚            sqlSession.rollback();        } finally {            //关闭sqlSession对象            if (sqlSession != null) {                sqlSession.close();            }        }    }</code></pre><p>执行结果：<br><img src="/images/mybatis/QQ截图20190310155821.png"><br>打开sql数据库：<br><img src="/images/mybatis/QQ截图20190310155921.png"></p><p>发现它插入的是枚举类型的下标。</p><hr><p>然后，再次修改MybatisMain类的main方法：</p><pre><code>        SqlSession sqlSession = null;        try {            sqlSession = SqlSessionFactoryUtil.openSqlSession();            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);            //id是数据库的，请填写你的id            User user = userMapper.selectById(&quot;a582c9ec-872b-4f6e-8520-a924e140efd7&quot;);            System.out.println(user);            sqlSession.commit();        } catch (Exception e) {            System.out.println(e.getMessage());            //出现异常，回滚            sqlSession.rollback();        } finally {            //关闭sqlSession对象            if (sqlSession != null) {                sqlSession.close();            }        }</code></pre><p>执行：<br><img src="/images/mybatis/QQ截图20190310161623.png"></p><p>运行成功，取数据时，根据枚举的下标进行转化，变成了FEMALE。</p><font color="red">注意，执行select后，打印出来的user的有可能有的字段没有值，这是因为当我们的使用resultMap后，select中就不要使用as了，这样会映射不对的！！！</font><p>即：(去掉所有的as)</p><pre><code>    &lt;select id=&quot;selectById&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot;&gt;        select userId,user_age ,user_name ,user_sex  from user where userId = #{id}    &lt;/select&gt;</code></pre><hr><h5 id="EnumTypeHandler"><a href="#EnumTypeHandler" class="headerlink" title="EnumTypeHandler"></a>EnumTypeHandler</h5><p>EnumTypeHandler是使用枚举名称去处理Java枚举类型。EnumTypeHandler对应的是一个字符串，让我们来看看它的用法。</p><p>首先将mysql中的user_sex改为<code>VARCHAR</code>类型，然后修改映射的xml文件。<br><img src="/images/mybatis/QQ截图20190310162436.png"></p><p>将typeHandler换成：org.apache.ibatis.type.EnumTypeHandler 即可。</p><p>再次插入数据后：<br><img src="/images/mybatis/QQ截图20190310162944.png"><br><img src="/images/mybatis/QQ截图20190310163028.png"></p><hr><h5 id="自定义枚举类的typeHandler"><a href="#自定义枚举类的typeHandler" class="headerlink" title="自定义枚举类的typeHandler"></a>自定义枚举类的typeHandler</h5><p>我们也看到了Mybatis系统内部的枚举类的typeHandler不太好，所以，一般情况下，我们都需要自己定义枚举类的typeHandler。</p><p>创建SexEnumTypeHandler：</p><pre><code>public class SexEnumTypeHandler extends BaseTypeHandler&lt;Sex&gt; {    @Override    public void setNonNullParameter(PreparedStatement ps, int i, Sex parameter, JdbcType jdbcType) throws SQLException {        System.out.println(&quot;自定义的枚举类型，set&quot;);        ps.setInt(i, parameter.getId());    }    @Override    public Sex getNullableResult(ResultSet rs, String columnName) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = rs.getInt(columnName);        return Sex.getSex(id);    }    @Override    public Sex getNullableResult(ResultSet rs, int columnIndex) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = rs.getInt(columnIndex);        return Sex.getSex(id);    }    @Override    public Sex getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = cs.getInt(columnIndex);        return Sex.getSex(id);    }}</code></pre><p>修改mbatis-config.xml配置文件：</p><pre><code>    &lt;typeHandlers&gt;        ···        &lt;typeHandler handler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot; javaType=&quot;com.liuzhuo.enums.Sex&quot;/&gt;    &lt;/typeHandlers&gt;</code></pre><p>修改userMapper.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.dao.UserMapper&quot;&gt;    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;        &lt;id column=&quot;userId&quot; property=&quot;userId&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result column=&quot;user_age&quot; property=&quot;userAge&quot;/&gt;        &lt;!--定义结果类型转化器标识，才能使用类型转换器--&gt;        &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; typeHandler=&quot;com.liuzhuo.typehandler.MyStringTypehandler&quot;/&gt;        &lt;!--新添加的字段--&gt;        &lt;result column=&quot;user_sex&quot; property=&quot;userSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot;&gt;        select userId,user_age ,user_name ,user_sex  from user where userId = #{id}&lt;/select&gt;    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt;        INSERT INTO user(userId,user_age,user_name,user_sex)        VALUES (#{userId},#{userAge},#{userName},#{userSex,typeHandler=com.liuzhuo.typehandler.SexEnumTypeHandler})    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><p>修改主函数：</p><pre><code>            sqlSession = SqlSessionFactoryUtil.openSqlSession();            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);            User user = new User();            user.setUserId(UUID.randomUUID().toString());            user.setUserName(&quot;gakkij&quot;);            user.setUserAge(18L);            user.setUserSex(Sex.FEMALE);            userMapper.insertUser(user);            sqlSession.commit();</code></pre><p><img src="/images/mybatis/QQ截图20190310164451.png"><br><img src="/images/mybatis/QQ截图20190310164520.png"></p><hr><p>修改主函数：</p><pre><code>            sqlSession = SqlSessionFactoryUtil.openSqlSession();            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);            User user = userMapper.selectById(&quot;635a61a2-1d0e-450a-bda1-20aa340567db&quot;);            System.out.println(user);            sqlSession.commit();</code></pre><p><img src="/images/mybatis/QQ截图20190310164703.png"></p><hr><h3 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h3><p>当Mybatis在构建一个结果返回的时候，都会使用ObjectFactory（对象工厂）去构建POJO，在Mybatis中可以定制自己的对象工厂。一般来说我们使用默认的ObjectFactory即可，Mybatis中默认的ObjectFactory是由 org.apache.ibatis.reflection.DefaultObjectFactory来提供服务的。在大部分的场景下我们都不用修改，如果要定制特定的工厂则需要进行配置，如下所示：</p><pre><code>&lt;objectFactory type=&quot;com.liuzhuo.objectFactory.MyObjectFactory&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;MyObjectFactory&quot;/&gt;&lt;/objectFactory&gt;</code></pre><p>这里，我们配置了一个对象工厂MyObjectFactory，对它的要求是实现ObjectFactory的接口。实际上DefaultObjectFactory已经实现了ObjectFactory的接口，我们可以通过继承DefaultObjectFactory来简化编程。</p><p>在com.liuzhuo.objectFactory包下，创建MyObjectFactory类：</p><pre><code>public class MyObjectFactory extends DefaultObjectFactory {    private static final long serialVersionUID = -4783947743847934344L;    Logger log = Logger.getLogger(MyObjectFactory.class);    @Override    public void setProperties(Properties properties) {        log.info(&quot;定制属性：&quot; + properties);        super.setProperties(properties);    }    @Override    public &lt;T&gt; T create(Class&lt;T&gt; type) {        log.info(&quot;使用定制对象工厂的create方法构建单个对象&quot;);        return super.create(type);    }    @Override    public &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {        log.info(&quot;使用定制对象工厂的create方法构建列表对象&quot;);        return super.create(type, constructorArgTypes, constructorArgs);    }    @Override    public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type) {        return super.isCollection(type);    }}</code></pre><p><img src="/images/mybatis/QQ截图20190310175851.png"></p><p>运行我们的main方法：<br><img src="/images/mybatis/QQ截图20190310180429.png"></p><p>从运行的结果可以看出，首先，setProperties方法可以获取到<code>&lt;property name=&quot;name&quot; value=&quot;MyObjectFactory&quot;/&gt;</code>定义的属性值。</p><p>create方法分别是处理单个对象和列表对象。</p><p>注意，大部分情况下，我们不需要使用自己配置的ObjectFactory，使用默认的即可。</p><hr><h3 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins(插件)"></a>plugins(插件)</h3><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ul><li><p>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</p></li><li><p>ParameterHandler (getParameterObject, setParameters)</p></li><li><p>ResultSetHandler (handleResultSets, handleOutputParameters)</p></li><li><p>StatementHandler (prepare, parameterize, batch, update, query)</p></li></ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 <strong>因为如果在试图修改或重写已有方法的行为的时候，你很可能在破坏 MyBatis 的核心模块。 这些都是更低层的类和方法，所以使用插件的时候要特别当心。</strong></p><p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p><pre><code>// ExamplePlugin.java@Intercepts({@Signature(  type= Executor.class,  method = &quot;update&quot;,  args = {MappedStatement.class,Object.class})})public class ExamplePlugin implements Interceptor {  public Object intercept(Invocation invocation) throws Throwable {    return invocation.proceed();  }  public Object plugin(Object target) {    return Plugin.wrap(target, this);  }  public void setProperties(Properties properties) {  }}</code></pre><pre><code>&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt;  &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt;    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;  &lt;/plugin&gt;&lt;/plugins&gt;</code></pre><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的第三天作用域</title>
      <link href="/2019/03/09/mybatis-de-di-san-tian-zuo-yong-yu/"/>
      <url>/2019/03/09/mybatis-de-di-san-tian-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<p>探讨Mybatis中的各个对象的作用域和生命周期<br><a id="more"></a></p><p>今天主要来正确的理解Mybatis中的SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession和Mapper的生命周期。</p><h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>SqlSessionFactoryBuilder是利用xml和java编码获取资源来构建SqlSessionFactory的，通过它可以构建多个SqlSessionFactory，它的作用就是一个构建器，一旦我们构建了SqlSessionFactory，它的作用就结束了，失去了存在的意义。因此 SqlSessionFactoryBuilder 实例的最佳作用域是<strong><code>方法作用域（也就是局部方法变量）</code></strong>。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory的作用就是创建SqlSession，而SqlSession就是一个会话，相当于JDBC中的Connection对象。每次应用程序访问数据库，我们就需要通过SqlSessionFactory创建的Sqlsession来访问数据库，所以SqlSessionFactory应该在Mybatis项目的整个生命周期中，而如果我们多次创建同一个数据库的SqlSessionFactory，则每次创建都会打开更多的数据库连接（Connection）资源，那么连接资源就会很快消耗殆尽。</p><p>SqlSessionFactory的责任是唯一的，它就是创建SqlSession的，所以我们果断采取<strong>单例模式</strong>。因此 SqlSessionFactory 的最佳作用域是<strong><code>应用作用域</code></strong>。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>SqlSession就是一个会话，相当于JDBC中的Connection对象，它的生命周期应该是在请求数据库处理事务的过程中。<strong>它是一个线程不安全的对象</strong>，在涉及多线程的时候我们需要特别小心，操作数据库需要注意其隔离级别、数据库锁等高级特性。此外每次操作SqlSession完后，需要及时关闭它，它长期存在就会使数据库连接池的活动资源减少，对系统的性能的影响很大。正如前面的博客所说一样，往往通过finally语句块保证我们正确的关闭SqlSession。</p><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是<strong><code>请求或方法作用域</code></strong>。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。</p><p>如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式：</p><pre><code>SqlSession session = sqlSessionFactory.openSession();try {  // do work} finally {  session.close();}</code></pre><h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p>Mapper是一个接口，而没有任何实现类，它的作用是发送SQL语句，然后返回我们需要的结果，或者执行SQL语句从而修改数据库中的数据，因为它应该存在一个SqlSession事务方法之中，是一个方法级别的东西。它就如同JDBC中的一条SQL语句的执行，它最大的范围和SqlSession同级。尽管我们想一直保存着Mapper，但是你会发现它很难控制，所以尽量在一个SqlSession事务的方法中使用它们，然后废弃掉。所以，最好把映射器放在<strong><code>方法作用域（method scope）</code></strong>内。</p><pre><code>SqlSession session = sqlSessionFactory.openSession();try {  BlogMapper mapper = session.getMapper(BlogMapper.class);  // do work} finally {  session.close();}</code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了上面的描述，我们已经清楚了Mybatis组件的生命周期了，如下图所示：<br><img src="/images/mybatis/QQ截图20190309202349.png"></p><hr><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这里简单的做一个实例，它可以帮助我们熟悉Mybatis主要组件的用法。我们需要满足Mybatis各个组件的生命周期。首先SqlSessionFactory是单例，然后让它生成SqlSession，进而拿到映射器来完成我们的业务逻辑。</p><p>使用IDEA创建一个简单的maven项目，项目的整体结构如下：<br><img src="/images/mybatis/QQ截图20190309212333.png" style="width:50%"></p><p>java源码中：</p><ul><li><p>com.liuzhuo.entities  =====&gt; 存放POJO对象</p></li><li><p>com.liuzhuo.dao       =======&gt; 存放java接口（Mapper）</p></li><li><p>com.liuzhuo.util      ========&gt; 存放工具类</p></li></ul><p>resources资源中：</p><ul><li>com.liuzhuo.mapper   ======&gt; 存放mapper.xml文件</li></ul><p>log4j.properties文件</p><p>mybatis-config.xml文件</p><hr><p>pom.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.liuzhuo&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>log4j.properties文件：</p><pre><code>#全局配置log4j.rootLogger=ERROR,stdout#MyBatis日志配置log4j.logger.com.liuzhuo=TRACE#控制台输出配置log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%5p] [%t] - %m %x %n</code></pre><p>mybatis-config.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--日志采用Log4j--&gt;    &lt;settings&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;    &lt;/settings&gt;    &lt;!--别名--&gt;    &lt;typeAliases&gt;        &lt;typeAlias alias=&quot;user&quot; type=&quot;com.liuzhuo.entities.User&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--定义数据库信息，默认使用development数据库构建环境--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!--采用JDBC事务管理--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;                &lt;!--取消自动提交--&gt;                &lt;property name=&quot;autoCommit&quot; value=&quot;false&quot;/&gt;            &lt;/transactionManager&gt;            &lt;!--配置数据源的信息--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot;                          value=&quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=GMT%2B8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/liuzhuo/mapper/userMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>注意：上面取消了事务的自动提交功能！！！（实际开发中，不需要取消，这里只是为了演示组件的生命周期而已）</p><p>SqlSessionFactoryUtil类：</p><pre><code>public class SqlSessionFactoryUtil {    private static SqlSessionFactory sqlSessionFactory = null;    //类锁    private static final Class CLASS_LOCK = SqlSessionFactoryUtil.class;    //私有化构造方法    private SqlSessionFactoryUtil() {    }    /*     *创建sqlSessionFactory     * */    public static SqlSessionFactory initSqlSessionFactory() {        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = null;        try {            inputStream = Resources.getResourceAsStream(resource);        } catch (IOException e) {            e.printStackTrace();        }        //上锁，防止创建多个SqlSessionFactory        synchronized (CLASS_LOCK) {            if (sqlSessionFactory == null) {                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);            }        }        return sqlSessionFactory;    }    /*     * 打开SqlSession     * */    public static SqlSession openSqlSession() {        if (sqlSessionFactory == null) {            initSqlSessionFactory();        }        return sqlSessionFactory.openSession();    }}</code></pre><p>User类：</p><pre><code>public class User {    private String userId;    private Long userAge;    private String userName;    //省略了set、get、toString方法}</code></pre><p>UserMapper接口：</p><pre><code>public interface UserMapper {    User selectById(Long id);    @Select(&quot;select userId,user_age as useAge,user_name as userName from user where userId = #{id}&quot;)    User selectById02(Long id);}</code></pre><p>userMapper.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.dao.UserMapper&quot;&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;long&quot; resultType=&quot;user&quot;&gt;        select userId,user_name as userName,user_age as userAge from user where userId = #{id}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>注意，接口的方法名与xml映射文件的id保持一致，namespace为接口的全限定名！！！</p><p>MybatisMain类：</p><pre><code>public class MybatisMain {    public static void main(String[] args) {        SqlSession sqlSession = null;        try {            sqlSession = SqlSessionFactoryUtil.openSqlSession();            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);            User user = userMapper.selectById(1L);            System.out.println(user);        } catch (Exception e) {            System.out.println(e.getMessage());            //出现异常，回滚            sqlSession.rollback();        } finally {            //关闭sqlSession对象            if (sqlSession != null) {                sqlSession.close();            }        }    }}</code></pre><p>本地的数据库为school：</p><p>表为user：<br><img src="/images/mybatis/QQ截图20190309213806.png"></p><hr><p>运行MybatisMain类中的main方法：<br><img src="/images/mybatis/QQ截图20190309213950.png"></p><p>打印出了日志信息，可以看到sql语句的打印信息，获取到了数据库中的数据。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的第二天简单入门</title>
      <link href="/2019/03/08/mybatis-de-di-er-tian-jian-dan-ru-men/"/>
      <url>/2019/03/08/mybatis-de-di-er-tian-jian-dan-ru-men/</url>
      
        <content type="html"><![CDATA[<p>今天来学习Mybatis的基本用法，带大家入门。<br><a id="more"></a></p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>学习编程是一门实操的科学，只有一边敲代码一边学习才能有更好的效果，所以需要搭建一个学习的环境才行。</p><h4 id="下载Mybatis"><a href="#下载Mybatis" class="headerlink" title="下载Mybatis"></a>下载Mybatis</h4><p>输入官网：<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a> 进入官网，我们就可以下载Mybatis，如下图所示：<br><img src="/images/mybatis/QQ截图20190308214814.png"></p><p>在这里，我们可以下载到Mybatis所需的jar包和源码包。</p><p>mybatis的jar包下载地址：<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a></p><p>mybatis和Spring整合jar包下载地址：<a href="https://github.com/mybatis/spring/releases" target="_blank" rel="noopener">https://github.com/mybatis/spring/releases</a></p><hr><p><strong><code>使用Mybatis项目可以参考</code></strong>：<a href="http://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">http://mybatis.org/mybatis-3/zh/index.html</a></p><p><strong><code>使用Mybatis-Spring项目可以参考</code></strong>：<a href="http://mybatis.org/spring/zh/index.html" target="_blank" rel="noopener">http://mybatis.org/spring/zh/index.html</a></p><h3 id="搭建Mybatis的环境"><a href="#搭建Mybatis的环境" class="headerlink" title="搭建Mybatis的环境"></a>搭建Mybatis的环境</h3><p>无论使用哪种java IDE都可以轻松的搭建开发环境。我这里使用IDEA来搭建开发环境，Eclipse也行，都是类似的。</p><p>使用IDEA时，我们可以创建普通的java项目，然后将<strong>下载的Mybatis的jar和lib包</strong>导入到项目中使用Mybatis，但是，我觉得还是使用maven来搭建环境比较好，毕竟大家最后开发都是使用maven来开发项目的，maven大家应该都比较熟悉了，这里就不解释了。</p><p>（1） 使用IDEA创建maven项目：<br><img src="/images/mybatis/QQ截图20190308220624.png"></p><p>（2）添加Mybatis的依赖：</p><pre><code>    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p><img src="/images/mybatis/QQ截图20190308220907.png"></p><p>至于：Mybatis的版本号，自己到maven的仓库中寻找最新即可，我现在最新的版本是3.4.6</p><p>以上，我们的Mybatis的开发环境就搭建完毕了。</p><hr><h3 id="Mybatis的基本构成"><a href="#Mybatis的基本构成" class="headerlink" title="Mybatis的基本构成"></a>Mybatis的基本构成</h3><ul><li><p>SqlSessionFactoryBuilder(构造器)：它会根据配置信息或者代码来生成SqlSessionFactory（工厂接口）</p></li><li><p>SqlSessionFactory：依靠工厂来生成SqlSession（会话）。</p></li><li><p>SqlSession：是一个既可以发送SQL去执行并返回结果，也可以获取Mapper的接口。</p></li><li><p>SQL Mapper：它是Mybatis新设计的组件，它是由一个java接口和XML文件（或注解）构成的，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。</p></li></ul><p>可以用如下的图来表示：<br><img src="/images/mybatis/QQ截图20190309094652.png"></p><h4 id="构建SqlSessionFactory"><a href="#构建SqlSessionFactory" class="headerlink" title="构建SqlSessionFactory"></a>构建SqlSessionFactory</h4><p>每个Mybatis应用都是以SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获取。但是注意：SqlSessionFactory只是一个接口，它的任务是创建SqlSession。SqlSession类似于一个JDBC的Connection对象。Mybatis提供了两种模式去创建SqlsessionFactory：<strong>一种是使用XML配置的方式</strong>，<strong>另一种是代码的方式</strong>。</p><p>通过SqlSessionFactoryBuilder创建SqlsessionFactory时，需要传入一个XML配置文件，然后构建Configuration对象，类的全限定名是：<code>org.apache.ibatis.session.Configuration</code>，这个对象存在于整个Mybatis应用的生命周期中，以便重复的读取和运用。我们解析一次配置的XML文件保存到Configuration类对象中，方便我们从这个对象中读取配置信息，性能高。</p><p>在Mybatis中提供了两个SqlSessionFactory的实现类，<strong>DefaultSqlSessionFactory</strong> 和 <strong>SqlSessionManager</strong>。 不过目前，SqlSessionManager还没有使用，Mybatis中目前使用的是：DefaulSqlSessionFactory。<br><img src="/images/mybatis/QQ截图20190309100536.png"></p><p>(1)XML构成SqlsessionFactory</p><p>在我们的项目中的resources的根目录中创建：mybatis-config.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--别名--&gt;    &lt;typeAliases&gt;        &lt;typeAlias alias=&quot;user&quot; type=&quot;com.liuzhuo.entity.User&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--定义数据库信息，默认使用development数据库构建环境--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!--采用JDBC事务管理--&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;!--配置数据源的信息--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=GMT%2B8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/liuzhuo/mapper/userMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p><img src="/images/mybatis/QQ截图20190309104551.png"></p><p>这里配置信息，看注释即可，以后会专门来讲解这个配置文件。</p><p><strong>这里注意一下，mysql的url的连接配置：</strong></p><p>我这里的驱动版本是：mysql-connector-java-8.0.13</p><p>8.0之前（网上有说6.0.2版本之后改的）<br>com.mysql.jdbc.Driver<br>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8</p><p>8.0及以后（或者说6.0.2版本之后）<br>com.mysql.cj.jdbc.Driver<br>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</p><p><code>还有，如果你是配置在xml中时，&amp; 需要使用：&amp;amp; 来代替！！！</code></p><hr><p>配置好mybatis-config.xml文件后，就可以创建SqlsessionFactory：</p><pre><code>        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre><p>Mybatis的解析器程序会把mybatis-config.xml文件配置的信息解析到Configuration类对象里面，然后利用SqlSessionFactoryBuilder读取这个对象为我们创建SqlSessionFactory。</p><p>（2）使用代码来创建SqlSessionFactory</p><pre><code>        //配置数据库连接池        PooledDataSource dataSource = new PooledDataSource();        dataSource.setDriver(&quot;com.mysql.cj.jdbc.Driver&quot;);        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&quot;);        dataSource.setUsername(&quot;root&quot;);        dataSource.setPassword(&quot;123456&quot;);        //构建数据库事务方式        JdbcTransactionFactory transactionFactory = new JdbcTransactionFactory();        Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);        //构建Configuration对象        Configuration configuration = new Configuration(environment);        //注册别名        configuration.getTypeAliasRegistry().registerAlias(&quot;user&quot;, User.class);        //加入映射器        configuration.addMapper(UserMapper.class);        //创建SqlSessionFactory        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);</code></pre><p>显然用代码方式和用XML方式只是换了一个方法实现而已，其本质都是一样的。采用代码方式一般是在需要加入自己特性的时候才会用到。</p><hr><h4 id="创建SqlSession"><a href="#创建SqlSession" class="headerlink" title="创建SqlSession"></a>创建SqlSession</h4><p>SqlSession是一个接口类，它类似于你们公司的美女客服，它扮演着门面的作用，而真正干活的是Executor接口，你可以认为它是公司的工程师。假设我是客户找你们公司干活，我只需要告诉前台的美女客服（SqlSession）我要什么信息（参数），要做什么东西，过段时间，她会将结果给我。在这个过程中，作为用户的我所关心的是：</p><p>（1）要给美女客户（SqlSession）什么信息（功能和参数）。</p><p>（2）美女客服会返回什么结果（ResultSet)。</p><p>在Mybatis中的Sqlsession接口的实现类有两个，分别是DefaultSqlSession 和 SqlSessionManager。这里我们不深入讨论Executor接口以及涉及的其他类，只关心SqlSession的用法就好。</p><p>SqlSession就相当于JDBC中的Connection接口对象，我们需要保证每次调用完后能关闭它，所以正确的做法是把关闭Sqlsession接口的代码写在finally语句中保证每次都会关闭SqlSession，让连接资源归还给数据库。</p><p>伪代码如下：</p><pre><code>SqlSession sqlSession = null;try{    //打开SqlSession会话    sqlSession = sqlSessionFactory.openSession();    //some code    sqlSession.commit();}catch(Exception ex){    System.out.println(ex.getMessage());    sqlSession.rollback();}finally{    //在finally语句中确保资源被顺利关闭    if(sqlSession!=null){        sqlSession.close();    }}</code></pre><p>SqlSession的作用：</p><p>（1）获取映射器Mapper，让映射器通过<code>命名空间</code>和<code>方法名</code>找到对应的SQL，发送给数据库执行后返回结果。</p><p>（2）直接通过命名信息去执行SQL返回结果，这是ibatis版本留下的方式。在SqlSession层可以直接通过update、insert、select、delete等方法，带上SQl的id来操作在XML中配置好的SQL，从而完成我们的工作；与此同时它也支持事务，通过commit、rollback方法提交事务或者回滚事务。</p><hr><h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><p>映射器是由 <code>java接口</code> 和 <code>XML文件</code>（或注解）共同组成的，它的作用如下：</p><p>（1）定义参数类型<br>（2）描述缓存<br>（3）描述SQL语句<br>（4）定义查询结果和POJO的映射关系。</p><p>一个映射器的实现方式有两种：<code>xml方式</code>，<code>注解方式</code>。</p><p>在mybatis-config.xml中，描述了一个xml文件，在<mapper></mapper>标签中，就是用来配置映射器的xml文件，通过它来生成Mapper文件。</p><p>注解的方式是不用写mapper的xml文件的，只需要在Java的接口方法上面写相应的注解信息即可。</p><p>两种方式，根据自己的项目来选择，xml更加灵活，便于排除，写动态sql语句，可读性好，注解只适合于书写简单的sql语句，方便开发简单的项目，不方便维护。</p><p>（1）xml的方式<br>在resources下，创建com.liuzhuo.mapper包，并在其中创建userMapper.xml文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.dao.UserMapper&quot;&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;long&quot; resultType=&quot;user&quot;&gt;        select userId,user_name as userName,user_age as userAge from user where userId = #{id}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p><img src="/images/mybatis/QQ截图20190309115557.png"></p><p>使用XML文件配置是Mybatis实现Mapper的首选方式。它是由一个java接口和一个XML文件组成的。</p><p>java接口文件如下：</p><pre><code>public interface UserMapper {    User selectById(Long id);}</code></pre><p>xml中的namespace必须为java接口类的全限定名，java接口中的方法名必须是xml中的id名，这两则必须一致！！！</p><p>我们看到<code>&lt;select&gt;</code>标签中，有一个resultType=user，这是因为我们在mybatis-config.xml中配置了别名，否则就需要填写User类的全限定名了(com.liuzhuo.entity.User)。</p><p>这里的User类为：</p><pre><code>public class User {    private String userId;    private Long userAge;    private String userName;    //省略了get、set、toString方法}</code></pre><p>再看看SQL语句，我们查询了user的信息，并给查询出来的列重新命名了，使用查询出来的列名和POJO对象的属性名一致了，这么Mybatis才会将从数据库中查询出来的信息，自动帮我们赋值到User对象中。如果数据库中的表的列名与POJO对象一致的话，就不需要别名了。</p><hr><h3 id="项目整体结构"><a href="#项目整体结构" class="headerlink" title="项目整体结构"></a>项目整体结构</h3><p>这个项目的整体结构如下：<br><img src="/images/mybatis/QQ截图20190309120612.png"></p><p>在java包下：</p><p>com.liuzhuo.entity:存储POJO类</p><p>com.liuzhuo.dao：存储java接口Mapper类</p><p>在resources包下：</p><p>根目录下，存放mybatis-config.xml的基本xml配置文件。</p><p>com.liuzhuo.mapper:存储mapper的xml文件。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在test下，创建com.liuzhuo.test包，并创建一个测试类：</p><pre><code>public class UserTest {    @Test    public void test01() throws IOException {        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        User user = userMapper.selectById(1L);        System.out.println(user);    }}</code></pre><p>现在完整的pom文件：</p><pre><code>    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>运行测试方法test01：<br><img src="/images/mybatis/QQ截图20190309121425.png"></p><hr><p>这里简单演示一下注解的使用</p><p>在UserMapper接口中：<br>添加新的方法</p><pre><code>public interface UserMapper {    User selectById(Long id);    @Select(&quot;select userId,user_age as useAge,user_name as userName from user where userId = #{id}&quot;)    User selectById02(Long id);}</code></pre><p>在测试类中，添加新的测试方法：</p><pre><code>    @Test    public void test04() throws IOException {        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        User user = userMapper.selectById02(1L);        System.out.println(user);    }</code></pre><p>这里我们使用：selectById02方法来执行<br><img src="/images/mybatis/QQ截图20190309122041.png"></p><p>发现也能执行成功，所以xml和注解的方式都是类似的。注解还有update、insert、delete等，大家可以去官网去看看，这里就不详细讲解了。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的开发的第一天</title>
      <link href="/2019/03/08/mybatis-de-kai-fa-de-di-yi-tian/"/>
      <url>/2019/03/08/mybatis-de-kai-fa-de-di-yi-tian/</url>
      
        <content type="html"><![CDATA[<p> 这是Mybatis的开发的第一天，我将讲述原始的jdbc，与orm的区别<br><a id="more"></a></p><h3 id="jdbc的概述"><a href="#jdbc的概述" class="headerlink" title="jdbc的概述"></a>jdbc的概述</h3><p>  Java程序都是通过JDBC（Java DataBase Connectivity）连接数据库的，这样，我们就能通过SQL对数据库编程了。JDBC是由SUN公司提出的一系列规范，但是它只定义了接口规范，而具体的实现是通过各个数据库厂商来实现的，因为每个数据库都有其特殊性，这些是Java规范没有办法来确定的，所以JDBC就是一种典型的桥接模式。</p><h3 id="jdbc的使用"><a href="#jdbc的使用" class="headerlink" title="jdbc的使用"></a>jdbc的使用</h3><p>  传统的jdbc编程的使用给我们带来了连接数据库的功能，但是也引起了巨大的问题。</p><p>  传统的代码如下：<br>  我使用的的编辑器是：idea<br>  打开idea，创建java普通项目即可：</p><p>  <img src="/images/mybatis/QQ截图20190308135115.png"></p><p>  创建com.liuzhuo.jdbc包<br>  然后，创建jdbcTempate类<br>  然后编写jdbc的固定代码：</p><p>  <code>1.创建connection：连接器</code></p><pre><code>     private Connection getConnection() {        Connection connection = null;        try {            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            String url = &quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;useSSL=true&quot;;            String user = &quot;root&quot;;            String password = &quot;123456&quot;;            connection = DriverManager.getConnection(url, user, password);        } catch (ClassNotFoundException | SQLException e) {            e.printStackTrace();            return null;        }        return connection;    }</code></pre><p> <code>2.编写获取用户的SQL代码</code>：</p><pre><code>     public User getUser(Long id) {        Connection connection = getConnection();        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        try {            preparedStatement = connection.prepareStatement(&quot;SELECT userId,user_age,user_name from user WHERE userId=?&quot;);            preparedStatement.setLong(1, id);            resultSet = preparedStatement.executeQuery();            while (resultSet.next()) {                String userId = resultSet.getString(&quot;userId&quot;);                long user_age = resultSet.getLong(&quot;user_age&quot;);                String user_name = resultSet.getString(&quot;user_name&quot;);                User user = new User();                user.setUserId(userId);                user.setUserAge(user_age);                user.setUserName(user_name);                return user;            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            this.close(resultSet, preparedStatement, connection);        }        return null;    }</code></pre><p> <code>3.编写关闭资源的方法：</code></p><pre><code>     private void close(ResultSet resultSet, PreparedStatement preparedStatement, Connection connection) {        try {            if (resultSet != null &amp;&amp; !resultSet.isClosed()) {                resultSet.close();            }            if (preparedStatement != null &amp;&amp; !preparedStatement.isClosed()) {                preparedStatement.close();            }            if (connection != null &amp;&amp; !connection.isClosed()) {                connection.close();            }        } catch (Exception e) {            e.printStackTrace();        }    }</code></pre><p> 上面的关闭资源，我就简单的使用最大的异常来接受了，生产环境就不要这样了。</p><p> <code>4.编写主函数main：</code></p><pre><code>     public static void main(String[] args) {        JdbcExample jdbcExample = new JdbcExample();        User user = jdbcExample.getUser(1L);        System.out.println(user);    }</code></pre><hr><p> 以上成功的前提是，我们的mysql数据库中有数据呀，我的school数据库中，有user的表：<br>   <img src="/images/mybatis/QQ截图20190308142223.png"></p><p> 现在，运行我们的main函数：</p><p> 发现出现了ClassNotFound异常：</p><p> 因为项目中还必须要包含mysql-connection的jar。</p><p> 在我们的idea中，点击file：<br> <img src="/images/mybatis/QQ截图20190308142504.png" style="width: 50%"></p><p>点击：Modules，然后点击Dependencies，再点击右边的绿色的加号：<br><img src="/images/mybatis/QQ截图20190308142758.png"></p><p>然后，在出现的选项中，选择第一项，添加jar包：</p><p>选中你的电脑中，下载的mysql-connector-java：jar包<br><img src="/images/mybatis/QQ截图20190308142926.png"></p><p>点击确定后，在我们的项目中，会在External Libraries中出现相应的jar包：<br><img src="/images/mybatis/QQ截图20190308143135.png" style="width: 50%"></p><p>再次运行main函数：<br><img src="/images/mybatis/QQ截图20190308143240.png"></p><p>输出了我们的数据库中的数据！！！</p><h3 id="jdbc的总结"><a href="#jdbc的总结" class="headerlink" title="jdbc的总结"></a>jdbc的总结</h3><ol><li><p>使用jdbc编程需要连接数据库，注册驱动和数据库信息</p></li><li><p>操作Connection，打开Statement对象</p></li><li><p>通过Statement执行SQL，返回结果到ResultSet对象。</p></li><li><p>使用ResultSet对象读取数据，然后通过代码转化为POJO对象。</p></li><li><p>关闭数据库相关的资源。</p></li></ol><hr><h3 id="ORM模型"><a href="#ORM模型" class="headerlink" title="ORM模型"></a>ORM模型</h3><p>由于jdbc存在缺陷，在实际工作中我们很少使用JDBC来进行编程，于是提出了对象关系映射（Object Relational Mapping，简称ORM）</p><p>ORM模型就是 将数据库中的表 和 简单的java对象（Plain Ordinary Java Object）进行关系映射。它主要解决了数据库中数据和POJO对象的相互映射。我们通过这层映射关系就可以简单迅速地把数据库表的数据转化为POJO对象，以便程序员更加容易理解和应用java程序。</p><p>ORM映射模型，有Hibernate和Mybatis等，这里，我主要讲解Mybatis的映射，至于HIbernate的使用，大家可以自行的去学习，类似。只不过Hibernate是全表映射，Mybatis是半自动映射的框架。</p><p>Mybatis所需要提供的映射文件包含以下三个部分：</p><ol><li><p>POJO</p></li><li><p>映射规则</p></li><li><p>SQL</p></li></ol><p>在Mybatis中，你需要自己编写SQL语句，虽然比Hibernate配置得多，但是Mybatis可以配置动态的SQL，这解决了Hibernate的表名根据时间变化，不同的条件下列名不一样的问题。同时你也可以优化SQL语句，通过配置决定你的SQl映射规则，也能支持存储过程，所以对于一些复杂的和需要优化性能的SQL的查询它更加方便，Mybatis几乎能做到JDBC所能做到的所有事情。Mybatis具有自动映射功能。换句话说，在注意一些规则的基础上，Mybatis可以给我们自动完成自动映射，而无需写任何的映射规则，这大大提高了开发效率和灵活性。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的父子类的执行顺序</title>
      <link href="/2019/01/22/java-zhong-de-fu-zi-lei-de-zhi-xing-shun-xu/"/>
      <url>/2019/01/22/java-zhong-de-fu-zi-lei-de-zhi-xing-shun-xu/</url>
      
        <content type="html"><![CDATA[<p>Java中的父子类执行顺序<br><a id="more"></a></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>类的加载顺序。</p><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</p><p>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</p><p>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )</p><p>(4) 父类构造函数</p><p>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )</p><p>(6) 子类构造函数</p><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>根据以上结论，运行下面代码，输出的结果是：</p><pre><code>class A {   public A() {//构造函数       System.out.println(&quot;class A&quot;);   }   { //代码块       System.out.println(&quot;I&#39;m A class&quot;);    }   static { //静态代码块       System.out.println(&quot;class A static&quot;);    }}public class B extends A {   public B() {//构造函数       System.out.println(&quot;class B&quot;);   }   { //代码块       System.out.println(&quot;I&#39;m B class&quot;);    }   static { System.out.println(&quot;class B static&quot;);    }   //静态代码块   public static void main(String[] args) {        new B();   }}</code></pre><p>答案：</p><pre><code>class A static class B static I&#39;m A class class AI&#39;m B class class B</code></pre><hr><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>那，父类中的既有静态属性，又有静态代码块的话，谁先执行呢？</p><pre><code>class Print{   Print(){       System.out.println(&quot;haha&quot;);   }}public class Cats {   static {       System.out.println(&quot;static Casts&quot;);   }   static Print test1 = new Print();}class qiaoGeli extends Cats{   public static void main(String [] args)   {       qiaoGeli t1 = new qiaoGeli();   }}</code></pre><p>以上输出：</p><pre><code>static Castshaha</code></pre><p>换一下静态变量和静态代码块的执行顺序。</p><pre><code>class Print{   Print(){       System.out.println(&quot;haha&quot;);   }}public class Cats {   static Print test1 = new Print();   static {       System.out.println(&quot;static Casts&quot;);   }}class qiaoGeli extends Cats{   public static void main(String [] args)   {       qiaoGeli t1 = new qiaoGeli();   }}</code></pre><p>以上输出：</p><pre><code>hahastatic Casts</code></pre><p><strong>结论：</strong>静态代码块和静态属性的执行顺序，取决于它两在代码中的位置。</p><h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><p>那，类中非静态属性与非静态代码块的顺序呢？</p><pre><code>class Print{   Print(){       System.out.println(&quot;haha&quot;);   }}public class Cats {   Print test = new Print();      //非静态属性   Cats(){                        //构造函数       System.out.println(&quot;I&#39;m qiaoGeLi&quot;);   }   {                              //非静态代码块       System.out.println(&quot;I&#39;m xiaoMeng&quot;);   }   public static void main(String [] args)   {       Cats cat = new Cats();   }}</code></pre><p>以上输出：</p><pre><code>haha              //非静态属性I&#39;m xiaoMeng      //非静态代码块I&#39;m qiaoGeLi      //构造方法</code></pre><p>那是不是：非静态属性 &gt; 非静态代码块 &gt; 构造器 呢 ？</p><font color="red">不是哦!</font><h3 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h3><pre><code>class Print{   Print(){       System.out.println(&quot;haha&quot;);   }}public class Cats {   Cats(){       System.out.println(&quot;I&#39;m qiaoGeLi&quot;);   }   {       System.out.println(&quot;I&#39;m xiaoMeng&quot;);   }   Print test = new Print();   public static void main(String [] args)   {       Cats cat = new Cats();   }}</code></pre><p>以上输出结果：</p><pre><code>I&#39;m xiaoMenghahaI&#39;m qiaoGeLi</code></pre><font color="red">故意将构造器放在最上面，但是它还是最后执行的，可是非静态属性与非静态代码块的执行顺序变了。</font><p><strong>结论：</strong>非静态属性和非静态代码块谁在前谁先执行，构造器在最后执行！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>类的执行顺序。</p><p>(1)父类静态变量 和 静态代码块（先声明的先执行）;</p><p>(2)子类静态变量 和 静态代码块（先声明的先执行）;</p><p>(3)父类的非静态属性（变量）和 非静态代码块（先声明的先执行）；</p><p>(4)父类构造函数</p><p>(5)子类的非静态属性（变量）和 非静态代码块（先声明的先执行）；</p><p>(6)子类构造函数</p>]]></content>
      
      
      <categories>
          
          <category> 父子类 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 父子类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的启动分析(四)webapp</title>
      <link href="/2019/01/18/tomcat-de-qi-dong-fen-xi-si-webapp/"/>
      <url>/2019/01/18/tomcat-de-qi-dong-fen-xi-si-webapp/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章中我们分析了 Service、Engine、Host、Pipeline、Valve 组件的启动逻辑，在 HostConfig 中会实例化 StandardContext，并启动 Context 容器，完成 webapp 应用程序的启动，这一块是最贴近我们开发的应用程序。在这一篇文章中，我们将要分析 tomcat 是如何解析并初始化应用程序定义的 Servlet、Filter、Listener 等<br><a id="more"></a></p><p>首先我们思考几个问题： </p><p>1.tomcat 如何支持 servlet3.0 的注解编程，比如对 javax.servlet.annotation.WebListener 注解的支持？</p><pre><code>如果 tomcat 利用 ClassLoader 加载 webapp 下面所有的 class，从而分析 Class 对象的注解，这样子肯定会导致很多问题，比如 MetaSpace 出现内存溢出，而且加载了很多不想干的类，我们知道 jvm 卸载 class 的条件非常苛刻，这显然是不可取的。因此，tomcat 开发了字节码解析的工具类，位于  org.apache.tomcat.util.bcel，bcel 即 ：Byte Code Engineering Library，专门用于解析 class 字节码，而不是像我们前面猜测的那样，把类加载到 jvm 中.</code></pre><p>2.假如 webapp 目录有多个应用，使用的开源框架的 jar 版本不尽一致，tomcat 是怎样避免出现类冲突？</p><pre><code>不同的 webapp 使用不同的 ClassLoader 实例加载 class，因此 webapp 内部加载的 class 是不同的，自然不会出现类冲突，当然这里要排除 ClassLoader 的 parent 能够加载的 class。关于 ClassLoader 这一块，后续会专门写一篇博客进行分析</code></pre><h3 id="Context-容器"><a href="#Context-容器" class="headerlink" title="Context 容器"></a>Context 容器</h3><p>首先，我们来看下StandardContext重要的几个属性，包括了我们熟悉的 ServletContext、servlet容器相关的Listener(比如 SessionListener 和 ContextListener)、FilterConfig</p><pre><code>protected ApplicationContext context：即ServletContext上下文private InstanceManager instanceManager：根据 class 实例化对象，比如 Listener、Filter、Servlet 实例对象private List&lt;Object&gt; applicationEventListenersList：SessionListener、ContextListner 等集合private HashMap&lt;String, ApplicationFilterConfig&gt; filterConfigs：filer 名字与 FilterConfig 的映射关系private Loader loader：用于加载class等资源private final ReadWriteLock loaderLock：用于对loader的读写操作protected Manager manager：Session管理器private final ReadWriteLock managerLock：用于对manager的读写操作private HashMap&lt;String, String&gt; servletMappings：url与Servlet名字的映射关系private HashMap&lt;Integer, ErrorPage&gt; statusPages：错误码与错误页的映射private JarScanner jarScanner：用于扫描jar包资源private CookieProcessor cookieProcessor：cookies处理器，默认使用Rfc6265CookieProcessor</code></pre><p>StandardContext 和其他 Container 一样，也是重写了 startInternal 方法。由于涉及到 webapp 的启动流程，需要很多准备工作，比如使用 WebResourceRoot 加载资源文件、利用 Loader 加载 class、使用 JarScanner 扫描 jar 包，等等。因此StandardContext 的启动逻辑比较复杂，这里描述下几个重要的步骤：</p><ol><li><p>创建工作目录，比如$CATALINA_HOME\work\Catalina\localhost\examples；实例化 ContextServlet，应用程序拿到的是 ApplicationContext的外观模式 </p></li><li><p>实例化 WebResourceRoot，默认实现类是 StandardRoot，用于读取 webapp 的文件资源 </p></li><li><p>实例化 Loader 对象，Loader 是 tomcat 对于 ClassLoader 的封装，用于支持在运行期间热加载 class </p></li><li><p>发出 CONFIGURE_START_EVENT 事件，ContextConfig 会处理该事件，主要目的是从 webapp 中读取 servlet 相关的 Listener、Servlet、Filter 等 </p></li><li><p>实例化 Sesssion 管理器，默认使用 StandardManager </p></li><li><p>调用 listenerStart，实例化 servlet 相关的各种 Listener，并且调用ServletContextListener </p></li><li><p>处理 Filter </p></li><li><p>加载 Servlet</p></li></ol><p>下面，将分析下几个重要的步骤</p><h4 id="触发-CONFIGURE-START-EVENT-事件"><a href="#触发-CONFIGURE-START-EVENT-事件" class="headerlink" title="触发 CONFIGURE_START_EVENT 事件"></a>触发 CONFIGURE_START_EVENT 事件</h4><p>ContextConfig 它是一个 LifycycleListener，它在 Context 启动过程中是承担了一个非常重要的角色。StandardContext 会发出 CONFIGURE_START_EVENT 事件，而 ContextConfig 会处理该事件，主要目的是通过 web.xml 或者 Servlet3.0 的注解配置，读取 Servlet 相关的配置信息，比如 Filter、Servlet、Listener 等，其核心逻辑在 ContextConfig#webConfig() 方法中实现。下面，我们对 ContextConfig 进行详细分析</p><ol><li>首先，是通过 WebXmlParser 对 web.xml 进行解析，如果存在 web.xml 文件，则会把文件中定义的 Servlet、Filter、Listener 注册到 WebXml 实例中</li></ol><pre><code>WebXmlParser webXmlParser = new WebXmlParser(context.getXmlNamespaceAware(),            context.getXmlValidation(), context.getXmlBlockExternal());Set&lt;WebXml&gt; defaults = new HashSet&lt;&gt;();defaults.add(getDefaultWebXmlFragment(webXmlParser));// 创建 WebXml实例，并解析 web.xml 文件WebXml webXml = createWebXml();InputSource contextWebXml = getContextWebXmlSource();if (!webXmlParser.parseWebXml(contextWebXml, webXml, false)) {    ok = false;}</code></pre><p>1、 接下来，会处理 javax.servlet.ServletContainerInitializer，把对象实例保存到 ContextConfig 的 Map 中，待 Wrapper 子容器添加到 StandardContext 子容器中之后，再把 ServletContainerInitializer 加入 ServletContext 中。ServletContainerInitializer 是 servlet3.0 提供的一个 SPI，可以通过 HandlesTypes 筛选出相关的 servlet 类，并可以对 ServletContext 进行额外处理，下面是一个自定义的 ServletContainerInitializer，实现了 ServletContainerInitializer 接口，和 jdk 提供的其它 SPI 一样，需要在 META-INF/services/javax.servlet.ServletContainerInitializer 文件中指定该类名 net.dwade.tomcat.CustomServletContainerInitializer</p><pre><code>@HandlesTypes( Filter.class )public class CustomServletContainerInitializer implements ServletContainerInitializer {    @Override    public void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException {        for ( Class&lt;?&gt; type : c ) {            System.out.println( type.getName() );        }    }}</code></pre><p>2、如果没有 web.xml 文件，tomcat 会先扫描 WEB-INF/classes 目录下面的 class 文件，然后扫描 WEB-INF/lib 目录下面的 jar 包，解析字节码读取 servlet 相关的注解配置类，这里不得不吐槽下 serlvet3.0 注解，对 servlet 注解的处理相当重量级。tomcat 不会预先把该 class 加载到 jvm 中，而是通过解析字节码文件，获取对应类的一些信息，比如注解、实现的接口等，核心代码如下所示：</p><pre><code>protected void processAnnotationsStream(InputStream is, WebXml fragment,            boolean handlesTypesOnly, Map&lt;String,JavaClassCacheEntry&gt; javaClassCache)            throws ClassFormatException, IOException {    // is 即 class 字节码文件的 IO 流    ClassParser parser = new ClassParser(is);    // 使用 JavaClass 封装 class 相关的信息    JavaClass clazz = parser.parse();    checkHandlesTypes(clazz, javaClassCache);    if (handlesTypesOnly) {        return;    }    AnnotationEntry[] annotationsEntries = clazz.getAnnotationEntries();    if (annotationsEntries != null) {        String className = clazz.getClassName();        for (AnnotationEntry ae : annotationsEntries) {            String type = ae.getAnnotationType();            if (&quot;Ljavax/servlet/annotation/WebServlet;&quot;.equals(type)) {                processAnnotationWebServlet(className, ae, fragment);            }else if (&quot;Ljavax/servlet/annotation/WebFilter;&quot;.equals(type)) {                processAnnotationWebFilter(className, ae, fragment);            }else if (&quot;Ljavax/servlet/annotation/WebListener;&quot;.equals(type)) {                fragment.addListener(className);            } else {                // Unknown annotation - ignore            }        }    }}</code></pre><p>tomcat 使用自己的工具类 ClassParser 通过对字节码文件进行解析，获取其注解，并把 WebServlet、WebFilter、WebListener 注解的类添加到 WebXml 实例中，统一由它对 ServletContext 进行参数配置。tomcat 对字节码的处理是由<br>org.apache.tomcat.util.bcel 包完成的，bcel 即 Byte Code Engineering Library，其实现比较繁锁，需要对字节码结构有一定的了解，感兴趣的童鞋可以研究下底层实现。</p><p>3、配置信息读取完毕之后，会把 WebXml 装载的配置赋值给 ServletContext，在这个时候，ContextConfig 会往 StardardContext 容器中添加子容器（即 Wrapper 容器），部分代码如下所示：</p><pre><code>private void configureContext(WebXml webxml) {    // 设置 Filter 定义    for (FilterDef filter : webxml.getFilters().values()) {        if (filter.getAsyncSupported() == null) {            filter.setAsyncSupported(&quot;false&quot;);        }        context.addFilterDef(filter);    }    // 设置 FilterMapping，即 Filter 的 URL 映射    for (FilterMap filterMap : webxml.getFilterMappings()) {        context.addFilterMap(filterMap);    }    // 往 Context 中添加子容器 Wrapper，即 Servlet    for (ServletDef servlet : webxml.getServlets().values()) {        Wrapper wrapper = context.createWrapper();        // 省略若干代码。。。        wrapper.setOverridable(servlet.isOverridable());        context.addChild(wrapper);    }}</code></pre><p>4、 tomcat 还会加载 WEB-INF/classes/META-INF/resources/、WEB-INF/lib/xxx.jar/META-INF/resources/ 的静态资源，这一块的作用暂时不清楚，关键代码如下所示：</p><pre><code>// fragments 包括了 WEB-INF/classes、WEB-INF/lib/xxx.jarprotected void processResourceJARs(Set&lt;WebXml&gt; fragments) {    for (WebXml fragment : fragments) {        URL url = fragment.getURL();        if (&quot;jar&quot;.equals(url.getProtocol()) || url.toString().endsWith(&quot;.jar&quot;)) {            try (Jar jar = JarFactory.newInstance(url)) {                jar.nextEntry();                String entryName = jar.getEntryName();                while (entryName != null) {                    if (entryName.startsWith(&quot;META-INF/resources/&quot;)) {                        context.getResources().createWebResourceSet(                                WebResourceRoot.ResourceSetType.RESOURCE_JAR,                                &quot;/&quot;, url, &quot;/META-INF/resources&quot;);                        break;                    }                    jar.nextEntry();                    entryName = jar.getEntryName();                }            }        } else if (&quot;file&quot;.equals(url.getProtocol())) {            File file = new File(url.toURI());            File resources = new File(file, &quot;META-INF/resources/&quot;);            if (resources.isDirectory()) {                context.getResources().createWebResourceSet(                        WebResourceRoot.ResourceSetType.RESOURCE_JAR,                        &quot;/&quot;, resources.getAbsolutePath(), null, &quot;/&quot;);            }        }    }}</code></pre><h4 id="启动-Wrapper-容器"><a href="#启动-Wrapper-容器" class="headerlink" title="启动 Wrapper 容器"></a>启动 Wrapper 容器</h4><p>ContextConfig 把 Wrapper 子容器添加到 StandardContext 容器中之后，便会挨个启动 Wrapper 子容器。但是实际上，由于 StandardContext 至 ContainerBase，在添加子容器的时候，便会调用 start 方法启动 Wrapper，关于 Wrapper 的启动在下文进行详细分析</p><pre><code>for (Container child : findChildren()) {    if (!child.getState().isAvailable()) {        child.start();    }}</code></pre><h4 id="调用-ServletContainerInitializer"><a href="#调用-ServletContainerInitializer" class="headerlink" title="调用 ServletContainerInitializer"></a>调用 ServletContainerInitializer</h4><p>在初始化 Servlet、Listener 之前，便会先调用 ServletContainerInitializer，进行额外的初始化处理。注意：ServletContainerInitializer 需要的是 Class 对象，而不是具体的实例对象，这个时候 servlet 相关的 Listener 并没有被实例化，因此不会产生矛盾</p><pre><code>// 指定 ServletContext 的相关参数mergeParameters();// 调用 ServletContainerInitializer#onStartup()for (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :    initializers.entrySet()) {    try {        entry.getKey().onStartup(entry.getValue(),                getServletContext());    } catch (ServletException e) {        log.error(sm.getString(&quot;standardContext.sciFail&quot;), e);        ok = false;        break;    }}</code></pre><h4 id="启动-Servlet-相关的-Listener"><a href="#启动-Servlet-相关的-Listener" class="headerlink" title="启动 Servlet 相关的 Listener"></a>启动 Servlet 相关的 Listener</h4><p>WebConfig 加载 Listener 时，只是保存了 className，实例化动作由 StandardContext 触发。前面在介绍 StandardContext 的时候提到了 InstanceManager，创建实例的逻辑由 InstanceManager 完成。</p><p>Listener 监听器分为 Event、Lifecycle 监听器，WebConfig 在加载 Listener 的时候是不会区分的，实例化之后才会分开存储。在完成 Listener 实例化之后，tomcat 容器便启动 OK 了。此时，tomcat 需要通知应用程序定义的 ServletContextListener，方便应用程序完成自己的初始化逻辑，它会遍历 ServletContextListener 实例，并调用其 contextInitialized 方法，比如 spring 的 ContextLoaderListener</p><p>有以下 Event 监听器，主要是针对事件通知：</p><ul><li><p>ServletContextAttributeListener</p></li><li><p>ServletRequestAttributeListener</p></li><li><p>ServletRequestListener </p></li><li><p>HttpSessionIdListener </p></li></ul><p>*　HttpSessionAttributeListener</p><p>有以下两种 Lifecycle 监听器，主要是针对 ServletContext、HttpSession 的生命周期管理，比如创建、销毁等 </p><ul><li><p>ServletContextListener</p></li><li><p>HttpSessionListener</p></li></ul><h3 id="初始化-Filter"><a href="#初始化-Filter" class="headerlink" title="初始化 Filter"></a>初始化 Filter</h3><p>ContextConfig 在处理 CONFIGURE_START_EVENT 事件的时候，会使用 FilterDef 保存 Filter 信息。而 StandardContext 会把 FilterDef 转化成 ApplicationFilterConfig，在 ApplicationFilterConfig 构造方法中完成 Filter 的实例化，并且调用 Filter 接口的 init 方法，完成 Filter 的初始化。ApplicationFilterConfig 是 javax.servlet.FilterConfig<br>接口的实现类。</p><pre><code>public boolean filterStart() {    boolean ok = true;    synchronized (filterConfigs) {        filterConfigs.clear();        for (Entry&lt;String,FilterDef&gt; entry : filterDefs.entrySet()) {            String name = entry.getKey();            try {                // 在构造方法中完成 Filter 的实例化，并且调用 Filter 接口的 init 方法，完成 Filter 的初始化                ApplicationFilterConfig filterConfig =                        new ApplicationFilterConfig(this, entry.getValue());                filterConfigs.put(name, filterConfig);            } catch (Throwable t) {                // 省略 logger 处理                ok = false;            }        }    }    return ok;}</code></pre><h3 id="处理-Wrapper-容器"><a href="#处理-Wrapper-容器" class="headerlink" title="处理 Wrapper 容器"></a>处理 Wrapper 容器</h3><p>Servlet 对应 tomcat 的 Wrapper 容器，完成 Filter 初始化之后便会对 Wrapper 容器进行处理，如果 Servlet 的 loadOnStartup &gt;= 0，便会在这一阶段完成 Servlet 的加载，并且值越小越先被加载，否则在接受到请求的时候才会加载 Servlet。</p><p>加载过程，主要是完成 Servlet 的实例化，并且调用 Servlet 接口的 init 方法，具体的逻辑将在下文进行详细分析</p><pre><code>// StandardWrapper 实例化并且启动 Servlet，由于 Servlet 存在 loadOnStartup 属性// 因此使用了 TreeMap，根据 loadOnStartup 值 对 Wrapper 容器进行排序，然后依次启动 Servletif (ok) {    if (!loadOnStartup(findChildren())){        log.error(sm.getString(&quot;standardContext.servletFail&quot;));        ok = false;    }}</code></pre><p>loadOnStartup 方法使用 TreeMap 对 Wrapper 进行排序，loadOnStartup 值越小越靠前，值相同的 Wrapper 放在同一个 List 中，代码如下所示：</p><pre><code>public boolean loadOnStartup(Container children[]) {    // 使用 TreeMap 对 Wrapper 进行排序，loadOnStartup 值越小越靠前，值相同的 Wrapper 放在同一个 List 中    TreeMap&lt;Integer, ArrayList&lt;Wrapper&gt;&gt; map = new TreeMap&lt;&gt;();    for (int i = 0; i &lt; children.length; i++) {        Wrapper wrapper = (Wrapper) children[i];        int loadOnStartup = wrapper.getLoadOnStartup();        if (loadOnStartup &lt; 0)            continue;        Integer key = Integer.valueOf(loadOnStartup);        ArrayList&lt;Wrapper&gt; list = map.get(key);        if (list == null) {            list = new ArrayList&lt;&gt;();            map.put(key, list);        }        list.add(wrapper);    }    // 根据 loadOnStartup 值有序加载 Wrapper 容器    for (ArrayList&lt;Wrapper&gt; list : map.values()) {        for (Wrapper wrapper : list) {            try {                wrapper.load();            } catch (ServletException e) {                if(getComputedFailCtxIfServletStartFails()) {                    return false;                }            }        }    }    return true;}</code></pre><h3 id="Wrapper-容器"><a href="#Wrapper-容器" class="headerlink" title="Wrapper 容器"></a>Wrapper 容器</h3><p>Wrapper 容器是 tomcat 所有容器中最底层子容器，它没有子容器，并且父容器是 Context，对这一块不了解的童鞋请移步前面的博客《tomcat框架设计》。默认实现是 StandardWrapper，我们先来看看类定义，它继承至 ContainBase，实现了 servlet 的 ServletConfig 接口，以及 tomcat 的 Wrapper 接口，说明 StandardWrapper 不仅仅是一个 Wrapper 容器实现，还是 ServletConfig 实现，部分代码如下所示：</p><pre><code>public class StandardWrapper extends ContainerBase    implements ServletConfig, Wrapper, NotificationEmitter {    // Wrapper 的门面模式，调用 Servlet 的 init 方法传入的是该对象    protected final StandardWrapperFacade facade = new StandardWrapperFacade(this);        protected volatile Servlet instance = null; // Servlet 实例对象    protected int loadOnStartup = -1;   // 默认值为 -1，不立即启动 Servlet    protected String servletClass = null;    public StandardWrapper() {        super();        swValve=new StandardWrapperValve();        pipeline.setBasic(swValve);        broadcaster = new NotificationBroadcasterSupport();    }}</code></pre><p>由前面对 Context 的分析可知，StandardContext 在启动的时候会发出 CONFIGURE_START_EVENT 事件，ContextConfig 会处理该事件，通过解析 web.xml 或者读取注解信息获取 Wrapper 子容器，并且会添加到 Context 容器中。由于 StandardContext 继承至 ContainerBase，在调用 addChild 的时候默认会启动 child 容器(即 Wrapper)，我们来看看 StandardWrapper 的启动逻辑。</p><h4 id="启动-Wrapper-容器-1"><a href="#启动-Wrapper-容器-1" class="headerlink" title="启动 Wrapper 容器"></a>启动 Wrapper 容器</h4><p>StandardWrapper 没有子容器，启动逻辑相对比较简单清晰，它重写了 startInternal 方法，主要是完成了 jmx 的事件通知，先后向 jmx 发出 starting、running 事件，代码如下所示：</p><pre><code>protected synchronized void startInternal() throws LifecycleException {    // 发出 j2ee.state.starting 事件通知    if (this.getObjectName() != null) {        Notification notification =            new Notification(&quot;j2ee.state.starting&quot;, this.getObjectName(), sequenceNumber++);        broadcaster.sendNotification(notification);    }    // ConainerBase 的启动逻辑    super.startInternal();    setAvailable(0L);    // 发出 j2ee.state.running 事件通知    if (this.getObjectName() != null) {        Notification notification =            new Notification(&quot;j2ee.state.running&quot;, this.getObjectName(), sequenceNumber++);        broadcaster.sendNotification(notification);    }}</code></pre><h4 id="加载-Wrapper"><a href="#加载-Wrapper" class="headerlink" title="加载 Wrapper"></a>加载 Wrapper</h4><p>由前面对 Context 容器的分析可知，Context 完成 Filter 初始化之后，如果 loadOnStartup &gt;= 0 便会调用 load 方法加载 Wrapper 容器。StandardWrapper 使用 InstanceManager 实例化 Servlet，并且调用 Servlet 的 init 方法进行初始化，传入的 ServletConfig 是 StandardWrapperFacade 对象</p><pre><code>public synchronized void load() throws ServletException {    // 实例化 Servlet，并且调用 init 方法完成初始化    instance = loadServlet();    if (!instanceInitialized) {        initServlet(instance);    }    if (isJspServlet) {        // 处理 jsp Servlet    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>tomcat 实现了 javax.servlet.ServletContext 接口，在 Context 启动的时候会实例化该对象。由 Context 容器通过 web.xml 或者 扫描 class 字节码读取 servlet3.0 的注解配置，从而加载 webapp 定义的 Listener、Servlet、Filter 等 servlet 组件，但是并不会立即实例化对象。</p><p>全部加载完毕之后，依次对 Listener、Filter、Servlet 进行实例化、并且调用其初始化方法，比如 ServletContextListener#contextInitialized()、Flter#init() 等。</p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的启动分析(三)Catalina启动</title>
      <link href="/2019/01/18/tomcat-de-qi-dong-fen-xi-san-catalina-qi-dong/"/>
      <url>/2019/01/18/tomcat-de-qi-dong-fen-xi-san-catalina-qi-dong/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中，我们分析了tomcat的初始化过程，是由Bootstrap反射调用Catalina的load方法完成tomcat的初始化，包括server.xml的解析、实例化各大组件、初始化组件等逻辑。那么tomcat又是如何启动webapp应用，又是如何加载应用程序的ServletContextListener，以及Servlet呢？我们将在这篇文章进行分析。<br><a id="more"></a></p><p>我们先来看下整体的启动逻辑，tomcat由上往下，挨个启动各个组件： </p><p><img src="/images/QQ截图20190118133508.png"></p><p>针对如此复杂的组件关系，tomcat 又是如何将各个组件串联起来，实现统一的生命周期管控呢？在这篇文章中，我们将分析 Service、Engine、Host、Pipeline、Valve 组件的启动逻辑，进一步理解tomcat的架构设计</p><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>启动过程和初始化一样，由Bootstrap反射调用Catalina的 start 方法</p><pre><code>public void start() throws Exception {    if( catalinaDaemon==null ) init();    Method method = catalinaDaemon.getClass().getMethod(&quot;start&quot;, (Class [] )null);    method.invoke(catalinaDaemon, (Object [])null);}</code></pre><h3 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h3><p>主要分为以下三个步骤，其核心逻辑在于Server组件： </p><ol><li><p>调用Server的start方法，启动Server组件 </p></li><li><p>注册jvm关闭的勾子程序，用于安全地关闭Server组件，以及其它组件</p></li><li><p>开启shutdown端口的监听并阻塞，用于监听关闭指令</p></li></ol><pre><code>public void start() {    // 省略若干代码......    // Start the new server    try {        getServer().start();    } catch (LifecycleException e) {        // 省略......        return;    }    // 注册勾子，用于安全关闭tomcat    if (useShutdownHook) {        if (shutdownHook == null) {            shutdownHook = new CatalinaShutdownHook();        }        Runtime.getRuntime().addShutdownHook(shutdownHook);    }    // Bootstrap中会设置await为true，其目的在于让tomcat在shutdown端口阻塞监听关闭命令    if (await) {        await();        stop();    }}</code></pre><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>在前面的Lifecycle文章中，我们介绍了StandardServer重写了startInternal方法，完成自己的逻辑，如果对tomcat的Lifecycle还不熟悉的童鞋，先学习下Lifecycle，<font color="red">《Tomcat8源码分析系列-启动分析(一) Lifecycle》</font></p><p>StandardServer的代码如下所示：</p><pre><code>protected void startInternal() throws LifecycleException {    fireLifecycleEvent(CONFIGURE_START_EVENT, null);    setState(LifecycleState.STARTING);    globalNamingResources.start();    // Start our defined Services    synchronized (servicesLock) {        for (int i = 0; i &lt; services.length; i++) {            services[i].start();        }    }}</code></pre><p>先是由LifecycleBase统一发出STARTING_PREP事件，StandardServer额外还会发出CONFIGURE_START_EVENT、STARTING事件，用于通知LifecycleListener在启动前做一些准备工作，比如NamingContextListener会处理CONFIGURE_START_EVENT事件，实例化tomcat相关的上下文，以及ContextResource资源</p><p>然后，启动内部的NamingResourcesImpl实例，这个类封装了各种各样的数据，比如ContextEnvironment、ContextResource、Container等等，它用于Resource资源的初始化，以及为webapp应用提供相关的数据资源，比如 JNDI 数据源(对应ContextResource)</p><p>接着，启动Service组件，这一块的逻辑将在下面进行详细分析，最后由LifecycleBase发出STARTED事件，完成start</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>StandardService的start代码如下所示： </p><ol><li><p>启动Engine，Engine的child容器都会被启动，webapp的部署会在这个步骤完成； </p></li><li><p>启动Executor，这是tomcat用Lifecycle封装的线程池，继承至java.util.concurrent.Executor以及tomcat的Lifecycle接口 </p></li><li><p>启动Connector组件，由Connector完成Endpoint的启动，这个时候意味着tomcat可以对外提供请求服务了</p></li></ol><pre><code>protected void startInternal() throws LifecycleException {    setState(LifecycleState.STARTING);    // 启动Engine    if (engine != null) {        synchronized (engine) {            engine.start();        }    }    // 启动Executor线程池    synchronized (executors) {        for (Executor executor: executors) {            executor.start();        }    }    // 启动MapperListener    mapperListener.start();    // 启动Connector    synchronized (connectorsLock) {        for (Connector connector: connectors) {            try {                // If it has already failed, don&#39;t try and start it                if (connector.getState() != LifecycleState.FAILED) {                    connector.start();                }            } catch (Exception e) {                // logger......            }        }    }}</code></pre><h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>在Server调用startInternal启动的时候，首先会调用start启动StandardEngine，而StandardEngine继承至ContainerBase，我们再来回顾下Lifecycle类图，关于Container，我们只需要关注右下角的部分即可。</p><p><img src="/images/QQ截图20190118134119.png"></p><p>StandardEngine、StandardHost、StandardContext、StandardWrapper各个容器存在父子关系，一个父容器包含多个子容器，并且一个子容器对应一个父容器。Engine是顶层父容器，它不存在父容器，关于各个组件的详细介绍，请参考《tomcat框架设计》。各个组件的包含关系如下图所示，默认情况下，StandardEngine只有一个子容器StandardHost，一个StandardContext对应一个webapp应用，而一个StandardWrapper对应一个webapp里面的一个 Servlet。</p><p><img src="/images/QQ截图20190118134247.png"></p><p>由类图可知，StandardEngine、StandardHost、StandardContext、StandardWrapper都是继承至ContainerBase，各个容器的启动，都是由父容器调用子容器的start方法，也就是说由StandardEngine启动StandardHost，再StandardHost启动StandardContext，以此类推。</p><p>由于它们都是继续至ContainerBase，当调用 start 启动Container容器时，首先会执行 ContainerBase 的 start 方法，它会寻找子容器，并且在线程池中启动子容器，StandardEngine也不例外。</p><h4 id="ContainerBase"><a href="#ContainerBase" class="headerlink" title="ContainerBase"></a>ContainerBase</h4><p>ContainerBase的startInternal方法如下所示，主要分为以下3个步骤： </p><ol><li><p>启动子容器 </p></li><li><p>启动Pipeline，并且发出STARTING事件</p></li><li><p>如果backgroundProcessorDelay参数 &gt;= 0，则开启ContainerBackgroundProcessor线程，用于调用子容器的backgroundProcess</p></li></ol><pre><code>protected synchronized void startInternal() throws LifecycleException {    // 省略若干代码......    // 把子容器的启动步骤放在线程中处理，默认情况下线程池只有一个线程处理任务队列    Container children[] = findChildren();    List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; children.length; i++) {        results.add(startStopExecutor.submit(new StartChild(children[i])));    }    // 阻塞当前线程，直到子容器start完成    boolean fail = false;    for (Future&lt;Void&gt; result : results) {        try {            result.get();        } catch (Exception e) {            log.error(sm.getString(&quot;containerBase.threadedStartFailed&quot;), e);            fail = true;        }    }    // 启用Pipeline    if (pipeline instanceof Lifecycle)        ((Lifecycle) pipeline).start();    setState(LifecycleState.STARTING);    // 开启ContainerBackgroundProcessor线程用于调用子容器的backgroundProcess方法，默认情况下backgroundProcessorDelay=-1，不会启用该线程    threadStart();}</code></pre><h4 id="启动子容器"><a href="#启动子容器" class="headerlink" title="启动子容器"></a>启动子容器</h4><p>startStopExecutor是在init阶段创建的线程池，默认情况下 coreSize = maxSize = 1，也就是说默认只有一个线程处理子容器的 start，通过调用 <font color="red">Container.setStartStopThreads(int startStopThreads) 可以改变默认值 1</font> 。</p><p>如果我们有4个webapp，希望能够尽快启动应用，我们只需要设置Host的startStopThreads值即可，如下所示。</p><pre><code>server.xml&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; startStopThreads=&quot;4&quot;&gt;  &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;         prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;         pattern=&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; /&gt;&lt;/Host&gt;</code></pre><p>ContainerBase会把StartChild任务丢给线程池处理，得到Future，并且会遍历所有的Future进行阻塞result.get()，这个操作是将异步启动转同步，子容器启动完成才会继续运行。我们再来看看submit到线程池的StartChild任务，它实现了java.util.concurrent.Callable接口，在call里面完成子容器的start动作</p><pre><code>private static class StartChild implements Callable&lt;Void&gt; {    private Container child;    public StartChild(Container child) {        this.child = child;    }    @Override    public Void call() throws LifecycleException {        child.start();        return null;    }}</code></pre><h4 id="启动Pipeline"><a href="#启动Pipeline" class="headerlink" title="启动Pipeline"></a>启动Pipeline</h4><p><strong>pipeline是什么？</strong></p><pre><code>Pipeline是管道组件，用于封装了一组有序的Valve，便于Valve顺序地传递或者处理请求</code></pre><p>Pipeline的接口定义如下，定义了 Valve 的常用操作，以及 Container 的 getter/setter 方法，它的默认实现类是org.apache.catalina.core.StandardPipeline，同时它也是一个Lifecycle组件</p><pre><code>public interface Pipeline {    public Valve getBasic();    public void setBasic(Valve valve);    public void addValve(Valve valve);    public Valve[] getValves();    public void removeValve(Valve valve);    public Valve getFirst();    public boolean isAsyncSupported();    public Container getContainer();    public void setContainer(Container container);    public void findNonAsyncValves(Set&lt;String&gt; result);}</code></pre><p><strong>Valve是什么？</strong></p><pre><code>Valve 是阀门组件，穿插在 Container 容器中，可以把它理解成请求拦截器，在 tomcat 接收到网络请求与触发 Servlet 之间执行</code></pre><p>Valve的接口如下所示，我们主要关注它的invoke方法，Request、Response分别是HttpServletRequest、HttpServletResponse的实现类</p><pre><code>public interface Valve {    public Valve getNext();    public void backgroundProcess();    public void invoke(Request request, Response response) throws IOException, ServletException;    public boolean isAsyncSupported();}</code></pre><p>我们再来看看 Pipeline 启动过程，默认使用 StandardPipeline 实现类，它也是一个Lifecycle。在容器启动的时候，StandardPipeline 会遍历 Valve 链表，如果 Valve 是 Lifecycle 的子类，则会调用其 start 方法启动 Valve 组件，代码如下:</p><pre><code>public class StandardPipeline extends LifecycleBase        implements Pipeline, Contained {    // 省略若干代码......    protected synchronized void startInternal() throws LifecycleException {        Valve current = first;        if (current == null) {            current = basic;        }        while (current != null) {            if (current instanceof Lifecycle)                ((Lifecycle) current).start();            current = current.getNext();        }        setState(LifecycleState.STARTING);    }}</code></pre><p>tomcat为我们提供了一系列的Valve :</p><ul><li><p>AccessLogValve，记录请求日志，默认会开启 </p></li><li><p>RemoteAddrValve，可以做访问控制，比如限制IP黑白名单 </p></li><li><p>RemoteIpValve，主要用于处理 X-Forwarded-For 请求头，用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段</p></li></ul><p>关于更详细的说明，请参考<a href="http://tomcat.apache.org/tomcat-8.5-doc/config/valve.html" target="_blank" rel="noopener"><font color="red">tomcat官方文档</font></a></p><h3 id="StandardHost"><a href="#StandardHost" class="headerlink" title="StandardHost"></a>StandardHost</h3><p>前面我们分析了 StandardEngine 的启动逻辑，它会启动其子容器 StandardHost，接下来我们看下 StandardHost 的 start 逻辑。其实， StandardHost 重写的 startInternal 方法主要是为了查找报告错误的 Valve 阀门</p><pre><code>protected synchronized void startInternal() throws LifecycleException {    // errorValve默认使用org.apache.catalina.valves.ErrorReportValve    String errorValve = getErrorReportValveClass();    if ((errorValve != null) &amp;&amp; (!errorValve.equals(&quot;&quot;))) {        try {            boolean found = false;            // 如果所有的阀门中已经存在这个实例，则不进行处理，否则添加到  Pipeline 中            Valve[] valves = getPipeline().getValves();            for (Valve valve : valves) {                if (errorValve.equals(valve.getClass().getName())) {                    found = true;                    break;                }            }            // 如果未找到则添加到 Pipeline 中，注意是添加到 basic valve 的前面            // 默认情况下，first valve 是 AccessLogValve，basic 是 StandardHostValve            if(!found) {                Valve valve =                    (Valve) Class.forName(errorValve).getConstructor().newInstance();                getPipeline().addValve(valve);            }        } catch (Throwable t) {            // 处理异常，省略......        }    }    // 调用父类 ContainerBase，完成统一的启动动作    super.startInternal();}</code></pre><p>StandardHost Pipeline 包含的 Valve 组件： </p><ol><li><p>basic：org.apache.catalina.core.StandardHostValve </p></li><li><p>first：org.apache.catalina.valves.AccessLogValve</p></li></ol><p>需要注意的是，在往 Pipeline 中添加 Valve 阀门时，是添加到 first 后面，basic 前面</p><p>由上面的代码可知，在 start 的时候，StandardHost 并没有做太多的处理，<strong>那么 StandardHost 又是怎么知道它有哪些 child 容器需要启动呢？</strong></p><pre><code>tomcat 在这块的逻辑处理有点特殊，使用 HostConfig 加载子容器，而这个 HostConfig 是一个 LifecycleListener，它会处理 start、stop 事件通知，并且会在线程池中启动、停止 Context 容器，接下来看下 HostConfig 是如何工作的</code></pre><h4 id="HostConfig"><a href="#HostConfig" class="headerlink" title="HostConfig"></a>HostConfig</h4><p>以下是 HostConfig 处理事件通知的代码，我们着重关注下 start 方法，这个方法里面主要是做一些应用部署的准备工作，比如过滤无效的webapp、解压war包等，而主要的逻辑在于 deployDirectories 中，它会往线程池中提交一个 DeployDirectory 任务，并且调用 Future#get() 阻塞当前线程，直到 deploy 工作完成。</p><pre><code>public void lifecycleEvent(LifecycleEvent event) {    // (省略若干代码) 判断事件是否由 Host 发出，并且为 HostConfig 设置属性    if (event.getType().equals(Lifecycle.PERIODIC_EVENT)) {        check();    } else if (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) {        beforeStart();    } else if (event.getType().equals(Lifecycle.START_EVENT)) {        start();    } else if (event.getType().equals(Lifecycle.STOP_EVENT)) {        stop();    }}public void start() {    // (省略若干代码)    if (host.getDeployOnStartup())        deployApps();}protected void deployApps() {    File appBase = host.getAppBaseFile();    File configBase = host.getConfigBaseFile();    // 过滤出 webapp 要部署应用的目录    String[] filteredAppPaths = filterAppPaths(appBase.list());    // 部署 xml 描述文件    deployDescriptors(configBase, configBase.list());    // 解压 war 包，但是这里还不会去启动应用    deployWARs(appBase, filteredAppPaths);    // 处理已经存在的目录，前面解压的 war 包不会再行处理    deployDirectories(appBase, filteredAppPaths);}···而这个 DeployDirectory 任务很简单，只是调用 `HostConfig#deployDirectory(cn, dir)````javaprivate static class DeployDirectory implements Runnable {    // (省略若干代码)    @Override    public void run() {        config.deployDirectory(cn, dir);    }}···我们再回到 HostConfig，看看 deployDirectory 的具体逻辑，分为以下几个步骤： 1. 使用 digester，或者反射实例化 StandardContext 2. 实例化 ContextConfig，并且为 Context 容器注册事件监听器，和 StandardHost 的套路一样，借助 XXXConfig 完成容器的启动、停止工作 3. 将当前 Context 实例作为子容器添加到 Host 容器中，添加子容器的逻辑在 ContainerBase 中已经实现了，如果当前 Container 的状态是 STARTING_PREP 并且 startChildren 为 true，则还会启动子容器```javaprotected void deployDirectory(ContextName cn, File dir) {    Context context = null;    File xml = new File(dir, Constants.ApplicationContextXml);    File xmlCopy = new File(host.getConfigBaseFile(), cn.getBaseName() + &quot;.xml&quot;);    // 实例化 StandardContext    if (deployThisXML &amp;&amp; xml.exists()) {        synchronized (digesterLock) {            // 省略若干异常处理的代码            context = (Context) digester.parse(xml);        }        // (省略)为 Context 设置 configFile    } else if (!deployThisXML &amp;&amp; xml.exists()) {        // 异常处理        context = new FailedContext();    } else {        context = (Context) Class.forName(contextClass).getConstructor().newInstance();    }    // 实例化 ContextConfig，作为 LifecycleListener 添加到 Context 容器中，这和 StandardHost 的套路一样，都是使用 XXXConfig    Class&lt;?&gt; clazz = Class.forName(host.getConfigClass());    LifecycleListener listener = (LifecycleListener) clazz.getConstructor().newInstance();    context.addLifecycleListener(listener);    context.setName(cn.getName());    context.setPath(cn.getPath());    context.setWebappVersion(cn.getVersion());    context.setDocBase(cn.getBaseName());    // 实例化 Context 之后，为 Host 添加子容器    host.addChild(context);}</code></pre><p>现在有两个疑问： </p><p>1.为什么要使用 HostConfig 组件启动 Context 容器呢，不可以直接在 Host 容器中直接启动吗？</p><pre><code>HostConfig 不仅仅是启动、停止 Context 容器，还封装了很多应用部署的逻辑，此外，还会对 web.xml、context.xml 文件的改动进行监听，默认情况会重新启动 Context 容器。而这个 Host 只是负责管理 Context 的生命周期，基于单一职责的原则，tomcat 利用事件通知的方式，很好地解决了藕合问题，Context 容器也是如此，它会对应一个 ContextConfig</code></pre><p>2.Context 容器又是如何启动的？</p><pre><code>前面我们也提到了，HostConfig 将当前 Context 实例作为子容器添加到 Host 容器中（调用 ContainerBase.addChild 方法 ），而 Context 的启动就是在添加的时候调用的，ContainerBase 的关键代码如下所示，Context 启动的时候会解析web.xml，以及启动 Servlet、Listener，Servlet3.0还支持注解配置，等等这一系列逻辑将在下一篇文章进行分析</code></pre><pre><code>@Overridepublic void addChild(Container child) {    if (Globals.IS_SECURITY_ENABLED) {        PrivilegedAction&lt;Void&gt; dp = new PrivilegedAddChild(child);        AccessController.doPrivileged(dp);    } else {        addChildInternal(child);    }}private void addChildInternal(Container child) {    synchronized(children) {        // 省略部分代码，避免重复添加子容器    }    try {        if ((getState().isAvailable()                || LifecycleState.STARTING_PREP.equals(getState()))                &amp;&amp; startChildren) {            // 启动添加的子容器            child.start();        }    } catch (LifecycleException e) {        throw new IllegalStateException(&quot;ContainerBase.addChild: start: &quot; + e);    } finally {        fireContainerEvent(ADD_CHILD_EVENT, child);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的启动分析(二)Catalina初始化</title>
      <link href="/2019/01/17/tomcat-de-qi-dong-fen-xi-er-catalina-chu-shi-hua/"/>
      <url>/2019/01/17/tomcat-de-qi-dong-fen-xi-er-catalina-chu-shi-hua/</url>
      
        <content type="html"><![CDATA[<p>Tomcat的启动分析：Catalina<br><a id="more"></a></p><p>Tomcat的运行是通过Bootstrap的main方法，在开发工具中，我们只需要运行Bootstrap的main方法，便可以启动tomcat进行代码调试和分析。Bootstrap是tomcat的入口，它会完成初始化ClassLoader，实例化Catalina以及load、start动作。在这一篇文章中，我们将会对tomcat初始化过程进行分析。</p><hr><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>首先实例化Bootstrap，并调用init方法对其初始化</p><pre><code>Bootstrap bootstrap = new Bootstrap();bootstrap.init();</code></pre><h4 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h4><p>首先初始化commonLoader、catalinaLoader、sharedLoader，默认情况下这三个是相同的实例，用于加载不同的资源。然后，使用反射实例化Catalina，设置其parentClassLoader为sharedLoader</p><pre><code>public void init() throws Exception {    // 初始化commonLoader、catalinaLoader、sharedLoader，关于ClassLoader的后面再单独分析    initClassLoaders();    Thread.currentThread().setContextClassLoader(catalinaLoader);    SecurityClassLoad.securityClassLoad(catalinaLoader);    // 反射方法实例化Catalina，后面初始化Catalina也用了很多反射，不知道意图是什么    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;);    Object startupInstance = startupClass.getConstructor().newInstance();    // 反射调用setParentClassLoader方法，设置其parentClassLoader为sharedLoader    String methodName = &quot;setParentClassLoader&quot;;    Class&lt;?&gt; paramTypes[] = new Class[1];    paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;);    Object paramValues[] = new Object[1];    paramValues[0] = sharedLoader;    Method method =        startupInstance.getClass().getMethod(methodName, paramTypes);    method.invoke(startupInstance, paramValues);    // 引用Catalina实例    catalinaDaemon = startupInstance;}</code></pre><h4 id="load-amp-start"><a href="#load-amp-start" class="headerlink" title="load &amp; start"></a>load &amp; start</h4><p>初始化Bootstrap之后，接下来就是<strong>加载配置，启动容器</strong>。而load、start实际上是由Bootstrap反射调用Catalina的load、start，这一部分代码将在下面的Catalina部分进行分析</p><ul><li><p>启动时，Catalina.setAwait(true)，其目的是为了让tomcat在关闭端口阻塞监听关闭命令，参考Catalina.await()方法</p></li><li><p>deamon.load(args)，实际上会去调用Catalina#load(args)方法，会去初始化一些资源，优先加载conf/server.xml，找不到再去加载server-embed.xml；此外，load方法还会初始化Server</p></li><li><p>daemon.start()，实例上是调用Catalina.start()</p></li></ul><pre><code>// daemon即Bootstrap实例daemon.setAwait(true);daemon.load(args);daemon.start();</code></pre><hr><h3 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h3><p>由前面的分析，可知Bootstrap中的load逻辑实际上是交给Catalina去处理的，下面我们对Catalina的初始化过程进行分析</p><h4 id="load-init"><a href="#load-init" class="headerlink" title="load(init)"></a>load(init)</h4><p>load阶段主要是通过读取conf/server.xml或者server-embed.xml，实例化Server、Service、Connector、Engine、Host等组件，并调用Lifecycle#init()完成初始化动作，以及发出INITIALIZING、INITIALIZED事件</p><ol><li><p>首先初始化jmx的环境变量</p></li><li><p>定义解析server.xml的配置，告诉Digester哪个xml标签应该解析成什么类，如果我们要改变server.xml的某个属性值(比如优化tomcat线程池)，直接查看对应实现类的setXXX方法即可</p></li><li><p>解析conf/server.xml或者server-embed.xml，并且实例化对应的组件并且赋值操作，比如Server、Container、Connector等等</p></li><li><p>为Server设置catalina信息，指定Catalina实例，设置catalina的home、base路径</p></li><li><p>调用StarndServer#init()方法，完成各个组件的初始化，并且由parent组件初始化child组件，一层套一层，这个设计真心牛逼！</p></li></ol><pre><code>public void load() {    initDirs();    // 初始化jmx的环境变量    initNaming();    // Create and execute our Digester    // 定义解析server.xml的配置，告诉Digester哪个xml标签应该解析成什么类    Digester digester = createStartDigester();    InputSource inputSource = null;    InputStream inputStream = null;    File file = null;    try {      // 首先尝试加载conf/server.xml，省略部分代码......      // 如果不存在conf/server.xml，则加载server-embed.xml(该xml在catalina.jar中)，省略部分代码......      // 如果还是加载不到xml，则直接return，省略部分代码......      try {          inputSource.setByteStream(inputStream);          // 把Catalina作为一个顶级实例          digester.push(this);          // 解析过程会实例化各个组件，比如Server、Container、Connector等          digester.parse(inputSource);      } catch (SAXParseException spe) {          // 处理异常......      }    } finally {        // 关闭IO流......    }    // 给Server设置catalina信息    getServer().setCatalina(this);    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());    // Stream redirection    initStreams();    // 调用Lifecycle的init阶段    try {        getServer().init();    } catch (LifecycleException e) {        // ......    }    // ......}</code></pre><p><strong>load的时序图如下所示:</strong><br><img src="/images/QQ截图20190117103649.png"></p><ul><li><p>Digester利用jdk提供的sax解析功能，将server.xml的配置解析成对应的Bean，并完成注入，比如往Server中注入Service</p></li><li><p>EngineConfig，它是一个LifecycleListener实现，用于配置Engine，但是只会处理START_EVENT和STOP_EVENT事件</p></li><li><p>Connector默认会有两种：HTTP/1.1、AJP，不同的Connector内部持有不同的CoyoteAdapter和ProtocolHandler，在Connector初始化的时候，也会对ProtocolHandler进行初始化，完成端口的监听</p></li><li><p>ProtocolHandler常用的实现有Http11NioProtocol、AjpNioProtocol，还有apr系列的Http11AprProtocol、AjpAprProtocol，apr系列只有在使用apr包的时候才会使用到</p></li><li><p>在ProtocolHandler调用init初始化的时候，还会去执行AbstractEndpoint的init方法，完成请求端口绑定、初始化NIO等操作，在tomcat7中使用JIoEndpoint阻塞IO，而tomcat8中直接移除了JIoEndpoint，具体信息请查看org.apache.tomcat.util.net这个包</p></li></ul><p>Catalina在load结束之前，会调用Server的init()完成各个组件的初始化，下面我们来分析下各个组件在init初始化过程中都做了哪些操作</p><h4 id="Server初始化"><a href="#Server初始化" class="headerlink" title="Server初始化"></a>Server初始化</h4><p>StandardServer是由Catalina进行init初始化的，调用的是LifecycleBase父类的init方法，而StandardServer继承至LifecycleMBeanBase，重写了initInternal方法。关于这块的知识，请参考上一篇Lifecycle的博客</p><p>StandardServer初始化的时序图如下所示，为了表述清楚，我这里把LifecycleBase、LifecycleMBeanBase拆开了，实际上是同一个StandardServer实例对象，存在继承关系<br><img src="/images/QQ截图20190117104152.png"></p><p>由上图可以很清晰地看到，StandardServer的初始化过程，先由父类LifecycleBase改变当前的state值并发出事件通知，<strong>那么这个时候StandardServer的子容器StandardService内部的state是否会发生改变呢，是否会发出事件通知呢？</strong> 当然是不会的，因为这个state值不是LifecycleBase的静态成员变量，StandardServer只能改变自己的值，而StandardService只有在被StandardServer调用init初始化的时候才会改变，二者拥有独立的状态。考虑到有其它线程可能会改变StandardServer的state值，比如利用jmx执行init操作，因此要考虑并发问题，所以LifecycleBase#init()使用了synchronized锁，并且state是volatile修饰的。</p><p>LifecycleBase改变state、发出事件通知之后，便会执行StandardServer自身的initInternal，我们来看看这个里面都干嘛了</p><pre><code>protected void initInternal() throws LifecycleException {    super.initInternal();    // 往jmx中注册全局的Stringcache，尽管这个cache是全局的，但是如果在同一个jvm中存在多个Server，    // 那么则会注册多个不同名字的StringCache，这种情况在内嵌的tomcat中可能会出现    onameStringCache = register(new StringCache(), &quot;type=StringCache&quot;);    // 注册MBeanFactory，用来管理Server    MBeanFactory factory = new MBeanFactory();    factory.setContainer(this);    onameMBeanFactory = register(factory, &quot;type=MBeanFactory&quot;);    // 往jmx中注册全局的NamingResources    globalNamingResources.init();    // Populate the extension validator with JARs from common and shared class loaders    if (getCatalina() != null) {        // 忽略ClassLoader操作    }    // 初始化内部的Service    for (int i = 0; i &lt; services.length; i++) {        services[i].init();    }}</code></pre><ol><li><p>先是调用super.initInternal()，把自己注册到jmx</p></li><li><p>然后注册StringCache和MBeanFactory</p></li><li><p>初始化NamingResources，就是server.xml中指定的GlobalNamingResources</p></li><li><p>调用Service子容器的init方法，让Service组件完成初始化，注意：在同一个Server下面，可能存在多个Service组件</p></li></ol><h4 id="Service初始化"><a href="#Service初始化" class="headerlink" title="Service初始化"></a>Service初始化</h4><p>StandardService和StandardServer都是继承至LifecycleMBeanBase，因此公共的初始化逻辑都是一样的，这里不做过多介绍，我们直接看下initInternal</p><pre><code>protected void initInternal() throws LifecycleException {    // 往jmx中注册自己    super.initInternal();    // 初始化Engine    if (engine != null) {        engine.init();    }    // 存在Executor线程池，则进行初始化，默认是没有的    for (Executor executor : findExecutors()) {        if (executor instanceof JmxEnabled) {            ((JmxEnabled) executor).setDomain(getDomain());        }        executor.init();    }    // 暂时不知道这个MapperListener的作用    mapperListener.init();    // 初始化Connector，而Connector又会对ProtocolHandler进行初始化，开启应用端口的监听    synchronized (connectorsLock) {        for (Connector connector : connectors) {            try {                connector.init();            } catch (Exception e) {                // 省略部分代码，logger and throw exception            }        }    }}</code></pre><ol><li><p>首先，往jmx中注册StandardService</p></li><li><p>初始化Engine，而Engine初始化过程中会去初始化Realm(权限相关的组件)</p></li><li><p>如果存在Executor线程池，还会进行init操作，这个Excecutor是tomcat的接口，继承至java.util.concurrent.Executor、org.apache.catalina.Lifecycle</p></li><li><p>初始化Connector连接器，默认有http1.1、ajp连接器，而这个Connector初始化过程，又会对ProtocolHandler进行初始化，开启应用端口的监听，后面会详细分析</p></li></ol><h4 id="Engine初始化"><a href="#Engine初始化" class="headerlink" title="Engine初始化"></a>Engine初始化</h4><p>StandardEngine在init阶段，需要获取Realm，这个Realm是干嘛用的？</p><pre><code>Realm(域)是用于对单个用户进行身份验证的底层安全领域的只读外观，并标识与这些用户相关联的安全角色。域可以在任何容器级别上附加，但是通常只附加到Context，或者更高级别的容器。</code></pre><p>StandardEngine初始化的代码如下：</p><pre><code>@Overrideprotected void initInternal() throws LifecycleException {    getRealm();    super.initInternal();}public Realm getRealm() {    Realm configured = super.getRealm();    if (configured == null) {        configured = new NullRealm();        this.setRealm(configured);    }    return configured;}</code></pre><p>由前面的类图可知，StandardEngine继承至ContainerBase，而ContainerBase重写了initInternal()方法，用于初始化start、stop线程池，这个线程池有以下特点：</p><ol><li><p>core线程和max是相等的，默认为1 </p></li><li><p>允许core线程在超时未获取到任务时退出线程 </p></li><li><p>线程获取任务的超时时间是10s，也就是说所有的线程(包括core线程)，超过10s未获取到任务，那么这个线程就会被销毁</p></li></ol><p>这么做的初衷是什么呢？因为这个线程池只需要在容器启动和停止的时候发挥作用，没必要时时刻刻处理任务队列</p><p>ContainerBase的代码如下所示：</p><pre><code>// 默认是1个线程private int startStopThreads = 1;protected ThreadPoolExecutor startStopExecutor;@Overrideprotected void initInternal() throws LifecycleException {    BlockingQueue&lt;Runnable&gt; startStopQueue = new LinkedBlockingQueue&lt;&gt;();    startStopExecutor = new ThreadPoolExecutor(            getStartStopThreadsInternal(),            getStartStopThreadsInternal(), 10, TimeUnit.SECONDS,            startStopQueue,            new StartStopThreadFactory(getName() + &quot;-startStop-&quot;));    // 允许core线程超时未获取任务时退出    startStopExecutor.allowCoreThreadTimeOut(true);    super.initInternal();}private int getStartStopThreadsInternal() {    int result = getStartStopThreads();    if (result &gt; 0) {        return result;    }    result = Runtime.getRuntime().availableProcessors() + result;    if (result &lt; 1) {        result = 1;    }    return result;}</code></pre><p>这个startStopExecutor线程池有什么用呢？</p><ol><li><p>在start的时候，如果发现有子容器，则会把子容器的start操作放在线程池中进行处理</p></li><li><p>在stop的时候，也会把stop操作放在线程池中处理</p></li></ol><p>在前面的文章中我们介绍了Container组件，StandardEngine作为顶层容器，它的直接子容器是StardandHost，但是对StandardEngine的代码分析，我们并没有发现它会对子容器StardandHost进行初始化操作，StandardEngine不按照套路出牌，而是把初始化过程放在start阶段。个人认为Host、Context、Wrapper这些容器和具体的webapp应用相关联了，初始化过程会更加耗时，因此在start阶段用多线程完成初始化以及start生命周期，否则，像顶层的Server、Service等组件需要等待Host、Context、Wrapper完成初始化才能结束初始化流程，整个初始化过程是具有传递性的。</p><h4 id="Connector初始化"><a href="#Connector初始化" class="headerlink" title="Connector初始化"></a>Connector初始化</h4><p>Connector也是继承至LifecycleMBeanBase，公共的初始化逻辑都是一样的。我们先来看下Connector的默认配置，大部分属性配置都可以在Connector类中找到，tomcat默认开启了HTTP/1.1、AJP/1.3，其实AJP的用处不大，可以去掉。</p><pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; /&gt;&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></pre><p>Connector定义了很多属性，比如port、redirectPort、maxCookieCount、maxPostSize等等，比较有意思的是竟然找不到connectionTimeout的定义，全文搜索后发现使用了属性名映射，估计是为了兼容以前的版本.</p><pre><code>protected static final HashMap&lt;String,String&gt; replacements = new HashMap&lt;&gt;();static {    replacements.put(&quot;acceptCount&quot;, &quot;backlog&quot;);    replacements.put(&quot;connectionLinger&quot;, &quot;soLinger&quot;);    replacements.put(&quot;connectionTimeout&quot;, &quot;soTimeout&quot;);    replacements.put(&quot;rootFile&quot;, &quot;rootfile&quot;);}public Object getProperty(String name) {    String repl = name;    if (replacements.get(name) != null) {        repl = replacements.get(name);    }    return IntrospectionUtils.getProperty(protocolHandler, repl);}public boolean setProperty(String name, String value) {    String repl = name;    if (replacements.get(name) != null) {        repl = replacements.get(name);    }    return IntrospectionUtils.setProperty(protocolHandler, repl, value);}</code></pre><p>initInternal过程如下所示： </p><ol><li><p>实例化Coyote适配器，这个适配器是用于Coyote的Request、Response与HttpServlet的Request、Response适配的，后续的博客会进行深入分析 </p></li><li><p>为ProtocolHander指定CoyoteAdapter用于处理请求 </p></li><li><p>初始化ProtocolHander，这一部分放在Connector后面进行分析</p></li></ol><pre><code>protected void initInternal() throws LifecycleException {    // 注册jmx    super.initInternal();    // 初始化Coyote适配器，这个适配器是用于Coyote的Request、Response与HttpServlet的Request、Response适配的    adapter = new CoyoteAdapter(this);    // protocolHandler需要指定Adapter用于处理请求    protocolHandler.setAdapter(adapter);    // Make sure parseBodyMethodsSet has a default    if (null == parseBodyMethodsSet) {        setParseBodyMethods(getParseBodyMethods());    }    // apr支持，忽略部分代码......    // 初始化ProtocolHandler，这个init不是Lifecycle定义的init，而是ProtocolHandler接口的init    try {        protocolHandler.init();    } catch (Exception e) {        throw new LifecycleException(                sm.getString(&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;), e);    }}</code></pre><h4 id="ProtocolHandler初始化"><a href="#ProtocolHandler初始化" class="headerlink" title="ProtocolHandler初始化"></a>ProtocolHandler初始化</h4><p>接下来，我们分析下HTTP/1.1的ProtocolHandler的初始化过程。首先，我们来认识下ProtocolHandler，它是一个抽象的协议实现，它不同于JNI这样的Jk协议，它是单线程、基于流的协议。ProtocolHandler是一个Cycote连接器实现的主要接口，而Adapter适配器是由一个Coyote Servlet容器实现的主要接口，定义了处理请求的抽象接口。</p><pre><code>public interface ProtocolHandler {    public void setAdapter(Adapter adapter);    public Adapter getAdapter();    public Executor getExecutor();    public void init() throws Exception;    public void start() throws Exception;    public void pause() throws Exception;    public void resume() throws Exception;    public void stop() throws Exception;    public void destroy() throws Exception;    // other code......}public interface Adapter {    public void service(Request req, Response res) throws Exception;    public boolean prepare(Request req, Response res) throws Exception;    public boolean asyncDispatch(Request req,Response res, SocketEvent status) throws Exception;    public void log(Request req, Response res, long time);    public void checkRecycled(Request req, Response res);    public String getDomain();}</code></pre><p>ProtocolHandler的子类如下所示，AbstractProtocol是基本的实现，而NIO默认使用的是Http11NioProtocol</p><p><img src="/images/QQ截图20190117111122.png"></p><p>调用ProtocolHandler的init进行初始化是调用的AbstractProtocol，首先完成jmx的注册，然后对NioEndpoint进行初始化</p><pre><code>public abstract class AbstractProtocol&lt;S&gt; implements ProtocolHandler,        MBeanRegistration {    public void init() throws Exception {        // 完成jmx注册        if (oname == null) {            oname = createObjectName();            if (oname != null) {                Registry.getRegistry(null, null).registerComponent(this, oname, null);            }        }        if (this.domain != null) {            rgOname = new ObjectName(domain + &quot;:type=GlobalRequestProcessor,name=&quot; + getName());            Registry.getRegistry(null, null).registerComponent(                    getHandler().getGlobal(), rgOname, null);        }        String endpointName = getName();        endpoint.setName(endpointName.substring(1, endpointName.length()-1));        endpoint.setDomain(domain);        // 初始化endpoint        endpoint.init();    }}</code></pre><p>NioEndpoint初始化过程，最重要的是完成端口和地址的绑定监听工作，关于网络通信这块的内容将在后面着重介绍</p><pre><code>public class NioEndpoint extends AbstractJsseEndpoint&lt;NioChannel&gt; {    public void bind() throws Exception {        // 实例化ServerSocketChannel，并且绑定端口和地址        serverSock = ServerSocketChannel.open();        socketProperties.setProperties(serverSock.socket());        InetSocketAddress addr = (getAddress()!=null?new InetSocketAddress(getAddress(),getPort()):new InetSocketAddress(getPort()));        // 设置最大连接数，原来是在这里设置的        serverSock.socket().bind(addr,getAcceptCount());        serverSock.configureBlocking(true); //mimic APR behavior        // 初始化acceptor、poller线程的数量        // Initialize thread count defaults for acceptor, poller        if (acceptorThreadCount == 0) {            // FIXME: Doesn&#39;t seem to work that well with multiple accept threads            acceptorThreadCount = 1;        }        if (pollerThreadCount &lt;= 0) {            pollerThreadCount = 1;        }        setStopLatch(new CountDownLatch(pollerThreadCount));        // 如果有必要的话初始化ssl        initialiseSsl();        // 初始化selector        selectorPool.open();    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，整个初始化过程便告一段落。整个初始化过程，由parent组件控制child组件的初始化，一层层往下传递，直到最后全部初始化OK。下图描述了整体的传递流程</p><p><img src="/images/QQ截图20190117111556.png"></p><p>默认情况下，Server只有一个Service组件，Service组件先后对Engine、Connector进行初始化。而Engine组件并不会在初始化阶段对子容器进行初始化，<strong>Host、Context、Wrapper容器的初始化是在start阶段完成的</strong>。tomcat默认会启用HTTP1.1和AJP的Connector连接器，这两种协议默认使用Http11NioProtocol、AJPNioProtocol进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的启动分析(一) Lifecycle</title>
      <link href="/2019/01/16/tomcat-de-qi-dong-fen-xi-yi-lifecycle/"/>
      <url>/2019/01/16/tomcat-de-qi-dong-fen-xi-yi-lifecycle/</url>
      
        <content type="html"><![CDATA[<p>Tomcat组件生命周期管理:Lifecycle<br><a id="more"></a></p><p>Lifecycle在其他框架中也很常见，比如spring，它常用于具有生命周期的组件，由Lifecycle控制组件的初始化、启动、销毁等动作，方便应用程序获取、释放某些资源，或者是触发某些特定的事件。Tomcat也是如此，在学习整个启动流程之前，我们先行了解下Lifecycle的实现机制，便于理解整个流程。</p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p>Lifecycle接口是一个公用的接口，定义了组件生命周期的一些方法，用于启动、停止Catalina组件。它是一个非常重要的接口，组件的生命周期包括：init、start、stop、destory，以及各种事件的常量、操作LifecycleListener的API，典型的观察者模式。</p><pre><code>public interface Lifecycle {    // ----------------------- 定义各种EVENT事件 -----------------------    public static final String BEFORE_INIT_EVENT = &quot;before_init&quot;;    public static final String AFTER_INIT_EVENT = &quot;after_init&quot;;    public static final String START_EVENT = &quot;start&quot;;    // 省略事件常量定义……    /**     * 注册一个LifecycleListener     */    public void addLifecycleListener(LifecycleListener listener);    /**     * 获取所有注册的LifecycleListener     */    public LifecycleListener[] findLifecycleListeners();    /**     * 移除指定的LifecycleListener     */    public void removeLifecycleListener(LifecycleListener listener);    /**     * 组件被实例化之后，调用该方法完成初始化工作，发会出以下事件     * &lt;ol&gt;     *   &lt;li&gt;INIT_EVENT: On the successful completion of component initialization.&lt;/li&gt;     * &lt;/ol&gt;     * @exception LifecycleException if this component detects a fatal error     *  that prevents this component from being used     */    public void init() throws LifecycleException;    /**     * 在组件投入使用之前调用该方法，先后会发出以下事件：BEFORE_START_EVENT、START_EVENT、AFTER_START_EVENT     * @exception LifecycleException if this component detects a fatal error     *  that prevents this component from being used     */    public void start() throws LifecycleException;    /**     * 使组件停止工作     */    public void stop() throws LifecycleException;    /**     * 销毁组件时被调用     */    public void destroy() throws LifecycleException;    /**     * Obtain the current state of the source component.     */    public LifecycleState getState();    /**     * 获取state的文字说明     */    public String getStateName();    /**     * Marker interface used to indicate that the instance should only be used     * once. Calling {@link #stop()} on an instance that supports this interface     * will automatically call {@link #destroy()} after {@link #stop()}     * completes.     */    public interface SingleUse {    }}</code></pre><p>各大组件均实现了Lifecycle接口，类图如下所示： </p><p><img src="/images/QQ截图20190116175426.png"></p><ul><li><p>LifecycleBase：它实现了Lifecycle的init、start、stop等主要逻辑，向注册在LifecycleBase内部的LifecycleListener发出对应的事件，并且预留了<strong>initInternal、startInternal、stopInternal</strong>等模板方法，便于子类完成自己的逻辑。</p></li><li><p>MBeanRegistration：JmxEnabled 的父类， jmx框架提供的注册MBean的接口，引入此接口是为了便于使用JMX提供的管理功能</p></li><li><p>LifecycleMBeanBase：JmxEnabled的子类，通过重写initInternal、destroyInternal方法，统一向jmx中注册/取消注册当前实例，方便利用jmx对实例对象进行管理，代码上特别强调要求子类先行调用super.initInternal</p></li><li><p>ContainerBase、StandardServer、StandardService、WebappLoader、Connector、StandardContext、StandardEngine、StandardHost、StandardWrapper等容器都继承了LifecycleMBeanBase，因此这些容器都具有了同样的生命周期并可以通过JMX进行管理。</p></li></ul><pre><code>public abstract class LifecycleMBeanBase extends LifecycleBase        implements JmxEnabled {    /**     * Sub-classes wishing to perform additional initialization should override     * this method, ensuring that super.initInternal() is the first call in the     * overriding method.     */    protected void initInternal() throws LifecycleException {        if (oname == null) {            mserver = Registry.getRegistry(null, null).getMBeanServer();            oname = register(this, getObjectNameKeyProperties());        }    }}public class Connector extends LifecycleMBeanBase  {    protected void initInternal() throws LifecycleException {        super.initInternal();        adapter = new CoyoteAdapter(this);        protocolHandler.setAdapter(adapter);        // other code......    }}</code></pre><h3 id="LifecycleState"><a href="#LifecycleState" class="headerlink" title="LifecycleState"></a>LifecycleState</h3><p>LifecycleState是枚举类，定义了各种状态:</p><pre><code>public enum LifecycleState {    // LifecycleBase实例化完成时的状态    NEW(false, null),       // 容器正在初始化的状态，在INITIALIZED之前    INITIALIZING(false, Lifecycle.BEFORE_INIT_EVENT),    // 初始化完成的状态    INITIALIZED(false, Lifecycle.AFTER_INIT_EVENT),    // 启动前    STARTING_PREP(false, Lifecycle.BEFORE_START_EVENT),    // 启动过程中的状态    STARTING(true, Lifecycle.START_EVENT),    // 启动完成    STARTED(true, Lifecycle.AFTER_START_EVENT),    // 停止前的状态    STOPPING_PREP(true, Lifecycle.BEFORE_STOP_EVENT),    // 停止过程中    STOPPING(false, Lifecycle.STOP_EVENT),    // 停止完成    STOPPED(false, Lifecycle.AFTER_STOP_EVENT),    // 销毁中    DESTROYING(false, Lifecycle.BEFORE_DESTROY_EVENT),    // 完成销毁    DESTROYED(false, Lifecycle.AFTER_DESTROY_EVENT),    // 启动、停止过程中出现异常    FAILED(false, null);    private final boolean available;    private final String lifecycleEvent;    private LifecycleState(boolean available, String lifecycleEvent) {        this.available = available;        this.lifecycleEvent = lifecycleEvent;    }    public boolean isAvailable() {        return available;    }    public String getLifecycleEvent() {        return lifecycleEvent;    }}</code></pre><h3 id="LifecycleListener"><a href="#LifecycleListener" class="headerlink" title="LifecycleListener"></a>LifecycleListener</h3><p>要订阅事件的实体类需要实现LifecycleListener</p><pre><code>public interface LifecycleListener {    public void lifecycleEvent(LifecycleEvent event);}</code></pre><p>默认情况下，tomcat会内置一些LifecycleListener，配置在server.xml中，除了xml中的LifecycleListener，还有org.apache.catalina.core.NamingContextListener，<strong>而这个LifecycleListener是在StandardServer的构造器中添加的</strong>，各个LifecycleListener的作用在此不再细说。如果我们在tomcat启动、停止的时候增加额外的逻辑，比如发送邮件通知，则可以从这个地方入手。</p><pre><code>&lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;&lt;!--APR library loader. Documentation at /docs/apr.html --&gt;&lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;&lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;&lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;&lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;&lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;</code></pre><pre><code>public StandardServer() {    // 忽略部分代码    if (isUseNaming()) {        namingContextListener = new NamingContextListener();        addLifecycleListener(namingContextListener);    } else {        namingContextListener = null;    }}</code></pre><h3 id="LifecycleBase"><a href="#LifecycleBase" class="headerlink" title="LifecycleBase"></a>LifecycleBase</h3><p>LifecycleBase实现了Lifecycle接口，完成了核心逻辑</p><ul><li><p>StringManager：用来做日志信息参数化输出的，支持国际化</p></li><li><p>内部使用CopyOnWriteArrayList维护所有的LifecycleListener，因为在各个生命周期，内部的LifecycleListener是会变化的，并且存在并发操作问题，因此使用了并发的List。注意，不同的LifecycleBase子类，其内部的lifecycleListeners存放不同的LifecyListener，比如Server和Service，它们是不同的Lifecycle实例，内部的lifecycleListeners也是不同 </p></li><li><p>LifecycleBase的state初始值是LifecycleState.NEW，也存在并发修改的问题，用了volatile修饰 </p></li><li><p>addLifecycleListener、removeLifecycleListener允许添加、删除LifecycleListener，告诉LifecycleBase有哪些监听者需要进行事件通知 </p></li><li><p>fireLifecycleEvent：向内部注册的LifecycleListener发出事件通知，它是protected的方法，所以LifecycleBase的子类可以在适当的时机调用该方法发出事件通知。事件通知由LifecycleListener实现类决定要不要对特定的事件进行处理 </p></li><li><p>setState：更新state值，并发出对应的事件通知，同样是调用fireLifecycleEvent</p></li></ul><pre><code>public abstract class LifecycleBase implements Lifecycle {    // 日志国际化输出使用    private static final StringManager sm = StringManager.getManager(LifecycleBase.class);    // 维护LifecycleListener    private final List&lt;LifecycleListener&gt; lifecycleListeners = new CopyOnWriteArrayList&lt;&gt;();    // 初始状态是NEW    private volatile LifecycleState state = LifecycleState.NEW;    /**     * 注册LifecycleListener     */    @Override    public void addLifecycleListener(LifecycleListener listener) {        lifecycleListeners.add(listener);    }    @Override    public LifecycleListener[] findLifecycleListeners() {        return lifecycleListeners.toArray(new LifecycleListener[0]);    }    /**     * 移除LifecycleListener     */    @Override    public void removeLifecycleListener(LifecycleListener listener) {        lifecycleListeners.remove(listener);    }    /**     * 发出事件通知，遍历内部所有的LifecycleListener，并调用其lifecycleEvent     */    protected void fireLifecycleEvent(String type, Object data) {        LifecycleEvent event = new LifecycleEvent(this, type, data);        for (LifecycleListener listener : lifecycleListeners) {            listener.lifecycleEvent(event);        }    }    @Override    public LifecycleState getState() {        return state;    }    @Override    public String getStateName() {        return getState().toString();    }    protected synchronized void setState(LifecycleState state)            throws LifecycleException {        setStateInternal(state, null, true);    }    protected synchronized void setState(LifecycleState state, Object data)            throws LifecycleException {        setStateInternal(state, data, true);    }    /**     * 设置state值，并发出事件通知     */    private synchronized void setStateInternal(LifecycleState state,            Object data, boolean check) throws LifecycleException {        // 校验state的正确性        if (check) {            if (state == null) {                invalidTransition(&quot;null&quot;);                return;            }            // Any method can transition to failed            // startInternal() permits STARTING_PREP to STARTING            // stopInternal() permits STOPPING_PREP to STOPPING and FAILED to            // STOPPING            if (!(state == LifecycleState.FAILED ||                    (this.state == LifecycleState.STARTING_PREP &amp;&amp;                            state == LifecycleState.STARTING) ||                    (this.state == LifecycleState.STOPPING_PREP &amp;&amp;                            state == LifecycleState.STOPPING) ||                    (this.state == LifecycleState.FAILED &amp;&amp;                            state == LifecycleState.STOPPING))) {                // No other transition permitted                invalidTransition(state.name());            }        }        this.state = state;        String lifecycleEvent = state.getLifecycleEvent();        if (lifecycleEvent != null) {            fireLifecycleEvent(lifecycleEvent, data);        }    }    // 省略其它代码......}</code></pre><p>Lifecycle组件的：init、start、stop、destory的套路基本上一样，先由LifecycleBase完成前期的校验、事件通知动作，再调用子类的方法完成自己的逻辑。</p><pre><code>校验state--&gt;发出事件通知发出事件通知--&gt;子类doInternal</code></pre><hr><h4 id="init分析"><a href="#init分析" class="headerlink" title="init分析"></a>init分析</h4><pre><code>@Overridepublic final synchronized void init() throws LifecycleException {        // 1        if (!state.equals(LifecycleState.NEW)) {            invalidTransition(Lifecycle.BEFORE_INIT_EVENT);        }        setStateInternal(LifecycleState.INITIALIZING, null, false);        try {            // 2             initInternal();        } catch (Throwable t) {            ExceptionUtils.handleThrowable(t);            setStateInternal(LifecycleState.FAILED, null, false);            throw new LifecycleException(                    sm.getString(&quot;lifecycleBase.initFail&quot;,toString()), t);        }        // 3         setStateInternal(LifecycleState.INITIALIZED, null, false);}</code></pre><p>下面我们逐一来分析一下上述代码中标注了数字的地方：</p><ol><li><p>标注1的代码首先检测当前组件的状态是不是NEW(新建)，如果不是就调用org.apache.catalina.util.LifecycleBase#invalidTransition方法来将当前的状态转换过程<strong>终止</strong>，<font color="red">而<strong>invalidTransition</strong>的实现是抛出了org.apache.catalina.LifecycleException异常。</font>接着调用了setStateInternal方法将状态设置为INITIALIZING（正在初始化）</p></li><li><p>标注2的代码就是<strong>init模板方法的钩子</strong>，子类可以通过实现protected abstract void initInternal() throws LifecycleException;方法来纳入初始化的流程。</p></li><li><p>标注3的代码将组件的状态改为INITIALIZED(已初始化)。</p></li></ol><h4 id="start分析"><a href="#start分析" class="headerlink" title="start分析"></a>start分析</h4><p>start过程会触发LifecycleState的STARTING_PREP、STARTED事件，如果出现启动失败还会触发FAILED事件，并且调用stop。因为会涉及多线程操作，因此对方法加了锁。如果start期间出现了异常，则会调用stop停止tomcat，或者state状态有误也会抛出异常</p><p><img src="/images/QQ截图20190116184357.png"></p><p>state状态变更时调用setStateInternal方法，遍历内部所有的LifecycleListener，并向其发起对应的事件通知，由LifecycleListener去完成某些动作。其子类可以直接调用fireLifecycleEvent，比如在StandardServer中，start过程会发出CONFIGURE_START_EVENT事件。注：所有事件的命名均定义在Lifecycle接口中。</p><pre><code>public abstract class LifecycleBase implements Lifecycle {    @Override    public final synchronized void start() throws LifecycleException {        // 如果是start前、进行中、start完成，则直接return        if (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||                LifecycleState.STARTED.equals(state)) {            // 忽略logger日志            return;        }        // 完成init初始化        if (state.equals(LifecycleState.NEW)) {            init();        } else if (state.equals(LifecycleState.FAILED)) {            stop();        } else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;                !state.equals(LifecycleState.STOPPED)) {            invalidTransition(Lifecycle.BEFORE_START_EVENT);        }        try {            // 发出STARTING_PREP事件            setStateInternal(LifecycleState.STARTING_PREP, null, false);            // 由子类实现            startInternal();            // 如果启动失败直接调用stop            if (state.equals(LifecycleState.FAILED)) {                stop();            }            // 说明状态有误            else if (!state.equals(LifecycleState.STARTING)) {                invalidTransition(Lifecycle.AFTER_START_EVENT);            }            // 成功完成start，发出STARTED事件            else {                setStateInternal(LifecycleState.STARTED, null, false);            }        } catch (Throwable t) {            ExceptionUtils.handleThrowable(t);            setStateInternal(LifecycleState.FAILED, null, false);            throw new LifecycleException(sm.getString(&quot;lifecycleBase.startFail&quot;, toString()), t);        }    }    /**     * 由子类实现     */    protected abstract void startInternal() throws LifecycleException;}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上面我们分析了init和start方法的流程，对于stop和destroy方法的总体过程是类似的，大家可以自己阅读一下，但是通过上面的分析，我们可以得出生命周期方法的总体的骨架，如果用 <strong>伪代码</strong> 来表示可以简化为如下：</p><pre><code>public final synchronized void lfieCycleMethod() throws LifecycleException {        stateCheck();//状态检查        //设置为进入相应的生命周期之前的状态        setStateInternal(LifecycleState.BEFORE_STATE, null, false);        lfieCycleMethodInternal();//钩子方法        //进入相应的生命周期之后的状态        setStateInternal(LifecycleState.AFTER_STATE, null, false);}</code></pre><h3 id="LifecycleMBeanBase"><a href="#LifecycleMBeanBase" class="headerlink" title="LifecycleMBeanBase"></a>LifecycleMBeanBase</h3><p>由前面的类图可知，LifecycleMBeanBase是LifecycleBase的直接子类，并且实现了JmxEnabled接口，很多组件都是直接继承它。</p><p>LifecycleMBeanBase完成了jmx注册的主要逻辑，重写了LifecycleBase的initInternal、destroyInternal方法，用于完成jmx的注册、注销动作，这两个模板方法中特别说明：</p><pre><code>Sub-classes wishing to perform additional initialization should override this method,ensuring that super.initInternal() is the first call in the overriding method.</code></pre><p>为了保证jmx的正常注册和注销，要求子类在重写initInternal、destroyInternal方法时，必须先调用super.initInternal()。例如Connector：</p><pre><code>public class Connector extends LifecycleMBeanBase  {    @Override    protected void initInternal() throws LifecycleException {        // 先行调用LifecycleMBeanBase的initInternal        super.initInternal();        // Initialize adapter        adapter = new CoyoteAdapter(this);        protocolHandler.setAdapter(adapter);        // other code......    }    // other code......}</code></pre><p>我们再来看看LifecycleMBeanBase的内部实现，在initInternal阶段初始化MBeanServer实例，并且把当前实例注册到jmx中；而destroyInternal阶段则是根据ObjectName注销MBean:</p><pre><code>public abstract class LifecycleMBeanBase extends LifecycleBase        implements JmxEnabled {    /**     * jmx的域，默认使用Service的name，即&quot;Catalina&quot;     */    private String domain = null;    /**     * 用于标识一个MBean的对象名称，也可以根据这个name来查找MBean     */    private ObjectName oname = null;    /**     * jmx的核心组件，提供代理端操作MBean的接口，提供了创建、注册、删除MBean的接口，它由MBeanServerFactory创建     */    protected MBeanServer mserver = null;    @Override    protected void initInternal() throws LifecycleException {        if (oname == null) {            mserver = Registry.getRegistry(null, null).getMBeanServer();            oname = register(this, getObjectNameKeyProperties());        }    }    @Override    protected void destroyInternal() throws LifecycleException {        unregister(oname);    }    protected final void unregister(ObjectName on) {        if (on == null) {            return;        }        if (mserver == null) {            log.warn(sm.getString(&quot;lifecycleMBeanBase.unregisterNoServer&quot;, on));            return;        }        try {            mserver.unregisterMBean(on);        } catch (MBeanRegistrationException e) {            log.warn(sm.getString(&quot;lifecycleMBeanBase.unregisterFail&quot;, on), e);        } catch (InstanceNotFoundException e) {            log.warn(sm.getString(&quot;lifecycleMBeanBase.unregisterFail&quot;, on), e);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的总体框架设计</title>
      <link href="/2019/01/16/tomcat-de-zong-ti-kuang-jia-she-ji/"/>
      <url>/2019/01/16/tomcat-de-zong-ti-kuang-jia-she-ji/</url>
      
        <content type="html"><![CDATA[<p>今天来学习tomcat的总体框架设计，帮助大家理解web的执行流程，fighting~~~<br><a id="more"></a></p><p>tomcat的总体架构如下图所示：</p><p><img src="/images/QQ截图20190116163946.png"></p><p>如上图所示，tomcat由：Server、Service、Engine、Connerctor、Host、Context组件组成，其中带有s的代表在一个tomcat实例上可以存在多个组件，比如Context(s)，tomcat允许我们部署多个应用，每个应用对应一个Context。这些组件在tomcat的<strong>conf/server.xml</strong>文件中可以找到，对tomcat的调优需要改动该文件。</p><p><code>server.xml:</code></p><pre><code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;&lt;Service name=&quot;Catalina&quot;&gt;    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;           connectionTimeout=&quot;20000&quot;           redirectPort=&quot;8443&quot; /&gt;    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;               resourceName=&quot;UserDatabase&quot;/&gt;      &lt;/Realm&gt;      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;               pattern=&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; /&gt;      &lt;/Host&gt;    &lt;/Engine&gt;&lt;/Service&gt;&lt;/Server&gt;</code></pre><p>Tomcat加载时，相应组件（容器）的配置参数都是从这个文件读进去的，这个文件也是Tomcat性能优化的关键。接下来我们就根据上图以及conf/server.xml的内容来一步步描述一下上面所说的各种组件吧。</p><hr><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server是Tomcat中最顶层的组件，它可以包含多个Service组件。在Tomcat源代码中Server组件对应源码中的  org.apache.catalina.core.StandardServer 类。StandardServer的继承关系图如下图所示：<br><img src="/images/QQ截图20190116165355.png"></p><p>Lifecycle是Tomcat的生命周期接口。保持组件启动和停止一致的的机制通过实现org.apache.catalina.Lifecycle接口来实现。</p><ul><li><p>Server继承至LifeCycle，LifeCycle是一个非常重要的接口，各大组件都继承了这个接口，用于管理tomcat的生命周期，比如init、start、stop、destory；另外，它使用了观察者模式，LifeCycle是一个监听者，它会向注册的LifecycleListener观察者发出各种事件</p></li><li><p>Server提供了findService、getCatalina、getCatalinaHome、getCatalinaBase等接口，支持查找、遍历Service组件，这里似乎看到了和Serivce组件的些许联系。</p></li></ul><pre><code>public interface Server extends Lifecycle {    public NamingResourcesImpl getGlobalNamingResources();    public void setGlobalNamingResources(NamingResourcesImpl globalNamingResources);    public javax.naming.Context getGlobalNamingContext();    public int getPort();    public void setPort(int port);    public String getAddress();    public void setAddress(String address);    public String getShutdown();    public void setShutdown(String shutdown);    public ClassLoader getParentClassLoader();    public void setParentClassLoader(ClassLoader parent);    public Catalina getCatalina();    public void setCatalina(Catalina catalina);    public File getCatalinaBase();    public void setCatalinaBase(File catalinaBase);    public File getCatalinaHome();    public void setCatalinaHome(File catalinaHome);    public void await();    public Service findService(String name);    public Service[] findServices();    public void removeService(Service service);    public Object getNamingToken();}</code></pre><hr><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service的默认实现类是StardardService，类结构和StardardServer很相似，也是继承至LifecycleMBeanBase，实现了Service接口。</p><p>Service组件相当于Connetor和Engine组件的包装器，它将一个或者多个Connector组件和一个Engine建立关联。上述配置文件中，定义一个叫Catalina的服务，并将Http,AJP（定向包的协议）这两个Connector关联到了一个名为Catalina的Service，注意一个Connetor对应处理一种协议。Service组件对应Tomcat源代码中的org.apache.catalina.core.StandardService,StandardService的继承关系图如下图所示：</p><p><img src="/images/QQ截图20190116170002.png"></p><p>由Service接口不难发现Service组件的内部结构 </p><ul><li><p>持有Engine实例</p></li><li><p>持有Server实例 </p></li><li><p>可以管理多个Connector实例</p></li><li><p>持有Executor引用</p></li></ul><pre><code>public class StandardService extends LifecycleMBeanBase implements Service {    // 省略若干代码}public interface Service extends Lifecycle {    public Engine getContainer();    public void setContainer(Engine engine);    public String getName();    public void setName(String name);    public Server getServer();    public void setServer(Server server);    public ClassLoader getParentClassLoader();    public void setParentClassLoader(ClassLoader parent);    public String getDomain();    public void addConnector(Connector connector);    public Connector[] findConnectors();    public void removeConnector(Connector connector);    public void addExecutor(Executor ex);    public Executor[] findExecutors();    public Executor getExecutor(String name);    public void removeExecutor(Executor ex);    Mapper getMapper();}</code></pre><hr><h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>Connector是tomcat中监听TCP端口的组件，server.xml默认定义了两个Connector，分别用于监听http、ajp端口。对应的代码是org.apache.catalina.connector.Connector，它是一个实现类，并且实现了Lifecycle接口。</p><pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</code></pre><ul><li>HTTP/1.1<br><connector port="8080" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443"> 上面定义了一个Connector，它缺省监听端口8080,这个端口我们可以根据具体情况进行改动。connectionTimeout定义了连接超时时间，单位是毫秒，redirectPort定义了ssl的重定向接口，根据缺省的配置，Connector会将ssl请求重定向到8443端口。</connector></li></ul><pre><code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></pre><ul><li>AJP/1.3<br>AJP表示Apache Jserv Protocol,此连接器将处理Tomcat和Apache http服务器之间的交互，这个连接器是用来处理我们将Tomcat和Apache http服务器结合使用的情况。假如在同样的一台物理Server上面部署了一台Apache http服务器和多台Tomcat服务器，通过Apache服务器来处理静态资源以及负载均衡的时候，针对不同的Tomcat实例需要AJP监听不同的端口。<strong>但是，在实际的项目应用中，AJP协议并不常用，大多数应用场景会使用 nginx + tomcat 实现负载均衡。</strong></li></ul><p>Connector对应源代码中的org.apache.catalina.connector.Connector,它的继承关系图如下所示：</p><p><img src="/images/QQ截图20190116170422.png"></p><hr><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>org.apache.catalina.Container接口定义了容器的api，它是一个处理用户servlet请求并返回对象给web用户的模块，它有四种不同的容器： </p><ul><li><p>Engine，表示整个Catalina的servlet引擎 </p></li><li><p>Host，表示一个拥有若干个Context的虚拟主机 </p></li><li><p>Context，表示一个Web应用，一个context包含一个或多个wrapper </p></li><li><p>Wrapper，表示一个独立的servlet</p></li></ul><p><img src="/images/QQ截图20190116171006.png"></p><p>Engine、Host、Context、Wrapper都有一个默认的实现类StandardXXX，均继承至ContainerBase。此外，一个容器还包含一系列的Lodder、Logger、Manager、Realm和Resources等</p><p>一个容器可以有一个或多个低层次上的子容器，并且一个Catalina功能部署并不一定需要全部四种容器。一个Context有一个或多个wrapper，而wrapper作为容器层次中的最底层，不能包含子容器。从一个容器添加到另一容器中可以使用在Container接口中定义的addChild()方法义：</p><pre><code>public void addChild(Container child);</code></pre><p>删除一个容器可以使用Container接口中定义的removeChild()方法：</p><pre><code>public void removeChild(Container child);</code></pre><p>另外容器接口支持子接口查找和获得所有子接口集合的方法findChild和findChildren方法：</p><pre><code>public Container findChild(String name);public Container[] findChildren();</code></pre><hr><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>Tomcat中有一个容器的概念，而Engine,Host,Context,Wrapper都属于Contanier，我们先来说说最顶层的容器Engine.<br>一个Engine可以包含一个或者多个Host,也就是说我们一个Tomcat的实例可以配置多个虚拟主机。</p><p>缺省的情况下<code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</code>定义了一个名称为 Cataline 的 Engine。</p><p>Engine对应源代码中的org.apache.catalina.core.StandardEngine，它的继承关系图如下图所示：</p><p><img src="/images/QQ截图20190116171521.png"></p><p>Engine表示Catalina的Servlet引擎，如果使用了Engine的话，则它是Catalina的<strong>顶层容器</strong>，因此在StardardCataline的setParent()方法中是直接抛出异常的。</p><pre><code>public interface Engine extends Container {    public String getDefaultHost();    public void setDefaultHost(String defaultHost);    public String getJvmRoute();    public void setJvmRoute(String jvmRouteId);    public Service getService();    public void setService(Service service);}public class StandardEngine extends ContainerBase implements Engine {    // other code...    public void setParent(Container container) {        throw new IllegalArgumentException(sm.getString(&quot;standardEngine.notParent&quot;));    }}</code></pre><p><code>server.xml:</code></p><pre><code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;  &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;    &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;           resourceName=&quot;UserDatabase&quot;/&gt;  &lt;/Realm&gt;  &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;    &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;           prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;           pattern=&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; /&gt;  &lt;/Host&gt;&lt;/Engine&gt;</code></pre><hr><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>Host定义了一个虚拟主机，正所谓虚拟主机，当然是可以用来部署应用程序的，Tomcat的Host也是如此。它在server.xml中定义了一个localhost的Host，应用根目录在webapps下面，默认是支持解压重新部署的。</p><pre><code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;...&lt;/Host&gt;</code></pre><p>其中appBase为webapps，也就是&lt;CATALINA_HOME&gt;\webapps目录，unpackingWARS属性指定在appBase指定的目录中的war包都自动的解压，缺省配置为true，autoDeploy属性指定是否对加入到appBase目录的war包进行自动的部署，缺省为true.</p><p>Host对应源代码中的org.apache.catalina.core.StandardHost,它的继承关系图如下所示：</p><p><img src="/images/QQ截图20190116172108.png"></p><hr><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>Context代表一个独立的web应用，针对每个Context，tomcat都是使用不同的Classloader避免类冲突。如果我们希望使用一个自定义的目录作为部署路径的话，可以在server.xml中新增Context即可。</p><p>在Tomcat中，每一个运行的webapp其实最终都是以Context的形成存在，<strong>每个Context都有一个根路径和请求URL路径</strong>，Context对应源代码中的org.apache.catalina.core.StandardContext,它的继承关系图如下图所示：</p><p><img src="/images/QQ截图20190116172254.png"></p><pre><code>&lt;Context path=&quot;/static&quot; docBase=&quot;D:/static&quot; reloadable=&quot;true&quot;&gt;&lt;/Context&gt;</code></pre><p>在Tomcat中我们通常采用如下的两种方式创建一个Context.下面分别描述一下：</p><ol><li><p>在<catalina-home>\webapps目录中创建一个目录，这个时候将自动创建一个context，默认context的访问url为<code>http://host:port/dirname</code>,你也可以通过在ContextRoot\META-INF中创建一个context.xml的文件，其中包含如下的内容来指定应用的访问路径。<code>&lt;Context path=&quot;/yourUrlPath&quot; /&gt;</code></catalina-home></p></li><li><p>conf\server.xml文件中增加context元素。 第二种创建context的方法，我们可以选择在server.xml文件的<host>元素，比如我们在server.xml文件中增加如下内容：</host></p></li></ol><pre><code>&lt;Context path=&quot;/mypath&quot; docBase=&quot;/Users/xxx&quot; reloadable=&quot;true&quot;&gt;&lt;/Context&gt;</code></pre><p>这样的话，我们就可以通过 <code>http://host:port/mypath</code> 访问上面配置的 context 了。</p><hr><p><strong>Valve:</strong></p><p>Valve中文意思是阀门，Valve是Tomcat中责任链模式的实现，通过链接多个Valve对请求进行处理。每个容器都有一个流水线Pipeline（过滤器链），每个流水线至少有一个阀门。其中Valve可以定义在任何的Container中，上面说的Engine,Host,Context都属于容器。tomcat 默认定义了一个名为org.apache.catalina.valves.AccessLogValve的Valve,这个Valve负责拦截每个请求，然后记录一条访问日志。</p><p>通过上面的分析，我们发现Server,Service,Engine,Host,Context都实现了org.apache.catalina.Lifecycle接口，通过这个接口管理了这些核心组件的生命周期，关于这些组件的生命周期，我们在下一篇文章描述。</p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解CAS</title>
      <link href="/2019/01/15/shen-ru-li-jie-cas/"/>
      <url>/2019/01/15/shen-ru-li-jie-cas/</url>
      
        <content type="html"><![CDATA[<p>CAS，Compare And Swap，即比较并交换。Doug lea大神在同步组件中大量使用CAS技术鬼斧神工地实现了Java多线程的并发操作。<br><a id="more"></a></p><hr><p>整个AQS同步组件、Atomic原子类操作等等都是以CAS实现的，甚至ConcurrentHashMap在1.8的版本中也调整为了CAS+Synchronized。可以说CAS是整个JUC的基石。</p><p><img src="/images/QQ截图20190115133741.png"></p><h3 id="CAS分析"><a href="#CAS分析" class="headerlink" title="CAS分析"></a>CAS分析</h3><p>在CAS中有三个参数：内存值V、旧的预期值A、要更新的值B，当且仅当内存值V的值等于旧的预期值A时，才会将内存值V的值修改为B，否则什么都不干。其伪代码如下：</p><pre><code>if(this.value == A){    this.value = B    return true;}else{    return false;}</code></pre><p>JUC下的atomic类都是通过CAS来实现的，下面就以AtomicInteger为例来阐述CAS的实现。如下：</p><pre><code>    private static final Unsafe unsafe = Unsafe.getUnsafe();    private static final long valueOffset;    static {        try {            valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));        } catch (Exception ex) { throw new Error(ex); }    }    private volatile int value;</code></pre><p>Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe，它提供了硬件级别的原子操作。</p><p>valueOffset为变量值在内存中的偏移地址，unsafe就是通过偏移地址来得到数据的原值的。</p><p>value当前值，使用volatile修饰，保证多线程环境下看见的是同一个。</p><p>我们就以AtomicInteger的addAndGet()方法来做说明，先看源代码：</p><pre><code>    public final int addAndGet(int delta) {        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;    }    public final int getAndAddInt(Object var1, long var2, int var4) {        int var5;        do {            var5 = this.getIntVolatile(var1, var2);        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));        return var5;    }</code></pre><p>内部调用unsafe的getAndAddInt方法，在getAndAddInt方法中主要是看compareAndSwapInt方法：</p><p><code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code></p><p>该方法为本地方法，有四个参数，分别代表：对象、对象的地址、预期值、修改值（<strong>有位伙伴告诉我他面试的时候就问到这四个变量是啥意思…</strong>）。该方法的实现这里就不做详细介绍了，有兴趣的伙伴可以看看openjdk的源码。</p><p>CAS可以保证一次的<strong>读-改-写</strong>操作是原子操作，在单处理器上该操作容易实现，但是在多处理器上实现就有点儿复杂了。</p><p>CPU提供了两种方法来实现多处理器的原子操作：总线加锁或者缓存加锁。</p><ul><li><p><strong>总线加锁：</strong>总线加锁就是就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。但是这种处理方式显得有点儿霸道，不厚道，他把CPU和内存之间的通信锁住了，在锁定期间，其他处理器都不能读取其他内存地址的数据，其开销有点儿大。所以就有了缓存加锁。</p></li><li><p><strong>缓存加锁：</strong>其实针对于上面那种情况我们只需要保证在同一时刻对某个内存地址的操作是原子性的即可。缓存加锁就是缓存在内存区域的数据如果在加锁期间，当它执行锁操作写回内存时，处理器不在输出LOCK#信号，而是修改内部的内存地址，利用缓存一致性协议来保证原子性。缓存一致性机制可以保证同一个内存区域的数据仅能被一个处理器修改，也就是说当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p></li></ul><hr><h3 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h3><p>CAS虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方法：循环时间太长、只能保证一个共享变量原子操作、ABA问题。</p><h4 id="循环时间太长"><a href="#循环时间太长" class="headerlink" title="循环时间太长"></a>循环时间太长</h4><p>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</p><h4 id="只能保证一个共享变量原子操作"><a href="#只能保证一个共享变量原子操作" class="headerlink" title="只能保证一个共享变量原子操作"></a>只能保证一个共享变量原子操作</h4><p>看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位</p><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p><p>用一个例子来阐述ABA问题所带来的影响。</p><p>有如下链表：</p><p><img src="/images/QQ截图20190115134714.png"></p><p>假如我们想要把A替换成B，也就是compareAndSet(this,A,B)。线程1执行B替换A的操作，线程2主要执行如下动作，A 、B出栈，然后C、A入栈，最终该链表如下：</p><p><img src="/images/QQ截图20190115134830.png"></p><p>完成后，线程1发现仍然是A，那么compareAndSet(this,A,B)成功，但是这时会存在一个问题就是B.next = null,compareAndSet(this,A,B)后，会导致C丢失，该栈仅有一个B元素了，平白无故把C给丢失了。</p><p>CAS的ABA隐患问题，解决方案则是<strong>版本号</strong>，Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记<strong>版本戳stamp</strong>，从而避免ABA问题。对于上面的案例应该线程1会失败。</p><p>AtomicStampedReference的compareAndSet()方法定义如下：</p><pre><code>    public boolean compareAndSet(V   expectedReference,                                 V   newReference,                                 int expectedStamp,                                 int newStamp) {        Pair&lt;V&gt; current = pair;        return            expectedReference == current.reference &amp;&amp;            expectedStamp == current.stamp &amp;&amp;            ((newReference == current.reference &amp;&amp;              newStamp == current.stamp) ||             casPair(current, Pair.of(newReference, newStamp)));    }</code></pre><p>compareAndSet有四个参数，分别表示：<strong>预期引用、更新后的引用、预期标志、更新后的标志</strong>。源码部分很好理解：预期的引用 == 当前引用，预期的标识 == 当前标识，如果更新后的引用和标志和当前的引用和标志相等则直接返回true，否则通过Pair生成一个新的pair对象与当前pair CAS替换。Pair为AtomicStampedReference的内部类，主要用于记录引用和版本戳信息（标识），定义如下：</p><pre><code>    private static class Pair&lt;T&gt; {        final T reference;        final int stamp;        private Pair(T reference, int stamp) {            this.reference = reference;            this.stamp = stamp;        }        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) {            return new Pair&lt;T&gt;(reference, stamp);        }    }    private volatile Pair&lt;V&gt; pair;</code></pre><p>Pair记录着对象的引用和版本戳，版本戳为int型，保持自增。同时Pair是一个不可变对象，其所有属性全部定义为final，对外提供一个of方法，该方法返回一个新建的Pari对象。pair对象定义为volatile，保证多线程环境下的可见性。在AtomicStampedReference中，大多方法都是通过调用Pair的of方法来产生一个新的Pair对象，然后赋值给变量pair。如set方法：</p><pre><code>    public void set(V newReference, int newStamp) {        Pair&lt;V&gt; current = pair;        if (newReference != current.reference || newStamp != current.stamp)            this.pair = Pair.of(newReference, newStamp);    }</code></pre><p>下面我们将通过一个例子可以可以看到AtomicStampedReference和AtomicInteger的区别。我们定义两个线程，线程1负责将<br>100 —&gt; 110 —&gt; 100，线程2执行 100 —&gt;120，看两者之间的区别。</p><pre><code>public class Test {    private static AtomicInteger atomicInteger = new AtomicInteger(100);    private static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1);    public static void main(String[] args) throws InterruptedException {        //AtomicInteger        Thread at1 = new Thread(new Runnable() {            @Override            public void run() {                atomicInteger.compareAndSet(100,110);                atomicInteger.compareAndSet(110,100);            }        });        Thread at2 = new Thread(new Runnable() {            @Override            public void run() {                try {                    TimeUnit.SECONDS.sleep(2);      // at1,执行完，这里睡眠时间可以设置大点！！                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(&quot;AtomicInteger:&quot; + atomicInteger.compareAndSet(100,120));            }        });        at1.start();        at2.start();        at1.join();        at2.join();        //AtomicStampedReference        Thread tsf1 = new Thread(new Runnable() {            @Override            public void run() {                try {                    //让 tsf2先获取stamp，导致预期时间戳不一致                    TimeUnit.SECONDS.sleep(2);                } catch (InterruptedException e) {                    e.printStackTrace();                }                // 预期引用：100，更新后的引用：110，预期标识getStamp() 更新后的标识getStamp() + 1                atomicStampedReference.compareAndSet(100,110,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);                atomicStampedReference.compareAndSet(110,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);            }        });        Thread tsf2 = new Thread(new Runnable() {            @Override            public void run() {                int stamp = atomicStampedReference.getStamp();                try {                    TimeUnit.SECONDS.sleep(2);      //线程tsf1执行完                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(&quot;AtomicStampedReference:&quot; +atomicStampedReference.compareAndSet(100,120,stamp,stamp + 1));            }        });        tsf1.start();        tsf2.start();    }}</code></pre><p>运行结果：</p><pre><code>AtomicInteger:trueAtomicStampedReference:false</code></pre><p><strong>注意：</strong>如果，运行结果和我不一样，请注意上面的睡眠时间的设置，才能达到相同的效果！！！</p>]]></content>
      
      
      <categories>
          
          <category> CAS </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap的实现原理</title>
      <link href="/2019/01/14/concurrenthashmap-de-shi-xian-yuan-li/"/>
      <url>/2019/01/14/concurrenthashmap-de-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>接着上篇的HashMap的原理分析后，今天来学ConcurrentHashMap的实现原理<br><a id="more"></a></p><p>在现实开发中，不可避免地会碰到一些多线程并发访问的情况。为了解决这个问题，HashTable 和 HashMap 先后诞生。</p><p>问题也随之而来，使用后发现HashTable 虽然能保证线程安全但是效率低下，而HashMap 虽然效率高于hashTable 但是是非线程安全的。这个很像一个鱼与熊掌的问题，真的不可兼得吗？</p><p>于是人们就考虑有没有一种及支持并发有能保证线程安全的方法。终于，在JDK1.5中，伟大的Doug Lea 给我们带来了concurrent 包，从此Map 也有安全的了，这就是ConcurrentHashMap。安全且高效，像一条长了熊掌的鱼。</p><p>为了更好的理解ConcurrentHashMap的优点，我们先了解下它的两个前辈HashTable 和HashMap。</p><p><strong>HashMap</strong>：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</p><p><strong>HashMap</strong>：非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><p><strong>HashMap的线程安全问题如下：</strong></p><p>在hashmap 做put 操作的时候，假如A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失。同理，当多线程对同一数组位置进行remove操作时也会产生覆盖。</p><p>因此如果不进行额外的外同步操作，HashMap 是非线程安全的。如果加锁必然导致效率低下，而且竞争越激烈，效率越低下。</p><hr><p><strong>Hashtable：</strong>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是<strong>线程安全</strong>的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><p><img src="/images/QQ截图20190114142923.png"></p><p>HashTable 只有一把锁，当一个线程访问HashTable的同步方法时，会将整张table 锁住，当其他线程也想访问HashTable 同步方法时，就会进入阻塞或轮询状态。也就是确保同一时间只有一个线程对同步方法的占用，避免多个线程同时对数据的修改，确保线程的安全性。</p><p>但HashTable 对 get，put，remove 方法都使用了同步操作，这就造成如果两个线程都只想使用get 方法去读取数据时，因为一个线程先到进行了锁操作，另一个线程就不得不等待，这样必然导致效率低下，而且竞争越激烈，效率越低下。</p><hr><h3 id="并发又安全的ConcurrentHashMap"><a href="#并发又安全的ConcurrentHashMap" class="headerlink" title="并发又安全的ConcurrentHashMap"></a>并发又安全的ConcurrentHashMap</h3><p>ConcurrentHashMap 保证线程安全的方法是：<strong>分段锁技术</strong></p><p><img src="/images/QQ截图20190114143134.png"></p><p>ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个Segment数组。</p><p>如上图，在hashMap 的基础上，ConcurrentHashMap 将数据分为多个segment（默认16个），然后每次操作对一个segment 加锁，HashTable 在竞争激烈的并发环境下表现出效率低下的原因是，由于所有访问HashTable的线程都必须竞争同一把锁，而ConcurrentHashMap 将数据分到多个segment 中（默认16，也可在申明时自己设置，不过一旦设定就不能更改，扩容都是扩充各个segment 的容量），每个segment 都有一个自己的锁，只要多个线程访问的不是同一个segment 就没有锁争用，就没有堵塞，也就是允许16个线程并发的更新而尽量没有锁争用。</p><p>ConcurrentHashMap 的 segment 就类似一个HashTable，但比HashTable 更加优化，前面说过HashTable对get，put，remove 方法都会使用锁，而ConcurrnetHashMap 中get 方法是不涉及到锁的。</p><p>在并发读取时，除了key 对应的value 为null 外，并没有用到锁，所以对于读操作无论多少线程并发都是安全高效的。</p><p>举个日常生活中的例子（背景是你在网上订好了一家旅店，然后拿着材料来入住，map就相当于这个旅店，你就相当于是操作map的线程）：上述这家旅店（Collections.synchronizedMap）如果只有一个前台，所有人要登记入住都得在前台办理手续，如果只有你一个人，那么你可以马上入住，如果有一群人，那你就得等着，这样效率不高。而ConcurrentHashMap在每层都有一个前台，你根据你的楼层号（哈希值）去相应的楼层办理入住手续，这样就减少排队等待的概率及时间。</p><hr><h3 id="ConcurrentHashMap源码分析"><a href="#ConcurrentHashMap源码分析" class="headerlink" title="ConcurrentHashMap源码分析"></a>ConcurrentHashMap源码分析</h3><p>ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个Segment数组。</p><pre><code> final Segment&lt;K,V&gt;[] segments;</code></pre><p>Segment继承了 <strong>ReentrantLock</strong>，所以它就是一种可重入锁（ReentrantLock)。在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。（就按默认的ConcurrentLeve为16来讲，理论上就允许16个线程并发执行，有木有很酷）</p><font color="red">所以，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。</font><p>Segment类似于HashMap，一个Segment维护着一个HashEntry数组:</p><pre><code> transient volatile HashEntry&lt;K,V&gt;[] table;</code></pre><p>HashEntry是目前我们提到的最小的逻辑处理单元了。一个ConcurrentHashMap维护一个Segment数组，一个Segment维护一个HashEntry数组。</p><pre><code> static final class HashEntry&lt;K,V&gt; {        final int hash;        final K key;        volatile V value;        volatile HashEntry&lt;K,V&gt; next;        //其他省略}    </code></pre><p>我们说Segment类似哈希表，那么一些属性就跟我们之前提到的HashMap差不离，比如负载因子loadFactor，比如阈值threshold等等，看下Segment的构造方法</p><pre><code>Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) {            this.loadFactor = lf;//负载因子            this.threshold = threshold;//阈值            this.table = tab;//主干数组即HashEntry数组        }</code></pre><p>我们来看下ConcurrentHashMap的构造方法:</p><pre><code>   public ConcurrentHashMap(int initialCapacity , float loadFactor, int concurrencyLevel) {          if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)                throw new IllegalArgumentException();          //MAX_SEGMENTS 为1&lt;&lt;16=65536，也就是最大并发数为65536          if (concurrencyLevel &gt; MAX_SEGMENTS)               concurrencyLevel = MAX_SEGMENTS;          //2的sshif次方等于ssize，例:ssize=16,sshift=4;ssize=32,sshif=5          int sshift = 0;          //ssize 为segments数组长度，根据concurrentLevel计算得出          int ssize = 1;          while (ssize &lt; concurrencyLevel) {              ++sshift;              ssize &lt;&lt;= 1;          }          //segmentShift和segmentMask这两个变量在定位segment时会用到，后面会详细讲          this.segmentShift = 32 - sshift;          this.segmentMask = ssize - 1;          if (initialCapacity &gt; MAXIMUM_CAPACITY)              initialCapacity = MAXIMUM_CAPACITY;          //计算cap的大小，即Segment中HashEntry的数组长度，cap也一定为2的n次方.          int c = initialCapacity / ssize;          if (c * ssize &lt; initialCapacity)              ++c;          int cap = MIN_SEGMENT_TABLE_CAPACITY;          while (cap &lt; c)              cap &lt;&lt;= 1;          //创建segments数组并初始化第一个Segment，其余的Segment延迟初始化          Segment&lt;K,V&gt; s0 =              new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),                               (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);          Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];          UNSAFE.putOrderedObject(ss, SBASE, s0);           this.segments = ss;      }</code></pre><p>初始化方法有三个参数，如果用户不指定则会使用默认值，initialCapacity为16，loadFactor为0.75（负载因子，扩容时需要参考），concurrentLevel为16。</p><p>从上面的代码可以看出来,Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。比如：默认情况下concurrentLevel是16，则ssize为16；若concurrentLevel为14，ssize为16；若concurrentLevel为17，则ssize为32。为什么Segment的数组大小一定是2的次幂？其实主要是便于通过按位与的散列算法来定位Segment的index。</p><h4 id="put的过程分析："><a href="#put的过程分析：" class="headerlink" title="put的过程分析："></a>put的过程分析：</h4><pre><code> public V put(K key, V value) {        Segment&lt;K,V&gt; s;        //concurrentHashMap不允许key/value为空        if (value == null)            throw new NullPointerException();        //hash函数对key的hashCode重新散列，避免差劲的不合理的hashcode，保证散列均匀        int hash = hash(key);        //返回的hash值无符号右移segmentShift位与段掩码进行位运算，定位segment        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment            s = ensureSegment(j);        return s.put(key, hash, value, false);    }</code></pre><p>从源码看出，put的主要逻辑也就两步：1.定位segment并确保定位的Segment已初始化 2.调用Segment的put方法。</p><p>关于segmentShift和segmentMask：</p><p>segmentShift 和 segmentMask 这两个全局变量的主要作用是用来定位Segment，int j =(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask。</p><p><strong>segmentMask：</strong>段掩码，假如segments数组长度为16，则段掩码为16-1=15；segments长度为32，段掩码为32-1=31。这样得到的所有bit位都为1，可以更好地保证散列的均匀性。</p><p><strong>segmentShift：</strong>2的sshift次方等于ssize，segmentShift=32-sshift。若segments长度为16，segmentShift=32-4=28;若segments长度为32，segmentShift=32-5=27。而计算得出的hash值最大为32位，<strong>无符号右移segmentShift，则意味着只保留高几位</strong>（其余位是没用的），然后与段掩码segmentMask位运算来定位Segment。</p><hr><h4 id="get的过程分析："><a href="#get的过程分析：" class="headerlink" title="get的过程分析："></a>get的过程分析：</h4><pre><code> public V get(Object key) {        Segment&lt;K,V&gt; s;         HashEntry&lt;K,V&gt;[] tab;        int h = hash(key);        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;        //先定位Segment，再定位HashEntry        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;            (tab = s.table) != null) {            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);                 e != null; e = e.next) {                K k;                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))                    return e.value;            }        }        return null;    }</code></pre><p><font color="red">get方法无需加锁，由于其中涉及到的共享变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。<font></font></font></p><p>来看下concurrentHashMap代理到Segment上的put方法，Segment中的put方法是要加锁的。只不过是锁粒度细了而已。</p><pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {            //tryLock不成功时会遍历定位到的HashEnry位置的链表（遍历主要是为了使CPU缓存链表)            //若找不到，则创建HashEntry。tryLock一定次数后（MAX_SCAN_RETRIES变量决定）则lock。            //若遍历过程中，由于其他线程的操作导致链表头结点变化，则需要重新遍历。            HashEntry&lt;K,V&gt; node = tryLock() ? null :scanAndLockForPut(key, hash, value);            V oldValue;            try {                HashEntry&lt;K,V&gt;[] tab = table;                //定位HashEntry，可以看到，这个hash值在定位Segment时和在Segment中定位HashEntry都会用到                //只不过定位Segment时只用到高几位。                int index = (tab.length - 1) &amp; hash;                HashEntry&lt;K,V&gt; first = entryAt(tab, index);                for (HashEntry&lt;K,V&gt; e = first;;) {                    if (e != null) {                        K k;                        if ((k = e.key) == key ||                            (e.hash == hash &amp;&amp; key.equals(k))) {                            oldValue = e.value;                            if (!onlyIfAbsent) {                                e.value = value;                                ++modCount;                            }                            break;                        }                        e = e.next;                    }                    else {                        if (node != null)                            node.setNext(first);                        else                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);                        int c = count + 1;　　　　　　　　　　　　 //若c超出阈值threshold，需要扩容并rehash。扩容后的容量是当前容量的2倍。                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)                            rehash(node);                        else                            setEntryAt(tab, index, node);                        ++modCount;                        count = c;                        oldValue = null;                        break;                    }                }            } finally {                unlock();            }            return oldValue;        }</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentHashMap作为一种线程安全且高效的哈希表的解决方案，尤其其中的”分段锁”的方案，相比HashTable的全表锁在性能上的提升非常之大。本文对ConcurrentHashMap的实现原理进行了详细分析，并解读了部分源码，希望能帮助到有需要的童鞋。</p>]]></content>
      
      
      <categories>
          
          <category> ConcurrentHashMap </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的实现原理</title>
      <link href="/2019/01/14/hashmap-de-shi-xian-yuan-li/"/>
      <url>/2019/01/14/hashmap-de-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>帮助大家理解，HashMap的底层原理，方便大家面试<br><a id="more"></a></p><h3 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h3><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p><pre><code>//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</code></pre><p>Entry是HashMap中的一个静态内部类。代码如下:</p><pre><code>    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final K key;        V value;        Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构        int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算        /**         * Creates new entry.         */        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {            hash = h;            key = k;            value = v;            next = n;        } </code></pre><p>所以，HashMap的整体结构如下:<br><img src="/images/QQ截图20190114130741.png"></p><p>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p><p><strong>几个重要字段：</strong></p><pre><code>//实际存储的key-value键值对的个数transient int size;//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到int threshold;//负载因子，代表了table的填充度有多少，默认是0.75final float loadFactor;//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationExceptiontransient int modCount;</code></pre><p>HashMap有4个构造器，其他构造器如果用户没有传入 <strong>initialCapacity</strong> 和 <strong>loadFactor</strong> 这两个参数，会使用默认值:</p><p>initialCapacity默认为16，loadFactory默认为0.75。</p><p>我们看下其中一个:</p><pre><code>public HashMap(int initialCapacity, float loadFactor) {　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                               initialCapacity);        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                               loadFactor);        this.loadFactor = loadFactor;        threshold = initialCapacity;　　　　　        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现    }</code></pre><p>从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组。</p><h4 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><pre><code>    public V put(K key, V value) {        //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间）        //入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)        if (table == EMPTY_TABLE) {            inflateTable(threshold);        }        //如果key为null，存储位置为table[0]或table[0]的冲突链上        if (key == null)            return putForNullKey(value);        int hash = hash(key); //对key的hashcode进一步计算，确保散列均匀        int i = indexFor(hash, table.length); //获取在table中的实际位置        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {        //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value            Object k;            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {                V oldValue = e.value;                e.value = value;                e.recordAccess(this);                return oldValue;            }        }        modCount++; //保证并发访问时，若HashMap内部结构发生变化，快速响应失败        addEntry(hash, key, value, i); //新增一个entry        return null;    }  </code></pre><p><strong>inflateTable方法：</strong></p><pre><code>private void inflateTable(int toSize) {        //capacity一定是2的次幂        int capacity = roundUpToPowerOf2(toSize);         //此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值        //capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);        table = new Entry[capacity];        initHashSeedAsNeeded(capacity);    }</code></pre><p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过 <strong>roundUpToPowerOf2(toSize)</strong> 可以确保capacity为大于或等于toSize的最接近toSize的二次幂，<strong>比如 toSize=13, 则capacity=16; to_size=16, capacity=16 ; to_size=17 , capacity=32.</strong></p><p><strong>roundUpToPowerOf2方法：</strong></p><pre><code> private static int roundUpToPowerOf2(int number) {        // assert number &gt;= 0 : &quot;number must be non-negative&quot;;        return number &gt;= MAXIMUM_CAPACITY                ? MAXIMUM_CAPACITY                : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;    }</code></pre><p>roundUpToPowerOf2 中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit 是用来获取最左边的bit（其他bit位为0）所代表的数值.</p><p><strong>hash函数：</strong></p><pre><code>//这是一个神奇的函数，用了很多的异或，移位等运算//对key的hashcode 进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀final int hash(Object k) {        int h = hashSeed;        if (0 != h &amp;&amp; k instanceof String) {            return sun.misc.Hashing.stringHash32((String) k);        }        h ^= k.hashCode();        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);    }</code></pre><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置.</p><p><strong>indexFor方法：</strong></p><pre><code>    /**     * 返回数组下标     */    static int indexFor(int h, int length) {        return h &amp; (length-1);    }</code></pre><p>h &amp;（length-1）保证获取的 index 一定在数组范围内，举个例子，默认容量16，length-1=15，h=18 , 转换成二进制计算为:</p><pre><code>        1  0  0  1  0    &amp;   0  1  1  1  1    __________________        0  0  0  1  0    = 2</code></pre><p>最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）。</p><p>所以最终存储位置的确定流程是这样的：<br><img src="/images/QQ截图20190114133102.png"></p><p>再来看看<strong>addEntry</strong>的实现：</p><pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {        // 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {            resize(2 * table.length);            // 扩容以后，重新计算 hash 值            hash = (null != key) ? hash(key) : 0;            // 重新计算扩容后的新的下标            bucketIndex = indexFor(hash, table.length);        }        // 往下看        createEntry(hash, key, value, bucketIndex);    }// 这个很简单，其实就是将新值放到链表的表头，然后 size++void createEntry(int hash, K key, V value, int bucketIndex) {    Entry&lt;K,V&gt; e = table[bucketIndex];    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);    size++;}</code></pre><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p><p><strong>resize方法：</strong></p><pre><code>void resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    if (oldCapacity == MAXIMUM_CAPACITY) {        threshold = Integer.MAX_VALUE;        return;    }    // 新的数组    Entry[] newTable = new Entry[newCapacity];    // 将原来数组中的值迁移到新的更大的数组中    transfer(newTable, initHashSeedAsNeeded(newCapacity));    table = newTable;    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);}</code></pre><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p><p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。</p><h3 id="为何HashMap的数组长度一定是2的次幂？"><a href="#为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="为何HashMap的数组长度一定是2的次幂？"></a>为何HashMap的数组长度一定是2的次幂？</h3><p>上述，我们已经知道了数组扩容的知识了，如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法：</p><pre><code>void transfer(Entry[] newTable, boolean rehash) {        int newCapacity = newTable.length;　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）        for (Entry&lt;K,V&gt; e : table) {            while(null != e) {                Entry&lt;K,V&gt; next = e.next;                if (rehash) {                    e.hash = null == e.key ? 0 : hash(e.key);                }                int i = indexFor(e.hash, newCapacity);　　　　　　　　//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。                e.next = newTable[i];                newTable[i] = e;                e = next;            }        }    }</code></pre><p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><p>hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会<strong>保证低位全为1</strong>，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p><p><img src="/images/QQ截图20190114134358.png"></p><p>还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p><p><img src="/images/QQ截图20190114134446.png"></p><p>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p><p><img src="/images/QQ截图20190114134636.png"></p><p>如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。(如上图)</p><hr><h4 id="get过程分析"><a href="#get过程分析" class="headerlink" title="get过程分析"></a>get过程分析</h4><pre><code> public V get(Object key) {　　　　 //如果key为null,则直接去table[0]处去检索即可。        if (key == null)            return getForNullKey();        Entry&lt;K,V&gt; entry = getEntry(key);        return null == entry ? null : entry.getValue(); }</code></pre><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法:</p><p><strong>getEntry方法：</strong></p><pre><code>final Entry&lt;K,V&gt; getEntry(Object key) {        if (size == 0) {            return null;        }        //通过key的hashcode值计算hash值        int hash = (key == null) ? 0 : hash(key);        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];             e != null;             e = e.next) {            Object k;            if (e.hash == hash &amp;&amp;                 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                return e;        }        return null;    } </code></pre><p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。<font color="red">要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，<strong>e.hash == hash这个判断没必要</strong>，仅通过equals判断就可以。</font>其实不然，试想一下，<font color="red">如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null</font>，后面的例子会做出进一步解释。</p><hr><h3 id="重写equals方法需同时重写hashCode方法"><a href="#重写equals方法需同时重写hashCode方法" class="headerlink" title="重写equals方法需同时重写hashCode方法"></a>重写equals方法需同时重写hashCode方法</h3><p>关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题呢？</p><pre><code>public class MyTest {    private static class Person{        int idCard;        String name;        public Person(int idCard, String name) {            this.idCard = idCard;            this.name = name;        }        @Override        public boolean equals(Object o) {            if (this == o) {                return true;            }            if (o == null || getClass() != o.getClass()){                return false;            }            Person person = (Person) o;            //两个对象是否等值，通过idCard来确定            return this.idCard == person.idCard;        }    }    public static void main(String []args){        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();        Person person = new Person(1234,&quot;乔峰&quot;);        //put到hashmap中去        map.put(person,&quot;天龙八部&quot;);        //get取出，从逻辑上讲应该能输出“天龙八部”        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));    }}</code></pre><p>实际输出结果：</p><font color="red"><strong>结果：null</strong></font><p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p><p>所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>]]></content>
      
      
      <categories>
          
          <category> HashMap </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java原子类实现原理分析</title>
      <link href="/2019/01/13/java-yuan-zi-lei-shi-xian-yuan-li-fen-xi/"/>
      <url>/2019/01/13/java-yuan-zi-lei-shi-xian-yuan-li-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>浅谈java中的原子类实现原理<br><a id="more"></a></p><p>在谈谈java中的volatile一文中，我们提到过并发包中的原子类可以解决类似num++这样的复合类操作的原子性问题，相比锁机制，使用原子类更精巧轻量，性能开销更小，本章就一起来分析下原子类的实现机理。</p><h3 id="悲观的解决方案（阻塞同步）"><a href="#悲观的解决方案（阻塞同步）" class="headerlink" title="悲观的解决方案（阻塞同步）"></a>悲观的解决方案（阻塞同步）</h3><p>我们知道，num++看似简单的一个操作，实际上是由<strong>1.读取 2.加一 3.写入 </strong>三步组成的，这是个复合类的操作（所以我们之前提到过的volatile是无法解决num++的原子性问题的），在并发环境下，如果不做任何同步处理，就会有线程安全问题。最直接的处理方式就是<strong>加锁</strong>。</p><pre><code>synchronized(this){    num++; }</code></pre><p>使用独占锁机制来解决，是一种<strong>悲观的并发策略</strong>，抱着一副“总有刁民想害朕”的态势，每次操作数据的时候都认为别的线程会参与</p><p>竞争修改，所以直接加锁。同一刻只能有一个线程持有锁，那其他线程就会阻塞。线程的挂起恢复会带来很大的性能开销，尽管</p><p>jvm对于非竞争性的锁的获取和释放做了很多优化，但是一旦有多个线程竞争锁，频繁的阻塞唤醒，还是会有很大的性能开销的。</p><p>所以，使用synchronized或其他重量级锁来处理显然不够合理。</p><hr><h3 id="乐观的解决方案（非阻塞同步）"><a href="#乐观的解决方案（非阻塞同步）" class="headerlink" title="乐观的解决方案（非阻塞同步）"></a>乐观的解决方案（非阻塞同步）</h3><p>乐观的解决方案，顾名思义，就是很大度乐观，每次操作数据的时候，都认为别的线程不会参与竞争修改，也不加锁。如果操作成功了那最好；如果失败了，比如中途确有别的线程进入并修改了数据（依赖于冲突检测），也不会阻塞，可以采取一些补偿机制，一般的策略就是<strong>反复重试</strong>。很显然，这种思想相比简单粗暴利用锁来保证同步要合理的多。</p><p>鉴于并发包中的原子类其实现机理都差不太多，本章我们就通过AtomicInteger这个原子类来进行分析。我们先来看看对于num++这样的操作AtomicInteger是如何保证其原子性的。</p><pre><code> /**     * Atomically increments by one the current value.     *     * @return the updated value     */    public final int incrementAndGet() {        for (;;) {            int current = get();            int next = current + 1;            if (compareAndSet(current, next))                return next;        }    }</code></pre><p>我们来分析下incrementAndGet的逻辑：</p><ol><li><p>先获取当前的value值</p></li><li><p>对value加一</p></li><li><p>第三步是关键步骤，调用<strong>compareAndSet</strong>方法来来进行原子更新操作，这个方法的语义是：</p></li></ol><font color="red"><strong>先检查当前value是否等于current，如果相等，则意味着value没被其他线程修改过，更新并返回true。如果不相等，compareAndSet则会返回false，然后循环继续尝试更新。</strong></font><p>compareAndSet调用了Unsafe类的compareAndSwapInt方法:</p><pre><code>/**     * Atomically sets the value to the given updated value     * if the current value {@code ==} the expected value.     *     * @param expect the expected value     * @param update the new value     * @return true if successful. False return indicates that     * the actual value was not equal to the expected value.     */    public final boolean compareAndSet(int expect, int update) {        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);    }</code></pre><p>Unsafe的compareAndSwapInt是个native方法，也就是平台相关的。它是基于CPU的CAS指令来完成的。</p><pre><code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code></pre><hr><h3 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS(Compare-and-Swap)"></a>CAS(Compare-and-Swap)</h3><p>CAS算法是由硬件直接支持来保证原子性的，有三个操作数：<font color="red"><strong>内存位置V、旧的预期值A 和 新值B，当且仅当V符合预期值A时，CAS用新值B原子化地更新V的值，否则，它什么都不做。</strong></font></p><p><strong>CAS的ABA问题:</strong></p><p>当然CAS也并不完美，它存在”ABA”问题，假若一个变量初次读取是A，<strong>在compare阶段依然是A，但其实可能在此过程中</strong>，<strong>它先被改为B，再被改回A</strong>，<strong>而CAS是无法意识到这个问题的。</strong>CAS只关注了比较前后的值是否改变，而无法清楚在此过程中变量的变更明细，这就是所谓的ABA漏洞。 </p>]]></content>
      
      
      <categories>
          
          <category> 原子类 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 原子类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈java中的volatile</title>
      <link href="/2019/01/13/tan-tan-java-zhong-de-volatile/"/>
      <url>/2019/01/13/tan-tan-java-zhong-de-volatile/</url>
      
        <content type="html"><![CDATA[<p>浅谈java中的volatile关键字<br><a id="more"></a></p><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>volatile是Java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色。同synchronized相比（synchronized通常称为重量级锁），volatile更轻量级，相比使用synchronized所带来的庞大开销，倘若能恰当的合理的使用volatile，自然是美事一桩。</p><p>为了能比较清晰彻底的理解volatile，我们一步一步来分析。首先来看看如下代码：</p><pre><code>public class TestVolatile {    boolean status = false;    /**     * 状态切换为true     */    public void changeStatus(){        status = true;    }    /**     * 若状态为true，则running。     */    public void run(){        if(status){            System.out.println(&quot;running....&quot;);        }    }}</code></pre><p>上面这个例子，在 <strong>多线程环境</strong> 里，假设 线程A 执行changeStatus()方法后 , 线程B 运行run()方法，可以保证输出”running…..”吗？</p><font color="red">答案是NO! </font><p>这个结论会让人有些疑惑，可以理解。因为倘若在单线程模型里，先运行changeStatus方法，再执行run方法，自然是可以正确输出”running….”的；但是在多线程模型中，是没法做这种保证的。因为对于共享变量status来说，线程A的修改，对于线程B来讲，<strong>是”不可见”的</strong>。也就是说，线程B此时可能无法观测到status已被修改为true。那么什么是可见性呢？</p><font color="red">所谓可见性，是指当一条线程修改了共享变量的值，新值对于其他线程来说是<strong>可以立即得知的</strong>。很显然，上述的例子中是没有办法做到内存可见性的。</font><p><strong>Java内存模型</strong></p><p>为什么出现这种情况呢，我们需要先了解一下JMM（java内存模型）</p><p>java虚拟机有自己的内存模型（Java Memory Model，JMM），JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p><p>JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。这三者之间的交互关系如下:</p><p><img src="/images/QQ截图20190113132739.png"></p><p>　　需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。当然如果是出于理解的目的，这样对应起来也无不可。</p><p>大概了解了JMM的简单定义后，问题就很容易理解了，对于普通的共享变量来讲，比如我们上文中的status，线程A将其修改</p><p>为true这个动作发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B缓存了status的初始值false，此时可能</p><p>没有观测到status的值被修改了，所以就导致了上述的问题。那么这种共享变量在多线程模型中的不可见性如何解决呢？比</p><p>较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，有点炮打蚊子的意思。比较合理的方式其实就是volatile。</p><p>volatile具备两种特性，第一就是保证共享变量对所有线程的可见性。将一个共享变量声明为volatile后，会有以下效应：</p><ul><li><p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去；</strong></p></li><li><p><strong>这个写会操作会导致其他线程中的缓存无效。</strong></p></li></ul><p>上面的例子只需将status声明为volatile，即可保证在线程A将其修改为true时，线程B可以立刻得知：</p><p><code>volatile boolean status = false;</code></p><hr><h3 id="留意复合类操作"><a href="#留意复合类操作" class="headerlink" title="留意复合类操作"></a>留意复合类操作</h3><p>但是需要注意的是，我们一直在拿volatile和synchronized做对比，仅仅是因为这两个关键字在某些内存语义上有共通之处，volatile并不能完全替代synchronized，它依然是个轻量级锁，在很多场景下，volatile并不能胜任。看下这个例子：</p><pre><code>package test;import java.util.concurrent.CountDownLatch;public class Counter {    public static volatile int num = 0;    //使用CountDownLatch来等待计算线程执行完    static CountDownLatch countDownLatch = new CountDownLatch(30);    public static void main(String []args) throws InterruptedException {        //开启30个线程进行累加操作        for(int i=0;i&lt;30;i++){            new Thread(){                public void run(){                    for(int j=0;j&lt;10000;j++){                        num++;//自加操作                    }                    countDownLatch.countDown();                }            }.start();        }        //等待计算线程执行完        countDownLatch.await();        System.out.println(num);    }}</code></pre><p>执行结果：</p><p><code>224291</code></p><p>针对这个示例，一些同学可能会觉得疑惑，如果用volatile修饰的共享变量可以保证可见性，那么结果不应该是<code>300000么</code>?</p><p>问题就出在num++这个操作上，<strong>因为num++不是个原子性的操作</strong>，<strong>而是个复合操作</strong>。我们可以简单讲这个操作理解为由这三步组成:</p><ol><li><p>读取</p></li><li><p>加一</p></li><li><p>赋值</p></li></ol><p>所以，在多线程环境下，有可能线程A将num读取到本地内存中，此时其他线程可能已经将num增大了很多，线程A依然对过期的num进行自加，重新写到主存中，最终导致了num的结果不合预期，而是小于30000。</p><hr><h3 id="解决num-操作的原子性问题"><a href="#解决num-操作的原子性问题" class="headerlink" title="解决num++操作的原子性问题"></a>解决num++操作的原子性问题</h3><p>针对 num++ 这类复合类的操作，可以使用 java并发包 中的原子操作类 , 原子操作类是通过循环CAS的方式来保证其原子性的。</p><pre><code>public class Counter {　　//使用原子操作类    public static AtomicInteger num = new AtomicInteger(0);    //使用CountDownLatch来等待计算线程执行完    static CountDownLatch countDownLatch = new CountDownLatch(30);    public static void main(String []args) throws InterruptedException {        //开启30个线程进行累加操作        for(int i=0;i&lt;30;i++){            new Thread(){                public void run(){                    for(int j=0;j&lt;10000;j++){                        num.incrementAndGet();//原子性的num++,通过循环CAS方式                    }                    countDownLatch.countDown();                }            }.start();        }        //等待计算线程执行完        countDownLatch.await();        System.out.println(num);    }}</code></pre><p>执行结果:</p><p><code>300000</code></p><p>关于原子类操作的基本原理，会在以后的章节进行介绍，此处不再赘述。</p><hr><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>volatile还有一个特性：<strong>禁止指令重排序优化。</strong></p><font color="red">重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。但是重排序也需要遵守一定规则：</font><p><strong>1.重排序操作不会对存在数据依赖关系的操作进行重排序。</strong></p><p>比如：a=1; b=a;  这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><p><strong>2.重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</strong></p><p>比如：a=1; b=2; c=a+b 这三个操作，第一步（a=1) 和 第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</p><p>重排序在单线程模式下是一定会保证最终结果的正确性，但是在多线程环境下，问题就出来了，来开个例子，我们对第一个TestVolatile的例子稍稍改进，再增加个共享变量a:</p><pre><code>public class TestVolatile {    int a = 1;    boolean status = false;    /**     * 状态切换为true     */    public void changeStatus(){        a = 2; //1        status = true; //2    }    /**     * 若状态为true，则running。     */    public void run(){        if(status){ //3            int b = a + 1; //4            System.out.println(b);        }    }}</code></pre><p>假设线程A执行changeStatus后，线程B执行run，我们能保证在4处，b一定等于3么？</p><p><strong>答案依然是无法保证！</strong>也有可能b仍然为2。上面我们提到过，为了提供程序并行度，编译器和处理器可能会对指令进行重排序，</p><p>而上例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true,再执行a=2。而此时线程B会顺利到达4处，</p><p>而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。</p><p><strong>使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序</strong></p><p>volatile禁止指令重排序也有一些规则，简单列举一下：</p><p><strong>1.当第二个操作是voaltile写时，无论第一个操作是什么，都不能进行重排序</strong></p><p><strong>2.当第一个操作是volatile读时，不管第二个操作是什么，都不能进行重排序</strong></p><p><strong>3.当第一个操作是volatile写时，第二个操作是volatile读时，不能进行重排序</strong></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单总结下，volatile是一种轻量级的同步机制，它主要有两个特性：一是保证共享变量对所有线程的<code>可见性</code>；二是<code>禁止指令重排序优化</code>。同时需要注意的是，<code>volatile对于单个的共享变量的读/写具有原子性</code>，但是像num++这种复合操作，volatile无法保证其原子性，当然文中也提出了解决方案，就是使用并发包中的原子操作类，通过循环CAS地方式来保证num++操作的原子性。关于原子操作类，会在后续的文章进行介绍。</p>]]></content>
      
      
      <categories>
          
          <category> volatile </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试中的单例问题</title>
      <link href="/2019/01/13/mian-shi-zhong-de-dan-li-wen-ti/"/>
      <url>/2019/01/13/mian-shi-zhong-de-dan-li-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>给大家普及一下，我在面试中遇到的单例问题。<br><a id="more"></a></p><p>当我兴冲冲的带着笔记答案参加面试时，突然发现面前的面试官显得很严肃而且眉头紧锁，不知道是工作太累了，还是说他对今天的面试者不是很满意。</p><p>于是我就勇敢的坐过去在他的面前坐了下来，没想到第一道题就让面试官看出了我的水平，因此今天跟大家聊聊面试中单例的问题，希望大家都能了解这块内容。</p><p>在早期的项目代码中，如果我们想使用类的某个方法，我们基本都会创建一个类的对象实例然后再调用方法，这样的实现往往在系统内就会存在某个类的大量实例。如此一来，项目框架很难管理大量的对象，而且如果java虚拟机不能及时回收，容易造成内存溢出。</p><p>首先我们要明白什么是单例，所谓单例就是说在项目框架内某个类的对象实例只存在一个，任何调用方获取到的对象实例都是一个，那么很明显这个类是不能够被外部直接调用类构造器创建的。</p><h3 id="只适合单线程环境（不好）"><a href="#只适合单线程环境（不好）" class="headerlink" title="只适合单线程环境（不好）"></a>只适合单线程环境（不好）</h3><p>我们先看下一个简单的单例设计：<br><img src="/images/QQ截图20190113123252.png"><br>上面代码在单线程是没有问题的，而且只有当线程调用类的静态方法时，才会生成类的静态变量。但是当多线程访问时，上面代码是有问题的，会生成多个对象的实例。</p><p>例如：当两个线程同时运行到判断instance是否为空的if语句，并且instance确实没有创建好时，那么两个线程都会创建一个实例。</p><hr><h3 id="多线程的情况（懒汉式，不好）"><a href="#多线程的情况（懒汉式，不好）" class="headerlink" title="多线程的情况（懒汉式，不好）"></a>多线程的情况（懒汉式，不好）</h3><p>那么，我们可以用另外一种方法实现，比如说在类加载时候就初始化对象的实例，这样后面无论怎么调用类静态方法都不创建新的实例。还有一种方法，但是会<strong>牺牲部分系统性能</strong>，意思就是在多线程访问方法时通过<strong>锁机制</strong>让线程排队访问。我们先通过在类方法上加锁来实现类的单例，比如：<br><img src="/images/QQ截图20190113123708.png"></p><p>注解：在解法一的基础上加上了同步锁，使得在多线程的情况下可以用。</p><p>例如：当两个线程同时想创建实例，由于在一个时刻只有一个线程能得到同步锁，当第一个线程加上锁以后，第二个线程只能等待。</p><p>第一个线程发现实例没有创建，创建之。第一个线程释放同步锁，第二个线程才可以加上同步锁，执行下面的代码。由于第一个线程已经创建了实例，所以第二个线程不需要创建实例。保证在多线程的环境下也只有一个实例。</p><p>缺点：每次通过getInstance方法得到singleton实例的时候都有一个试图去获取同步锁的过程。<strong>而众所周知，加锁是很耗时的。能避免则避免。</strong></p><hr><h3 id="双重锁-Double-CheckLock-机制"><a href="#双重锁-Double-CheckLock-机制" class="headerlink" title="双重锁(Double CheckLock)机制"></a>双重锁(Double CheckLock)机制</h3><p>一方面需要在实例上加上<strong>volatile关键字</strong> 通知操作系统实现线程访问时<strong>内存屏障</strong>，然后还需要在方法中通过虚拟机实现的synchronized来同步方法访问，写法如下：<br><img src="/images/QQ截图20190113124128.png"></p><p>注解：只有当 singleton 为 null 时，需要获取同步锁，创建一次实例。当实例被创建，则无需试图加锁。</p><p>缺点：用 双重 if 判断，复杂，容易出错。</p><hr><h3 id="饿汉式（建议使用）"><a href="#饿汉式（建议使用）" class="headerlink" title="饿汉式（建议使用）"></a>饿汉式（建议使用）</h3><p>如果说我们不考虑服务负载问题，在多线程环境下可以<strong>预先加载类的静态实例</strong>，当虚拟机加载完成类后就会创建类的静态变量，甭管你到时用不用，反正给你留在那里。所有线程访问到的都是同一静态实例，有人也称这种方式为饿汉式，具体写法如下：<br><img src="/images/QQ截图20190113124637.png"></p><p>注解：初试化静态的 singleton 创建一次。如果我们在 Singleton类 里面写一个静态的方法不需要创建实例，它仍然会早早的创建一次实例。而降低内存的使用率。</p><p>缺点：没有 <strong>延迟加载</strong> 的效果，从而降低内存的使用率。</p><h3 id="静态内部内（建议使用）"><a href="#静态内部内（建议使用）" class="headerlink" title="静态内部内（建议使用）"></a>静态内部内（建议使用）</h3><p>上面写法实现单例也是没有问题的，但是有些同学就会觉得如果我只是想调用一个类的某个静态方法，并不想生成它的实例，那有没有其他方法呢，经过各路大神的指点结合自身的总结，可以使用内部静态类来实现这个需求。</p><p>开发的同学都知道，虚拟机在加载类的过程中一开始并不会初始化类的内部静态类。如果线程调用内部静态类时，虚拟机只会初始化一次，这样既可以实现单例，同时也是线程安全的。具体写法如下：<br><img src="/images/QQ截图20190113130451.png"></p><p>注解：定义一个私有的内部类，在第一次用这个嵌套类时，会创建一个实例。而类型为SingletonHolder的类，只有在Singleton.getInstance()中调用时，由于私有的属性，他人无法使用SingletonHolder，不调用Singleton.getInstance()就不会创建实例。</p><p>优点：达到了 <strong>延迟加载</strong> 的效果，即按需创建实例。</p><hr><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>除了以上讲到的几种方式外，JDK自身的枚举类型本身就是单例的实现，调用者不能显式的调用构造器完成实例创建，因此很多Java规范文档推荐使用枚举来实现单例。<br><img src="/images/QQ截图20190113130413.png"></p><p>上面提到的四种实现多线程下单例的方式都有共同的缺点：</p><p>1）需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例。</p><p>2）可以使用反射强行调用私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）</p><p>而枚举类很好的解决了这两个问题，使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。因此，《Effective Java》作者推荐使用的方法。不过，在实际工作中，很少看见有人这么写。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文总结了五种Java中实现单例的方法，其中懒汉式和饿汉式两种都不够完美，双重校验锁 和 静态内部类的方式可以解决大部分问题，平时工作中使用的最多的也是这两种方式。枚举方式虽然很完美的解决了各种问题，但是这种写法多少让人感觉有些生疏。</p><p>个人的建议是，在没有特殊需求的情况下，使用 <strong>双重校验锁</strong> 和 <strong>静态内部类</strong> 方式实现单例模式。</p>]]></content>
      
      
      <categories>
          
          <category> 单例 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 单例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中的本地镜像发布到阿里云</title>
      <link href="/2019/01/12/docker-zhong-de-ben-di-jing-xiang-fa-bu-dao-a-li-yun/"/>
      <url>/2019/01/12/docker-zhong-de-ben-di-jing-xiang-fa-bu-dao-a-li-yun/</url>
      
        <content type="html"><![CDATA[<p>这篇主要来学习怎么将Docker中的本地镜像发布到阿里云上面。<br><a id="more"></a></p><h2 id="本地镜像发布到阿里云流程"><a href="#本地镜像发布到阿里云流程" class="headerlink" title="本地镜像发布到阿里云流程"></a>本地镜像发布到阿里云流程</h2><p><img src="/images/QQ截图20190112165829.png"></p><h2 id="镜像的生成方法"><a href="#镜像的生成方法" class="headerlink" title="镜像的生成方法"></a>镜像的生成方法</h2><h3 id="使用Dockerfile文件生成"><a href="#使用Dockerfile文件生成" class="headerlink" title="使用Dockerfile文件生成"></a>使用Dockerfile文件生成</h3><p><code>docker build -f Dockerfile路径 -t 镜像名:TAG</code> 指令来生成，参考Dockerfile文件解析那篇文章。</p><h3 id="从已有的容器中创建一个新的镜像"><a href="#从已有的容器中创建一个新的镜像" class="headerlink" title="从已有的容器中创建一个新的镜像"></a>从已有的容器中创建一个新的镜像</h3><p><code>docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]</code></p><pre><code>OPTIONS说明：-a :提交的镜像作者；-m :提交时的说明文字；</code></pre><p>这里，我使用mycentos:1.3为例，来生成 mycentos:1.4镜像：<br><img src="/images/QQ截图20190112170636.png"></p><p>首先启动 mycentos:1.3 容器：<br><img src="/images/QQ截图20190112170847.png"></p><p>接下来，生成 mycentos:1.4 镜像：</p><p><code>docker commit -a gakki -m &#39;gakki commit mycentos:1.4&#39; mycentos:1.3的容器ID mycentos:1.4</code><br><img src="/images/QQ截图20190112171218.png"></p><hr><h2 id="将本地镜像推送到阿里云"><a href="#将本地镜像推送到阿里云" class="headerlink" title="将本地镜像推送到阿里云"></a>将本地镜像推送到阿里云</h2><h3 id="本地要推送的镜像素材"><a href="#本地要推送的镜像素材" class="headerlink" title="本地要推送的镜像素材"></a>本地要推送的镜像素材</h3><p><img src="/images/QQ截图20190112171359.png"></p><h3 id="进入阿里云开发者平台"><a href="#进入阿里云开发者平台" class="headerlink" title="进入阿里云开发者平台"></a>进入阿里云开发者平台</h3><p><code>https://dev.aliyun.com/search.html</code><br><img src="/images/QQ截图20190112171634.png"><br><img src="/images/QQ截图20190112171805.png"></p><h3 id="创建仓库镜像"><a href="#创建仓库镜像" class="headerlink" title="创建仓库镜像"></a>创建仓库镜像</h3><p><img src="/images/QQ截图20190112172159.png"><br><img src="/images/QQ截图20190112172330.png"><br><img src="/images/QQ截图20190112172701.png"></p><h3 id="将本地镜像推送到阿里云-1"><a href="#将本地镜像推送到阿里云-1" class="headerlink" title="将本地镜像推送到阿里云"></a>将本地镜像推送到阿里云</h3><p><img src="/images/QQ截图20190112172831.png"><br><img src="/images/QQ截图20190112172921.png"></p><pre><code>$ sudo docker login --username=liuzhuo19940206 registry.cn-hangzhou.aliyuncs.com$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/gakkij/mycentos:[镜像版本号]$ sudo docker push registry.cn-hangzhou.aliyuncs.com/gakkij/mycentos:[镜像版本号]如果你是 root，就不需要加上sudo。上面是我的账号，如果是你的话，请改成你的账号，即：拷贝阿里云上面的关键步骤</code></pre><p>第一步：登入<br><img src="/images/QQ截图20190112173427.png"><br><img src="/images/QQ截图20190112173632.png"></p><p>第二步：设置镜像的版本号<br><img src="/images/QQ截图20190112173913.png"></p><p>第三步：推送<br><img src="/images/QQ截图20190112174050.png"><br><img src="/images/QQ截图20190112174317.png"></p><h3 id="在阿里云的公有云可以查到"><a href="#在阿里云的公有云可以查到" class="headerlink" title="在阿里云的公有云可以查到"></a>在阿里云的公有云可以查到</h3><p><img src="/images/QQ截图20190112174617.png"><br><img src="/images/QQ截图20190112174741.png"><br><img src="/images/QQ截图20190112174811.png"></p><h3 id="将阿里云上的镜像下载到本地"><a href="#将阿里云上的镜像下载到本地" class="headerlink" title="将阿里云上的镜像下载到本地"></a>将阿里云上的镜像下载到本地</h3><p><img src="/images/QQ截图20190112175134.png"></p><pre><code>拼接起来如下：docker pull registry.cn-hangzhou.aliyuncs.com/gakkij/mycentos:1.4.1</code></pre><p>首先删除本地的mycentos:1.4.1的镜像：<br><img src="/images/QQ截图20190112175450.png"><br><img src="/images/QQ截图20190112175634.png"><br><img src="/images/QQ截图20190112175722.png"><br><img src="/images/QQ截图20190112175847.png"></p><hr><p>以上，就是今天所有的内容了，相信大家已经学会了，从本地上传镜像到阿里云，也会从阿里云上拉取镜像了。爱生活，爱技术，我是gakkij酱。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中的常用安装</title>
      <link href="/2019/01/12/docker-zhong-de-chang-yong-an-zhuang/"/>
      <url>/2019/01/12/docker-zhong-de-chang-yong-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>今天，主要来介绍Docker中的常用安装，希望大家学习完毕后，可以举一反三。<br><a id="more"></a></p><h2 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h2><ul><li><p>搜索镜像：docker search 镜像名</p></li><li><p>拉取镜像：docker pull 镜像名:TAG</p></li><li><p>查看镜像：docker images 镜像名</p></li><li><p>启动镜像：docker run 镜像名</p></li><li><p>停止容器：docker stop 容器ID</p></li><li><p>移除容器：docker rm 容器ID</p></li></ul><hr><h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><p>1.docker hub 上面查找tomcat镜像 或者 docker search tomcat<br><img src="/images/QQ截图20190112143621.png"><br><img src="/images/QQ截图20190112143711.png"></p><p>2.从docker hub上面拉取tomcat镜像到本地</p><p><code>docker pull tomcat</code></p><p>官网命令：<br><img src="/images/QQ截图20190112143916.png"></p><p>拉取完成：<br><img src="/images/QQ截图20190112144007.png"></p><p>3.docker images 查看是否有拉取到的tomcat<br><img src="/images/QQ截图20190112144124.png"></p><p>4.使用tomcat镜像启动容器</p><p><code>docker run -it -p 8080:8080 tomcat</code><br><img src="/images/QQ截图20190112144307.png"><br><img src="/images/QQ截图20190112144405.png"></p><hr><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>1.从docker hub上面搜索mysql镜像<br><img src="/images/QQ截图20190112144556.png"><br><img src="/images/QQ截图20190112144632.png"></p><p>2.从docker hub上拉取mysql镜像到本地，标签为：5.6</p><p><img src="/images/QQ截图20190112145414.png"></p><p><img src="/images/QQ截图20190112145518.png"></p><p>3.启动mysql镜像</p><pre><code>docker run -p 3306:3306 --name mysql -v /gakki/mysql/conf:/etc/mysql/conf.d -v /gakki/mysql/logs:/logs -v /gakki/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6拆开：docker run -p 3306:3306 --name mysql -v /gakki/mysql/conf:/etc/mysql/conf.d -v /gakki/mysql/logs:/logs -v /gakki/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456-d mysql:5.6命令说明：-p 3306:3306：将主机的3306端口映射到docker容器的3306端口。--name mysql：运行服务名字-v /gakki/mysql/conf:/etc/mysql/conf.d ：将主机/gakki/mysql目录下的conf目录 挂载到容器的 /etc/mysql/conf.d-v /gakki/mysql/logs:/logs：将主机/gakki/mysql目录下的 logs 目录挂载到容器的 /logs。-v /gakki/mysql/data:/var/lib/mysql ：将主机/gakki/mysql目录下的data目录挂载到容器的 /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。-d mysql:5.6 : 后台程序运行mysql5.6docker run -p 3306:3306 --name mysql -v /gakki/mysql/conf:/etc/mysql/conf.d -v /gakki/mysql/logs:/logs -v /gakki/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</code></pre><p><img src="/images/QQ截图20190112150227.png"></p><p>4.进入启动后的mysql容器内：</p><p><code>docker exec -it MySQL运行成功后的容器ID /bin/bash</code><br><img src="/images/QQ截图20190112150441.png"></p><p>进入容器中的mysql服务内：</p><p><code>mysql -uroot -p</code></p><p><code>Enter password: 输入你的mysql密码</code></p><p><img src="/images/QQ截图20190112150631.png"><br><img src="/images/QQ截图20190112150933.png"><br><img src="/images/QQ截图20190112151207.png"><br><img src="/images/QQ截图20190112151353.png"></p><p>5.使用我们的windows机来验证这个mysql是否成功：<br><img src="/images/QQ截图20190112151634.png"><br><img src="/images/QQ截图20190112151745.png"></p><p>现在，在windows上面插入数据，在docker容器检查：<br><img src="/images/QQ截图20190112151908.png"><br><img src="/images/QQ截图20190112152012.png"></p><hr><p>5.备份数据</p><p><code>docker exec myql服务容器ID sh -c &#39;exec mysqldump --all-databases -uroot -p&quot;123456&quot;&#39; &gt; /gakki/all-databases.sql</code><br><img src="/images/QQ截图20190112152311.png"></p><p>然后，我们就可以使用这个备份文件来恢复数据，或者在其他机器上执行。</p><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><p>1.从docker hub上搜索redis镜像<br><img src="/images/QQ截图20190112152715.png"><br><img src="/images/QQ截图20190112152740.png"></p><p>2.拉取redis镜像，标签为：3.2<br><img src="/images/QQ截图20190112153022.png"><br><img src="/images/QQ截图20190112153127.png"></p><p>3.使用redis:3.2生成容器</p><pre><code>docker run -p 6379:6379 --name myredis -v /gakki/myredis/data:/data -v /gakki/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis:3.2 redis-server /usr/local/etc/redis/redis.conf --appendonly yes拆开：docker run -p 6379:6379 --name myredis -v /gakki/myredis/data:/data-v /gakki/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf-d redis:3.2 redis-server /usr/local/etc/redis/redis.conf--appendonly yes</code></pre><p><img src="/images/QQ截图20190112153817.png"></p><p>4.在宿主机的：/gakki/myredis/conf/redis.conf目录下：新建redis.conf文件</p><p><code>vim /gakki/myredis/conf/redis.conf/redis.conf</code></p><p>redis.conf内容：</p><pre><code>就是标准的redis.conf的内容，这里就不演示了，因为文件内容比较多。主要是：关闭 bind 主机的功能：# bind 127.0.0.1</code></pre><p><img src="/images/QQ截图20190112154401.png"><br><img src="/images/QQ截图20190112154536.png"></p><p>5.使用redis-cli来测试：</p><p><code>docker exec -it 运行着Redis服务的容器ID redis-cli</code><br><img src="/images/QQ截图20190112154823.png"></p><p>6.测试持久化文件<br><img src="/images/QQ截图20190112155035.png"></p><hr><p>我相信大家对这三个常用的软件安装熟悉后，对于其他的软件安装应该也就没有问题了。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中的Dockerfile解析</title>
      <link href="/2019/01/11/docker-zhong-de-dockerfile-jie-xi/"/>
      <url>/2019/01/11/docker-zhong-de-dockerfile-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>这篇专门来讲解Docker中比较重要的DockerFile文件<br><a id="more"></a></p><h2 id="DockerFile是什么"><a href="#DockerFile是什么" class="headerlink" title="DockerFile是什么"></a>DockerFile是什么</h2><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p><p>构建三步骤：</p><ul><li><p>编写Dockerfile文件</p></li><li><p>docker build</p></li><li><p>docker run</p></li></ul><p>Dockerfile文件是什么样呢？</p><p>以我们熟悉的CentOS为例：</p><p><img src="/images/QQ截图20190111192141.png"><br><img src="/images/QQ截图20190111192322.png"><br><img src="/images/QQ截图20190111192232.png"></p><hr><h2 id="DockerFile构建过程解析"><a href="#DockerFile构建过程解析" class="headerlink" title="DockerFile构建过程解析"></a>DockerFile构建过程解析</h2><h3 id="Dockerfile内容基础知识"><a href="#Dockerfile内容基础知识" class="headerlink" title="Dockerfile内容基础知识"></a>Dockerfile内容基础知识</h3><p>1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数</p><p>2：指令按照从上到下，顺序执行</p><p>3：#表示注释</p><p>4：每条指令都会创建一个新的镜像层，并对镜像进行提交</p><h3 id="Docker执行Dockerfile的流程"><a href="#Docker执行Dockerfile的流程" class="headerlink" title="Docker执行Dockerfile的流程"></a>Docker执行Dockerfile的流程</h3><p>（1）docker从基础镜像运行一个容器</p><p>（2）执行一条指令并对容器作出修改</p><p>（3）执行类似docker commit的操作提交一个新的镜像层</p><p>（4）docker再基于刚提交的镜像运行一个新容器</p><p>（5）执行dockerfile中的下一条指令直到所有指令都执行完成</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段：</p><ul><li><p>Dockerfile是软件的原材料</p></li><li><p>Docker镜像是软件的交付品</p></li><li><p>Docker容器则可以认为是软件的运行态。</p></li></ul><p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p><p><img src="/images/QQ截图20190111192957.png"></p><ol><li><p>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p></li><li><p>Docker镜像，在用Dockerfile定义一个文件之后，docker build 时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</p></li><li><p>Docker容器，容器是直接提供服务的。</p></li></ol><h2 id="DockerFile体系结构-保留字指令"><a href="#DockerFile体系结构-保留字指令" class="headerlink" title="DockerFile体系结构(保留字指令)"></a>DockerFile体系结构(保留字指令)</h2><pre><code>FROM:         基础镜像，当前新镜像是基于哪个镜像的MAINTAINER:   镜像维护者的姓名和邮箱地址RUN:          容器构建时需要运行的linux命令EXPOSE:       当前容器对外暴露出的端口------------------------------------------------------ENV:          用来在构建镜像过程中设置环境变量ENV MY_PATH /usr/mytest这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以在其它指令中直接使用这些环境变量，比如：WORKDIR $MY_PATH------------------------------------------------------WORKDIR:      指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点ADD:          将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包COPY:         类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置.VOLUME:       容器数据卷，用于数据保存和持久化工作。-------------------------------------------------------CMD:          指定一个容器启动时要运行的命令,Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换.CMD指令的格式与RUN相似，也是两种格式：shell 格式：CMD &lt;命令&gt;exec 格式：CMD [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;,···]参数列表格式：CMD [&quot;参数1&quot;,&quot;参数2&quot;,···]。在指定了 ENTRYPOINT 指令后，可以用 CMD 指定具体的参数。--------------------------------------------------------ENTRYPOINT：  指定一个容器启动时要运行的命令，ENTRYPOINT 的目的 和 CMD 一样，都是在指定容器启动程序及参数，但是它是叠加命令，不是覆盖命令。ONBUILD：     当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</code></pre><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p><img src="/images/QQ截图20190111194330.png"></p><hr><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="Base镜像-scratch"><a href="#Base镜像-scratch" class="headerlink" title="Base镜像(scratch)"></a>Base镜像(scratch)</h3><p>Docker Hub 中 99% 的镜像都是 通过在 base 镜像中安装和配置需要的软件构建出来的。<code>scratch</code> 就是最基础的镜像，和 java中对象默认继承Object对象一样。<br><img src="/images/QQ截图20190111194719.png"></p><h3 id="自定义镜像mycentos"><a href="#自定义镜像mycentos" class="headerlink" title="自定义镜像mycentos"></a>自定义镜像mycentos</h3><h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><p>1.默认的centos镜像是什么情况呢？<br><img src="/images/QQ截图20190111195155.png"></p><p>现在：我们想创建自己的mycentos镜像，修改登入后的工作目录，支持vim编辑器，支持ifconfig网络配置。</p><p>2.编写dockerfile文件</p><p>由于之前，我们在mydocker文件下，写过Dockerfile文件，所以接着在里面写了，你们如果没有，就在根目录下创建即可，随意。<br><img src="/images/QQ截图20190111195627.png"></p><p>Dockerfile文件中的内容：</p><pre><code>FROM centos                               #继承centos镜像MAINTAINER gakki&lt;gakki167@126.com&gt;        #填写作者与邮箱地址ENV mypath /usr/local                     #编写环境变量，方便后续使用WORKDIR $mypath                           #修改登入后的工作目录RUN yum -y install vim                    #使用RUN命令，下载vim编辑RUN yum -y install net-tools              #使用RUN命令，下载网络配置工具EXPOSE 80                                 #暴露端口号为80CMD echo $mypath                          #为了测试，随便写的，不写也行CMD echo &quot;success--------------ok&quot;        #为了测试，随便写的，不写也行CMD /bin/bash                             #启动容器，执行/bin/bash命令</code></pre><p><img src="/images/QQ截图20190111200217.png"></p><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p><code>docker build -f Dockerfile文件的路径 -t 新镜像名字:TAG .</code>  注意最后有一个点,  . 表示当前目录</p><p>如果当前目录下，存在Dockerfile文件话，而且就是<code>Dockerfile</code>这个名字，那么可以不写 <code>-f Dockerfile的路径</code></p><pre><code>docker build -t mycentos:1.3 .</code></pre><p><img src="/images/QQ截图20190111200803.png"></p><p>然后开始一顿哗啦啦的代码，因为要下载 vim 和 net-tools。<br><img src="/images/QQ截图20190111200933.png"><br><img src="/images/QQ截图20190111201130.png"></p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><code>docker run -it 新镜像名:TAG</code><br><img src="/images/QQ截图20190111201358.png"><br><img src="/images/QQ截图20190111201459.png"><br><img src="/images/QQ截图20190111201548.png"></p><h4 id="列出镜像的变更历史"><a href="#列出镜像的变更历史" class="headerlink" title="列出镜像的变更历史"></a>列出镜像的变更历史</h4><p><code>docker history 镜像名</code><br><img src="/images/QQ截图20190111201937.png"></p><h3 id="CMD-ENTRYPOINT-镜像案例"><a href="#CMD-ENTRYPOINT-镜像案例" class="headerlink" title="CMD/ENTRYPOINT 镜像案例"></a>CMD/ENTRYPOINT 镜像案例</h3><p>为了区分 CMD 与 ENTRYPOINT 命令的区别，而做了案例。</p><p>两者都是：指定一个容器启动时要运行的命令。</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>采用 CMD 的话，当Dockerfile 中有多个 CMD 指令时，只能最后一个生效。而且 CMD 会被 docker run 之后的参数替换。</p><pre><code>比如，当Dockerfile文件中的最后是:CMD [&quot;/bin/bash&quot;]CMD [&quot;ls&quot;,&quot;-l&quot;]那么，只会执行 ls -l 命令，不会执行/bin/bash 命令。当使用 docker run -it 镜像名 ls -l ： 启动容器也是一样的效果，这里的ls -l 会覆盖掉Dockerfile文件中的：CMD [&quot;/bin/bash&quot;]</code></pre><p>这里，我以tomcat为例来演示：</p><p><img src="/images/QQ截图20190111202901.png"></p><p>如果不加 ls -l ，就会执行默认的 CMD [“catalina.sh”, “run”] （上图写错了）<br><img src="/images/QQ截图20190111203033.png"></p><hr><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合，不会覆盖之前的命令。</p><p>制作CMD版可以查询IP信息的容器：</p><p>在mydocker文件夹下，创建Dockerfile2文件：<br><img src="/images/QQ截图20190111203430.png"></p><p>Dockerfile2文件内容：</p><pre><code>FROM centosRUN yum install -y curlCMD [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot;]</code></pre><p><img src="/images/QQ截图20190111204426.png"></p><p>生成 myip镜像：<br><img src="/images/QQ截图20190111203855.png"></p><p>运行 myip镜像：<br><img src="/images/QQ截图20190111204646.png"></p><p>那是因为，我们生成myip的镜像的Dockerfile文件，最后执行了：<code>CMD [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot;]。</code></p><p>如果，我们想要获取抓包过程中的头部信息，还需要加上 -i 。<br><img src="/images/QQ截图20190111204950.png"></p><p>现在，我在启动myip的过程中 加上 -i：<br><img src="/images/QQ截图20190111205157.png"></p><p>因为，我们使用的是CMD，不是ENTRYPOINT，所以，在docker run 后面的参数，会直接覆盖Dockerfile中的<code>CMD [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot;]</code>，相当于现在变成了<code>CMD [&quot;-i&quot;]</code> ，这个当然报错呀，都不知道是什么玩意！！！</p><hr><p>现在，在mydocker文件夹下，创建Dockerfile3：</p><pre><code>FROM centosRUN yum install -y curlENTRYPOINT [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot;]</code></pre><p>唯一的区别就是：将CMD 换成了 ENTRYPOINT 。<br><img src="/images/QQ截图20190111205600.png"></p><p>生成新的镜像：myip2<br><img src="/images/QQ截图20190111205729.png"></p><p>启动 myip2 容器：<br><img src="/images/QQ截图20190111205905.png"></p><p>到目前为止，都和CMD一样。现在 再次启动 myip2 还面带上 -i 参数：<br><img src="/images/QQ截图20190111210120.png"></p><p>发现，没有报错，返回了 头部信息 和 主体信息。</p><p>以上：就是 CMD 和 ENTRYPOINT 的区别！！！</p><h4 id="CURL"><a href="#CURL" class="headerlink" title="CURL"></a>CURL</h4><p>考虑到大家有可能对 curl 不熟，这里简单介绍一下：</p><p>curl命令可以用来执行 下载、发送各种HTTP请求，指定HTTP头部等操作。</p><p>如果系统没有curl可以使用 yum install curl安装，也可以下载安装。</p><p><code>curl是将下载文件输出到stdout</code></p><pre><code>使用命令：curl http://www.baidu.com执行后，www.baidu.com的html就会显示在屏幕上了这是最简单的使用方法。用这个命令获得了http://curl.haxx.se指向的页面同样，如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。如果下载的是HTML文档，那么缺省的将只显示文件头部，即HTML文档的header。要全部显示，请加参数 -i</code></pre><hr><h3 id="自定义镜像Tomcat9"><a href="#自定义镜像Tomcat9" class="headerlink" title="自定义镜像Tomcat9"></a>自定义镜像Tomcat9</h3><h4 id="创建一个目录来编写Dockerfile文件"><a href="#创建一个目录来编写Dockerfile文件" class="headerlink" title="创建一个目录来编写Dockerfile文件"></a>创建一个目录来编写Dockerfile文件</h4><p><code>mkdir -p /gakki/mydocker/tomcat9</code><br><img src="/images/QQ截图20190111210844.png"></p><h4 id="在上述目录下创建c-txt"><a href="#在上述目录下创建c-txt" class="headerlink" title="在上述目录下创建c.txt"></a>在上述目录下创建c.txt</h4><p><img src="/images/QQ截图20190111211019.png"></p><p>创建c.txt，主要是为了使用：COPY命令来玩的，没有什么作用意义。</p><h4 id="将jdk和tomcat安装的压缩包拷贝进上一步目录"><a href="#将jdk和tomcat安装的压缩包拷贝进上一步目录" class="headerlink" title="将jdk和tomcat安装的压缩包拷贝进上一步目录"></a>将jdk和tomcat安装的压缩包拷贝进上一步目录</h4><p>在我的centos中，已经下载过 jdk 和 tocmat 的压缩包，如果大家没有，请自行下载，自学，比较简单。</p><p><code>cp /usr/local/src/apache-tomcat-8.5.37.tar.gz ./</code></p><p><code>cp /usr/local/src/jdk-8u191-linux-x64.tar.gz ./</code></p><p><img src="/images/QQ截图20190112105516.png"></p><h4 id="在当前目录下创建Dockerfile文件"><a href="#在当前目录下创建Dockerfile文件" class="headerlink" title="在当前目录下创建Dockerfile文件"></a>在当前目录下创建Dockerfile文件</h4><p><img src="/images/QQ截图20190112105740.png"></p><p>Dockerfile文件内容：</p><pre><code>#基于centos镜像FROM centos#作者以及邮箱MAINTAINER gakki&lt;gakkij@126.com&gt;#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下COPY c.txt /usr/local/copycontainer.txt#把java与tomcat添加到容器中ADD jdk-8u191-linux-x64.tar.gz /usr/local/ADD apache-tomcat-8.5.37.tar.gz /usr/local/#安装vim编辑器RUN yum -y install vim#设置工作访问时候的WORKDIR路径，登录落脚点ENV MYPATH /usr/localWORKDIR $MYPATH#配置java与tomcat环境变量ENV JAVA_HOME /usr/local/jdk1.8.0_191ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-8.5.37ENV CATALINA_BASE /usr/local/apache-tomcat-8.5.37ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin#容器运行时监听的端口EXPOSE  8080#启动时运行tomcat# ENTRYPOINT [&quot;/usr/local/apache-tomcat-8.5.37/bin/startup.sh&quot; ]# CMD [&quot;/usr/local/apache-tomcat-8.5.37/bin/catalina.sh&quot;,&quot;run&quot;]CMD /usr/local/apache-tomcat-8.5.37/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-8.5.37/bin/logs/catalina.out</code></pre><p><img src="/images/QQ截图20190112110723.png"></p><p><strong>注意：</strong>上面的 jdk 和 tomcat 填写成你的机器上面的 jdk 和 tomcat 的版本，不要和我一样，除非你下载的jdk和tomcat的版本和我一样！！！</p><h4 id="构建-1"><a href="#构建-1" class="headerlink" title="构建"></a>构建</h4><p><code>docker build -t gakkitomcat9 .</code></p><p><img src="/images/QQ截图20190112111444.png"><br><img src="/images/QQ截图20190112111531.png"><br><img src="/images/QQ截图20190112111623.png"></p><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><pre><code>docker run -d -p 9080:8080 --name myt9 -v /gakki/mydocker/tomcat9/app:/usr/local/apache-tomcat-8.5.37/webapps/app -v /gakki/mydocker/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-8.5.37/logs --privileged=true gakkitomcat9解释：上面创建了两个数据卷，一个用来创建app来与gakkitomcat9共享，放置网站用的，这样的话，我们直接就可以在宿主机上操作网站中的内容了另一个数据卷是用来存放gakkitomcat9容器启动后的日志信息。</code></pre><p><img src="/images/QQ截图20190112112223.png"><br><img src="/images/QQ截图20190112112335.png"><br><img src="/images/QQ截图20190112112437.png"></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="/images/QQ截图20190112112648.png"><br><img src="/images/QQ截图20190112112801.png"></p><h4 id="发布webapp"><a href="#发布webapp" class="headerlink" title="发布webapp"></a>发布webapp</h4><p>在我们的宿主机的app目录下(数据卷目录)，创建webapp的标准目录结构：</p><pre><code>app---a.jsp---WEB-INF------web.xmlapp目录下：有a.jsp文件 和 WEB-INF目录WEB-INF目录下：有web.xml文件</code></pre><p><img src="/images/QQ截图20190112113341.png"></p><p>web.xml中的内容：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;  xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;  id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;  &lt;display-name&gt;myApp&lt;/display-name&gt;&lt;/web-app&gt;</code></pre><p><img src="/images/QQ截图20190112113625.png"></p><p>a.jsp中的内容：</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    -----------welcome------------    &lt;%=&quot;i am in docker tomcat self &quot;%&gt;    &lt;br&gt;    &lt;br&gt;    &lt;% System.out.println(&quot;=============docker tomcat self&quot;);%&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/QQ截图20190112113715.png"></p><p>测试：</p><p>在浏览器中输入：<code>localhost:9080/app/a.jsp</code><br><img src="/images/QQ截图20190112113853.png"><br><img src="/images/QQ截图20190112113939.png"></p><hr><p>现在，我们稍微修改一下，a.jsp中的内容：</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    -----------welcome------------&lt;br&gt;    &lt;%=&quot;i am update in docker tomcat self &quot;%&gt;    &lt;br&gt;    &lt;br&gt;    &lt;% System.out.println(&quot;=============docker tomcat self&quot;);%&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>就是在：welcome后面加了换行，修改了输出语句加了：update。<br><img src="/images/QQ截图20190112114252.png"></p><p>现在，来查看日志信息：<br><img src="/images/QQ截图20190112115253.png"><br><img src="/images/QQ截图20190112115340.png"></p><p>现在稍微明白容器数据卷的作用的吧，以后我们只需要在宿主机中的 app目录下修改、添加内容，docker容器中就会同步数据，方便开发和查看日志信息。</p><hr><p>现在，我们进入gakkitomcat9中，验证：<br><img src="/images/QQ截图20190112115727.png"><br><img src="/images/QQ截图20190112120945.png"><br><img src="/images/QQ截图20190112121214.png"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/QQ截图20190112121346.png"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中的容器数据卷</title>
      <link href="/2019/01/10/docker-zhong-de-rong-qi-shu-ju-juan/"/>
      <url>/2019/01/10/docker-zhong-de-rong-qi-shu-ju-juan/</url>
      
        <content type="html"><![CDATA[<p>Docker中的容器数据卷，我们知道redis是一个内存数据库，为啥，退出后，下次重启后，数据库中还有之前的数据呢？因为有rdb和aof持久化。<br>因此，Docker中的容器数据卷，也是为了将容器中的数据，保存到宿主机中的技术，防止容器停止后，数据丢失。<br><a id="more"></a></p><h2 id="数据卷是什么"><a href="#数据卷是什么" class="headerlink" title="数据卷是什么"></a>数据卷是什么</h2><p>先来看看Docker的理念：</p><ul><li><p>将应用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</p></li><li><p>容器之间希望有可能共享数据</p></li></ul><p>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。</p><p>为了能保存在docker中的数据，我们使用卷。</p><h2 id="数据卷能干嘛"><a href="#数据卷能干嘛" class="headerlink" title="数据卷能干嘛"></a>数据卷能干嘛</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性。</p><p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><p>1：数据卷可在容器之间共享或重用数据<br>2：卷中的更改可以直接生效<br>3：数据卷中的更改不会包含在镜像的更新中<br>4：数据卷的生命周期一直持续到没有容器使用它为止</p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><p>容器内添加，有两种方式：</p><ul><li><p>直接命令添加</p></li><li><p>DockerFile添加</p></li></ul><h3 id="直接命令添加"><a href="#直接命令添加" class="headerlink" title="直接命令添加"></a>直接命令添加</h3><p><strong><code>docker run -it -v /宿主机绝对路径目录:/容器内目录   镜像名</code></strong></p><pre><code>这里主要就是添加了一个 -v 的选项参数。</code></pre><p>现在，我们来正式演示一遍：</p><p><strong>在宿主机的根目录下创建：mydataVolume目录。</strong></p><p>然后使用：<code>docker run -it -v /mydataVolume:/dataVolumeContainer centos /bin/bash</code> 将两者挂载在一起，实现数据共享。</p><p>该命令会帮我们以交换式的方式启动centos容器，然后会自动帮我们在centos的根目录下创建：dataVolumeContainer目录。</p><p><img src="/images/QQ截图20190111112831.png"><br><img src="/images/QQ截图20190111113633.png"></p><p><strong>查看数据卷是否挂载成功：</strong></p><p><code>docker inspect 容器ID</code><br><img src="/images/QQ截图20190111113940.png"><br><img src="/images/QQ截图20190111114243.png"><br><img src="/images/QQ截图20190111114421.png"></p><p>出现上面的信息，说明挂载数据卷成功。</p><hr><p><strong>宿主机与容器之间数据共享：</strong></p><p>在宿主机中的：mydataVolume目录下：创建一个host.txt文件，随便编写一些数据。</p><p><img src="/images/QQ截图20190111114942.png"><br><img src="/images/QQ截图20190111115028.png"><br><img src="/images/QQ截图20190111115109.png"></p><p>在centos容器中，查看：dataVolumeContainer目录下，是否存在host.txt，并且里面有数据：<br><img src="/images/QQ截图20190111115709.png"></p><p>瞬间懵逼了，后来发现：我是宿主机的root目录下创建的：mydataVolume，然后在该目录下创建的host.txt文件，当然是无法共享的呀。</p><p>因为，<code>docker run -it -v /mydataVolume:/dataVolumeContainer centos /bin/bash</code> <strong>是宿主机的根目录下创建：mydataVolume ！！！！</strong></p><p>现在，在宿主机下，切换到根目录下，发现mydataVolume目录已经存在了，说明执行了：<code>docker run -it -v /mydataVolume:/dataVolumeContainer centos /bin/bash</code> 命令后，会自动帮我们创建这两个共享的目录。</p><p><img src="/images/QQ截图20190111120217.png"><br><img src="/images/QQ截图20190111120316.png"><br><img src="/images/QQ截图20190111120500.png"></p><p>那，在容器下，创建新的文件，修改旧的文件，在宿主机中能更新吗？ 能，数据卷是互相共享的。<br><img src="/images/QQ截图20190111120811.png"><br><img src="/images/QQ截图20190111120941.png"></p><hr><p><strong>那么，容器退出后，在宿主机中修改数据，等到原来的容器再次启动时，数据是否会同步呢？</strong><br><img src="/images/QQ截图20190111121222.png"><br><img src="/images/QQ截图20190111121327.png"></p><p>接着，在宿主机中，修改host.txt文件中的内容：<br><img src="/images/QQ截图20190111121514.png"></p><p>启动，<strong>原先的</strong>centos容器：</p><p><code>docker start 容器的ID</code><br><img src="/images/QQ截图20190111121959.png"></p><p>进入centos容器内部：</p><p><code>docker attach 容器ID</code><br><img src="/images/QQ截图20190111122237.png"></p><p>上面就是，宿主机与容器之间的数据卷共享，可读可写。</p><hr><p><strong>那么，可不可以，只能宿主机可读可写，而容器只读呢？ 可以的。</strong></p><p><code>docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</code></p><p>请看，上面命令，只是下后面加了一个 <code>:ro</code> , ro : readonly的意思，只读。<br><img src="/images/QQ截图20190111122815.png"><br><img src="/images/QQ截图20190111123127.png"><br><img src="/images/QQ截图20190111123217.png"></p><p>使用 <code>docker inspect 容器ID</code><br><img src="/images/QQ截图20190111123350.png"><br><img src="/images/QQ截图20190111123441.png"><br><img src="/images/QQ截图20190111123526.png"></p><hr><h3 id="使用DockerFile添加"><a href="#使用DockerFile添加" class="headerlink" title="使用DockerFile添加"></a>使用DockerFile添加</h3><p>这里，不会讲太多的DockerFile的知识，只是简单带大家了解一下，使用DockerFile来数据共享，下篇文章，我会继续带大家进行DockerFile的探索。</p><p><strong>第一步：在宿主机的根目录下，创建mydocker文件夹并进入：</strong><br><img src="/images/QQ截图20190111135831.png"></p><p>可在 Dockerfile中 使用 <strong>VOLUME指令</strong> 来给镜像添加一个或多个数据卷。</p><p><code>VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]</code></p><p>说明：</p><p>出于 <strong>可移植</strong> 和 <strong>分享</strong> 的考虑，用 -v <strong>主机目录:容器目录</strong> 这种方法不能够直接在Dockerfile中实现。</p><p>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p><p>所以，使用DockerFile来进行数据卷的共享时，不需要创建宿主机的共享目录，只需要确定容器内的共享目录即可，这是与使用 -v 命令的区别所在。</p><p>那么，什么是DockerFile文件呢？ 这里还是带大家简单了解一下：</p><p>打开docker hub的官网，随便搜索一个镜像，比如tomcat：<br><img src="/images/QQ截图20190111141044.png"><br><img src="/images/QQ截图20190111141140.png"><br><img src="/images/QQ截图20190111141243.png"></p><p>简单来看一下：最上面是基于jdk1.8的镜像来生成tomcat镜像的，所以tomcat镜像文件才几百兆，不想在windows中下在一个tomcat几十兆那么小，因为tomcat镜像中包括了jdk的运行环境等，所以比较大。</p><pre><code>EVN :  配置环境变量的EXPOSE 8080   ：配置暴露的端口号CMD [&quot;catalina.sh&quot;, &quot;run&quot;]  ：运行镜像最外层的可写的那层</code></pre><p>使用Dockerfile来数据卷的共享，就是编写一个Dockerfile文件，然后使用这个Dockerfile来生成新的镜像。这里只是简单了解一下。</p><p><strong>第二步，在mydocker文件夹下，编写dockerfile文件：</strong><br><img src="/images/QQ截图20190111141828.png"></p><p>在dockerfile中：</p><pre><code># volume testFROM centos                                               #相当于继承centos镜像VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]  #配置数据卷容器内的目录，可以是多个CMD echo &quot;finished,--------success1&quot;                      #CMD执行命令，这里是简单测试语句CMD /bin/bash                                             #执行 /bin/bash 命令，进入终端</code></pre><p><img src="/images/QQ截图20190111142130.png"><br><img src="/images/QQ截图20190111142226.png"></p><p><strong>第三步，build我们的dockerfile文件，生成镜像</strong></p><p><code>docker build -f /mydocker/dockerfile -t liuzhuo/centos .</code></p><pre><code>-f：     dockerfile文件的路径-t：     命名空间/镜像名称注意：最后有一个 空格 + 点</code></pre><p><img src="/images/QQ截图20190111142918.png"><br><img src="/images/QQ截图20190111143207.png"></p><p><strong>第四步，查看有没有生成新的镜像</strong><br><img src="/images/QQ截图20190111143325.png"></p><p><strong>第五步，启动新的镜像</strong><br><img src="/images/QQ截图20190111143523.png"></p><p><strong>通过上述步骤，容器内的卷目录地址已经知道，对应的主机目录地址哪？？</strong></p><p>使用 <code>docker inspect 容器id</code> 来查看宿主机的目录地址：<br><img src="/images/QQ截图20190111143950.png"><br><img src="/images/QQ截图20190111144227.png"></p><p>这里，我就使用 <strong>/dataVolumeContainer1</strong> 对应的宿主机的地址来演示了</p><pre><code>/var/lib/docker/volumes/ef6a4b962d138913b14a43750d12c1a553c2837c34481ff732796e79e62203b3/_data</code></pre><p><img src="/images/QQ截图20190111144408.png"></p><p>创建新的文件，container.txt<br><img src="/images/QQ截图20190111144609.png"></p><p>然后在，容器中查看是否有：container.txt<br><img src="/images/QQ截图20190111144609.png"><br><img src="/images/QQ截图20190111144738.png"></p><hr><p><strong>备注:</strong></p><p>Docker挂载主机目录Docker访问出现 cannot open directory . : Permission denied</p><p><strong>解决办法：在挂载目录后多加一个 –privileged=true 参数即可。</strong></p><p>即：<code>docker run -it -v /mydataVolume:/dataVolumeContainer --privileged=true centos /bin/bash</code></p><p>一般情况下，是不会出现这样的问题的。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><h3 id="数据卷容器是什么"><a href="#数据卷容器是什么" class="headerlink" title="数据卷容器是什么"></a>数据卷容器是什么</h3><p>命名的容器 挂载 数据卷后，<strong>其它容器</strong> 通过 挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><p>使用上面的：liuzhuo/centos 为模板，运行三个容器：doc01、doc02、doc03。</p><p>它们三个容器本身都具有两个容器卷：<code>/dataVolumeContainer1</code> 和 <code>/dataVolumeContainer2</code></p><h3 id="容器间传递共享"><a href="#容器间传递共享" class="headerlink" title="容器间传递共享"></a>容器间传递共享</h3><p><strong>1.先启动一个父容器doc01</strong></p><p><code>docker run -it --name doc01 liuzhuo/centos</code><br><img src="/images/QQ截图20190111145928.png"></p><p>在 /dataVolumeContainer2 中：添加新的文件：doc01.txt<br><img src="/images/QQ截图20190111150102.png"></p><p><strong>2.将doc02、doc03容器都继承自doc01</strong></p><p><code>docker run -it --name doc02 --volumes-from doc01 liuzhuo/centos</code></p><pre><code>--volumes-from  :  继承自哪个容器</code></pre><p><img src="/images/QQ截图20190111150614.png"></p><p>查看：/dataVolumeContainer2 目录：<br><img src="/images/QQ截图20190111150750.png"></p><p>在doc02中的 /dataVolumeContainer2 目录下：创建新的文件：doc02.txt<br><img src="/images/QQ截图20190111150908.png"></p><p>接着：<code>docker run -it --name doc03 --volumes-from doc01 liuzhuo/centos</code></p><p><img src="/images/QQ截图20190111151244.png"></p><p>查看：/dataVolumeContainer2 目录：<br><img src="/images/QQ截图20190111151340.png"></p><p>在doc03中的 /dataVolumeContainer2 目录下：创建新的文件：doc03.txt<br><img src="/images/QQ截图20190111151826.png"></p><p>大家到此，有没有觉得疑惑呢？ 明明doc03 只是继承 doc01 ，为啥连doc02的文件也共享了呢？这就是docker强大之处，其实就像一个网状结构一样，doc03 继承 doc01，而 doc01 与 doc02 互通，所以 doc02 与 doc03 也就互通了。</p><hr><p><strong>回到doc01，可以看到doc02、doc03创建的文件</strong><br><img src="/images/QQ截图20190111151937.png"></p><p><strong>删除doc01，doc02修改doc02.txt文件，doc03中能检查到文件发生改变</strong></p><p><img src="/images/QQ截图20190111152312.png"><br><img src="/images/QQ截图20190111152540.png"><br><img src="/images/QQ截图20190111152655.png"></p><p>验证了，虽然 doc03 继承与 doc01 ，现在将 doc01 停止了，但是还能与 doc02 互通。（网状结构）</p><p><strong>删除doc02后，doc03能否访问</strong><br><img src="/images/QQ截图20190111153020.png"><br><img src="/images/QQ截图20190111153116.png"></p><p>现在，在doc03中，再添加一个新的文件：doc03_update.txt<br><img src="/images/QQ截图20190111153248.png"></p><p><strong>新建doc04容器，删除doc03容器</strong></p><p><img src="/images/QQ截图20190111153938.png"><br><img src="/images/QQ截图20190111154035.png"><br><img src="/images/QQ截图20190111154132.png"><br><img src="/images/QQ截图20190111154226.png"></p><hr><p><strong>结论：</strong></p><p><strong><font color="red">容器之间 配置信息的传递，数据卷的生命周期 一直持续到 没有容器使用它为止。</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的镜像原理</title>
      <link href="/2019/01/10/docker-de-jing-xiang-yuan-li/"/>
      <url>/2019/01/10/docker-de-jing-xiang-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>今天来学习docker中镜像原理，以及相关的commit命令。<br><a id="more"></a></p><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，<font color="red">用来打包软件运行环境和基于运行环境开发的软件</font>，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><h3 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h3><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。<strong>镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</strong></p><p><strong>特性</strong>：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h3 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h3><font color="red">Docker镜像加载原理：</font><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><font color="blue">平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</font><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><h3 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载<br><img src="/images/QQ截图20190110160603.png"></p><h3 id="为什么Docker镜像要采用这种分层结构呢"><a href="#为什么Docker镜像要采用这种分层结构呢" class="headerlink" title="为什么Docker镜像要采用这种分层结构呢"></a>为什么Docker镜像要采用这种分层结构呢</h3><p>最大的一个好处就是 - 共享资源</p><p>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h2 id="镜像的特点"><a href="#镜像的特点" class="headerlink" title="镜像的特点"></a>镜像的特点</h2><ul><li><p>docker镜像都是<strong>只读的</strong>。</p></li><li><p>当容器启动时，一个新的<strong>可写层</strong>被加载到镜像的<strong>顶部</strong>。</p></li><li><p>这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p></li></ul><h2 id="镜像的提交"><a href="#镜像的提交" class="headerlink" title="镜像的提交"></a>镜像的提交</h2><p>我们能不能提交自己的镜像呢？ 然后根据自己的镜像生成相应的容器呢？</p><p>答案：当然是可以的撒，不然的话，docker将无法适应开发者多变的需要。</p><h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h3><p><code>docker commit</code>: 提交容器副本使之成为一个新的镜像。</p><pre><code>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot;  容器ID  命名空间/要创建的目标镜像名:[标签名]</code></pre><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><p>这里，我们来使用tomcat镜像来演示。</p><p><strong>1.从Hub上下载tomcat镜像到本地并成功运行</strong></p><p><code>docker pull tomcat</code><br><img src="/images/QQ截图20190110155847.png"></p><p><strong>2.运行tomcat容器</strong></p><p><code>docker run -it -p 8080:8080 tomcat</code></p><pre><code>启动容器后面的参数，之前应该讲过了，这里再重复一遍-it：以后台交互的方式启动容器。-p：dockerPort:containerPort     docker的端口号映射到docker容器的端口号。（小写的p）-P：docker会随机帮我们分配端口号 (大写的P)解释：我们的docker是运行在宿主机上面的，而宿主机只能访问到docker的端口号，如果想要访问到docker内部容器的端口号，就需要映射。    </code></pre><p><img src="/images/QQ截图20190110161525.png"><br><img src="/images/QQ截图20190110161629.png"><br><img src="/images/QQ截图20190110161827.png"></p><p>验证tomcat容器是否启动成功：</p><p>1.在虚拟机验证<br><img src="/images/QQ截图20190110162108.png"></p><p>2.在本机中验证<br><img src="/images/QQ截图20190110162230.png"></p><p><strong>3.删除tomcat的文档说明文件</strong></p><p>现在，我们故意删除tomcat的文档说明文件，然后提交生成新的镜像来说明问题。</p><p>怎么删除tomcat中是文档说明文件呢？</p><p>在window系统中，我们知道下载好的tomcat的目录下的webapp下有一个doc目录，就是文档说明文件。<br><img src="/images/QQ截图20190110162737.png"></p><p>在linux中，下载好的tomcat也有相关的文档说明文件，但是使用docker镜像生成的tomcat容器，怎么进入里面呢？</p><p>我们知道，docker镜像文件，就相当于一个微小型linux系统，因此进入里面的方法，就是相当于进入centos的交互方法一样。</p><p> <code>docker exec -it tomcat容器id /bin/bash</code><br><img src="/images/QQ截图20190110163823.png"></p><p>在浏览器中输入：<code>localhost:8888</code> , 然后点击Documentation<br><img src="/images/QQ截图20190110164641.png"><br><img src="/images/QQ截图20190110164727.png"></p><p>如果，没有出现404，刷新一下，因为有缓存。注意：以上都是一气呵成的，中途tomcat容器不能停止运行呀。</p><p><strong>4.将已经删除文档的tomcat容器生成新的镜像</strong></p><p><code>docker commit -a=&#39;liuzhuo&#39; -m=&#39;del tomcat docs&#39; tomcat容器的ID gakki/mytomcat:1.1</code></p><pre><code>说明：-a：  提交的作者-m：  提交的信息gakki/mytomcat:1.1         命名空间/新的镜像名:标签命令空间：只是为了区分而已。</code></pre><p><img src="/images/QQ截图20190110165701.png"></p><p><strong>5.启动我们的新的镜像并与原来的镜像进行对比</strong></p><p>启动gakki/mytomcat:1.1<br><img src="/images/QQ截图20190110170937.png"></p><p>启动原来的tomcat<br><img src="/images/QQ截图20190110170958.png"></p><p><img src="/images/QQ截图20190110171048.png"><br><img src="/images/QQ截图20190110171205.png"><br><img src="/images/QQ截图20190110171314.png"></p><p>以上就是演示，怎么提交新的镜像，根据新的镜像，启动新的容器的过程。</p><hr><p>演示，使用<code>-P</code>（大写的P）<br><img src="/images/QQ截图20190110171629.png"><br><img src="/images/QQ截图20190110171718.png"><br><img src="/images/QQ截图20190110171842.png"></p><p>演示，使用 <code>-d</code> 后台运行tomcat容器</p><p><img src="/images/QQ截图20190110172200.png"><br><img src="/images/QQ截图20190110172250.png"></p><p><strong>注意：</strong></p><p>之前不是说，后台运行的容器，只是运行一下下就退出的嘛？怎么这里不是呢？</p><p>因为，tomcat后台启动后，会挂起，如果不是挂起的后台启动，都只是会启动一下就停止运行。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的常用命令</title>
      <link href="/2019/01/09/docker-de-chang-yong-ming-ling/"/>
      <url>/2019/01/09/docker-de-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>接着上篇，我们来学习docker的常用命令，大家是不是已经开始蠢蠢欲动了呢？come on！！！<br><a id="more"></a></p><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h3><p><img src="/images/QQ截图20190109212142.png"></p><h3 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h3><p><img src="/images/QQ截图20190109212258.png"></p><h3 id="docker-help"><a href="#docker-help" class="headerlink" title="docker --help"></a><code>docker --help</code></h3><p>重要，帮助指令，就像linux中的man指令一样。</p><p><img src="/images/QQ截图20190109212428.png"></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p>列出本地主机上的镜像</p><pre><code>docker images [OPTIONS]各个选项说明:REPOSITORY： 表示镜像的仓库源TAG：        镜像的标签IMAGE ID：   镜像IDCREATED：    镜像创建时间SIZE：       镜像大小</code></pre><p><img src="/images/QQ截图20190109213548.png"></p><p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p><p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p><pre><code>OPTIONS说明-a：        列出所有镜像-q：        只列出镜像的id--digests:  显示出镜像的摘要信息--no-trunc: 显示出完整的镜像信息</code></pre><p><img src="/images/QQ截图20190109214237.png"></p><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>在docker hub上面查找某个镜像</p><pre><code>docker search 镜像名 [OPTION]NAME：           镜像的名字DESCRPTION:      镜像的描述信息STARS:           相当于点赞数，星数，越多说明人用的越多OFFICIAL:        是否官方AUTOMATED:       是否自动构建、组装</code></pre><p>使用该命令 与 在docker hub上面直接查找镜像是一样。docker hub地址：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></p><p>比如说：查找 tomcat镜像<br><img src="/images/QQ截图20190109215126.png"><br><img src="/images/QQ截图20190109215251.png"></p><pre><code>OPTIONS说明：--no-trunc:    显示完整的镜像描述-s 3:          列出收藏数（点赞数）不小于指定值的镜像。（这里就是不小于3）这里说明一下，  命令已经过时了，现在使用：--filter=stars=3 来代替了--automated:   只列出automated build类型的镜像这里说明一下，  命令已经过时了，现在使用：--filter=is-automated=true 来代替了 </code></pre><p><img src="/images/QQ截图20190109220322.png"><br><img src="/images/QQ截图20190109220719.png"><br><img src="/images/QQ截图20190109221006.png"></p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>下载某个镜像，如果没有配置阿里云镜像，就是从docker huh上面拉取镜像，配置了的话，就是从阿里云镜像上面拉取镜像。<br>没有配置的话，下载速度老慢了，会吓死个人的。</p><pre><code>docker pull 镜像名字[:TAG]如果镜像名后面不加 :TAG , 那么就是下载最新的镜像。即  :latest。docker pull tomcat   &lt;======&gt; docker pull tomcat:latest</code></pre><p>现在，比如下载tomcat镜像。<br><img src="/images/QQ截图20190109223129.png"><br><img src="/images/QQ截图20190109223225.png"></p><p>如果，不想下载最新的镜像，要么就需要加上tag标签，那tag在哪里可以看呢？查官网。</p><p>比如，要下载tomcat镜像，点击进去后，会发现很多tag。<br><img src="/images/QQ截图20190109223409.png"></p><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p>删除某个镜像</p><pre><code>docker rmi 某个XXX镜像名字（或镜像ID）注意，如果你不加tag，那么就是删除latest的镜像。强制删除一个镜像docker rmi -f 镜像名字（或镜像ID）删除多个镜像：docker rmi -f 镜像名1:TAG 镜像名2:TAG多个镜像，用空格隔开删除全部：docker rmi -f $(docker images -qa)使用了$(),很像mysql中的 in的作用，delete from table where id in（id1，id2，id3）。docker images -qa：查找本地所有镜像的id</code></pre><p>使用镜像名删除：<br><img src="/images/QQ截图20190109224931.png"></p><p>使用镜像id删除：<br><img src="/images/QQ截图20190109224736.png"></p><hr><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><font color="red"><strong>有镜像才能创建容器，这是根本的前提(下载一个CentOS镜像演示)</strong></font><p><code>docker pull centos</code><br><img src="/images/QQ截图20190110111910.png"></p><h3 id="docker-run-image"><a href="#docker-run-image" class="headerlink" title="docker run image"></a>docker run image</h3><p>新建并启动一个容器：</p><pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]OPTIONS说明（常用）：有些是一个减号，有些是两个减号--name=&quot;容器新名字&quot;: 为容器指定一个名称；-d: 后台运行容器，并返回容器ID，也即启动守护式容器；-i：以交互模式运行容器，通常与 -t 同时使用；-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；-P: 随机端口映射；(大写)-p: 指定端口映射，有以下四种格式 （小写）    ip:hostPort:containerPort    ip::containerPort    hostPort:containerPort    containerPort</code></pre><p>启动交互式容器：</p><p><code>docker run -it centos</code>  (-i -t 可以缩写成：-it)<br><img src="/images/QQ截图20190110113630.png"></p><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>列出当前所有<strong>运行</strong>的容器</p><pre><code>docker ps [OPTIONS]OPTIONS说明（常用）：-a :列出当前所有正在运行的容器 + 历史上运行过的。-l :显示最近创建的容器(不管是否运行)。-n：显示最近 n个创建的容器(不管是否运行)。-q :静默模式，只显示容器编号。--no-trunc :不截断输出。</code></pre><p><img src="/images/QQ截图20190110114219.png"></p><p>退出使用交互式运行的容器：</p><pre><code>两种方式：exit：    容器停止并退出交互式。ctrl+P+Q：容器不停止但退出交互式。</code></pre><p>使用 exit 退出刚刚我们启动的centos容器：<br><img src="/images/QQ截图20190110114603.png"></p><p>检测是否停止了容器：<br><img src="/images/QQ截图20190110114823.png"></p><h3 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start"></a>docker start</h3><p>启动容器</p><pre><code>docker start 容器ID或者容器名</code></pre><p>再次启动，centos容器<br><img src="/images/QQ截图20190110115559.png"></p><h3 id="docker-restart"><a href="#docker-restart" class="headerlink" title="docker restart"></a>docker restart</h3><p>重启容器</p><pre><code>docker restart 容器ID或者容器名</code></pre><p>重启centos容器<br><img src="/images/QQ截图20190110120004.png"></p><h3 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a>docker stop</h3><p>停止容器</p><pre><code>docker stop 容器ID或者容器名</code></pre><p>停止centos容器运行：<br><img src="/images/QQ截图20190110120253.png"></p><h3 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h3><p>强制停止</p><pre><code>docker kill 容器ID或者容器名强制停止：就好比直接拔掉了电源，而stop停止就相当于正常的关机操作。</code></pre><h3 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h3><p>删除容器</p><pre><code>docker rm 容器ID或者容器名-f：选项，用来强制删除正在运行的容器。注意：rmi：是删除镜像，rm才是删除容器。一次性删除多个容器方式一：docker rm -f $(docker ps -a -q)方式二：docker ps -a -q | xargs docker rm</code></pre><p><img src="/images/QQ截图20190110121246.png"></p><hr><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p><strong>1.启动守护式容器</strong></p><pre><code>docker run -d 镜像ID或镜像名 </code></pre><p>之前，我们使用的是交互式启动容器，现在我们来以后台的方式来启动容器：<br><img src="/images/QQ截图20190110125011.png"></p><p>问题：然后docker ps -a 进行查看, 会发现容器已经退出了。</p><p>很重要的要说明的一点: <font color="red">Docker容器后台运行 , 就必须有一个前台进程. 否则会自动退出。</font><br>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p><p><strong>这个是docker的机制问题</strong>,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如：service nginx start<br>但是,这样做,nginx为后台进程模式运行，就导致docker前台没有运行的应用，这样的容器后台启动后，会立即自杀，因为他觉得他没事可做了。<font color="blue">所以，最佳的解决方案是，将你要运行的程序以前台进程的形式运行。</font></p><p><strong>2.查看容器运行的日记</strong></p><pre><code>docker logs -f -t --tail 容器ID-t：           打印日志时，会加入时间戳-f：           只打印最新的日志，会不退出，一直打印。--tail 数字：  显示最后的多少条日志。（数字是几，就打印几条日志）       </code></pre><p>使用：<code>docker run -d centos /bin/sh -c &quot;while true;do echo hello zzyy;sleep 2;done&quot;</code></p><p>因为后台运行会自动退出，所以当以后台运行容器时，我们加入了shell脚本，使其一直打印 hello zzyy，所以容器就不会退出。<br><img src="/images/QQ截图20190110130157.png"><br><img src="/images/QQ截图20190110130315.png"><br><img src="/images/QQ截图20190110130442.png"><br><img src="/images/QQ截图20190110130705.png"><br><img src="/images/QQ截图20190110130617.png"></p><p><strong>3.查看容器内运行的进程</strong></p><pre><code>docker top 容器的ID</code></pre><p><img src="/images/QQ截图20190110131211.png"><br><img src="/images/QQ截图20190110131324.png"></p><p><strong>4.查看容器内部的细节</strong></p><pre><code>docker inspect 容器的ID</code></pre><p><img src="/images/QQ截图20190110131530.png"></p><p><strong>5.进入正在运行的容器并以命令行交互</strong></p><pre><code>有两种方式：方式一：docker attach 容器ID方式二：docker exec -it 容器ID /bin/bash方式二的功能更强大些，其实docker exec 是运行当前容器的命令，运行完命令后，就返回到宿主机，由于运行的是/bin/bash，所以才没有返回到宿主机</code></pre><p>方式一：<br><img src="/images/QQ截图20190110132223.png"></p><p>方式二：<br><img src="/images/QQ截图20190110132352.png"></p><p>更强大的功能：<br><img src="/images/QQ截图20190110132800.png"></p><font color="blue">两者的区别：</font><p>attach：直接进入容器启动命令的终端，不会启动新的进程。</p><p>exec：是在容器中打开新的终端，并且可以启动新的进程。</p><p><strong>6.从容器内拷贝文件到宿主机上</strong></p><pre><code>docker cp  容器ID:容器内路径 目的主机路径</code></pre><p>将centos中的/tmp下的yum.log 拷贝到root根目录下。<br><img src="/images/QQ截图20190110133245.png"><br><img src="/images/QQ截图20190110133436.png"></p><hr><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><p><img src="/images/QQ截图20190110133708.png"></p><pre><code>attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像commit    Create a new image from a container changes   # 提交当前容器为新的镜像cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器diff      Inspect changes on a container&#39;s filesystem   # 查看 docker 容器变化events    Get real time events from the server          # 从 docker 服务获取容器实时事件exec      Run a command in an existing container        # 在已存在的容器上运行命令export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]history   Show the history of an image                  # 展示一个镜像形成历史images    List images                                   # 列出系统当前镜像import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info      Display system-wide information               # 显示系统相关信息inspect   Return low-level information on a container   # 查看容器详细信息kill      Kill a running container                      # kill 指定 docker 容器load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器logout    Log out from a Docker registry server         # 从当前 Docker registry 退出logs      Fetch the logs of a container                 # 输出当前容器日志信息port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口pause     Pause all processes within a container        # 暂停容器ps        List containers                               # 列出容器列表pull      Pull an image or a repository from the docker registry server  # 从docker镜像源服务器拉取指定镜像或者库镜像push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器restart   Restart a running container                   # 重启运行的容器rm        Remove one or more containers                 # 移除一个或者多个容器rmi       Remove one or more images                     # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run       Run a command in a new container              # 创建一个新的容器并运行一个命令save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像start     Start a stopped containers                    # 启动容器stop      Stop a running containers                     # 停止容器tag       Tag an image into a repository                # 给源中镜像打标签top       Lookup the running processes of a container   # 查看容器中运行的进程信息unpause   Unpause a paused container                    # 取消暂停容器version   Show the docker version information           # 查看 docker 版本号wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的安装</title>
      <link href="/2019/01/09/docker-de-an-zhuang/"/>
      <url>/2019/01/09/docker-de-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>本篇讲解docker的安装<br><a id="more"></a></p><h2 id="Docker安装前提说明"><a href="#Docker安装前提说明" class="headerlink" title="Docker安装前提说明"></a>Docker安装前提说明</h2><font color="blue">CentOS Docker 安装：</font><p>Docker支持以下的CentOS版本：<br>CentOS 7 (64-bit)<br>CentOS 6.5 (64-bit) 或更高的版本</p><p><strong>前提条件</strong></p><p>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统<strong>内核版本为 2.6.32-431</strong> 或者更高版本。</p><p><strong>查看自己的内核</strong></p><p>uname命令用于打印当前系统相关信息（<strong>内核版本号</strong>、硬件架构、主机名称和操作系统类型等）。</p><p><img src="/images/QQ截图20190109164948.png"></p><p>查看已安装的CentOS版本信息<br><img src="/images/QQ截图20190109165254.png"></p><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><p>Docker的架构图：<br><img src="/images/QQ截图20190109165533.png" style="width:50%"></p><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像（Image）就是一个只读的模板。<strong>镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。</strong><br><img src="/images/QQ截图20190109165653.png"></p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Docker 利用容器（Container）独立运行的一个或一组应用。<strong><code>容器是用镜像创建的运行实例。</code></strong></p><p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p><font color="red"><i><strong>可以把容器看做是一个简易版的 Linux 环境</strong></i></font>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，<strong>唯一区别在于容器的最上面那一层是可读可写的。</strong></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库（Repository）是<font color="red"> 集中存放镜像文件的场所</font>。</p><p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p><p>仓库分为 公开仓库（Public）和 私有仓库（Private）两种形式。</p><p>最大的公开仓库是 Docker Hub <code>(https://hub.docker.com/)</code> , 存放了数量庞大的镜像供用户下载。</p><p>国内的公开仓库包括：<strong>阿里云 、网易云</strong> 等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>需要正确的理解：仓储 / 镜像 / 容器 这几个概念:</p><p>Docker 本身是一个容器运行载体或称之为<strong>管理引擎</strong>。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><ul><li><p>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p></li><li><p>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</p></li><li><p>至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。</p></li></ul><h2 id="Docker的安装步骤"><a href="#Docker的安装步骤" class="headerlink" title="Docker的安装步骤"></a>Docker的安装步骤</h2><h3 id="CentOS6-8安装Docker"><a href="#CentOS6-8安装Docker" class="headerlink" title="CentOS6.8安装Docker"></a>CentOS6.8安装Docker</h3><p>1.<code>yum install -y epel-release</code></p><p>Docker使用EPEL发布，RHEL系的OS首先要确保已经持有EPEL仓库，否则先检查OS的版本，然后安装相应的EPEL包。<br><img src="/images/QQ截图20190109172137.png"></p><p>2.<code>yum install -y docker-io</code><br><img src="/images/QQ截图20190109172251.png"></p><p>3.<code>检测docker的配置文件</code></p><p><code>/etc/sysconfig/docker</code>:该文件是否存在<br><img src="/images/QQ截图20190109172409.png"></p><p>4.<code>启动Docker后台服务</code></p><p><font color="red"><strong>service docker start</strong></font>（开机启动docker服务）</p><p>5.<code>docker version验证</code></p><p><img src="/images/QQ截图20190109172603.png"></p><p>以上五个步骤就是：centOS:6.8的安装docker的步骤。</p><hr><h3 id="CentOS7安装Docker"><a href="#CentOS7安装Docker" class="headerlink" title="CentOS7安装Docker"></a>CentOS7安装Docker</h3><p>1.请看官方手册：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p><p><img src="/images/QQ截图20190109173019.png"></p><p>看上图，我们能知道，docker有社区版和企业版，社区版是免费的，如果你的公司有钱，那你就下载企业版，这里，我下载的是社区版的docker。</p><p><strong>如果大家英文不好的话，这里有中文版的安装手册：</strong></p><p><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#prerequisites" target="_blank" rel="noopener">https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#prerequisites</a></p><p>2.确定你的CentOS的版本是否是7以及以上</p><p><code>cat /etc/redhat-release</code></p><p>3.yum安装gcc相关</p><ul><li><p>CentOS7能上外网</p></li><li><p>yum -y install gcc</p></li><li><p>yum -y install gcc-c++<br><img src="/images/QQ截图20190109173704.png"></p></li></ul><p>4.卸载旧版本</p><p>方法一：<code>yum -y remove docker docker-common docker-selinux docker-engine</code></p><p>方法二：查看官网删除</p><pre><code>$ sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine</code></pre><p>如果 yum 报告未安装任何这些软件包，这表示情况正常。</p><p>将保留 /var/lib/docker/ 的内容，包括镜像、容器、存储卷和网络。Docker CE 软件包现在称为 docker-ce。</p><p>5.安装需要的软件包</p><p><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></p><p>6.设置stable镜像仓库</p><p>方式一：官网上面：</p><p><code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></p><pre><code>如果出现报错：（请使用方法二）1   [Errno 14] curl#35 - TCP connection reset by peer2   [Errno 12] curl#35 - Timeout</code></pre><p>方式二：推荐：</p><p><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p><p>7.更新yum软件包索引</p><p><code>yum makecache fast</code></p><p>如果这是自添加 Docker 镜像仓库以来您首次刷新软件包索引，系统将提示您接受 GPG 密钥，并且将显示此密钥的指纹。验证指纹是否正确，并且在正确的情况下接受此密钥。指纹应匹配 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35。</p><p>8.安装DOCKER CE</p><p><code>yum -y install docker-ce</code></p><p>该命令是安装最新版本的，在生产系统中，您应该安装特定版本的 Docker CE，而不是始终使用最新版本。列出可用版本。</p><pre><code>注：此 yum list 命令仅显示二进制软件包。如果还需要显示 源软件包，请从软件包名称中省略 .x86_64。$ yum list docker-ce.x86_64  --showduplicates | sort -rdocker-ce.x86_64  17.06.0.el7                               docker-ce-stable  使用下面的命令，安装指定的版本：$ sudo yum install docker-ce-&lt;VERSION&gt;</code></pre><p>9.启动docker</p><p><code>systemctl start docker</code> (注意CentOS7 与 CentOS6 系列的启动命令不一样了)</p><p>10.测试</p><p><code>docker version</code></p><p><img src="/images/QQ截图20190109181449.png"></p><p>11.配置镜像加速</p><pre><code>1.  mkdir -p /etc/docker2.  vim  /etc/docker/daemon.json#网易云{&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;] }#阿里云{  &quot;registry-mirrors&quot;: [&quot;https://｛自已的编码｝.mirror.aliyuncs.com&quot;]}注意上面的配置，不要加上 #网易云 和 #阿里云。在配置文件中，直接写入文字下面的花括号里面的内容即可！！！配置一个加速器就行，推荐阿里云加速度阿里云的编码，从阿里云的容器镜像服务里面找即可。3.  systemctl daemon-reload4.  systemctl restart docker</code></pre><p><img src="/images/QQ截图20190109183932.png"></p><p>12.卸载</p><pre><code>1.   systemctl stop docker 2.   yum -y remove docker-ce3.   rm -rf /var/lib/docker</code></pre><hr><h2 id="永远的hello-world"><a href="#永远的hello-world" class="headerlink" title="永远的hello-world"></a>永远的hello-world</h2><p>在我们实际开发中，如果是使用dicker-hub的话，会很慢，因为是国外的网站，所以为了方便开发，一般会使用国内的镜像加速地址。</p><p>国内属于：阿里云 与 网易云 镜像加速比较好，现在来详细说明两者的配置。</p><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p>1.打开阿里云的官网：<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a><br><img src="/images/QQ截图20190109194448.png"></p><p>2.注册一个属于自己的阿里云账户（可复用淘宝账户）</p><p>3.获取加速器地址连接</p><p>登入阿里云，进入控制台：<br><img src="/images/QQ截图20190109194804.png"></p><p>找到容器镜像服务：<br><img src="/images/QQ截图20190109195001.png"></p><p>点击左侧的容器镜像服务：<br><img src="/images/QQ截图20190109195201.png"></p><hr><h4 id="CentOS6的系统镜像加速配置"><a href="#CentOS6的系统镜像加速配置" class="headerlink" title="CentOS6的系统镜像加速配置"></a>CentOS6的系统镜像加速配置</h4><p>如果你是<strong>CentOS6的系统</strong>，当你安装好docker之后，docker的配置<strong>文件</strong>是在：<code>/etc/sysconfig/docker</code></p><p><code>vim /etc/sysconfig/docker</code></p><p>将获得的自己账户下的阿里云加速地址配置进</p><p><code>other_args=&quot;--registry-mirror=https://你自己的账号加速信息.mirror.aliyuncs.com&quot;</code><br><img src="/images/QQ截图20190109195423.png"></p><p>配置成功后，重新启动docker的后台服务：<code>service docker restart</code></p><p>检查Linux 系统下配置完加速器需要检查是否生效：</p><p>如果从结果中看到了配置的<code>--registry-mirror</code>参数说明配置成功，如下所示:</p><p><code>ps -ef|grep docker</code><br><img src="/images/QQ截图20190109195724.png"></p><hr><h4 id="CentOS7的系统镜像加速配置"><a href="#CentOS7的系统镜像加速配置" class="headerlink" title="CentOS7的系统镜像加速配置"></a>CentOS7的系统镜像加速配置</h4><p>如果你是<strong>CentOS7的系统</strong>，当你安装好docker之后，docker的配置文件<strong>目录</strong>是在：<code>/etc/docker</code></p><p>在该目录下，创建一个新的文件：daemon.json文件。</p><p><code>mkdir -p /etc/docker</code></p><p>将该文件中，输入：</p><pre><code>{  &quot;registry-mirrors&quot;: [&quot;https://你的加速编码.mirror.aliyuncs.com&quot;]}</code></pre><p>配置成功后，重启加速配置文件：</p><p><code>systemctl daemon-reload</code></p><p>重新启动docker后台服务：</p><p><code>systemctl restart docker</code></p><h3 id="网易云镜像加速"><a href="#网易云镜像加速" class="headerlink" title="网易云镜像加速"></a>网易云镜像加速</h3><p>网易云的镜像加速配置 与 阿里云镜像加速配置一样，只是加速地址变了。</p><p>只要把其中的加速地址换成：<code>http://hub-mirror.c.163.com</code> 即可。</p><p>例如：</p><pre><code>{ &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]}</code></pre><p><strong>一般推荐：阿里云的镜像加速配置。</strong></p><h3 id="不使用国内镜像加速"><a href="#不使用国内镜像加速" class="headerlink" title="不使用国内镜像加速"></a>不使用国内镜像加速</h3><p>还可以不使用国内镜像加速的方法，在国内有一个镜像加速下载的网站：<a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">https://www.docker-cn.com/registry-mirror</a><br><img src="/images/QQ截图20190110134356.png"></p><p>按照网站上面的说明，当pull镜像的时候：</p><p><code>$ docker pull registry.docker-cn.com/myname/myrepo:mytag</code></p><p>例如：拉取ubuntu:16.04 （tag为16.04）</p><p><code>$ docker pull registry.docker-cn.com/library/ubuntu:16.04</code></p><p>意思就是：当pull的时候，加上前缀：<code>registry.docker-cn.com/library/</code> 即可。</p><h3 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h3><p>启动Docker后台容器(测试运行 hello-world)</p><p><code>docker run hello-world</code></p><p><img src="/images/QQ截图20190109201836.png"></p><p>输出这段提示以后，hello world 就会停止运行，容器自动终止。</p><p>这个run干了什么呢？<br><img src="/images/QQ截图20190109202054.png"></p><p>因为我们配置了阿里云镜像，所以当本地找不到镜像的时候，会去阿里云镜像找，而不是去docker hub中找相关的镜像！！！</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="docker是怎么工作的"><a href="#docker是怎么工作的" class="headerlink" title="docker是怎么工作的"></a>docker是怎么工作的</h4><p>docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 <strong>容器，是一个运行时环境，就是我们前面说到的集装箱。</strong><br><img src="/images/QQ截图20190109203549.png"></p><h4 id="为什么Docker比较比VM快"><a href="#为什么Docker比较比VM快" class="headerlink" title="为什么Docker比较比VM快"></a>为什么Docker比较比VM快</h4><p>(1) docker有着比虚拟机更少的抽象层。由于docker不需要<strong>Hypervisor</strong>实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p>(2) docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。然而避免了引寻、加载操作系统内核这个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,所以新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个过程,因此新建一个docker容器只需要几秒钟。<br><img src="/images/QQ截图20190109204013.png" style="width:50%"><br><img src="/images/QQ截图20190109204054.png" style="width:50%"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的简介</title>
      <link href="/2019/01/09/docker-de-jian-jie/"/>
      <url>/2019/01/09/docker-de-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>今天开始学习Docker的基础篇章的学习。<br><a id="more"></a></p><p>前提知识：首先，确定大家是已经学习过linux和git的相关知识的，如果大家不了解的话，请看我的前面的相关博客。</p><h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p>问题：为什么会有docker的出现？</p><p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验。</p><p>Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。</p><p><img src="/images/QQ截图20190109154747.png"></p><p>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿电商项目的环境来说吧，Java/Tomcat/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p><p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，<font color="blue">开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。</font><font color="red">Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。<strong>透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</strong></font></p><p>docker的理念：</p><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到<font color="red"><strong> “一次封装，到处运行”。</strong></font><br><img src="/images/QQ截图20190109155823.png"></p><p>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p><p>一句话：<strong>解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</strong></p><h2 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h2><h3 id="之前的虚拟技术"><a href="#之前的虚拟技术" class="headerlink" title="之前的虚拟技术"></a>之前的虚拟技术</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。</p><p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。<br><img src="/images/QQ截图20190109160213.png"></p><p> 虚拟机的缺点：</p><ol><li>资源占用多　　　　2. 冗余步骤多　　　　　3. 启动慢</li></ol><h3 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h3><p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><p><font color="red">Linux 容器不是模拟一个完整的操作系统</font>，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。<br><img src="/images/QQ截图20190109160730.png"></p><p>比较了 Docker 和 传统虚拟化方式的不同之处：</p><ul><li><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p></li><li><p>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，<strong>而且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</p></li><li><p>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p></li></ul><h3 id="开发与运维-DevOps"><a href="#开发与运维-DevOps" class="headerlink" title="开发与运维(DevOps)"></a>开发与运维(DevOps)</h3><p>一次构建、随处运行：</p><ul><li>更快速的应用交付和部署：</li></ul><p>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</p><ul><li>更便捷的升级和扩缩容：</li></ul><p>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p><ul><li>更简单的系统运维：</li></ul><p>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p><ul><li>更高效的计算资源利用：</li></ul><p>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p><h2 id="Docker去哪里下"><a href="#Docker去哪里下" class="headerlink" title="Docker去哪里下"></a>Docker去哪里下</h2><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p>docker官网：<a href="http://www.docker.com" target="_blank" rel="noopener">http://www.docker.com</a>  （外网，估计会很慢）</p><p>docker中文网站：<a href="https://www.docker-cn.com" target="_blank" rel="noopener">https://www.docker-cn.com</a>  </p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Docker Hub官网: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a>  （外网，下载速度慢）</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么分布式一定要有Redis</title>
      <link href="/2019/01/08/wei-shi-me-fen-bu-shi-yi-ding-yao-you-redis/"/>
      <url>/2019/01/08/wei-shi-me-fen-bu-shi-yi-ding-yao-you-redis/</url>
      
        <content type="html"><![CDATA[<p>考虑到绝大部分写业务的程序员，在实际开发中使用 Redis 的时候，只会 Set Value 和 Get Value 两个操作，对 Redis 整体缺乏一个认知。所以对 Redis 常见问题做一个总结，希望能够弥补大家的知识盲点。<br><a id="more"></a></p><p>本文围绕以下几点进行阐述：</p><ol><li><p>为什么使用 Redis</p></li><li><p>使用 Redis 有什么缺点</p></li><li><p>单线程的 Redis 为什么这么快</p></li><li><p>Redis 的数据类型，以及每种数据类型的使用场景</p></li><li><p>Redis 的过期策略以及内存淘汰机制</p></li><li><p>Redis 和数据库双写一致性问题</p></li><li><p>如何应对缓存穿透和缓存雪崩问题</p></li><li><p>如何解决 Redis 的并发竞争 Key 问题</p></li></ol><h2 id="为什么使用-Redis"><a href="#为什么使用-Redis" class="headerlink" title="为什么使用 Redis"></a>为什么使用 Redis</h2><p>我觉得在项目中使用 Redis，主要是从两个角度去考虑：性能和并发。</p><p>当然，Redis 还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件，如 ZooKpeer 等代替，并不是非要使用 Redis。因此，这个问题主要从性能和并发两个角度去答。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的 SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</p><p><img src="/images/QQ截图20190108225346.png"></p><p><strong>题外话：</strong>忽然想聊一下这个迅速响应的标准。根据交互效果的不同，这个响应时间没有固定标准。</p><p><strong>不过曾经有人这么告诉我：</strong>“在理想状态下，我们的页面跳转需要在瞬间解决，对于页内操作则需要在刹那间解决。</p><p>另外，超过一弹指的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。”</p><p>那么瞬间、刹那、一弹指具体是多少时间呢？</p><pre><code>根据《摩诃僧祗律》记载：一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</code></pre><p>那么，经过周密的计算，一瞬间为 0.36 秒、一刹那有 0.018 秒、一弹指长达 7.2 秒。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。</p><p>这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库。</p><p><img src="/images/QQ截图20190108225619.png"></p><h2 id="使用-Redis-有什么缺点"><a href="#使用-Redis-有什么缺点" class="headerlink" title="使用 Redis 有什么缺点"></a>使用 Redis 有什么缺点</h2><p>大家用 Redis 这么久，这个问题是必须要了解的，基本上使用 Redis 都会碰到一些问题，常见的也就几个。</p><p><strong><code>回答主要是四个问题：</code></strong></p><p>1.缓存和数据库双写一致性问题</p><p>2.缓存雪崩问题</p><p>3.缓存击穿问题</p><p>4.缓存的并发竞争问题</p><p>这四个问题，我个人觉得在项目中是常遇见的，具体解决方案，后文给出。</p><h2 id="单线程的-Redis-为什么这么快"><a href="#单线程的-Redis-为什么这么快" class="headerlink" title="单线程的 Redis 为什么这么快"></a>单线程的 Redis 为什么这么快</h2><p>这个问题是对 Redis 内部机制的一个考察。根据我的面试经验，很多人都不知道Redis 是单线程工作模型。所以，这个问题还是应该要复习一下的。</p><p><strong><code>回答主要是以下三点：</code></strong></p><p>1.纯内存操作</p><p>2.单线程操作，避免了频繁的上下文切换</p><p>3.采用了非阻塞 I/O 多路复用机制</p><p>下面类比到真实的 Redis 线程模型，如图所示：<br><img src="/images/QQ截图20190108230004.png"></p><p>简单来说，就是我们的 redis-client 在操作的时候，会产生具有不同事件类型的 Socket。</p><p>在服务端，有一段 I/O 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</p><p>需要说明的是，这个 I/O 多路复用机制，Redis 还提供了 select、epoll、evport、kqueue 等多路复用函数库，大家可以自行去了解。</p><h2 id="Redis-的数据类型，以及每种数据类型的使用场景"><a href="#Redis-的数据类型，以及每种数据类型的使用场景" class="headerlink" title="Redis 的数据类型，以及每种数据类型的使用场景"></a>Redis 的数据类型，以及每种数据类型的使用场景</h2><p>是不是觉得这个问题很基础？我也这么觉得。然而根据面试经验发现，至少百分之八十的人答不上这个问题。</p><p>建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>这个没啥好说的，最常规的 set/get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。</p><p>我在做单点登录的时候，就是用这种数据结构存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>使用 List 的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用 JVM 自带的 Set 进行去重？</p><p>因为我们的系统一般都是集群部署，使用 JVM 自带的 Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</p><p>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>Sorted Set多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。</p><p>可以做排行榜应用，取 TOP N 操作。Sorted Set 可以用来做延时任务。最后一个应用就是可以做范围查找。</p><h2 id="Redis-的过期策略以及内存淘汰机制"><a href="#Redis-的过期策略以及内存淘汰机制" class="headerlink" title="Redis 的过期策略以及内存淘汰机制"></a>Redis 的过期策略以及内存淘汰机制</h2><p>这个问题相当重要，到底 Redis 有没用到家，这个问题就可以看出来。</p><p>比如你 Redis 只能存 5G 数据，可是你写了 10G，那会删 5G 的数据。怎么删的，这个问题思考过么?</p><p>还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p><p><strong>回答：Redis 采用的是定期删除+惰性删除策略。</strong></p><h3 id="为什么不用定时删除策略"><a href="#为什么不用定时删除策略" class="headerlink" title="为什么不用定时删除策略?"></a>为什么不用定时删除策略?</h3><p>定时删除，用一个定时器来负责监视 Key，过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。</p><p>在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 Key，因此没有采用这一策略。</p><h3 id="定期删除-惰性删除是如何工作"><a href="#定期删除-惰性删除是如何工作" class="headerlink" title="定期删除+惰性删除是如何工作"></a>定期删除+惰性删除是如何工作</h3><p>定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。</p><p>需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。</p><p>因此，如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。</p><p>也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。</p><p><strong><code>采用定期删除+惰性删除就没其他问题了么?</code></strong></p><p>不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。</p><p><strong><code>在 redis.conf 中有一行配置：</code></strong></p><pre><code># maxmemory-policy volatile-lru</code></pre><p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)：</p><pre><code>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。</code></pre><p>PS：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。</p><h2 id="Redis-和数据库双写一致性问题"><a href="#Redis-和数据库双写一致性问题" class="headerlink" title="Redis 和数据库双写一致性问题"></a>Redis 和数据库双写一致性问题</h2><p>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。</p><p>答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。</p><p>另外，我们所做的方案从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p><p><strong>回答：</strong>首先，采取正确更新策略，<strong>先更新数据库，再删缓存</strong>。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p><h2 id="如何应对缓存穿透和缓存雪崩问题"><a href="#如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="如何应对缓存穿透和缓存雪崩问题"></a>如何应对缓存穿透和缓存雪崩问题</h2><p>这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</p><p><strong>缓存穿透:</strong> 即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p><p><strong><code>缓存穿透解决方案：</code></strong></p><p>1.利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。</p><p>2.采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。</p><p>3.提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。</p><p><strong>缓存雪崩:</strong> 即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p><p><strong><code>缓存雪崩解决方案：</code></strong></p><p>1.给缓存的失效时间，加上一个随机值，避免集体失效。</p><p>2.使用互斥锁，但是该方案吞吐量明显下降了。</p><p>3.双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。</p><p>然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。</p><h2 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h2><p>这个问题大致就是，同时有多个子系统去 Set 一个 Key。这个时候大家思考过要注意什么呢？</p><p>需要说明一下，我提前百度了一下，发现答案基本都是推荐用 Redis 事务机制。</p><p>我并不推荐使用 Redis 的事务机制。因为我们的生产环境，基本都是 Redis 集群环境，做了数据分片操作。</p><p>你一个事务中有涉及到多个 Key 操作的时候，这多个 Key 不一定都存储在同一个 redis-server 上。因此，Redis 的事务机制，十分鸡肋。</p><h3 id="如果对这个Key操作-不要求顺序"><a href="#如果对这个Key操作-不要求顺序" class="headerlink" title="如果对这个Key操作,不要求顺序"></a>如果对这个Key操作,不要求顺序</h3><p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可，比较简单。</p><h3 id="如果对这个Key操作-要求顺序"><a href="#如果对这个Key操作-要求顺序" class="headerlink" title="如果对这个Key操作,要求顺序"></a>如果对这个Key操作,要求顺序</h3><p>假设有一个 key1，系统 A 需要将 key1 设置为 valueA，系统 B 需要将 key1 设置为 valueB，系统 C 需要将 key1 设置为 valueC。</p><p>期望按照 key1 的 value 值按照 valueA &gt; valueB &gt; valueC 的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。</p><p><strong><code>假设时间戳如下：</code></strong></p><pre><code>系统A key 1 {valueA  3:00}系统B key 1 {valueB  3:05}系统C key 1 {valueC  3:10}</code></pre><p>那么，假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了，以此类推。</p><p>其他方法，比如利用队列，将 set 方法变成串行访问也可以。总之，灵活变通。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对 Redis 的常见问题做了一个总结。大部分是自己在工作中遇到，以及之前面试别人的时候，爱问的一些问题。</p><p>另外，不推荐大家临时抱佛脚，真正碰到一些有经验的工程师，其实几下就能把你问懵。最后，希望大家有所收获吧。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Redis实现分布式锁</title>
      <link href="/2019/01/08/li-yong-redis-shi-xian-fen-bu-shi-suo/"/>
      <url>/2019/01/08/li-yong-redis-shi-xian-fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<p>我在之前总结幂等性的时候，写过一种分布式锁的实现，可惜当时没有真正应用过，着实的心虚啊。正好这段时间对这部分实践了一下，也算是对之前填坑了。<br><a id="more"></a></p><p>分布式锁按照网上的结论，大致分为三种：1、数据库乐观锁； 2、基于Redis的分布式锁；3、基于ZooKeeper的分布式锁。</p><p>关于数据库的乐观锁实现网上已经有很多了，如果有必要的话，留言一下，我以后会出相关的mysql乐观锁。</p><p>今天先简单总结下redis的实现方法，后面详细研究过ZooKeeper的实现原理后再具体说说ZooKeeper的实现。</p><h2 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h2><p>在传统单体应用单机部署的情况下，可以使用Java并发相关的锁，如<strong>ReentrantLcok</strong>或<strong>synchronized</strong>进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统，渐渐的被部署在多机器多JVM上同时提供服务，这使得原单机部署情况下的并发控制锁策略失效了，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。</p><h2 id="分布式锁的实现条件"><a href="#分布式锁的实现条件" class="headerlink" title="分布式锁的实现条件"></a>分布式锁的实现条件</h2><p>1、互斥性，和单体应用一样，要保证任意时刻，只能有一个客户端持有锁</p><p>2、可靠性，要保证系统的稳定性，不能产生死锁</p><p>3、一致性，要保证锁只能由加锁人解锁，不能出现A用户产生的锁被B用户解锁的情况</p><h2 id="Redis分布式锁的实现"><a href="#Redis分布式锁的实现" class="headerlink" title="Redis分布式锁的实现"></a>Redis分布式锁的实现</h2><p>Redis实现分布式锁，不同的人可能有不同的实现逻辑，但是核心就是下面三个方法。</p><h3 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h3><p>SETNX key val<br>当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。</p><h3 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h3><p>expire key timeout<br>为key设置一个超时时间，单位为second（秒），超过这个时间锁会自动释放，避免死锁。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>delete key<br>删除key。</p><h2 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h2><p>首先讲一个目前网上应用最多的一种实现:</p><p><img src="/images/QQ截图20190108214911.png"></p><p>实现思路：</p><p>1.获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁以免产生死锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</p><p>2.获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p><p>3.释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p><pre><code>public String getRedisLock(Jedis jedis, String lockKey, Long acquireTimeout, Long timeOut) {    try {        // 定义 redis 对应key 的value值(uuid) 作用 释放锁 随机生成value,根据项目情况修改        String identifierValue = UUID.randomUUID().toString();        // 定义在获取锁之后的超时时间        int expireLock = (int) (timeOut / 1000);// 以秒为单位，timeOut：传入的是毫秒值。        // 定义在获取锁之前的超时时间        // 使用循环机制 如果没有获取到锁，要在规定acquireTimeout时间 保证重复进行尝试获取锁        // 使用循环方式重试的获取锁        Long endTime = System.currentTimeMillis() + acquireTimeout;        while (System.currentTimeMillis() &lt; endTime) {            // 获取锁            // 使用setnx命令插入对应的redislockKey ，如果返回为1 成功获取锁            if (jedis.setnx(lockKey, identifierValue) == 1) {                // 设置对应key的有效期                jedis.expire(lockKey, expireLock);                return identifierValue;            }        }    } catch (Exception e) {        e.printStackTrace();    }     return null;    }</code></pre><p>这种实现方法也是目前应用最多的实现，我一直以为这确实是正确的。<strong>然而由于这是两条Redis命令，不具有原子性</strong>，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么还是会发生死锁的情况。<strong>网上之所以有人这样实现，是因为低版本的 jedis 并不支持多参数的set()方法。</strong></p><p>当然这种情况 jedis 的设计者也显然想到了，新版的 jedis 可以<strong>同时set多个参数</strong>，具体实现如下：<br><img src="/images/QQ截图20190108215608.png"></p><p>实现思路：</p><p>基本上和原来的逻辑类似，<strong>只是将 setnx 和 expire 的操作合并为一步</strong>，改为使用新的set多参的方法。</p><p>set(final String key, final String value, final String nxxx, final String expx , final long time)</p><p>key和value自然不用多说。nxxx参数只可以传String 类型的NX（仅在不存在的情况下设置）和 XX（和普通的set操作一样会做更新操作）两种。</p><p>expx是指到期时间单位，可传参数为EX （秒）和 PX （毫秒）, time就是具体的过期时间了，单位为前面expx所指定的。</p><pre><code>public String getRedisLock(Jedis jedis, String lockKey, Long acquireTimeout, Long timeOut) {    try {        // 定义 redis 对应key 的value值(uuid) 作用 释放锁 随机生成value,根据项目情况修改        String identifierValue = UUID.randomUUID().toString();        // 定义在获取锁之前的超时时间        // 使用循环机制 如果没有获取到锁，要在规定acquireTimeout时间 保证重复进行尝试获取锁        // 使用循环方式重试的获取锁        Long endTime = System.currentTimeMillis() + acquireTimeout;        while (System.currentTimeMillis() &lt; endTime) {            // 获取锁            // set使用NX参数的方式就等同于 setnx()方法，成功返回OK。PX以毫秒为单位            if (&quot;OK&quot;.equals(jedis.set(lockKey, identifierValue, &quot;NX&quot;, &quot;PX&quot;, timeOut))) {                return identifierValue;            }        }    } catch (Exception e) {        e.printStackTrace();    }     return null;    }</code></pre><p>好了，获取锁的操作基本上就上面这些，有同学可能要问，为什么不直接返回一个Boolean型的true或false呢？</p><p>正如我前面所说的，要保证解锁的一致性，所以就需要通过value值来保证解锁人就是加锁人，而不能直接返回true或false了。</p><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>还是先举一个错误的例子：</p><p><img src="/images/QQ截图20190108220325.png"></p><p>实现思路：</p><p>释放锁的时候，通过传入key和加锁时返回的value值，判断传入的value是否和key从redis中取出的相等。相等则证明解锁人就是加锁人，执行delete释放锁的操作。</p><pre><code>// 释放redis锁public void unRedisLock(Jedis jedis, String lockKey, String identifierValue) {    try {        // 如果该锁的id 等于identifierValue 是同一把锁情况才可以删除        if (jedis.get(lockKey).equals(identifierValue)) {            jedis.del(lockKey);        }    } catch (Exception e){        e.printStackTrace();    }}</code></pre><p>看着好像没啥问题哈。然而仔细想想又总感觉哪里不对。</p><p>如果在执行jedis.del(lockKey)操作之前，刚好锁的过期时间到了，而这个时候又有别的客户端取到了锁，我们在此时执行删除操作，不是又不符合一致性的要求了嘛？</p><p>然后我们修改为下述方案：</p><p><img src="/images/QQ截图20190108220645.png"></p><p>修改后的代码为：</p><pre><code>  public void unRedisLock(Jedis jedis, String lockKey, String identifierValue) {    try {        String script = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;        Long result = (Long) jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(identifierValue));        //0释放锁失败。1释放成功        if (1 == result) {            //如果你想返回删除成功还是失败，可以在这里返回            System.out.println(result+&quot;释放锁成功&quot;);        }         if (0 == result){            System.out.println(result+&quot;释放锁失败&quot;);        }    } catch (Exception e){        e.printStackTrace();    } }</code></pre><p>实现思路：</p><p>我们将 <strong>Lua代码</strong> 传到 <strong>jedis.eval()</strong> 方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为identifierValue。eval()方法是将Lua代码交给Redis服务端执行。</p><p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与identifierValue相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？<strong>因为要确保上述操作是原子性的。</strong></p><p>那么为什么执行eval()方法可以确保原子性？源于Redis的特性，因为Redis是单线程，在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的常用配置选项</title>
      <link href="/2019/01/08/redis-de-chang-yong-pei-zhi-xuan-xiang/"/>
      <url>/2019/01/08/redis-de-chang-yong-pei-zhi-xuan-xiang/</url>
      
        <content type="html"><![CDATA[<p>列举redis中的常用配置选项<br><a id="more"></a></p><pre><code>==配置文件全解======基本配置=======bind 127.0.0.1    #绑定的主机地址port 6379         #指定Redis监听端口，默认端口为6379daemonize no      #是否以后台进程启动,no：不是，yes：是pidfile /var/run/redis.pid  #当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定timeout 300       #当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能。databases 16      #创建database的数量(默认选中的是database 0)loglevel verbose  #指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verboselogfile stdout    #日志记录方式，默认为标准输出,如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null----------------------------------------------------------save &lt;seconds&gt; &lt;changes&gt;Redis默认配置文件中提供了三个条件：(or)save 900 1        #刷新快照到硬盘中，必须满足两者要求才会触发，即900秒之后至少1个关键字发生变化。save 300 10       #必须是300秒之后至少10个关键字发生变化。save 60 10000     #必须是60秒之后至少10000个关键字发生变化。-----------------------------------------------------------stop-writes-on-bgsave-error yes    #后台存储错误停止写。rdbcompression yes         #使用LZF压缩rdb文件。rdbchecksum yes            #存储和加载rdb文件时校验。dbfilename dump.rdb        #设置rdb文件名。dir ./                     #设置工作目录，rdb文件会写入该目录。=====主从配置======slaveof &lt;masterip&gt; &lt;masterport&gt;   #设为某台机器的从服务器,新版本是：replicaof &lt;masterip&gt; &lt;masterport&gt;masterauth &lt;master-password&gt;      #连接主服务器的密码slave-server-stale-data yes       #当主从断开或slave正在复制中 , slave从服务器是否应答。yes：slave会仍然响应客户端请求,此时可能会有问题，no: slave会返回&quot;SYNC with master in progress&quot;这样的错误信息slave-read-only yes               #从服务器只读,不能执行set等写入命令repl-ping-slave-period 10         #从服务器ping主服务器的时间间隔 , 秒为单位repl-timeout 60                   #主从超时时间(超时认为断线了) , 要比repl-ping-slave-period大.slave-priority 100                #如果master不能再正常工作，那么会在多个slave中，选择优先值最小的一个slave提升为master，优先值为0表示不能提升为master。repl-disable-tcp-nodelay no       #主服务器端是否合并数据,大块发送给slave。=====安全配置======requirepass foobared              # 需要密码#命令重命名rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52 #如果公共环境,可以重命名部分敏感命令 如config=====限制配置=======maxclients 10000                  #最大客户端连接数maxmemory &lt;bytes&gt;                 #最大使用内存,如果你想把Redis视为一个真正的DB的话，那不要设置&lt;maxmemory&gt;,只有你只想把Redis作为cache.-------------------------------------------------------maxmemory-policy volatile-lru     #内存到极限后的处理volatile-lru     -&gt; LRU算法删除过期keyallkeys-lru      -&gt; LRU算法删除key(不区分过不过期)volatile-random  -&gt; 随机删除过期key，allkeys-random   -&gt; 随机删除key(不区分过不过期)，volatile-ttl     -&gt; 删除快过期的key，noeviction       -&gt; 不删除,返回错误信息。-------------------------------------------------------#解释LRU ttl 都是近似算法,可以选N个,再比较最适宜T踢出的数据。默认的样本数是3，你可以修改它。maxmemory-samples 3====日志模式配置=====appendonly  no                     #是否开启aof日志持久化appendfilename appendonly.aof      # append only 文件名 (默认: &quot;appendonly.aof&quot;)--------------------------------------------------------------------------------# Redis支持3中模式:appendfsync no                     #系统缓冲 , 统一写,速度快appendfsync always                 #系统不缓冲,直接写,慢,丢失数据少。appendfsync everysec               #折衷 , 每秒写1次--------------------------------------------------------------------------------no-appendfsync-on-rewrite no       #为yes,则其他线程的数据放内存里,合并写入(速度快,容易丢失的多)。# append only 文件的自动重写auto-aof-rewrite-percentage 100    #当前aof文件比上次重写文件大N%时，重写。auto-aof-rewrite-percentage 设置为 0 ，可以关闭AOF重写功能。auto-aof-rewrite-min-size 64mb     #aof重写至少要达到的大小。====慢查询配置=======slowlog-log-slower-than 10000       #记录响应时间大于10000微秒的慢查询，负数则关闭slow log，0则会导致每个命令都被记录。单位：微秒！！！slowlog-max-len 128                 #最多记录慢查询128条====高级配置=======hash-max-zipmap-entries 512        #存储hash的键，当hash的键值对的数量超过指定的数字时，底层使用字典来存储hash键，否则使用压缩列表。hash-max-zipmap-value 64           #存储hash的键，当hash的键值对的大小超过指定的数字时，底层使用字典来存储hash键，否则使用压缩列表。activerehashing yes                #指定是否激活重置hash，默认开启。list-max-ziplist-entries 512       #类似，list的底层结构也有很多种。list-max-ziplist-value 64set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64include /path/to/local.conf       #指定包含其他配置文件，可以在同一主机上多个redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 --------------------------------------------------------------------------------------------------------------------------------------------=============服务端命令===============（是指令，不是配置在配置文件中）time                               #返回时间戳+微秒dbsize                             #返回key的数量bgrewriteaof                       #重写aofbgsave                             #后台开启子进程，进行dump数据save                               #阻塞进程，进行dump数据lastsave                           #上次进行dump数据的时间slaveof host port                  #做host port的从服务器(数据清空,复制新主内容)slaveof no one                     #变成主服务器(原数据不丢失,一般用于主服失败后)flushdb                            #清空当前数据库的所有数据flushall                           #清空所有数据库的所有数据(误用了怎么办?)shutdown [save/nosave]             #关闭服务器,保存数据,修改AOF(如果设置)slowlog get N                      #获取N条慢查询日志slowlog len                        #获取慢查询日志条数slowlog reset                      #清空慢查询info []                            #查看很多服务器端的信息config get   选项(支持*通配)       #查看配置文件中的信息config set   选项值                #修改配置文件中的信息（临时的）config rewrite                     #把值写到配置文件（永久的）config restart                     #更新info命令的信息。debug object key                   #调试选项 , 看一个key的情况。debug segfault                     #模拟段错误,让服务器崩溃。object key (refcount|encoding|idletime)monitor                            #打开控制台,观察命令(调试用)client list                        #列出所有客户端的连接client kill                        #杀死某个客户端连接 ，CLIENT KILL 127.0.0.1:43501client getname                     #获取连接的名称 默认是nilclient setname &quot;名称&quot;              #设置连接名称,便于调试====连接命令=====auth 密码                          #密码登陆(如果有密码)ping                               #测试服务器是否可用echo &quot;some content&quot;                #测试服务器是否正常交互select 0/1/2...                    #选择数据库quit                               #退出连接</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的伪微博项目</title>
      <link href="/2019/01/04/redis-de-wei-wei-bo-xiang-mu/"/>
      <url>/2019/01/04/redis-de-wei-wei-bo-xiang-mu/</url>
      
        <content type="html"><![CDATA[<p>之前的篇章，介绍了redis中的大多数用法，今天使用redis来设计与实现一个伪微博项目。<br><a id="more"></a></p><p>具体使用什么客户端语言（java、python等），这里就不详细写了，主要是讲解该项目怎么使用redis这个key-value数据库来设计。</p><p>我一直觉得，一个程序猿，思想很重要，语言只是一种工具！！！</p><h2 id="微博项目的key设计"><a href="#微博项目的key设计" class="headerlink" title="微博项目的key设计"></a>微博项目的key设计</h2><h3 id="全局key的设计"><a href="#全局key的设计" class="headerlink" title="全局key的设计"></a>全局key的设计</h3><pre><code>-----------------------------------------------------------表名                  global列名                  操作                  备注global:userid         incr                 产生全局的useridglobal:postid         incr                 产生全局的postid-----------------------------------------------------------说明：在以前，我们使用mysql等关系型数据库时，一般会使用数据库自带的自增主键，在redis中，我们可以设置一个全局的key，然后通过incr指令来实现mysql中的自增主键。userid：代表用户的idpostid：代表微博的id</code></pre><h3 id="用户相关的key的设计"><a href="#用户相关的key的设计" class="headerlink" title="用户相关的key的设计"></a>用户相关的key的设计</h3><pre><code>用户相关的表设计(mysql中)------------------------------------------------------------------------表名                  useruserid               username             password            authsecret1                    test1                11111111            #Ujkdjf#o4&amp;2                    test2                22222222            zzuWNM#$jkf···                  ···                  ···                 ···------------------------------------------------------------------------在redis中,变成以下几个key-----------------------------------------------------------------------------------------------------key的前缀             useruser:userid:*        user:userid:*:username      user:userid:*:password      user:userid:*:authsecretuser:userid:1        user:userid:1:username      user:userid:1:password      user:userid:1:authsecret-----------------------------------------------------------------------------------------------------get global:userid  ====&gt; 返回一个userid假设返回：1set user:userid:1:username test1set user:userid:1:password 11111111set user:userid:1:authsecret #Ujkdjf#o4&amp;说明：authsecret是为了防止，客户端修改cookie中的userid和username来切换用户的身份，为了安全性，所以设置了authsecret。每次用户登入，都会随机设置新的authsecret值。</code></pre><h3 id="微博相关的key设计"><a href="#微博相关的key设计" class="headerlink" title="微博相关的key设计"></a>微博相关的key设计</h3><pre><code>微博相关的表设计-------------------------------------------------------------表名              postpostid            userid            time             content4                 2                 13792238923      测试内容-------------------------------------------------------------微博在redis中, 与表设计对应的key设计--------------------------------------------------------------------------------------------------------------------key的前缀           postpost:postid:*       post:postid:*:userid       post:postid:*:username     post:postid:*:time   post:postid:*:contentpost:postid:4       post:postid:4:userid       post:postid:4:username     post:postid:4:time   post:postid:4:content--------------------------------------------------------------------------------------------------------------------注意：在这里，可以看到，我们在redis中，多设置了username的属性，这是为啥？username不是存在user:userid:*:username里面嘛，这样不是数据冗余了嘛，有时候，为了提高查询的速度，适当的增加一些冗余数据是可以的，我们使用redis，不就是因为它的执行速度快嘛。这里，使用的是string结构来存储的，但是可以改成hash更棒哦，大家可以自己设计一个hash结构。</code></pre><h3 id="关注表和粉丝表的设计"><a href="#关注表和粉丝表的设计" class="headerlink" title="关注表和粉丝表的设计"></a>关注表和粉丝表的设计</h3><p>在伪微博的项目中，一定会有关注者，被关注者的功能，即：你的粉丝，和你关注的人。</p><p><strong>关注表：</strong><br>我们使用redis中的集合结构来存储：</p><p>following:$userid —&gt;  set</p><p>即：sadd following:1 2 3 4<br>表示：用户1，关注了用户id为2、3、4的用户。</p><p><strong>粉丝表：</strong><br>我们使用redis中的集合结构来存储：</p><p>follower:$userid —–&gt;  set</p><p>即：sadd follower:2 6 7 8<br>表示：用户id为2的粉丝有：6、7、8。</p><h3 id="微博推送的设计"><a href="#微博推送的设计" class="headerlink" title="微博推送的设计"></a>微博推送的设计</h3><p>在该项目中，一个用户发表了一条微博，那么他的粉丝应该也会收到微博的推送信息。即：在用户的首页，可以看到自己发的微博和你们关注的博主的微博。</p><p>这个功能是该项目的难点，也是最重要的部分。</p><p><strong>方法一：采用推送的方式</strong></p><p>推送表: revicepost<br>使用list结构：</p><p>recivepost:$userid   —-&gt; list(3,4,7)</p><p>即当一个用户发布一条微博的时候，他会自己主动的向他的粉丝发送该条微博。</p><p>即：lpush recivepost:$userid   —-&gt; list(3,4,7)<br>表示的是，当前博主发送了多条微博的话，会向redis数据库中，recivepost列表中加入发布的微博的id。<br>使用一个for循环，向自己的粉丝，调用:lpush recivepost:$userid  $postid。$userid：粉丝的id，postid：自己发布的微博的id。</p><p>然后，在其中一个粉丝登入之后，点击首页的时候，获取到recivepost中的所有微博id，再通过post来获取微博的信息。</p><p><strong>方法二：采用拉取的方式</strong></p><p>推送的方式，有一个致命的缺点，那就是当一个粉丝有可能会很久不登入微博来了，那么那些博主自己主动推的意义也不大，会浪费内存，因为该粉丝短时间不登入微博。某一天，粉丝突然登入微博的话，会接受到大量的博主的推送信息，会造成大量的数据发送，而且该粉丝只想看到最近的博主发送的微博，这个方式会发送所有的微博，意义不大。</p><p>采用拉取方式，是粉丝登入后，自己主动拉取博主的微博信息，不是被动的接受信息，而且，我们可以设置只拉取关注的每个博主的最近的20条数据，不需要很久之前的微博信息。</p><p>该怎么实现呢？这是一个难点。</p><p>拉取表<br>pull:$userid:  —–&gt; list(3,4,7)</p><p>问: 上次我拉取了 A -&gt; 5,6,7, 三条微博, 下次刷新首页 , 需要从postid大于7的微博开始拉取。<br>解决: 拉取时, 设定一个lastpull时间点, 下次拉取时, 取&gt;lastpull的微博</p><p>问: 有很多关注人,如何取?<br>解决: 循环自己的关注列表 , 逐个取他们的新微博</p><p>问:  取出来之后放在哪儿?<br>答:  pull:$userid的链接里面</p><p>问: 如果个人中心 , 只有前1000条<br>答: ltrim,只取前1000条</p><p>问: 如果我关注 A,B两人, 从2人中,各取3条最新信息, 这3+3条信息, 从时间上,是交错的, 如何按时间排序?<br>答: 我们发布时, 是发布的hash结构 , 不能按时间来排序.</p><p>解决: 同步时, 取微博后, 记录本次取的微博的最大id,下次同步时, 只取比最大id更大的微博。</p><hr><p>思路：<br>（1）当博主发送微博后，会pull:$userid $postid。 $userid：博主的userid，博主发送的postid。因为postid的自增的，所以postid越大表示该微博是最近发布的，这样就可以根据postid的大小来决定获取最近的1000条数据了。</p><p>（2）当粉丝登入到首页后，使用for循环来获取到博主的userid，然后通过userid来获取到每个博主发送的postid，该postid &gt; lastpull (lastpull初始化为0，后来就赋值为上次访问后的最大的postid)</p><p>（3）然后将第二步获取到的所有postid，取其中的最近的1000条数据。</p><h3 id="将redis中的数据写入到mysql中"><a href="#将redis中的数据写入到mysql中" class="headerlink" title="将redis中的数据写入到mysql中"></a>将redis中的数据写入到mysql中</h3><p>前面的操作，都是在redis中操作的，现在，我们需要将每个用户的不经常访问的微博放到mysql中，redis中只保存最新的1000条数据即可。</p><p>思路：</p><p>每个用户发微博的时候，将自己的微博构新建成一个链表，然后还有添加一个全局的链表</p><p>即：mypost:userid:* —–&gt; postid  和 global:storge —–&gt; postid</p><p>当mypost:userid中的postid的数量，大于1000后，就将mypost链表最后的一条postid，插入到global:storge的最左端。</p><p>当global:storge中的postid的数量大于1000后，一致性将global:storge中的最右端的1000条数据，批量插入到mysql中。</p><p>示意图如下：<br><img src="/images/QQ截图20190105112749.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中key的设计技巧</title>
      <link href="/2019/01/02/redis-zhong-key-de-she-ji-ji-qiao/"/>
      <url>/2019/01/02/redis-zhong-key-de-she-ji-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>传统，我们都使用关系型数据库，比如mysql数据库，一般大家都熟悉了关系型数据库的表设计技巧了，这篇来讲解key-value数据库中key的设计技巧。<br><a id="more"></a></p><h2 id="redis与关系型数据库的适合场景"><a href="#redis与关系型数据库的适合场景" class="headerlink" title="redis与关系型数据库的适合场景"></a>redis与关系型数据库的适合场景</h2><p>现在，我们来考虑一个场景需求，比如豆瓣网站中的书，每本书都有标签，比如西游记，标签：文学等。</p><h3 id="mysql中的设计"><a href="#mysql中的设计" class="headerlink" title="mysql中的设计"></a>mysql中的设计</h3><p>在mysql中，我们设计表结构如下：</p><p>书签系统设计：</p><pre><code>#book表create table book (bookid int,         # book的idtitle char(20)      # book的书名)engine myisam charset utf8;insert into book values (5 , &#39;PHP圣经&#39;),(6 , &#39;ruby实战&#39;),(7 , &#39;mysql运维&#39;)(8, &#39;ruby服务端编程&#39;);#书签表create table tags (tid int,          # 书签的idbookid int,       # book的idcontent char(20)  # 书签的内容)engine myisam charset utf8;insert into tags values (10 , 5 , &#39;PHP&#39;),(11 , 5 , &#39;WEB&#39;),(12 , 6 , &#39;WEB&#39;),(13 , 6 , &#39;ruby&#39;),(14 , 7 , &#39;database&#39;),(15 , 8 , &#39;ruby&#39;),(16 , 8 , &#39;server&#39;);</code></pre><p>现在，我想要知道既有”WEB”标签又有”PHP”标签的书名，sql语句该怎么写呢？</p><pre><code>select b.bookid , b.title from book as b,tags inner join tags as t on tags.bookid=t.bookidwhere tags.content=&#39;PHP&#39; and t.content=&#39;WEB&#39; and b.bookid = tags.bookid;</code></pre><p>大家可以看到，这是多么麻烦的操作，如果再加一个标签，还包括”ruby”标签呢？ 则 and c.content = ‘ruby’ </p><p>如果数据库中的数量很大，这样的内连接查询，会很耗时的。</p><p>因此，对于这样的需求，可以使用key-value数据库。</p><h3 id="key-value中的设计"><a href="#key-value中的设计" class="headerlink" title="key-value中的设计"></a>key-value中的设计</h3><pre><code>book使用string来存储set book:5:title &#39;PHP圣经&#39;set book:6:title &#39;ruby实战&#39;set book:7:title &#39;mysql运难&#39;set book:8:title ‘ruby server’tag使用set集合来存储sadd tag:PHP 5sadd tag:WEB 5 6sadd tag:database 7sadd tag:ruby 6 8sadd tag:SERVER 8</code></pre><p>查: 既有PHP,又有WEB的书。</p><pre><code>sinter tag:PHP tag:WEB  #查集合的交集</code></pre><p>查: 有PHP或有WEB标签的书.</p><pre><code>sunin tag:PHP tag:WEB  #查集合的并集</code></pre><p>查: 含有ruby,不含WEB标签的书.</p><pre><code>sdiff tag:ruby tag:WEB #求差集</code></pre><p><img src="/images/QQ截图20190102222658.png"></p><p><img src="/images/QQ截图20190102222938.png"></p><p>我们能很轻松的实现这样的需求，速度快。</p><hr><h2 id="redis中key的设计技巧"><a href="#redis中key的设计技巧" class="headerlink" title="redis中key的设计技巧"></a>redis中key的设计技巧</h2><p>通过上面的演示，我们知道了，key-value数据库可以实现一些特殊的需求，怎样设计key呢？</p><p>一般，分为以下4步：</p><p>1：第1段放置表名，作为为key前缀 ，如：<code>user:</code><br>2：第2段放置用于区分区key的字段–对应mysql中的主键的列名,如：<code>userid</code><br>3：第3段放置主键值,如 <code>2,3,4...., a , b ,c</code><br>4：第4段,写要存储的列名。如 <code>name,passwd,email</code></p><p>完整的key：<code>set user:userid:1:name gakki</code></p><hr><p>mysql中的表：</p><pre><code>user表：----------------------------------------------------------userid         username           password      email1              lisi               123456        a@a.com2              jack               987656        b@b.com3              rose               454354        c@c.com···            ···                ···           ···----------------------------------------------------------</code></pre><p>key-value：</p><pre><code>set user:userid:1:username lisiset user:userid:1:password 123456set user:userid:1:email a@a.com----------------------------------set user:userid:2:username jackset user:userid:2:password 987656set user:userid:2:email b@b.com----------------------------------set user:userid:3:username roseset user:userid:3:password 454354set user:userid:3:email c@c.com</code></pre><p>这样设计的好处是，通过设计的key的前缀，比如：<code>user:userid:1</code> 通过hash函数，定位到指定的redis服务器，从该服务器中获取所有的id：1的数据。</p><p>这样对于分布式存储很有用处，一般id相同的数据都存储在一个数据库中，不可能id：1的name存储在1号redis服务器，id：1的password存储在2号redis服务器中。</p><p><strong>注意：</strong></p><p>在关系型数据库中, 除主键外, 还有可能其他列也会频繁查询。<br>如上表中, username 也是极频繁查询的,往往这种列会通过加索引来加快查询的速度。</p><p>那么，在redis中，要查询username为lisi，该怎么呢？</p><p>不会使用：<code>keys user:userid:*:username lisi</code></p><p>这样查询的话，redis会从userid为1开始往后依次对比username是否为lisi，这样效率当然很低了。</p><p>没有什么其他好的办法了，只能使用<strong>冗余数据来加快username的查询</strong>。</p><pre><code>set user:username:lisi:userid 1set user:username:jack:userid 2set user:username:rose:userid 3</code></pre><p>注意，这里，我们额外添加了冗余的数据，使用username来作为前缀了，来保存userid的值，但是只保存userid的值，其他的值，可以通过username获取的id，再通过id来获取其他的值。</p><p>比如：我想获取 jack 的 email </p><p>首先，<strong>get user:username:<font color="red">jack</font>:userid</strong>     ====&gt; <code>返回id：2</code></p><p>然后，<strong>get user:userid:<font color="red">2</font>:email</strong>           ====&gt; <code>返回email：b@b.com</code></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的sentinel运维工具</title>
      <link href="/2019/01/02/redis-zhong-de-sentinel-yun-wei-gong-ju/"/>
      <url>/2019/01/02/redis-zhong-de-sentinel-yun-wei-gong-ju/</url>
      
        <content type="html"><![CDATA[<p>接着上篇，来学习redis中的sentinel运维工具。<br><a id="more"></a></p><h2 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h2><p>在使用sentinel运维工具之前，首先来看一个问题：</p><p>当我们搭建好一个主从配置后，1个master，2个slave。入下图：<br><img src="/images/QQ截图20190102151649.png" style="width:50%"></p><p>如果图中的master宕机了？此时，2个slave就成为了孤儿，该怎么解决呢？</p><p>应该将其中一台slave变成master，另一台slave成为这台新master的slave。如下图：<br><img src="/images/QQ截图20190102152108.png" style="width:50%"></p><p>图中就是使用sentinel自动帮我们监控主从复制的原理图，当sentinel检测到与旧的master之间的通信断开了后，就自动帮我们创建一个新的mater，图中是使用slave1来作为新的master，slave2成为slave1的slave。</p><h2 id="手动解决"><a href="#手动解决" class="headerlink" title="手动解决"></a>手动解决</h2><p>再手动解决该问题之前，要先搭建好：这个master-slave的架构。</p><p>怎么搭建主从集群，之前的文章有，这里就不详细写了，搭建好后，示意图如下：<br><img src="/images/QQ截图20190102153345.png"><br><img src="/images/QQ截图20190102153553.png"><br><img src="/images/QQ截图20190102153815.png"><br><img src="/images/QQ截图20190102154007.png"><br><img src="/images/QQ截图20190102154207.png"></p><hr><p>以上主从复制搭建好后的效果。现在断开master，使用：shutdown 指令。<br><img src="/images/QQ截图20190102154412.png"></p><p>在6380中：<br><img src="/images/QQ截图20190102154523.png"></p><p>在6381中：<br><img src="/images/QQ截图20190102154646.png"></p><p>现在开始手动将slave1：即6380变为：master。</p><p>使用：<code>slaveof no one</code> 命令，将其修改为，不成为其他redis服务器的slave。<br><img src="/images/QQ截图20190102155104.png"></p><p>修改成master后，还要修改那个：<code>replica-read-only yes</code> 只读，改为：no。不然这个master不能写入操作。<br><img src="/images/QQ截图20190102155416.png"></p><p>接下来，将slave2：即6381，变为6380的slave。</p><p>使用：<code>slaveof ip port</code> 来变成其他redis服务器的slave。<br><img src="/images/QQ截图20190102155744.png"></p><p>测试：在6380中，插入数据，在6781中，读取该数据。<br><img src="/images/QQ截图20190102155935.png"><br><img src="/images/QQ截图20190102160019.png"></p><p>以上就是手动解决master宕机后的方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运行时更改master-slave<br>修改一台slave(设为A)为new master<br>1) 命令该服务不作为其他redis服务器的slave<br>   <strong>命令: slaveof no one</strong><br>2) 修改其replica-read-only为 no （使用config指令）<br>   <strong>命令：config set replica-read-only no</strong></p><p>其他的slave再指向new master A<br>1) 命令该服务为new master A的slave<br>   <strong>命令： slaveof  ip  port</strong></p><hr><h2 id="使用sentinel自动解决"><a href="#使用sentinel自动解决" class="headerlink" title="使用sentinel自动解决"></a>使用sentinel自动解决</h2><p>手动解决，确实能行，但是，不能让运维工作人员，24小时待命，一有问题，就去手动解决一下吧，凌晨3点爬起来，手动一下？</p><p>因此，redis官网出了一个sentinel运维工具来自动解决这个问题。</p><p><strong>首先将之前的三个redis服务器断开。删除持久化文件，避免干扰。</strong></p><p>从redis的src源文件中，拷贝一份sentinel.conf配置文件到当前目录下：<br><img src="/images/QQ截图20190102161000.png"></p><p>sentinel.conf配置文件的说明：</p><pre><code>port 26379   # 端口号daemonize no # 是否后台启动pidfile /var/run/redis-sentinel.pid #pid文件sentinel monitor mymaster 127.0.0.1 6379 2 这一行代表sentinel监控的master的名字叫做mymaster,地址为127.0.0.1:6379，行尾最后的一个2代表什么意思呢？我们知道，网络是不可靠的，有时候一个sentinel会因为网络堵塞而误以为一个master redis已经死掉了，当sentinel集群式，解决这个问题的方法就变得很简单，只需要多个sentinel互相沟通来确认某个master是否真的死了，这个2代表，当集群中有2个sentinel认为master死了时，才能真正认为该master已经不可用了。（sentinel集群中各个sentinel也有互相通信，通过gossip协议）。sentinel auth-pass &lt;master-name&gt; &lt;password&gt; # 如果监视的master设置了密码，该处就需要设置sentinel down-after-milliseconds mymaster 30000 #30秒之后监视的master还是没有响应，就认为一次监视失败，配合上述的sentinel monitor后的2来用。单位：毫秒。sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了(subjectively down, 也简称为SDOWN)。而这个down-after-milliseconds就是用来指定这个“一定时间范围”的，单位是毫秒。sentinel parallel-syncs mymaster 1 #恢复数据时的同步个数，我们知道只要master与slave断开后，重写连接后，都需要重写rdb、aof，如果同时间重连太多，会导致master产生大量的IO运行，容易将master搞奔溃的，所以数字尽量要小！！！在发生failover主备切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave处于不能处理命令请求的状态。sentinel can-failover def_master yes #当前sentinel实例是否允许实施“failover”(故障转移) ，no表示当前sentinel为“观察者”(只参与&quot;投票&quot;.不参与实施failover)，全局中至少有一个为yes。sentinel failover-timeout mymaster 180000 #sentinel去执行failover的等待时间</code></pre><p><strong>Sentinel的”仲裁会”</strong></p><p>前面我们谈到，当一个master被sentinel集群监控时，需要为它指定一个参数，这个参数指定了当需要判决master为不可用，并且进行failover时，所需要的sentinel数量，本文中我们暂时称这个参数为票数.</p><p>不过，当failover主备切换真正被触发后，failover并不会马上进行，还需要sentinel中的大多数sentinel授权后才可以进行failover。<br>当ODOWN时，failover被触发。failover一旦被触发，尝试去进行failover的sentinel会去获得“大多数”sentinel的授权（如果票数比大多数还要大的时候，则询问更多的sentinel)<br>这个区别看起来很微妙，但是很容易理解和使用。例如，集群中有5个sentinel，票数被设置为2，当2个sentinel认为一个master已经不可用了以后，将会触发failover，但是，进行failover的那个sentinel必须先获得至少3个sentinel的授权才可以实行failover。<br>如果票数被设置为5，要达到ODOWN状态，必须所有5个sentinel都主观认为master为不可用，要进行failover，那么得获得所有5个sentinel的授权。</p><p><strong>配置版本号</strong></p><p>为什么要先获得大多数sentinel的认可时才能真正去执行failover呢？</p><p>当一个sentinel被授权后，它将会获得宕掉的master的一份最新配置版本号，当failover执行结束以后，这个版本号将会被用于最新的配置。因为大多数sentinel都已经知道该版本号已经被要执行failover的sentinel拿走了，所以其他的sentinel都不能再去使用这个版本号。这意味着，每次failover都会附带有一个独一无二的版本号。我们将会看到这样做的重要性。</p><p>而且，sentinel集群都遵守一个规则：如果sentinel A推荐sentinel B去执行failover，B会等待一段时间后，自行再次去对同一个master执行failover，这个等待的时间是通过failover-timeout配置项去配置的。从这个规则可以看出，sentinel集群中的sentinel不会再同一时刻并发去failover同一个master，第一个进行failover的sentinel如果失败了，另外一个将会在一定时间内进行重新进行failover，以此类推。</p><p>redis sentinel保证了活跃性：如果大多数sentinel能够互相通信，最终将会有一个被授权去进行failover.<br>redis sentinel也保证了安全性：每个试图去failover同一个master的sentinel都会得到一个独一无二的版本号。</p><p><strong>配置传播</strong></p><p>一旦一个sentinel成功地对一个master进行了failover，它将会把关于master的最新配置通过广播形式通知其它sentinel，其它的sentinel则更新对应master的配置。</p><p>一个faiover要想被成功实行，sentinel必须能够向选为master的slave发送<strong>SLAVEOF NO ONE</strong>命令，然后能够通过INFO命令看到新master的配置信息。</p><p>当将一个slave选举为master并发送<strong>SLAVEOF NO ONE</strong>后，即使其它的slave还没针对新master重新配置自己，failover也被认为是成功了的，然后所有sentinels将会发布新的配置信息。</p><p>新配在集群中相互传播的方式，就是为什么我们需要当一个sentinel进行failover时必须被授权一个版本号的原因。</p><p>每个sentinel使用##发布/订阅##的方式持续地传播master的配置版本信息，配置传播的##发布/订阅##管道是：<code>__sentinel__:hello</code>。</p><p>因为每一个配置都有一个版本号，所以以版本号最大的那个为标准。</p><p>举个栗子：假设有一个名为mymaster的地址为192.168.1.50:6379。一开始，集群中所有的sentinel都知道这个地址，于是为mymaster的配置打上版本号1。一段时候后mymaster死了，有一个sentinel被授权用版本号2对其进行failover。如果failover成功了，假设地址改为了192.168.1.50:9000，此时配置的版本号为2，进行failover的sentinel会将新配置广播给其他的sentinel，由于其他sentinel维护的版本号为1，发现新配置的版本号为2时，版本号变大了，说明配置更新了，于是就会采用最新的版本号为2的配置。</p><p>这意味着sentinel集群保证了第二种活跃性：一个能够互相通信的sentinel集群最终会采用版本号最高且相同的配置。</p><hr><p>说了这么多，我们来验证一下sentinel的功能：</p><p>就使用默认的sentinel.conf，不需要改变。</p><p>依次启动三个redis服务器：<br><img src="/images/QQ截图20190102171724.png"></p><p>查看三个redis服务器的配置是否正确：<br><img src="/images/QQ截图20190102171853.png"><br><img src="/images/QQ截图20190102171933.png"><br><img src="/images/QQ截图20190102172020.png"></p><p>首先：启动sentinel进程</p><p><code>redis-sever sentinel --sentinel</code><br><img src="/images/QQ截图20190102172230.png"><br><img src="/images/QQ截图20190102172319.png"></p><p>现在已经启动sentinel进程了，进程阻塞在那里，一直在帮我们监视着：127.0.0.1：6379 redis服务器。<br><img src="/images/QQ截图20190102172533.png"></p><p>现在：断开6379：master：redis服务器。<br><img src="/images/QQ截图20190102172635.png"></p><p>等待一段时间，喝一杯茶，再看sentinel前台的信息：</p><p>会发现：输出 +sdown master mymaster 127.0.0.1 6379 之后就不输出了，只是提示我们，6379：master 挂了，但是没有帮我们自动指定新的master等一些列操作。<br><img src="/images/QQ截图20190102173312.png"></p><p>这是为啥呢？这是因为默认的sentinel.conf配置文件中，<code>sentinel monitor mymaster 127.0.0.1 6379 2</code>,最后面为2，意思是需要两个sentinel确认master已经宕机了才会触发faiover操作。sentinel也是支持集群部署的。</p><p>所以，我们需要将其的数字改为：1.</p><p>退出三个redis服务器，修改sentinel配置文件：<br><img src="/images/QQ截图20190102182328.png"></p><p>重启三个redis服务器和sentinel进程，然后shutdown：master。<br><img src="/images/QQ截图20190102182704.png"><br><img src="/images/QQ截图20190102182758.png"></p><p>这次，真的喝一杯茶，sentinel就会自动帮助我们处理。<br><img src="/images/QQ截图20190102183150.png"></p><p>在6380中，info Replication：<br><img src="/images/QQ截图20190102183405.png"></p><p>在6381中，info Replication：<br><img src="/images/QQ截图20190102183541.png"></p><p>在6380中，随便插入新的数据， 验证在6381中是否能获取到：<br><img src="/images/QQ截图20190102183708.png"><br><img src="/images/QQ截图20190102183803.png"></p><p>以上就是，sentinel自动帮助我们处理的情况。</p><hr><p>这个，sentinel自动帮我们选择了6380作为新的master，但是有时，我们需要自己设置怎么办？不想让sentinel随机帮我们选择新的master。</p><p>这样的话，我们需要设置slave的优先级，如果我们想要使用6381作为新的master，修改其redis.conf配置文件，将其slave的优先级数字改小，越小优先级越高。</p><p><img src="/images/QQ截图20190102184259.png"><br><img src="/images/QQ截图20190102184432.png"></p><p><strong>注意：在之前的redis版本中：是slave-priority , 现在是：replica-priority </strong></p><p>接下来重启三个redis服务器和sentinel进程，shutdown：6379。<br>注意：在此之前，因为此时三个redis服务器已经被sentinel改了，所以，需要恢复到初始状态，6379：作为6380和6381的master。<br><img src="/images/QQ截图20190102185825.png"><br><img src="/images/QQ截图20190102190120.png"></p><p>以上就是今天是所有内容，希望大家喜欢。</p><p>参考链接：<br><a href="https://blog.csdn.net/zhanglh046/article/details/78630336" target="_blank" rel="noopener">Redis的主从复制(Sentinel)</a><br><a href="https://www.cnblogs.com/zhoujinyi/p/5569462.html" target="_blank" rel="noopener">Redis中的Sentinel机制与用法</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的aof恢复与rdb的迁移</title>
      <link href="/2019/01/02/redis-zhong-de-aof-hui-fu-yu-rdb-de-qian-yi/"/>
      <url>/2019/01/02/redis-zhong-de-aof-hui-fu-yu-rdb-de-qian-yi/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的aof恢复与rdb服务器之间的迁移<br><a id="more"></a></p><p>基于上篇的知识，当我们在redis的开发中，一不小心，手贱 运行了 flushall，数据都被清空了，该怎么恢复呢？</p><p>今天的话题，就由此展开。</p><h2 id="aof的恢复"><a href="#aof的恢复" class="headerlink" title="aof的恢复"></a>aof的恢复</h2><p>目前redis下的目录结构如下：<br><img src="/images/QQ截图20190102112932.png"></p><pre><code>bin :            与redis相关的命令目录redis.conf :     6379的redis配置文件（默认的）redis6380.conf : 6380的redis配置文件（拷贝的6379）</code></pre><p>我们知道，redis持久化的目录在：/var/rdb下。（配置文件中配置的）<br><img src="/images/QQ截图20190102113401.png"><br><img src="/images/QQ截图20190102113617.png"></p><p>启动，redis:6379的服务器<br><img src="/images/QQ截图20190102113805.png"></p><p>先向redis中，随便存点数据。<br><img src="/images/QQ截图20190102113957.png"></p><p>现在一不小心，执行了：flushall 。</p><p>赶紧：执行 shutdown nosave ，抢救一下。 （后面的参数，加上save的话，就是将shutdown指令也保存到aof文件中，nosave就是不保存）<br><img src="/images/QQ截图20190102114233.png"></p><p>查看持久化目录：<br><img src="/images/QQ截图20190102114435.png"></p><p>查看aof文件中的内容：<br><img src="/images/QQ截图20190102114435.png"><br><code>more /var/rdb/appendonly6379.aof</code><br><img src="/images/QQ截图20190102114705.png"></p><p>再次启动，redis服务器：<br><img src="/images/QQ截图20190102114916.png"><br><img src="/images/QQ截图20190102115022.png"></p><p>删除aof文件中 与flushall相关的指令即可恢复之前的数据。</p><p><code>vim /var/rdb/appendonly6379.aof</code><br><img src="/images/QQ截图20190102115338.png"><br><img src="/images/QQ截图20190102115550.png"><br><img src="/images/QQ截图20190102115654.png"></p><hr><p>再次启动redis服务器，验证数据是否恢复<br>启动之前，首先检查一下，我们修改后的aof是否有效：（防止格式不对，启动redis服务器失败）<br><img src="/images/QQ截图20190102120357.png"></p><p><img src="/images/QQ截图20190102115806.png"><br><img src="/images/QQ截图20190102120532.png"></p><p><strong>注意：当你执行flushall之后，如果恰好aof进行了重写，那么就真的完蛋了，准备写辞职信吧！</strong></p><p>进行aof重写后，aof文件就会清空了，因为里面是有flushall指令了，redis就会在重写的时候，认为数据库该清空，aof文件就会清空了。</p><h2 id="rdb在服务器之间的迁移"><a href="#rdb在服务器之间的迁移" class="headerlink" title="rdb在服务器之间的迁移"></a>rdb在服务器之间的迁移</h2><p>现在，我们想要进行数据的迁移怎么办呢？我们想将一台redis服务器中数据迁移到另一台redis服务器中。</p><p>这里，我们演示将6379：redis服务器中的数据迁移到6380：redis服务器中。</p><p>查看持久化目录，此时6380还没有rdb文件。<br><img src="/images/QQ截图20190102125758.png"></p><p>修改6380配置文件，关闭aof持久化功能，避免干扰，因为如果rdb与aof同时存在的话，是会使用aof来恢复数据的。<br>（注意rdb功能是开启的。）<br><img src="/images/QQ截图20190102130035.png"></p><p>启动6380的redis服务器，验证该服务器中是否有数据：<br><img src="/images/QQ截图20190102130806.png"><br><img src="/images/QQ截图20190102130922.png"></p><p>关闭6380的redis服务器，并且删除：/var/rdb/下的dump6380.rdb文件（如果有的话）。</p><p><strong>在持久化目录下：拷贝一份dump6379.rdb 文件，名字为dump6380.rdb（与redis6380.conf配置文件配置的一样）</strong><br><img src="/images/QQ截图20190102131149.png"></p><p>分别开启：6379与6380的redis服务器。<br><img src="/images/QQ截图20190102130324.png"><br><img src="/images/QQ截图20190102131317.png"><br><img src="/images/QQ截图20190102131445.png"></p><p><strong>注意：6379的redis服务器是通过aof文件来恢复内存中的数据的，所以如果在拷贝dump文件之前，需要执行save命令，强行执行rdb保存，这样aof持久化的数据就与rdb一致了，否则，有可能现在出现6380服务器中数据与6379不一致问题。</strong></p><hr><p><strong>要点：</strong></p><p>将要迁移的redis服务器的rdb文件，拷贝一份放到需要该数据的redis服务器的<strong>持久化目录下</strong>,而且名字必须与配置文件中<strong>一致</strong>。</p><p>比如：我这里，持久化的目录为：<code>/var/rdb</code>。rdb的名字为：<code>dump6380.rdb</code>。</p><p>因为：6380的redis.conf配置文件中：<br><img src="/images/QQ截图20190102132109.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中运维相关的指令</title>
      <link href="/2019/01/01/redis-zhong-yun-wei-xiang-guan-de-zhi-ling/"/>
      <url>/2019/01/01/redis-zhong-yun-wei-xiang-guan-de-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>这篇文章，将讲述redis中与运维相关的指令。<br><a id="more"></a></p><p>上篇，我们讲解了redis中的集群搭建过程。现在来学习redis中的运维相关的知识。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>现在redis的目录结构如下：<br><img src="/images/QQ截图20190101213016.png"></p><p>redis.conf配置文件中主要的配置：</p><pre><code>port 6379daemonize yespidfile /var/run/redis_6379.pidsave 900 1save 300 10save 60 10000dbfilename dump6379.rdbdir /var/rdbappendonly yesappendfilename &quot;appendonly6379.aof&quot;</code></pre><p>首先，删除：/var/rdb/下的所有持久化文件，为了防止干扰。<br><img src="/images/QQ截图20190101214056.png"></p><p>使用这个配置文件，启动redis服务器：</p><p><img src="/images/QQ截图20190101213740.png"><br><img src="/images/QQ截图20190101214242.png"></p><p>启动redis的客户端：<br><img src="/images/QQ截图20190101214441.png"></p><hr><h2 id="运维常用指令"><a href="#运维常用指令" class="headerlink" title="运维常用指令"></a>运维常用指令</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><pre><code>显示redis 服务器端命令。第一行：时间戳(秒)第二行：微秒数</code></pre><p><img src="/images/QQ截图20190101214755.png"></p><h3 id="dbsize"><a href="#dbsize" class="headerlink" title="dbsize"></a>dbsize</h3><pre><code>显示当前数据库的key是数量</code></pre><p><img src="/images/QQ截图20190101214927.png"></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><pre><code>select N: 切换到N数据库下，默认16个数据库</code></pre><p><img src="/images/QQ截图20190101215137.png"></p><h3 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a>bgrewriteaof</h3><pre><code>后台进程重写aof文件</code></pre><p>我们知道，开启aof持久化后，必须满足一定的条件，才会执行aof重写操作，但是直接使用该命令，会立即重写aof文件。<br><img src="/images/QQ截图20190101215852.png"><br><img src="/images/QQ截图20190101215950.png"><br><img src="/images/QQ截图20190101220120.png"><br><img src="/images/QQ截图20190101220220.png"><br><img src="/images/QQ截图20190101220359.png"></p><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><pre><code>save: 保存rdb快照之前，都是当系统满足那三个save条件后，自动帮我们保存rdb快照现在直接执行这个命令，就可以帮我们保存rdb快照了。</code></pre><p><img src="/images/QQ截图20190101220829.png"><br><img src="/images/QQ截图20190101220924.png"><br><img src="/images/QQ截图20190101221014.png"></p><h3 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h3><pre><code>bgsave: 后台保存rdb快照。save是直接使用主进程来执行rdb保存操作，这样会阻塞当前进程。bgsave是后台进程执行，就不会阻塞当前进程。</code></pre><p><img src="/images/QQ截图20190101221140.png"><br><img src="/images/QQ截图20190101221451.png"></p><h3 id="lastsave"><a href="#lastsave" class="headerlink" title="lastsave"></a>lastsave</h3><pre><code>上次保存快照的时间戳</code></pre><p><img src="/images/QQ截图20190101221647.png"></p><h3 id="flushdb"><a href="#flushdb" class="headerlink" title="flushdb"></a>flushdb</h3><pre><code>清空当前数据库中的所有数据实际生产中，轻易不要用这个命令！！！</code></pre><p><img src="/images/QQ截图20190101221927.png"></p><h3 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h3><pre><code>清空所有数据库中的数据</code></pre><p><img src="/images/QQ截图20190101222419.png"></p><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><pre><code>showdown [save/nosave] ：关闭服务器如果不小心执行了flushall，立即 shutdown nosave ， 关闭服务器然后，手动编辑aof文件，去掉文件中的&quot;flushall&quot;相关的行，然后开启服务器，就可以导入回原来的数据了。如果flushall之后 , 系统恰好bgrewriteaof了 , 那么aof就清空了 , 数据丢失.（无力回天）</code></pre><p><img src="/images/QQ截图20190101222802.png"><br><img src="/images/QQ截图20190101222957.png"><br><img src="/images/QQ截图20190101223216.png"></p><h3 id="slowlog"><a href="#slowlog" class="headerlink" title="slowlog"></a>slowlog</h3><pre><code>slowlog: 显示慢查询怎样才算是一个慢执行过程呢？这是由redis.conf配置中的：slowlog-log-slower-than 10000（默认值） 来指定的单位是：微秒。最多能存储多少条慢查询信息呢？这是由redis.conf配置中的：slowlog-max-len 128 （默认值）, 来做限制slowlog get N ：获取N条慢查询的信息</code></pre><p><img src="/images/QQ截图20190101223813.png"></p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><pre><code>用来修改redis.conf配置文件中的值，是在redis运行的期间。config get 配置项  config set 配置项 值 (特殊的选项,不允许用此命令设置,如slave-of, 需要用单独的slaveof命令来设置)注意：如果调用config set **** 之后，没有使用config rewrite命令的话，是不会将更改保存到redis.conf中的只对当前允许的redis实例生效，进程结束之后就失效里。所以如果想保存到配置文件的话，别忘了在使用config set ****之后，调用config rewrite</code></pre><p><img src="/images/QQ截图20190101224601.png"><br><img src="/images/QQ截图20190101224740.png"><br><img src="/images/QQ截图20190101225054.png"></p><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><pre><code>查看redis服务器信息的。1: 内存# Memoryused_memory:859192      数据结构的空间used_memory_rss:7634944 实占空间mem_fragmentation_ratio:8.89 前2者的比例,1.N为佳,如果此值过大,说明redis的内存的碎片化严重,可以导出再导入一次.2: 主从复制# Replicationrole:slavemaster_host:192.168.1.128master_port:6379master_link_status:up3:持久化# Persistencerdb_changes_since_last_save:0rdb_last_save_time:13752240634: fork耗时#Statuslatest_fork_usec:936  上次导出rdb快照,持久化花费微秒注意: 如果某实例有10G内容,导出需要2分钟,每分钟写入10000次,导致不断的rdb导出,磁盘始处于高IO状态.</code></pre><p><img src="/images/QQ截图20190101225516.png"><br><img src="/images/QQ截图20190101225740.png"></p><p>从上图可以看出，slaves：0，没有slave服务器，所以，现在配置一个。</p><p>将当前目录下的redis.conf 复制一份为：redis6380.conf.</p><p><code>cp redis.conf redis6380.conf</code><br><img src="/images/QQ截图20190102095059.png"></p><p>redis.conf中的配置信息</p><pre><code>bind 127.0.0.1   # 实际生产中，添加自己的ip地址。port 6379daemonize yespidfile /var/run/redis_6379.pidsave 900 1save 300 10save 60 10000dbfilename dump6379.rdbdir /var/rdbappendonly yesappendfilename &quot;appendonly6379.aof&quot;</code></pre><p>redis6380.conf中的配置信息</p><pre><code>bind 127.0.0.1   # 实际生产中，添加自己的ip地址。port 6380daemonize yespidfile /var/run/redis_6380.pid#save 900 1       # 不要rdb，因为6379：master已经配置了。#save 300 10#save 60 10000dbfilename dump6380.rdbdir /var/rdbappendonly no     # 不要配置aof，6379：master已经配置了。appendfilename &quot;appendonly6380.aof&quot;#配置主从复制replicaof 127.0.0.1 6379  # 配置master的ip地址和端口号。注意这里不能写localhost！！！replica-read-only yes     # slave只读。</code></pre><p>分别启动这两个redis服务器。</p><p><code>./bin/redis-server ./redis.conf</code></p><p><code>./bin/redis-server ./redis6380.conf</code><br><img src="/images/QQ截图20190102100807.png"><br><img src="/images/QQ截图20190102100930.png"><br><img src="/images/QQ截图20190102101103.png"></p><p>以上主从复制配置成功，在使用info来查看信息。</p><p>在6379：redis客户端中：<br><img src="/images/QQ截图20190102101446.png"></p><p>在6380：redis客户端中：<br><img src="/images/QQ截图20190102101638.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的集群部署</title>
      <link href="/2018/12/31/redis-zhong-de-ji-qun-bu-shu/"/>
      <url>/2018/12/31/redis-zhong-de-ji-qun-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的集群部署，防止一台master宕机后，就全盘皆输的局面。<br><a id="more"></a></p><h2 id="集群的作用"><a href="#集群的作用" class="headerlink" title="集群的作用"></a>集群的作用</h2><p>1:  主从备份 防止主机宕机<br>2:  读写分离,分担master的任务（master写，slave读）<br>3:  任务分离,如从服务器分担备份工作与计算工作</p><h2 id="redis中的集群"><a href="#redis中的集群" class="headerlink" title="redis中的集群"></a>redis中的集群</h2><p>通常有两种集群的搭建方式：</p><p>1）星型<br><img src="/images/QQ截图20181231175911.png" style="width:50%"></p><p>2) 链式<br><img src="/images/QQ截图20181231180020.png" style="width:50%"></p><p>第2种方式的好处:</p><p>master宕机后 , 可以直接切换到 slave1 。</p><h2 id="redis中主从的通信过程"><a href="#redis中主从的通信过程" class="headerlink" title="redis中主从的通信过程"></a>redis中主从的通信过程</h2><p><img src="/images/QQ截图20181231180204.png" style="width:50%"></p><p>首先，slave向master发出同步的命令，master会将dump文件发给slave，在dump的过程中向master发出的命令再使用aof文件来同步到slave中。之后就使用replicationFeedSlaves来同步。</p><h2 id="redis集群的配置"><a href="#redis集群的配置" class="headerlink" title="redis集群的配置"></a>redis集群的配置</h2><p>Master配置:<br>1:关闭rdb快照(备份工作交给slave)<br>2:可以开启aof</p><p>slave配置:<br>1: <strong>声明slave-of</strong><br>2: 配置密码[如果master有密码]<br>3: [某1个] slave 打开 rdb快照功能<br>4: <strong>配置是否只读[slave-read-only]</strong></p><hr><p>下面开始，真正的操作过程。</p><h3 id="redis中简单的主从复制配置"><a href="#redis中简单的主从复制配置" class="headerlink" title="redis中简单的主从复制配置"></a>redis中简单的主从复制配置</h3><p>准备搭 ：1个master + 2个slave的redis集群。</p><p>这里是模拟集群，可以使用多个配置文件来模拟多个redis服务器。启动一个配置文件，就是一个redis服务器。</p><p>master的配置文件：关闭rdb，开启aof。</p><p>第一个slave服务器：开启rdb，关闭aof，开启slave只读。</p><p>第二个slave服务器：rdb、aof都不关闭，开启slave只读。</p><hr><p>将当前目录下的redis.conf文件，复制两份，改个名字。<br><img src="/images/QQ截图20181231202510.png"></p><p><strong>修改master的redis.conf配置文件：</strong><br><img src="/images/QQ截图20181231202701.png"><br><img src="/images/QQ截图20181231203232.png"><br><img src="/images/QQ截图20181231203341.png"></p><p><strong>修改第一个slave的redis6780.conf的配置文件</strong><br><img src="/images/QQ截图20181231203939.png"><br><img src="/images/QQ截图20181231204258.png"><br><img src="/images/QQ截图20181231204410.png"><br><img src="/images/QQ截图20181231204626.png"><br><img src="/images/QQ截图20181231205035.png"><br><img src="/images/QQ截图20181231205144.png"></p><p><strong>修改第二个slave的redis6781.conf的配置文件</strong><br><img src="/images/QQ截图20181231205323.png"><br><img src="/images/QQ截图20181231205428.png"><br><img src="/images/QQ截图20181231205538.png"><br><img src="/images/QQ截图20181231205726.png"><br><img src="/images/QQ截图20181231205849.png"><br><img src="/images/QQ截图20181231205940.png"></p><hr><p>分别启动这个三个redis服务器：</p><p>启动之前先删除之前的rdb与aof文件，避免形成干扰。<br><img src="/images/QQ截图20181231211210.png"></p><p><img src="/images/QQ截图20181231210422.png"><br><img src="/images/QQ截图20181231210638.png"><br><img src="/images/QQ截图20181231214510.png"><br><img src="/images/QQ截图20181231214713.png"></p><p>发现，我们往master中插入name数据后，在两个slave服务器中，根本就没有name数据。</p><font color="red"><strong>这是为啥呢？这是因为redis版本更新后，在slave中配置master的ip时候，不能使用localhost ！！！必须是ip地址，即要写成127.0.0.1</strong></font><p>将两个slave中的：<code>replicaof 127.0.0.1 6379</code> 这样写就可以了。</p><p>下面是三个redis配置文件中的详细信息：</p><p>master：redis.conf</p><pre><code>bind 127.0.0.1   # 实际生产中，添加自己的ip地址。port 6379daemonize yespidfile /var/run/redis_6379.pid#save 900 1                     # master:关闭rdb，留给slave来完成#save 300 10#save 60 10000dbfilename dump6379.rdbdir /var/rdbappendonly yes                  # master：开启aof。appendfilename &quot;appendonly6379.aof&quot;</code></pre><p>slave：redis6780.conf</p><pre><code>bind 127.0.0.1   # 实际生产中，添加自己的ip地址。port 6780daemonize yespidfile /var/run/redis_6780.pidsave 900 1                     # 6780的slave开启：rdbsave 300 10save 60 10000dbfilename dump6780.rdbdir /var/rdbappendonly no                  # 关闭aof功能，因为master已经开启了appendfilename &quot;appendonly6780.aof&quot;#配置主从复制replicaof 127.0.0.1 6379  # 配置master的ip地址和端口号。注意这里不能写localhost！！！replica-read-only yes     # slave只读。</code></pre><p>slave：redis6781.conf</p><pre><code>bind 127.0.0.1   # 实际生产中，添加自己的ip地址。port 6781daemonize yespidfile /var/run/redis_6781.pid#save 900 1                     # 关闭rdb功能#save 300 10#save 60 10000dbfilename dump6781.rdbdir /var/rdbappendonly no                  # 关闭aof功能appendfilename &quot;appendonly6781.aof&quot;#配置主从复制replicaof 127.0.0.1 6379  # 配置master的ip地址和端口号。注意这里不能写localhost！！！replica-read-only yes     # slave只读。</code></pre><p>这样：分别启动三个redis客户端来验证，数据就一致了。</p><p><strong>注意：高版本的redis主从复制中配置文件中，是：replicaof 、replica-read-only；低版本中是：slaveof、slave-read-only。</strong></p><hr><p>下面，来演示redis-2版本之上的版本集群搭建方式：</p><h3 id="redis中的集群搭建"><a href="#redis中的集群搭建" class="headerlink" title="redis中的集群搭建"></a>redis中的集群搭建</h3><p>上面，我们演示了redis中的，简单主从复制的搭建，比较简单。其实slave就是将master中的数据拷贝了一份。<br>而redis中的集群的话，就不是那么简单了，当我们访问其中一个redis服务器时，首先会使用hash算法，定位到具体要使用哪个redis服务器，详细理论知识请看官网。</p><p>下面开始redis的搭建过程。</p><p>Redis的集群部署需要在每台集群部署的机器上安装Redis，然后修改配置以集群的方式启动。</p><p>这里演示的话，就是使用多个redis.conf配置文件来模拟redis集群。</p><h4 id="搭建redis集群"><a href="#搭建redis集群" class="headerlink" title="搭建redis集群"></a>搭建redis集群</h4><p>1）现在搭建redis集群，<strong>最小集群模式需要三个master实例</strong>，一般建议起六个实例，即三主三从。因此我们创建6个以端口号命名的目录存放实例的配置文件和其他信息。</p><pre><code>mkdir redis-clustercd redis-clustermkdir 7000 7001 7002 7003 7004 7005</code></pre><p>在对应端口号的目录中复制一份redis.conf的文件。每个配置文件中的端口号port参数改为对应目录的端口号。</p><p>目录结构可参考：</p><pre><code>redis-cluster/├── 7000│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7000.conf│   └── redis.conf├── 7001│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7001.conf│   └── redis.conf├── 7002│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7002.conf│   └── redis.conf├── 7003│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7003.conf│   └── redis.conf├── 7004│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7004.conf│   └── redis.conf├── 7005│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7005.conf│   └── redis.conf</code></pre><p><img src="/images/QQ截图20190101112544.png"><br><img src="/images/QQ截图20190101113222.png"></p><p>每个redis.conf配置文件的大致需要配置的内容：</p><pre><code>#可选操作，该项设置后台方式运行，daemonize yes                       # 开启后台运行bind 127.0.0.1                      # 如果是实际中，填写每个机器的ip地址port 7000                           # 对应每个文件夹的名字，设置不同的端口号pidfile /var/run/redis_7000.pid     # 设置pid文件，对应每个端口号cluster-enabled yes                 # 开启redis的集群cluster-config-file nodes-7000.conf # redis集群节点信息文件cluster-node-timeout 5000           # redis集群节点连接超时的设置appendonly yes                      # 开启aof持久化</code></pre><p>以7000为例：<br><img src="/images/QQ截图20190101114057.png"><br><img src="/images/QQ截图20190101114230.png"><br><img src="/images/QQ截图20190101114311.png"><br><img src="/images/QQ截图20190101114349.png"></p><p><img src="/images/QQ截图20190101114436.png"><br><img src="/images/QQ截图20190101114551.png"><br><img src="/images/QQ截图20190101123950.png"><br><img src="/images/QQ截图20190101115015.png"><br><img src="/images/QQ截图20190101115120.png"><br><img src="/images/QQ截图20190101120216.png"><br><img src="/images/QQ截图20190101115259.png"></p><p>7003：<br>只是开启rdb持久化。7000-7002：master，关闭rdb；7003-7005：slaver，开启rdb。<br>其他的配置类似于7000。<br><img src="/images/QQ截图20190101114700.png"></p><h4 id="启动redis服务器"><a href="#启动redis服务器" class="headerlink" title="启动redis服务器"></a>启动redis服务器</h4><p>2）启动六个redis服务器<br><img src="/images/QQ截图20190101121530.png"><br><img src="/images/QQ截图20190101124528.png"><br><img src="/images/QQ截图20190101124720.png"></p><p>如果是使用前台的方式启动redis服务器的话，会出现：</p><pre><code>[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&#39;m 97a3a64667477371c4479320d683e4c8db5858b1</code></pre><p>每个实例都会生成一个Node ID，类似97a3a64667477371c4479320d683e4c8db5858b1，用来作为Redis实例在集群中的唯一标识，而不是通过IP和Port，IP和Port可能会改变，该Node ID不会改变。</p><h4 id="使用redis-trib创建集群"><a href="#使用redis-trib创建集群" class="headerlink" title="使用redis-trib创建集群"></a>使用redis-trib创建集群</h4><p>3）使用redis-trib创建集群</p><p>redis的实例全部运行之后，还需要redis-trib.rb工具来完成集群的创建，redis-trib.rb二进制文件在Redis包主目录下的src目录中，运行该工具依赖 <strong>ruby环境 和 gem</strong>，因此需要提前安装。</p><h5 id="安装：ruby"><a href="#安装：ruby" class="headerlink" title="安装：ruby"></a>安装：ruby</h5><p>安装：ruby</p><p><code>yum -y install ruby rubygems</code><br><img src="/images/QQ截图20190101125702.png"><br><img src="/images/QQ截图20190101125829.png"></p><p>查看ruby的版本：<br><code>ruby --version</code><br><img src="/images/QQ截图20190101130020.png"></p><p><strong>由于centos系统默认支持Ruby版本为2.0.0，因此执行 gem install redis 命令时会报以下错误。</strong></p><p><code>gem install redis</code><br><img src="/images/QQ截图20190101130250.png"></p><p><strong>解决方法是先安装 rvm，再升级ruby版本。</strong></p><h5 id="安装：rvm"><a href="#安装：rvm" class="headerlink" title="安装：rvm"></a>安装：rvm</h5><p>安装rvm</p><p><code>curl -L get.rvm.io | bash -s stable</code><br><img src="/images/QQ截图20190101130536.png"></p><p>如果出现以下错误：<br><img src="/images/QQ截图20190101130655.png"></p><p>则执行报错中的：<code>gpg2 --keyserver ·····</code> 命令。</p><pre><code>gpg2 --keyserver hkp://pool.sks-keyservers.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</code></pre><p><img src="/images/QQ截图20190101131331.png"></p><p>再次执行命令curl -L get.rvm.io | bash -s stable。例如：</p><p><img src="/images/QQ截图20190101131715.png"></p><p>以上表示执行成功，然后执行以下命令。</p><p><code>source /usr/local/rvm/scripts/rvm</code></p><p>查看rvm库中已知的ruby版本</p><p><code>rvm list known</code><br><img src="/images/QQ截图20190101131922.png"></p><h5 id="升级：ruby"><a href="#升级：ruby" class="headerlink" title="升级：ruby"></a>升级：ruby</h5><p>升级Ruby:</p><pre><code>#安装rubyrvm install 2.5.0#使用新版本rvm use  2.5.0#移除旧版本rvm remove 2.0.0#查看当前版本ruby --version</code></pre><p>例如：<br><img src="/images/QQ截图20190101134937.png"><br><img src="/images/QQ截图20190101135058.png"><br><img src="/images/QQ截图20190101135223.png"></p><h5 id="安装：gem"><a href="#安装：gem" class="headerlink" title="安装：gem"></a>安装：gem</h5><p>安装：gem</p><p><code>gem install redis</code><br><img src="/images/QQ截图20190101135356.png"></p><hr><h5 id="redis-trib-rb"><a href="#redis-trib-rb" class="headerlink" title="redis-trib.rb"></a>redis-trib.rb</h5><p>以上前提工具终于安装好了，可以开始执行：redis-trib.rb 命令</p><p>在redis的src源码下，存在：redis-trib.rb 命令。<br><img src="/images/QQ截图20190101135937.png"><br><img src="/images/QQ截图20190101140009.png"></p><p>在src目录下：执行<br><code>./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</code></p><pre><code>参数create表示创建一个新的集群，--replicas 1 :表示为每个master创建一个slave。</code></pre><p>如果创建成功会显示以下信息</p><pre><code>[OK] All 16384 slots covered</code></pre><p><img src="/images/QQ截图20190101140758.png"></p><p><code>./redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1</code></p><p>执行成功后会停止在：</p><p>Can I set the above configuration? (type ‘yes’ to accept):</p><p>输入：yes 即可。</p><p><img src="/images/QQ截图20190101141229.png"></p><p><img src="/images/QQ截图20190101141342.png"></p><hr><h4 id="部署结果验证"><a href="#部署结果验证" class="headerlink" title="部署结果验证"></a>部署结果验证</h4><p>4) 部署结果验证</p><p>1、客户端验证</p><p>使用客户端redis-cli二进制访问某个实例，执行set和get的测试。<br><img src="/images/QQ截图20190101142210.png"></p><p><strong>注意：</strong> -h：填写实际中的ip地址，-p：端口号，<strong>-c：代表连接的是redis集群</strong>（一定要带上-c）<br><img src="/images/QQ截图20190101142637.png"><br><img src="/images/QQ截图20190101142956.png"></p><p><img src="/images/QQ截图20190101143006.png"><br><img src="/images/QQ截图20190101143225.png"></p><p>2、集群状态</p><p>使用 cluster info 命令查看集群状态。<br><img src="/images/QQ截图20190101143436.png"></p><p>3、节点状态</p><p>使用cluster nodes命令查看节点状态。<br><img src="/images/QQ截图20190101143720.png"></p><h2 id="配置master密码"><a href="#配置master密码" class="headerlink" title="配置master密码"></a>配置master密码</h2><p>一般，我们搭建redis集群是在内网中，所以，不需要设置master密码，也不许要配置防火墙，这样会加快redis的访问速度。</p><p>如果，你一定要为了安全性，要配置master的密码的话。</p><p>首先退出redis集群，杀死六个redis服务器进程。</p><p><img src="/images/QQ截图20190101145033.png"></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><strong>修改所有redis集群中的redis.conf文件 </strong></p><p><img src="/images/QQ截图20190101145328.png"></p><p><img src="/images/QQ截图20190101145614.png"><br><img src="/images/QQ截图20190101150746.png"></p><p><strong>注意所有节点的密码都必须一致，masterauth也要加的。</strong></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>通过指令找到安装的redis在ruby环境中的配置client.rb</strong></p><pre><code>find / -name &quot;client.rb&quot;</code></pre><p><img src="/images/QQ截图20190101151416.png"></p><p>编辑该文件:</p><pre><code>vim /usr/local/rvm/gems/ruby-2.5.0/gems/redis-4.1.0/lib/redis/client.rb</code></pre><p><img src="/images/QQ截图20190101151542.png"><br><img src="/images/QQ截图20190101151614.png"></p><p>修改其中的密码配置：pass</p><p><img src="/images/QQ截图20190101151753.png"></p><p>之后重启Redis，即可。</p><hr><p><img src="/images/QQ截图20190101152529.png"><br><img src="/images/QQ截图20190101152635.png"><br><img src="/images/QQ截图20190101152738.png"><br><img src="/images/QQ截图20190101152836.png"></p><p><strong>现在，必须使用带密码的参数来连接redis服务器才有权限</strong><br><img src="/images/QQ截图20190101153331.png"><br><img src="/images/QQ截图20190101153455.png"><br><img src="/images/QQ截图20190101153612.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的aof日志持久化</title>
      <link href="/2018/12/31/redis-zhong-de-aof-ri-zhi-chi-jiu-hua/"/>
      <url>/2018/12/31/redis-zhong-de-aof-ri-zhi-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<p>接着上篇的内容，来讲述redis中的aof日志持久化操作<br><a id="more"></a></p><p>通过上篇，我们知道了redis中的rdb快照持久化操作，但是由于其存在丢失数据的现象，所以提出了aof持久化的操作。</p><p>rdb恢复数据的速度是比aof快的，aof是通过将每次执行的操作命令，写入到一个文件中保存起来，当作持久化的。</p><h2 id="aof的原理"><a href="#aof的原理" class="headerlink" title="aof的原理"></a>aof的原理</h2><p><img src="/images/QQ截图20181231154133.png"></p><p>现在提出两个问题：</p><p>1:每次执行一次命令都要写入到aof文件中吗?<br>2:某key操作100次,产生100行记录,aof文件会很大,怎么解决?</p><p>首先先思考，在后面的学习中，会依次解决这两个问题。</p><h2 id="aof的配置选项"><a href="#aof的配置选项" class="headerlink" title="aof的配置选项"></a>aof的配置选项</h2><p>打开redis.conf文件<br><img src="/images/QQ截图20181231154509.png"><br><img src="/images/QQ截图20181231154616.png"><br><img src="/images/QQ截图20181231154717.png"></p><p>主要关注aof中几个重点配置选项</p><pre><code>appendonly no        # 是否仅要日志,就是是否开启aof日志appendfsync always   # 系统不缓冲,每次执行一次命令，就写入一次，慢,丢失数据少appendfsync everysec # 折中,每秒写如一次appendfsync no       # 系统缓冲,统一写,由操作系统来决定，速度快no-appendfsync-on-rewrite no     # 当重写aof文件时是否同步最新数据，no同步更新，yes不同步更新auto-AOF-rewrite-percentage 100  # 当前aof文件比上次重写时文件大N%时重写auto-AOF-rewrite-min-size 64mb   # aof重写至少要达到的大小</code></pre><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>1）开启aof日志，并设置aof文件的保存目录以及名字<br><img src="/images/QQ截图20181231155858.png"></p><p>2）开启redis服务器</p><p>如果已经开启了，就杀死：<code>pkill -9 redis</code><br><img src="/images/QQ截图20181231160138.png"></p><p>重新开启redis服务器，使用刚刚修改后的redis.conf配置文件<br><img src="/images/QQ截图20181231160423.png"><br><img src="/images/QQ截图20181231160619.png"><br><img src="/images/QQ截图20181231160709.png"></p><p>3）开启redis的客户端<br><img src="/images/QQ截图20181231161005.png"><br><img src="/images/QQ截图20181231161144.png"></p><hr><p>如果aof是每执行一次命令，就向aof文件插入一条数据的话，那就不能体现redis快速缓存的优势了，因为每次都是写入到磁盘上面，和mysql一样了。</p><p>为了平衡 快速读取数据与持久化 ，aof所以出现了：appendfsync 配置。</p><p>根据你的实际需求，设置appendfsync的值，如果数据很重要，不能丢失一丁点，那就always。一般使用：everysec。</p><hr><p>我们也注意到了，每次对同一个key执行操作，都会写入到aof文件中。<br><img src="/images/QQ截图20181231161921.png"></p><p>如果num想加到100，那么aof文件中就会出现很多incr指令，这样不是很浪费空间吗？aof文件会瞬间增涨很多，怎么解决呢？</p><p>redis中，就出现了aof重写的方法。我们知道num最后的状态是100，那么直接存指令set num 100就好了，就不用存在那么多的incr指令，节约空间。</p><p>使用：<code>auto-AOF-rewrite-percentage 和 auto-AOF-rewrite-min-size</code></p><p>如果不使用：auto-AOF-rewrite-min-size的话，前期aof文件很小，每次写入一个命令，都是之前文件的100%倍，那样的话，每次都会重写，因此出现了设置aof文件最小重写的大小，当到达最小要求时，才会重写。</p><p>现在我们来验证这个配置。</p><p>修改aof的最小重写大小，这里是为了方便演示，所以设置成了20mb。</p><p><img src="/images/QQ截图20181231162751.png"></p><p>重启redis服务器<br><img src="/images/QQ截图20181231162920.png"></p><p>使用测试redis性能的执行，来随机执行20000条指令<br><img src="/images/QQ截图20181231163103.png"><br><img src="/images/QQ截图20181231163337.png"></p><p>接着再执行20000条数据。<br><img src="/images/QQ截图20181231163530.png"></p><p>在右边的客户端执行redis命令时，左边的一直测试aof文件的大小，发现aof文件一开始是从13M开始增加，当超过20M后，就会突然变小成4.3M了，这是因为触发了aof的重写命令。</p><p>也可以直接执行aof重写的命令来重写：<code>bgrewriteaof</code><br><img src="/images/QQ截图20181231164124.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>注: 1）在dump rdb过程中 , aof如果停止同步 , 会不会丢失?<br>答: 不会 , 所有的操作缓存在内存的队列里, dump完成后,统一操作.</p><p>注: 2）aof重写是指什么?<br>答: aof重写是指把内存中的数据,逆化成命令,写入到.aof日志里.<br>以解决 aof日志过大的问题.</p><p><strong>问: 3）如果rdb文件,和aof文件都存在,优先用谁来恢复数据?</strong><br>答: <font color="red"><strong>aof</strong></font></p><p>问: 4）2种是否可以同时用?<br>答: 可以,而且推荐这么做</p><p>问: 5）恢复时rdb和aof哪个恢复的快<br>答: rdb快,因为其是数据的内存映射,直接载入到内存,而aof是命令,需要逐条执行.</p><hr><p>演示第三个问题。</p><p>当rdb文件和aof文件同时存在时，会使用aof来恢复数据！！！</p><p>1）首先查看是否存在rdb文件。<br><img src="/images/QQ截图20181231164640.png"></p><p>2）删除aof文件，避免干扰<br><img src="/images/QQ截图20181231164851.png"></p><p>3）查看现在redis缓存中存在哪些数据<br><img src="/images/QQ截图20181231164942.png"></p><p>存在site数据。</p><p>4）杀死redis服务器，重启redis服务器<br><img src="/images/QQ截图20181231165054.png"><br><img src="/images/QQ截图20181231165310.png"></p><p>为啥site不存了呢？这是因为，我们开启了aof日志，但是，目前aof文件中还没有保存任何数据，所以恢复数据的时候，啥也没有！</p><p>查看aof文件的保存目录：<br><img src="/images/QQ截图20181231165538.png"></p><p>现在删除aof文件，并关闭aof日志。<br><img src="/images/QQ截图20181231165659.png"><br><img src="/images/QQ截图20181231165801.png"></p><p>重启redis服务器<br><img src="/images/QQ截图20181231170047.png"></p><p>此时site数据又存在了，这是因为，我们关闭了aof日志，此时是依靠rdb文件来恢复数据的。<br><img src="/images/QQ截图20181231170228.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的rdb快照持久化</title>
      <link href="/2018/12/31/redis-zhong-de-rdb-kuai-zhao-chi-jiu-hua/"/>
      <url>/2018/12/31/redis-zhong-de-rdb-kuai-zhao-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的持久化操作，这是redis缓存一大优势。<br><a id="more"></a></p><h2 id="rdb的工作原理"><a href="#rdb的工作原理" class="headerlink" title="rdb的工作原理"></a>rdb的工作原理</h2><p>每隔 <font color="red"><strong>N分钟 或 N次写</strong></font> 操作后, 从内存dump数据形成rdb文件 , <font color="red"><strong>压缩</strong></font> 放在 <font color="red">备份<strong>目录</strong></font></p><p>注: <font color="red"><strong>红色部分</strong></font>可通过参数来配置。</p><h2 id="rdb的配置文件"><a href="#rdb的配置文件" class="headerlink" title="rdb的配置文件"></a>rdb的配置文件</h2><p>打开redis.conf文件。<br><img src="/images/QQ截图20181231114006.png"><br><img src="/images/QQ截图20181231114858.png"></p><p><img src="/images/QQ截图20181231115310.png"><br><img src="/images/QQ截图20181231115344.png"><br><img src="/images/QQ截图20181231115423.png"></p><p>接下来详细说明：</p><pre><code>save 900 1    #刷新快照到硬盘中，必须满足两者要求才会触发，即900秒之内至少有1个key发生变化。save 300 10   #必须是300秒之内至少有10个key发生变化。save 60 10000 #必须是60秒之内至少有10000个key发生变化。stop-writes-on-bgsave-error yes    #后台存储rdb文件发生错误时停止写入。rdbcompression yes    #使用LZF压缩rdb文件。rdbchecksum yes       #存储和加载rdb文件时校验。dbfilename dump.rdb   #设置rdb文件名。dir ./                #设置工作目录，rdb文件会写入该目录。</code></pre><p>主要说一下：stop-writes-on-bgsave-error的配置。在之前的redis版本中，redis是单进程的，因此在redis在持久化的过程中，如果有其他的客户端发送请求，此时redis服务器是不会响应客户端的请求的，后来redis改版后，可以通过主进程来进行持久化的工作，子进程来响应客户端的请求。此时就会出现一个问题，当主进程进行持久化的过程中，客户端同时在向服务器端发送写的操作，如果突然断电等特殊情况，导致主进程的持久化出现了错误，在这个过程中的客户端的写入是否保存呢？就是该参数来配置的，stop-writes-on-bgsave-error <strong>yes</strong>,那就是此阶段客户端的写操作不写入。</p><hr><h2 id="rdb的缺陷"><a href="#rdb的缺陷" class="headerlink" title="rdb的缺陷"></a>rdb的缺陷</h2><p>在2个保存点之间 , 断电 , 将会丢失（1到N）分钟的数据。</p><p>出于对持久化的更精细要求 , redis增添了aof方式 （append only file）。</p><h3 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h3><p>1）设置保存rdb文件的目录<br><img src="/images/QQ截图20181231122100.png"></p><p>修改rdb持久化保存目录。<br><img src="/images/QQ截图20181231124756.png"></p><p>2）删除当前目下的dump.rdb文件（防止干扰）<br><img src="/images/QQ截图20181231122214.png"></p><p>3）开启redis服务器<br><img src="/images/QQ截图20181231122636.png"></p><p>4）使用redis的工具，一秒钟中set一万条数据<br><img src="/images/QQ截图20181231122956.png"></p><p>上面的参数写错了，应该是 <code>./bin/redis-benchmark -n 10000</code>. 注意是 <strong>-n</strong><br><img src="/images/QQ截图20181231123119.png"><br><img src="/images/QQ截图20181231123547.png"></p><p>5）再次插入一个不相干的数据<br><img src="/images/QQ截图20181231123710.png"></p><p>6）模拟断电，不正常的情况<br><img src="/images/QQ截图20181231123844.png"></p><p>7）再次启动redis服务器<br><img src="/images/QQ截图20181231124112.png"></p><p>8）测试数据是否存在<br><img src="/images/QQ截图20181231124242.png"><br><img src="/images/QQ截图20181231124416.png"></p><p>想必，大家应该知道为啥最后的 address没有保存下来了吧，因为是刚刚插入那条数据，就模拟突然断电了，不符合那三个save的要求，所以没有保存。</p><p>这就是redis使用rdb持久化的缺陷，会存在数据丢失的情况。</p><p>查看redis的持久化文件dump.rdb<br><img src="/images/QQ截图20181231125002.png"><br><img src="/images/QQ截图20181231125053.png"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果不想使用rdb来持久化操作，直接注释掉那三个save配置信息即可。</p><p>想要进行更加精细的持久化，请使用aop日志来持久化。一般，我使用两者来进行持久化。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的发布与订阅</title>
      <link href="/2018/12/30/redis-de-fa-bu-yu-ding-yue/"/>
      <url>/2018/12/30/redis-de-fa-bu-yu-ding-yue/</url>
      
        <content type="html"><![CDATA[<p>这篇介绍redis中的发布与订阅的简单操作。<br><a id="more"></a></p><h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><pre><code>subscribe channel [channel ...]订阅给指定频道的信息。一旦客户端进入订阅状态，客户端就只可接受订阅相关的命令。如SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE和PUNSUBSCRIBE命令，除了这些命令，其他命令一律失效。</code></pre><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><pre><code>publish channel message将信息 message 发送到指定的频道 channel返回值收到消息的客户端数量。</code></pre><h3 id="unsubscribe"><a href="#unsubscribe" class="headerlink" title="unsubscribe"></a>unsubscribe</h3><pre><code>unsubscribe channel [channel ...]指示客户端退订给定的频道，若没有指定频道，则退订所有频道.如果没有频道被指定，即，一个无参数的 unsubscribe 调用被执行，那么客户端会将使用 SUBSCRIBE 命令订阅的所有频道都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。</code></pre><h3 id="psubscribe"><a href="#psubscribe" class="headerlink" title="psubscribe"></a>psubscribe</h3><pre><code>psubscribe channel [channel ...]订阅给定的模式(patterns)。支持的模式(patterns)有:h?llo subscribes to hello, hallo and hxlloh*llo subscribes to hllo and heeeelloh[ae]llo subscribes to hello and hallo, but not hillo如果想输入普通的字符，可以在前面添加\</code></pre><h2 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h2><p>1）开启两个redis客户端</p><p><img src="/images/QQ截图20181231100525.png"></p><p>2）第一个客户端订阅频道news<br><img src="/images/QQ截图20181231100701.png"></p><p>3）第二个客户端向news频道发布消息<br><img src="/images/QQ截图20181231100910.png"></p><p>4）再开启一个客户端，也订阅news频道<br><img src="/images/QQ截图20181231101121.png"></p><p>5）向news频道发送消息<br><img src="/images/QQ截图20181231101438.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的简单事务</title>
      <link href="/2018/12/30/redis-zhong-de-jian-dan-shi-wu/"/>
      <url>/2018/12/30/redis-zhong-de-jian-dan-shi-wu/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的简单事务。<br><a id="more"></a></p><p>在Redis中只支持简单的事务。</p><h2 id="redis与mysql事务的对比"><a href="#redis与mysql事务的对比" class="headerlink" title="redis与mysql事务的对比"></a>redis与mysql事务的对比</h2><p><img src="/images/QQ截图20181230170926.png"></p><p>注: rollback与discard 的区别.</p><p>如果已经成功执行了2条语句, 第3条语句出错.</p><p>在mysql中，rollback后 , 前2条的语句影响消失.<br>在redis中，<font color="red"><strong>discard只是结束本次事务 , 前2条语句造成的影响仍然还在</strong></font></p><hr><p><strong>注意:</strong></p><p>在mutil后面的语句中, 语句出错可能有2种情况</p><p>1: 书写的<strong>指令语法</strong>本身就有问题<br>这种 , 执行exec命令时就会报错, 所有语句得不到执行。</p><p>2: 语法本身没错 , 但像那种命令的操作对象有问题时. 比如 zadd 操作list对象。<br>这种，执行exec命令之后 , <strong>会执行正确的语句 , 并跳过有不适当的语句</strong>.</p><p>(如果zadd操作list这种事怎么避免? 这一点,由程序员负责)</p><hr><h2 id="演示操作"><a href="#演示操作" class="headerlink" title="演示操作"></a>演示操作</h2><p>现在通过演示转账的案例，来讲解redis中的事务。</p><p>首先flushdb，清空redis中的数据库。</p><p>1）设置 wang 和 zhao 的初始化金额</p><pre><code>127.0.0.1:6379&gt; set wang 200OK127.0.0.1:6379&gt; set zhao 700OK127.0.0.1:6379&gt; mget wang zhao1) &quot;200&quot;2) &quot;700&quot;127.0.0.1:6379&gt; </code></pre><p>现在，wang：200元 ，zhao：700元。</p><p>2）zhao 向 wang 转入100元。</p><pre><code>127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incrby wang 100QUEUED127.0.0.1:6379&gt; decrby zhao 100QUEUED127.0.0.1:6379&gt; exec1) (integer) 3002) (integer) 600127.0.0.1:6379&gt; mget wang zhao1) &quot;300&quot;2) &quot;600&quot;127.0.0.1:6379&gt; </code></pre><p>首先使用 <strong>multi命令</strong> 开启redis的事务，之后的所有操作命令都会放到一个队列中（从返回的QUEUED可以看出来），当执行exec命令后，redis会将队列中的所有操作命令一次性执行完毕，即符合原子性。</p><p>最终的结果，wang：300 ，zhao：600 正确。</p><p>3）当操作的语法出现问题时</p><pre><code>127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; set wang 200OK127.0.0.1:6379&gt; set zhao 700OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incrby wang 100QUEUED127.0.0.1:6379&gt; xxxx zhao 100(error) ERR unknown command `xxxx`, with args beginning with: `zhao`, `100`, 127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; mget wang zhao1) &quot;200&quot;2) &quot;700&quot;127.0.0.1:6379&gt; </code></pre><p>从上演示的操作过程中可以看出，当在multi中执行错误的语法时，会提前退出事务环境，之前所有的操作都不会执行，其实就是放弃了队列中的任务。</p><p>4）当操作没有语法错误，但有操作命令对象不适合时</p><pre><code>127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; set wang 200OK127.0.0.1:6379&gt; set zhao 700OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incrby wang 100QUEUED127.0.0.1:6379&gt; sadd zhao pigQUEUED127.0.0.1:6379&gt; exec1) (integer) 3002) (error) WRONGTYPE Operation against a key holding the wrong kind of value127.0.0.1:6379&gt; mget wang zhao1) &quot;300&quot;2) &quot;700&quot;127.0.0.1:6379&gt; </code></pre><p>上面的操作过程中，故意使用了sadd集合命令来操作字符串对象，但是语法是对的，由于操作对象的不符，当执行exec时，就会发现操作对象的错误提示信息，<strong>但是我们会发现对wang的incrby指令居然执行了！！！，wang增加了100元，变成了300元。因此，redis的事务和mysql的事务不一样，请注意这个细节！！！</strong></p><p>出现类似sadd操作string的这种事时怎么避免呢？<font color="red"><strong>这种事情只能是程序员来避免。</strong></font></p><p>5) 自主回退的情况<br>程序员自己觉得不想执行之前的操作了，想要撤回之前的操作，使用discard。</p><pre><code>127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; set wang 200OK127.0.0.1:6379&gt; set zhao 700OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incrby wang 100QUEUED127.0.0.1:6379&gt; decrby zhao 100QUEUED127.0.0.1:6379&gt; discardOK127.0.0.1:6379&gt; mget wang zhao1) &quot;200&quot;2) &quot;700&quot;127.0.0.1:6379&gt; </code></pre><p>当不想执行之前的命令时，使用discard命令即可，redis就会把队列里的命令都丢掉，不执行。</p><hr><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>我正在买票：ticket -1 , money -100 。<br>而票只有1张, 如果在我multi之后 , 和exec之前, 票被别人买了<code>---即ticket变成0了.</code><br>我该如何观察这种情景,并不再提交呢？</p><p>1）首先开启两个redis客户端。</p><p><img src="/images/QQ截图20181230202305.png"></p><p>2）在一个客户端中，设置ticket票数为1，lisi：300元，wangwu：300元，票价为200。</p><p><img src="/images/QQ截图20181230202426.png"></p><p>3）在一个客户端中，执行multi，将票数减一，lisi减200元，但是不执行exec；在另一个客户端中，执行<br>multi，将票数减一，wangwu减200元，执行exec；在执行exec完成后，在第一个客户端中执行exec。</p><p><strong>第一个客户端中：</strong><br><img src="/images/QQ截图20181230203003.png"></p><p><strong>第二个客户端中：</strong><br><img src="/images/QQ截图20181230203230.png"></p><p><strong>第一个客户端中：</strong><br><img src="/images/QQ截图20181230203517.png"></p><p>解决这种问题，通常有两种解决办法：</p><p>悲观的想法：</p><p>世界是充满危险的，肯定有人同时和我抢票，给ticket上锁，只有我能操作。[悲观锁]</p><p>乐观的想法：</p><p>没有那么多人和我抢,因此,我只需要注意,有没有人更改ticket的值就可以了。[乐观锁]</p><font color="blue"><strong>Redis的事务中,启用的是乐观锁,只负责监测key没有被改动.</strong></font><p>具体是使用watch命令。</p><p><strong>第一个客户端中：</strong><br><img src="/images/QQ截图20181230204011.png"></p><p><strong>第二个客户端中：</strong><br><img src="/images/QQ截图20181230204339.png"></p><p><strong>第一个客户端中：</strong><br><img src="/images/QQ截图20181230204536.png"></p><hr><p>watch命令</p><pre><code>WATCH key [key ...]监视多个key的值的变化</code></pre><p>unwatch命令</p><pre><code>解除掉所有的被watch命令监视的key值</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的hash命令操作</title>
      <link href="/2018/12/25/redis-de-hash-ming-ling-cao-zuo/"/>
      <url>/2018/12/25/redis-de-hash-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的最后一个数据结构hash结构。<br><a id="more"></a></p><p>redis中的hash的key-value，我一般称为field-value：域和值。主要是为了区别设置时候的key。</p><h2 id="hset-key-field-value"><a href="#hset-key-field-value" class="headerlink" title="hset key field value"></a>hset key field value</h2><pre><code>设置 key 指定的哈希集中指定字段的值。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段在哈希集中存在，它将被重写。返回值integer-reply：含义如下1如果field是一个新的字段0如果field原来在map里面已经存在redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HGET myhash field1&quot;Hello&quot;redis&gt; </code></pre><h2 id="hsetnx-key-field-value"><a href="#hsetnx-key-field-value" class="headerlink" title="hsetnx key field value"></a>hsetnx key field value</h2><pre><code>只在 key 指定的哈希集中不存在指定的字段时，设置字段的值。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段已存在，该操作无效果。redis&gt; HSETNX myhash field &quot;Hello&quot;(integer) 1redis&gt; HSETNX myhash field &quot;World&quot;(integer) 0redis&gt; HGET myhash field&quot;Hello&quot;redis&gt; </code></pre><h2 id="hmset-key-field-value-field-value-…"><a href="#hmset-key-field-value-field-value-…" class="headerlink" title="hmset key field value [field value …]"></a>hmset key field value [field value …]</h2><pre><code>hset：只能为key设置一组field-value，不能设置多组。hmset：能够设置多组field-value。设置 key 指定的哈希集中指定字段的值。该命令将重写所有在哈希集中存在的字段。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。redis&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;OKredis&gt; HGET myhash field1&quot;Hello&quot;redis&gt; HGET myhash field2&quot;World&quot;redis&gt;</code></pre><h2 id="hget-key-field"><a href="#hget-key-field" class="headerlink" title="hget key field"></a>hget key field</h2><pre><code>返回 key 指定的哈希集中该字段所关联的值。redis&gt; HSET myhash field1 &quot;foo&quot;(integer) 1redis&gt; HGET myhash field1&quot;foo&quot;redis&gt; HGET myhash field2(nil)redis&gt;</code></pre><h2 id="hmget-key-field-field-…"><a href="#hmget-key-field-field-…" class="headerlink" title="hmget key field [field …]"></a>hmget key field [field …]</h2><pre><code>返回 key 指定的哈希集中指定字段的值。对于哈希集中不存在的每个字段，返回 nil 值。因为不存在的keys被认为是一个空的哈希集，对一个不存在的 key 执行 HMGET 将返回一个只含有 nil 值的列表。redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HSET myhash field2 &quot;World&quot;(integer) 1redis&gt; HMGET myhash field1 field2 nofield1) &quot;Hello&quot;2) &quot;World&quot;3) (nil)redis&gt; </code></pre><h2 id="hgetall-key"><a href="#hgetall-key" class="headerlink" title="hgetall key"></a>hgetall key</h2><pre><code>返回 key 指定的哈希集中所有的字段和值。返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍。redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HSET myhash field2 &quot;World&quot;(integer) 1redis&gt; HGETALL myhash1) &quot;field1&quot;2) &quot;Hello&quot;3) &quot;field2&quot;4) &quot;World&quot;redis&gt; </code></pre><h2 id="hdel-key-field-field-…"><a href="#hdel-key-field-field-…" class="headerlink" title="hdel key field [field …]"></a>hdel key field [field …]</h2><pre><code>从 key 指定的哈希集中移除指定的域。在哈希集中不存在的域将被忽略。如果 key 指定的哈希集不存在，它将被认为是一个空的哈希集，该命令将返回0。redis&gt; HSET myhash field1 &quot;foo&quot;(integer) 1redis&gt; HDEL myhash field1(integer) 1redis&gt; HDEL myhash field2(integer) 0redis&gt; </code></pre><h2 id="hexists-key-field"><a href="#hexists-key-field" class="headerlink" title="hexists key field"></a>hexists key field</h2><pre><code>返回hash里面field是否存在。integer-reply, 含义如下：1 hash里面包含该field。0 hash里面不包含该field或者key不存在。redis&gt; HSET myhash field1 &quot;foo&quot;(integer) 1redis&gt; HEXISTS myhash field1(integer) 1redis&gt; HEXISTS myhash field2(integer) 0redis&gt; </code></pre><h2 id="hincrby-key-field-increment"><a href="#hincrby-key-field-increment" class="headerlink" title="hincrby key field increment"></a>hincrby key field increment</h2><pre><code>增加 key 指定的哈希集中指定字段的数值。如果 key 不存在，会创建一个新的哈希集并与 key 关联。如果字段不存在，则字段的值在该操作执行前被设置为 0。HINCRBY 支持的值的范围限定在 64位 有符号整数。redis&gt; HSET myhash field 5(integer) 1redis&gt; HINCRBY myhash field 1(integer) 6redis&gt; HINCRBY myhash field -1(integer) 5redis&gt; HINCRBY myhash field -10(integer) -5redis&gt; </code></pre><h2 id="hincrbyfloat-key-field-increment"><a href="#hincrbyfloat-key-field-increment" class="headerlink" title="hincrbyfloat key field increment"></a>hincrbyfloat key field increment</h2><pre><code>为指定key的hash的field字段值执行float类型的increment加。如果field不存在，则在执行该操作前设置为0.如果出现下列情况之一，则返回错误：field的值包含的类型错误(不是字符串)。当前field或者increment不能解析为一个float类型。redis&gt; HSET mykey field 10.50(integer) 1redis&gt; HINCRBYFLOAT mykey field 0.1&quot;10.6&quot;redis&gt; HSET mykey field 5.0e3(integer) 1redis&gt; HINCRBYFLOAT mykey field 2.0e2&quot;5200&quot;redis&gt; </code></pre><h2 id="hlen-key"><a href="#hlen-key" class="headerlink" title="hlen key"></a>hlen key</h2><pre><code>返回 key 指定的哈希集包含的字段的数量。redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HSET myhash field2 &quot;World&quot;(integer) 1redis&gt; HLEN myhash(integer) 2redis&gt;</code></pre><h2 id="hstrlen-key-field"><a href="#hstrlen-key-field" class="headerlink" title="hstrlen key field"></a>hstrlen key field</h2><pre><code>返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0。redis&gt; HMSET myhash f1 HelloWorld f2 99 f3 -256OKredis&gt; HSTRLEN myhash f1(integer) 10redis&gt; HSTRLEN myhash f2(integer) 2redis&gt; HSTRLEN myhash f3(integer) 4redis&gt;</code></pre><hr><h2 id="hkeys-key"><a href="#hkeys-key" class="headerlink" title="hkeys key"></a>hkeys key</h2><pre><code>返回 key 指定的哈希集中所有字段的名字。redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HSET myhash field2 &quot;World&quot;(integer) 1redis&gt; HKEYS myhash1) &quot;field1&quot;2) &quot;field2&quot;redis&gt; </code></pre><h2 id="hvals-key"><a href="#hvals-key" class="headerlink" title="hvals key"></a>hvals key</h2><pre><code>返回 key 指定的哈希集中所有字段的值。redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HSET myhash field2 &quot;World&quot;(integer) 1redis&gt; HVALS myhash1) &quot;Hello&quot;2) &quot;World&quot;redis&gt; </code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的sorted set命令操作</title>
      <link href="/2018/12/23/redis-de-sorted-set-ming-ling-cao-zuo/"/>
      <url>/2018/12/23/redis-de-sorted-set-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>redis中的有序集合：sorted set。<br><a id="more"></a></p><p>上一篇文章中，我们学习了redis中的集合set的相关操作，今天来学redis中的有序集合。set集合中，我们知道是无序性的，所以redis就出了一个有序的集合，方便用户操作使用。</p><p>有序集合的相关命令对比set集合，就是将s变成了z。</p><h2 id="zadd-key-NX-XX-CH-INCR-score-member-score-member-…"><a href="#zadd-key-NX-XX-CH-INCR-score-member-score-member-…" class="headerlink" title="zadd key [NX|XX] [CH] [INCR] score member [score member …]"></a>zadd key [NX|XX] [CH] [INCR] score member [score member …]</h2><pre><code>Redis Zadd 命令用于将一个或多个成员元素及其分数值加入到有序集当中。如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。分数值可以是整数值或双精度浮点数。如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。XX：仅更新已存在的元素。 永远不要添加元素NX：不要更新现有元素。   始终添加新元素。CH：将返回值从添加的新元素数修改为更改的元素总数（CH是已更改的缩写）。     更改的元素是添加的新元素和已更新分数的已存在元素。 因此，命令行中指定的元素具有与过去相同的分数，不计算在内。     注意：通常ZADD的返回值仅计算添加的新元素的数量。INCR：指定此选项时，ZADD的作用类似于ZINCRBY。 在此模式下只能指定一个得分元素对。注意： 在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。redis 127.0.0.1:6379&gt; ZADD myset 1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myset 1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myset 2 &quot;world&quot; 3 &quot;bar&quot;(integer) 2redis 127.0.0.1:6379&gt; ZRANGE myzset 0 -1 WITHSCORES1) &quot;hello&quot;2) &quot;1&quot;3) &quot;foo&quot;4) &quot;1&quot;5) &quot;world&quot;6) &quot;2&quot;7) &quot;bar&quot;8) &quot;3&quot;</code></pre><h2 id="zcard-key"><a href="#zcard-key" class="headerlink" title="zcard key"></a>zcard key</h2><pre><code>Redis Zcard 命令用于计算集合中元素的数量。redis 127.0.0.1:6379&gt; ZADD myset 1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myset 1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myset 2 &quot;world&quot; 3 &quot;bar&quot;(integer) 2redis 127.0.0.1:6379&gt; ZCARD myzset(integer) 4</code></pre><h2 id="zcount-key-min-max"><a href="#zcount-key-min-max" class="headerlink" title="zcount key min max"></a>zcount key min max</h2><pre><code>计算在有序集合中指定区间分数的成员数min和max指的是score分数，不是排名！！！redis 127.0.0.1:6379&gt; ZADD myzset 1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myzset 1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myzset 2 &quot;world&quot; 3 &quot;bar&quot;(integer) 2redis 127.0.0.1:6379&gt; ZCOUNT myzset 1 3(integer) 4</code></pre><h2 id="zincrby-key-increment-member"><a href="#zincrby-key-increment-member" class="headerlink" title="zincrby key increment member"></a>zincrby key increment member</h2><pre><code>Redis Zincrby 命令对有序集合中指定成员member的分数加上增量 increment可以通过传递一个负数值 increment ，让分数减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。当 key 不存在，或member不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。当 key 不是有序集类型时，返回一个错误。分数值可以是整数值或双精度浮点数。redis 127.0.0.1:6379&gt; ZADD myzset 1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myzset 1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; ZINCRBY myzset 2 &quot;hello&quot;(integer) 3redis 127.0.0.1:6379&gt; ZRANGE myzset 0 -1 WITHSCORES1) &quot;foo&quot;2) &quot;2&quot;3) &quot;hello&quot;4) &quot;3&quot;</code></pre><h2 id="zrange-key-start-stop-withscores"><a href="#zrange-key-start-stop-withscores" class="headerlink" title="zrange key start stop [withscores]"></a>zrange key start stop [withscores]</h2><pre><code>Redis Zrange 返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。具有相同分数值的成员按字典序(lexicographical order )来排列。如果你需要成员按值递减(从大到小)来排列，请使用 zrevrange 命令。下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。[withscores]:选项用来表示是否输出分数score。redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES             # 显示整个有序集成员1) &quot;jack&quot;2) &quot;3500&quot;3) &quot;tom&quot;4) &quot;5000&quot;5) &quot;boss&quot;6) &quot;10086&quot;redis 127.0.0.1:6379&gt; ZRANGE salary 1 2 WITHSCORES              # 显示有序集下标区间 1 至 2 的成员1) &quot;tom&quot;2) &quot;5000&quot;3) &quot;boss&quot;4) &quot;10086&quot;redis 127.0.0.1:6379&gt; ZRANGE salary 0 200000 WITHSCORES         # 测试 end 下标超出最大下标时的情况1) &quot;jack&quot;2) &quot;3500&quot;3) &quot;tom&quot;4) &quot;5000&quot;5) &quot;boss&quot;6) &quot;10086&quot;redis &gt; ZRANGE salary 200000 3000000 WITHSCORES                  # 测试当给定区间不存在于有序集时的情况(empty list or set)</code></pre><h2 id="zrangebylex-key-min-max-LIMIT-offset-count"><a href="#zrangebylex-key-min-max-LIMIT-offset-count" class="headerlink" title="zrangebylex key min max [LIMIT offset count]"></a>zrangebylex key min max [LIMIT offset count]</h2><pre><code>ZRANGEBYLEX 返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同。 在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行排序时,可以使用Redis中SortSet这种数据结构来处理。min: 字典中排序位置较小的成员,必须以&quot;[&quot;开头,或者以&quot;(&quot;开头,可使用&quot;-&quot;代替max: 字典中排序位置较大的成员,必须以&quot;[&quot;开头,或者以&quot;(&quot;开头,可使用&quot;+&quot;代替limit: 返回结果是否分页,指令中包含LIMIT后 offset 、count必须输入offset: 返回结果起始位置count: 返回结果数量提示:分数必须相同! 如果有序集合中的成员分数有不一致的,返回的结果就不准。成员字符串作为二进制数组的字节数进行比较。默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。可以使用 “-“ 和 “+” 表示得分最小值和最大值“min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空与ZRANGEBYLEX获取顺序相反的指令是ZREVRANGEBYLEX。源码中采用C语言中 memcmp() 函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。可以使用 “-“ 和 “+” 表示得分最小值和最大值:redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1(integer) 12redis&gt; ZRANGEBYLEX zset - + 1) &quot;a&quot; 2) &quot;aa&quot; 3) &quot;abc&quot; 4) &quot;apple&quot; 5) &quot;b&quot; 6) &quot;c&quot; 7) &quot;d&quot; 8) &quot;d1&quot; 9) &quot;dd&quot;10) &quot;dobble&quot;11) &quot;z&quot;12) &quot;z1&quot;获取分页数据:redis&gt; ZRANGEBYLEX zset - + LIMIT 0 31) &quot;a&quot;2) &quot;aa&quot;3) &quot;abc&quot;redis&gt; ZRANGEBYLEX zset - + LIMIT 3 31) &quot;apple&quot;2) &quot;b&quot;3) &quot;c&quot;获取成员之间的元素:默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。“[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。redis&gt; ZRANGEBYLEX zset [aa [c1) &quot;aa&quot;2) &quot;abc&quot;3) &quot;apple&quot;4) &quot;b&quot;5) &quot;c&quot;“min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空redis&gt; ZRANGEBYLEX zset [c [aa(empty list or set)使用 “(“ 小于号获取成员之间的元素:“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。redis&gt; ZRANGEBYLEX zset [aa (c1) &quot;aa&quot;2) &quot;abc&quot;3) &quot;apple&quot;4) &quot;b&quot;</code></pre><h2 id="zrangebyscore-key-min-max-withscores-limit-offset-count"><a href="#zrangebyscore-key-min-max-withscores-limit-offset-count" class="headerlink" title="zrangebyscore key min max [withscores] [limit offset count]"></a>zrangebyscore key min max [withscores] [limit offset count]</h2><pre><code>返回key的有序集合中的分数在min和max之间的所有元素（包括分数等于max或者min的元素）。元素被认为是从低分到高分排序的。具有相同分数的元素按字典序排列（这个根据redis对有序集合实现的情况而定，并不需要进一步计算）。可选的LIMIT参数指定返回结果的数量及区间（类似SQL中SELECT LIMIT offset, count）。注意，如果offset太大，定位offset就可能遍历整个有序集合，这会增加O(N)的复杂度。可选参数WITHSCORES会返回元素和其分数，而不只是元素。这个选项在redis2.0之后的版本都可用。##区间及无限min和max可以是-inf和+inf，这样一来，你就可以在不知道有序集的最低和最高score值的情况下，使用ZRANGEBYSCORE这类命令。默认情况下，区间的取值使用闭区间(小于等于或大于等于)，你也可以通过给参数前增加(符号来使用可选的开区间(小于或大于)。ZRANGEBYSCORE zset (1 5     返回所有符合条件 1 &lt; score &lt;= 5的成员。ZRANGEBYSCORE zset (5 (10   返回所有符合条件 5 &lt; score &lt;  10的成员。例子：redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZRANGEBYSCORE myzset -inf +inf1) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;redis&gt; ZRANGEBYSCORE myzset 1 21) &quot;one&quot;2) &quot;two&quot;redis&gt; ZRANGEBYSCORE myzset (1 21) &quot;two&quot;redis&gt; ZRANGEBYSCORE myzset (1 (2(empty list or set)redis&gt; </code></pre><h2 id="zrank-key-member"><a href="#zrank-key-member" class="headerlink" title="zrank key member"></a>zrank key member</h2><pre><code>返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。排名以0为底，也就是说，score值最小的成员排名为0。使用ZREVRANK命令可以获得成员按score值递减(从大到小)排列的排名。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZRANK myzset &quot;three&quot;(integer) 2redis&gt; ZRANK myzset &quot;four&quot;(nil)redis&gt; </code></pre><h2 id="zrem-key-member-member-…"><a href="#zrem-key-member-member-…" class="headerlink" title="zrem key member [member …]"></a>zrem key member [member …]</h2><pre><code>删除有序集合key中的member。当key存在，但是其不是有序集合类型，就返回一个错误。返回的是从有序集合中删除的成员个数，不包括不存在的成员。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZREM myzset &quot;two&quot;(integer) 1redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) &quot;one&quot;2) &quot;1&quot;3) &quot;three&quot;4) &quot;3&quot;redis&gt; </code></pre><h2 id="zremrangebylex-key-min-max"><a href="#zremrangebylex-key-min-max" class="headerlink" title="zremrangebylex key min max"></a>zremrangebylex key min max</h2><pre><code>ZREMRANGEBYLEX 删除名称按字典由低到高排序成员之间所有成员。不要在成员分数不同的有序集合中使用此命令, 因为它是基于分数一致的有序集合设计的,如果使用,会导致删除的结果不正确。待删除的有序集合中,分数最好相同,否则删除结果会不正常。min：字典中排序位置较小的成员,必须以&quot;[&quot;开头,或者以&quot;(&quot;开头,可使用&quot;-&quot;代替max：字典中排序位置较大的成员,必须以&quot;[&quot;开头,或者以&quot;(&quot;开头,可使用&quot;+&quot;代替删除所有元素：可以使用 “-“ 和 “+” 表示最小值和最大值redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1(integer) 12redis&gt; zrangebylex zset - + 1) &quot;a&quot; 2) &quot;aa&quot; 3) &quot;abc&quot; 4) &quot;apple&quot; 5) &quot;b&quot; 6) &quot;c&quot; 7) &quot;d&quot; 8) &quot;d1&quot; 9) &quot;dd&quot;10) &quot;dobble&quot;11) &quot;z&quot;12) &quot;z1&quot;redis&gt; zremrangebylex zset - +(integer) 7redis&gt; zrangebylex zset - +(empty list or set)按名称删除某个元素：下面是删除d1这个元素redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1(integer) 12redis&gt; zrangebylex  zset - + 1) &quot;a&quot; 2) &quot;aa&quot; 3) &quot;abc&quot; 4) &quot;apple&quot; 5) &quot;b&quot; 6) &quot;c&quot; 7) &quot;d&quot; 8) &quot;d1&quot; 9) &quot;dd&quot;10) &quot;dobble&quot;11) &quot;z&quot;12) &quot;z1&quot;redis&gt; zremrangebylex zset [d1 (dd(integer) 1redis&gt; zrangebylex  zset - + 1) &quot;a&quot; 2) &quot;aa&quot; 3) &quot;abc&quot; 4) &quot;apple&quot; 5) &quot;b&quot; 6) &quot;c&quot; 7) &quot;d&quot; 8) &quot;dd&quot; 9) &quot;dobble&quot;10) &quot;z&quot;11) &quot;z1&quot;按名称删除成员之间的元素,包含”max” 和 “min”成员：redis&gt; ZRANGEBYLEX zset - + 1) &quot;a&quot; 2) &quot;aa&quot; 3) &quot;abc&quot; 4) &quot;apple&quot; 5) &quot;b&quot; 6) &quot;c&quot; 7) &quot;d&quot; 8) &quot;dd&quot; 9) &quot;dobble&quot;10) &quot;z&quot;11) &quot;z1&quot;redis&gt; ZREMRANGEBYLEX zset [a [apple(integer) 4redis&gt; ZRANGEBYLEX zset - +1) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;dd&quot;5) &quot;dobble&quot;6) &quot;z&quot;7) &quot;z1&quot;按名称删除成员之间的元素,不包含”max” 和 “min”成员：redis&gt; ZRANGEBYLEX zset - +1) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;dd&quot;5) &quot;dobble&quot;6) &quot;z&quot;7) &quot;z1&quot;     redis&gt; ZREMRANGEBYLEX zset (d (dobble(integer) 1redis&gt; ZRANGEBYLEX zset - +1) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;dobble&quot;5) &quot;z&quot;6) &quot;z1&quot;</code></pre><h2 id="zremrangebyrank-key-start-stop"><a href="#zremrangebyrank-key-start-stop" class="headerlink" title="zremrangebyrank key start stop"></a>zremrangebyrank key start stop</h2><pre><code>移除有序集key中，指定排名(rank)区间内的所有成员。下标参数start和stop都以0为底，0处是分数最小的那个元素。这些索引也可是负数，表示位移从最高分处开始数。例如，-1是分数最高的元素，-2是分数第二高的，依次类推。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZREMRANGEBYRANK myzset 0 1(integer) 2redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) &quot;three&quot;2) &quot;3&quot;redis&gt; </code></pre><h2 id="zremrangebyscore-key-min-max"><a href="#zremrangebyscore-key-min-max" class="headerlink" title="zremrangebyscore key min max"></a>zremrangebyscore key min max</h2><pre><code>移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。 自版本2.1.6开始，score值等于min或max的成员也可以不包括在内，语法请参见ZRANGEBYSCORE命令。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZREMRANGEBYSCORE myzset -inf (2(integer) 1redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) &quot;two&quot;2) &quot;2&quot;3) &quot;three&quot;4) &quot;3&quot;redis&gt; </code></pre><hr><h2 id="zrevrank-key-member"><a href="#zrevrank-key-member" class="headerlink" title="zrevrank key member"></a>zrevrank key member</h2><pre><code>返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列。排名以0为底，也就是说，score值最大的成员排名为0。使用ZRANK命令可以获得成员按score值递增(从小到大)排列的排名。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZREVRANK myzset &quot;one&quot;(integer) 2redis&gt; ZREVRANK myzset &quot;four&quot;(nil)redis&gt; </code></pre><h2 id="zrevrange-key-start-stop-withscores"><a href="#zrevrange-key-start-stop-withscores" class="headerlink" title="zrevrange key start stop [withscores]"></a>zrevrange key start stop [withscores]</h2><pre><code>返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。具有相同score值的成员按字典序的反序排列。 除了成员按score值递减的次序排列这一点外，ZREVRANGE命令的其他方面和ZRANGE命令一样redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZREVRANGE myzset 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;redis&gt; ZREVRANGE myzset 2 31) &quot;one&quot;redis&gt; ZREVRANGE myzset -2 -11) &quot;two&quot;2) &quot;one&quot;redis&gt; </code></pre><h2 id="zrevrangebylex-key-max-min-limit-offset-count"><a href="#zrevrangebylex-key-max-min-limit-offset-count" class="headerlink" title="zrevrangebylex key max min [limit offset count]"></a>zrevrangebylex key max min [limit offset count]</h2><pre><code>zrevrangebylex 返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同。在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行倒序排列时,可以使用Redis中SortSet这种数据结构来处理。</code></pre><h2 id="zrevrangebyscore-key-max-min-withscores-limit-offset-count"><a href="#zrevrangebyscore-key-max-min-withscores-limit-offset-count" class="headerlink" title="zrevrangebyscore key max min [withscores] [limit offset count]"></a>zrevrangebyscore key max min [withscores] [limit offset count]</h2><pre><code>zrevrangebyscore 返回有序集合中指定分数区间内的成员，分数由高到低排序。</code></pre><h2 id="zscore-key-member"><a href="#zscore-key-member" class="headerlink" title="zscore key member"></a>zscore key member</h2><pre><code>返回有序集key中，成员member的score值。如果member元素不是有序集key的成员，或key不存在，返回nil。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZSCORE myzset &quot;one&quot;&quot;1&quot;redis&gt; </code></pre><h2 id="zpopmax-key-count"><a href="#zpopmax-key-count" class="headerlink" title="zpopmax key [count]"></a>zpopmax key [count]</h2><pre><code>删除并返回有序集合key中的最多count个具有最高得分的成员。如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最高的元素将是第一个元素，然后是分数较低的元素。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZPOPMAX myzset1) &quot;3&quot;2) &quot;three&quot;redis&gt; </code></pre><h2 id="zpopmin-key-count"><a href="#zpopmin-key-count" class="headerlink" title="zpopmin key [count]"></a>zpopmin key [count]</h2><pre><code>删除并返回有序集合key中的最多count个具有最低得分的成员。如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最低的元素将是第一个元素，然后是分数较高的元素。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZPOPMIN myzset1) &quot;1&quot;2) &quot;one&quot;redis&gt; </code></pre><h2 id="zinterstore-destination-numkeys-key-key-…-weights-weight-aggregate-sum-min-max"><a href="#zinterstore-destination-numkeys-key-key-…-weights-weight-aggregate-sum-min-max" class="headerlink" title="zinterstore destination numkeys key [key …] [weights weight] [aggregate sum|min|max]"></a>zinterstore destination numkeys key [key …] [weights weight] [aggregate sum|min|max]</h2><pre><code>计算给定的numkeys个有序集合的交集，并且把结果放到destination中。 在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。默认情况下，结果中一个元素的分数是有序集合中该元素分数之和，前提是该元素在这些有序集合中都存在。因为交集要求其成员必须是给定的每个有序集合中的成员，结果集中的每个元素的分数和输入的有序集合个数相等。numkeys: 有序集合key的个数。weights：后面加上的是每个key的权重，就是后面的数字乘以每个key的score。aggregate：计算方式，默认是sum：求和。min：numkeys个key中score最小的，max：最大的。如果destination存在，就把它覆盖。127.0.0.1:6379&gt; zadd liu 3 cat 5 dog 7 horse (integer) 3127.0.0.1:6379&gt; zadd deng 4 cat 6 dog 8 horse 1 monkey(integer) 4127.0.0.1:6379&gt; zinterstore result 2 liu deng(integer) 3127.0.0.1:6379&gt; zrange result 0 -1 withscores1) &quot;cat&quot;2) &quot;7&quot;3) &quot;dog&quot;4) &quot;11&quot;5) &quot;horse&quot;6) &quot;15&quot;通过上述的结果看出，默认是求和。127.0.0.1:6379&gt; zinterstore result 2 liu deng weights 2 1(integer) 3127.0.0.1:6379&gt; zrange result 0 -1 withscores1) &quot;cat&quot;2) &quot;10&quot;3) &quot;dog&quot;4) &quot;16&quot;5) &quot;horse&quot;6) &quot;22&quot;liu的权重就是2了，就是liu中的每个score乘以2，deng乘以1；然后求和。127.0.0.1:6379&gt; zinterstore result 2 liu deng aggregate max(integer) 3127.0.0.1:6379&gt; zrange result 0 -1 withscores1) &quot;cat&quot;2) &quot;4&quot;3) &quot;dog&quot;4) &quot;6&quot;5) &quot;horse&quot;6) &quot;8&quot;127.0.0.1:6379&gt; 改变了计算方式：为max了，就是求keys中每个score分数最大的了，不是求和了。</code></pre><h2 id="zunionstore-destination-numkeys-key-key-…-weights-weight-sum-min-max"><a href="#zunionstore-destination-numkeys-key-key-…-weights-weight-sum-min-max" class="headerlink" title="zunionstore destination numkeys key [key …] [weights weight] [sum|min|max]"></a>zunionstore destination numkeys key [key …] [weights weight] [sum|min|max]</h2><pre><code>和zinterstore一样，只是求并集而已。redis&gt; ZADD zset1 1 &quot;one&quot;(integer) 1redis&gt; ZADD zset1 2 &quot;two&quot;(integer) 1redis&gt; ZADD zset2 1 &quot;one&quot;(integer) 1redis&gt; ZADD zset2 2 &quot;two&quot;(integer) 1redis&gt; ZADD zset2 3 &quot;three&quot;(integer) 1redis&gt; ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3(integer) 3redis&gt; ZRANGE out 0 -1 WITHSCORES1) &quot;one&quot;2) &quot;5&quot;3) &quot;three&quot;4) &quot;9&quot;5) &quot;two&quot;6) &quot;10&quot;redis&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的set命令操作</title>
      <link href="/2018/12/23/redis-de-set-ming-ling-cao-zuo/"/>
      <url>/2018/12/23/redis-de-set-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的集合操作命令。<br><a id="more"></a></p><p>集合的性质: 唯一性,无序性,确定性</p><p>注: 在string 和 list的命令中,可以通过 range 来访问 string 中的某几个字符或某几个元素</p><p>但,因为集合的无序性,无法通过下标或范围来访问部分元素.</p><h2 id="sadd-key-member-member-…"><a href="#sadd-key-member-member-…" class="headerlink" title="sadd key member [member …]"></a>sadd key member [member …]</h2><pre><code>作用: 往集合key中增加元素。Redis Sadd 命令将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。当集合 key 不是集合类型时，返回一个错误。注意：在Redis2.4版本以前， SADD 只接受单个成员值。redis&gt; SADD myset &quot;Hello&quot;(integer) 1redis&gt; SADD myset &quot;World&quot;(integer) 1redis&gt; SADD myset &quot;World&quot;(integer) 0redis&gt; SMEMBERS myset1) &quot;World&quot;2) &quot;Hello&quot;redis&gt; </code></pre><h2 id="smembers-key"><a href="#smembers-key" class="headerlink" title="smembers key"></a>smembers key</h2><pre><code>Redis Smembers 命令返回集合中的所有的成员。 不存在的集合 key 被视为空集合。redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SMEMBERS myset11) &quot;World&quot;2) &quot;Hello&quot;</code></pre><h2 id="srem-value-value…"><a href="#srem-value-value…" class="headerlink" title="srem value [value…]"></a>srem value [value…]</h2><pre><code>作用: 删除集合中集为 value1 value2的元素返回值: 忽略不存在的元素后,真正删除掉的元素的个数127.0.0.1:6379&gt; sadd gender male famale yao(integer) 3127.0.0.1:6379&gt; 127.0.0.1:6379&gt; smembers gender1) &quot;yao&quot;2) &quot;famale&quot;3) &quot;male&quot;127.0.0.1:6379&gt; srem gender yao(integer) 1127.0.0.1:6379&gt; smembers gender1) &quot;famale&quot;2) &quot;male&quot;</code></pre><h2 id="spop-key"><a href="#spop-key" class="headerlink" title="spop key"></a>spop key</h2><pre><code>作用: 返回并删除集合中key中1个随机元素.随机--体现了无序性.redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SPOP myset1&quot;bar&quot;redis 127.0.0.1:6379&gt; SMEMBERS myset11) &quot;Hello&quot;2) &quot;world&quot;不是删除第一个或最后一个插入集合的元素，而是随机删除的！！！</code></pre><h2 id="srandmember-key"><a href="#srandmember-key" class="headerlink" title="srandmember key"></a>srandmember key</h2><pre><code>作用: 返回集合key中,随机的1个元素。只是返回，不删除！！！127.0.0.1:6379&gt; srandmember gender&quot;famale&quot;127.0.0.1:6379&gt; srandmember gender&quot;famale&quot;127.0.0.1:6379&gt; srandmember gender&quot;famale&quot;127.0.0.1:6379&gt; srandmember gender&quot;famale&quot;127.0.0.1:6379&gt; srandmember gender&quot;male&quot;这里不是说famale的概率大啊，是随机的，只是测试次数少，所以看起来好像famale的概率大。</code></pre><h2 id="sismember-key-value"><a href="#sismember-key-value" class="headerlink" title="sismember key value"></a>sismember key value</h2><pre><code>作用: 判断value是否在key集合中是返回1,否返回0redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SISMEMBER myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SISMEMBER myset1 &quot;world&quot;(integer) 0</code></pre><h2 id="scard-key"><a href="#scard-key" class="headerlink" title="scard key"></a>scard key</h2><pre><code>作用: 返回集合中元素的个数redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 0redis 127.0.0.1:6379&gt; SCARD myset(integer) 2</code></pre><h2 id="smove-source-dest-member"><a href="#smove-source-dest-member" class="headerlink" title="smove source dest member"></a>smove source dest member</h2><pre><code>作用:把source中的 member 删除 , 并添加到dest集合中。SMOVE 是原子性操作。如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 dest 集合中去。当 dest 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。当 source 或 dest 不是集合类型时，返回一个错误。redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SMOVE myset1 myset2 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SMEMBERS myset11) &quot;World&quot;2) &quot;Hello&quot;redis 127.0.0.1:6379&gt; SMEMBERS myset21) &quot;foo&quot;2) &quot;bar&quot;</code></pre><h2 id="sinter-key-key-…"><a href="#sinter-key-key-…" class="headerlink" title="sinter  key [key …]"></a>sinter  key [key …]</h2><pre><code>Redis Sinter 命令返回给定所有给定集合的交集。 不存在的集合 key 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SINTER myset myset21) &quot;hello&quot;</code></pre><h2 id="sinterstore-destination-key-key-…"><a href="#sinterstore-destination-key-key-…" class="headerlink" title="sinterstore destination key [key …]"></a>sinterstore destination key [key …]</h2><pre><code>Redis Sinterstore 命令将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖。redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SINTERSTORE myset myset1 myset2(integer) 1redis 127.0.0.1:6379&gt; SMEMBERS myset1) &quot;hello&quot;</code></pre><h2 id="sunion-key-key-…"><a href="#sunion-key-key-…" class="headerlink" title="sunion key [key …]"></a>sunion key [key …]</h2><pre><code>Redis Sunion 命令返回给定集合的并集。不存在的集合 key 被视为空集。redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SUNION myset1 myset21) &quot;bar&quot;2) &quot;world&quot;3) &quot;hello&quot;4) &quot;foo&quot;</code></pre><h2 id="sunionstore-destination-key-key-…"><a href="#sunionstore-destination-key-key-…" class="headerlink" title="sunionstore destination key [key …]"></a>sunionstore destination key [key …]</h2><pre><code>Redis Sunionstore 命令将给定集合的并集存储在指定的集合 destination 中。redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SUNIONSTORE myset myset1 myset2(integer) 1redis 127.0.0.1:6379&gt; SMEMBERS myset1) &quot;bar&quot;2) &quot;world&quot;3) &quot;hello&quot;4) &quot;foo&quot;</code></pre><h2 id="sdiff-key-key-…"><a href="#sdiff-key-key-…" class="headerlink" title="sdiff key [key …]"></a>sdiff key [key …]</h2><pre><code>Redis Sdiff 命令返回给定集合之间的差集。不存在的集合 key 将视为空集。redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SDIFF myset myset21) &quot;foo&quot;2) &quot;bar&quot;</code></pre><h2 id="sdiffstore-destination-key-key-…"><a href="#sdiffstore-destination-key-key-…" class="headerlink" title="sdiffstore destination key [key …]"></a>sdiffstore destination key [key …]</h2><pre><code>Redis Sdiffstore 命令将给定集合之间的差集存储在指定的集合中。如果指定的集合 key 已存在，则会被覆盖。redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SDIFFSTORE destset myset myset2(integer) 2redis 127.0.0.1:6379&gt; SMEMBERS destset1) &quot;foo&quot;2) &quot;bar&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的list命令操作</title>
      <link href="/2018/12/22/redis-de-list-ming-ling-cao-zuo/"/>
      <url>/2018/12/22/redis-de-list-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>这篇文章来讲述redis中的list：链表的操作，学过数据结构的应该都清楚，链表的结构，这里就不详细描述了，只讲述redis中的链表操作。<br><a id="more"></a></p><h2 id="lpush-key-value-value-…"><a href="#lpush-key-value-value-…" class="headerlink" title="lpush key value [value …]"></a>lpush key value [value …]</h2><pre><code>作用: 把值插入到链接头部[从左边插入]redis&gt; LPUSH mylist &quot;world&quot;(integer) 1redis&gt; LPUSH mylist &quot;hello&quot;(integer) 2redis&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;world&quot;redis&gt; </code></pre><h2 id="rpush-key-value-value-…"><a href="#rpush-key-value-value-…" class="headerlink" title="rpush key value [value …]"></a>rpush key value [value …]</h2><pre><code>作用: 把值插入到链接尾部[从右边插入]redis&gt; RPUSH mylist &quot;hello&quot;(integer) 1redis&gt; RPUSH mylist &quot;world&quot;(integer) 2redis&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;world&quot;redis&gt; </code></pre><h2 id="lpop-key"><a href="#lpop-key" class="headerlink" title="lpop key"></a>lpop key</h2><pre><code>作用: 把链接头部的元素弹出[从左边弹出]redis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; LPOP mylist&quot;one&quot;redis&gt; LRANGE mylist 0 -11) &quot;two&quot;2) &quot;three&quot;redis&gt; </code></pre><h2 id="rpop-key"><a href="#rpop-key" class="headerlink" title="rpop key"></a>rpop key</h2><pre><code>作用: 把链接尾部的元素弹出[从右边弹出]redis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; RPOP mylist&quot;three&quot;redis&gt; LRANGE mylist 0 -11) &quot;one&quot;2) &quot;two&quot;redis&gt; </code></pre><h2 id="lrange-key-start-stop"><a href="#lrange-key-start-stop" class="headerlink" title="lrange key start  stop"></a>lrange key start  stop</h2><pre><code>作用: 返回链表中[start ,stop]中的元素规律: 左数从0开始,右数从-1开始redis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; LRANGE mylist 0 01) &quot;one&quot;redis&gt; LRANGE mylist -3 21) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;redis&gt; LRANGE mylist -100 1001) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;redis&gt; LRANGE mylist 5 10(empty list or set)redis&gt; </code></pre><h2 id="lrem-key-count-value"><a href="#lrem-key-count-value" class="headerlink" title="lrem key count value"></a>lrem key count value</h2><pre><code>作用: 从key链表中删除 value值注:   删除count的绝对值个value后结束count&gt;0 从表头删除等于value的值count&lt;0 从表尾删除等于value的值count=0 从链表中删除所有等于value的值127.0.0.1:6379&gt; lrange mylist 0 -1 1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;c&quot; 4) &quot;a&quot; 5) &quot;d&quot; 6) &quot;e&quot; 7) &quot;f&quot; 8) &quot;e&quot; 9) &quot;e&quot;10) &quot;g&quot;127.0.0.1:6379&gt; lrem mylist a(error) ERR wrong number of arguments for &#39;lrem&#39; command127.0.0.1:6379&gt; lrem mylist 0 a(integer) 2127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;e&quot;5) &quot;f&quot;6) &quot;e&quot;7) &quot;e&quot;8) &quot;g&quot;127.0.0.1:6379&gt; lrem mylist 1 e(integer) 1127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;f&quot;5) &quot;e&quot;6) &quot;e&quot;7) &quot;g&quot;127.0.0.1:6379&gt; rpush mylist d(integer) 8127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;f&quot;5) &quot;e&quot;6) &quot;e&quot;7) &quot;g&quot;8) &quot;d&quot;127.0.0.1:6379&gt; lrem mylist -1 d(integer) 1127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;f&quot;5) &quot;e&quot;6) &quot;e&quot;7) &quot;g&quot;</code></pre><h2 id="ltrim-key-start-stop"><a href="#ltrim-key-start-stop" class="headerlink" title="ltrim key start stop"></a>ltrim key start stop</h2><pre><code>作用: 剪切key对应的链接,切[start,stop]一段,并把该段重新赋给keyredis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; LTRIM mylist 1 -1&quot;OK&quot;redis&gt; LRANGE mylist 0 -11) &quot;two&quot;2) &quot;three&quot;redis&gt; </code></pre><h2 id="lindex-key-index"><a href="#lindex-key-index" class="headerlink" title="lindex key index"></a>lindex key index</h2><pre><code>作用: 返回index索引上的值,如  lindex key 2redis&gt; LPUSH mylist &quot;World&quot;(integer) 1redis&gt; LPUSH mylist &quot;Hello&quot;(integer) 2redis&gt; LINDEX mylist 0&quot;Hello&quot;redis&gt; LINDEX mylist -1&quot;World&quot;redis&gt; LINDEX mylist 3(nil)redis&gt;</code></pre><h2 id="lset-key-index-value"><a href="#lset-key-index-value" class="headerlink" title="lset key index value"></a>lset key index value</h2><pre><code>作用：在指定的index处，修改value值。redis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; LSET mylist 0 &quot;four&quot;&quot;OK&quot;redis&gt; LSET mylist -2 &quot;five&quot;&quot;OK&quot;redis&gt; LRANGE mylist 0 -11) &quot;four&quot;2) &quot;five&quot;3) &quot;three&quot;redis&gt; </code></pre><h2 id="llen-key"><a href="#llen-key" class="headerlink" title="llen key"></a>llen key</h2><pre><code>作用:计算链接表的元素个数redis&gt; LPUSH mylist &quot;World&quot;(integer) 1redis&gt; LPUSH mylist &quot;Hello&quot;(integer) 2redis&gt; LLEN mylist(integer) 2redis&gt;</code></pre><h2 id="linsert-key-after-before-search-value"><a href="#linsert-key-after-before-search-value" class="headerlink" title="linsert  key after|before search value"></a>linsert  key after|before search value</h2><pre><code>作用: 在key链表中寻找’search’ , 并在search值 之后|之前 , 插入value注: 一旦找到一个search后,命令就结束了,因此不会插入多个valueredis&gt; RPUSH mylist &quot;Hello&quot;(integer) 1redis&gt; RPUSH mylist &quot;World&quot;(integer) 2redis&gt; LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;(integer) 3redis&gt; LRANGE mylist 0 -11) &quot;Hello&quot;2) &quot;There&quot;3) &quot;World&quot;redis&gt; </code></pre><h2 id="rpoplpush-source-dest"><a href="#rpoplpush-source-dest" class="headerlink" title="rpoplpush source dest"></a>rpoplpush source dest</h2><pre><code>作用: 把source的尾部拿出,放在dest的头部,并返回 该单元值注意：这是一个原子操作，那么都成功，要么都失败！！！redis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; RPOPLPUSH mylist myotherlist&quot;three&quot;redis&gt; LRANGE mylist 0 -11) &quot;one&quot;2) &quot;two&quot;redis&gt; LRANGE myotherlist 0 -11) &quot;three&quot;redis&gt; ==================================================场景: task + bak 双链表完成安全队列业务逻辑:1:Rpoplpush task  bak2:接收返回值, 并做业务处理3:如果成功 , lpop bak 清除任务。 如不成功 , 下次从bak表里取任务。</code></pre><h2 id="brpop-blpop-key-timeout"><a href="#brpop-blpop-key-timeout" class="headerlink" title="brpop,blpop key timeout"></a>brpop,blpop key timeout</h2><pre><code>作用:等待弹出key的尾/头元素, Timeout为等待超时时间，单位秒如果timeout为0,则一直等待</code></pre><p>使用两个redis客户端来操作。</p><p>在一个redis客户端中弹出mylist里面的数据，但是没有数据，设置过期时间为5秒。</p><p>如果在5秒内，还没有往mylist中插入数据，那么会退出。</p><p><img src="/images/QQ截图20181222202823.png"></p><p>如果在规定的时间内插入了数据，就会弹出该数据。<br><img src="/images/QQ截图20181222203213.png"></p><p>场景: 长轮询Ajax,在线聊天时,能够用到。</p><h2 id="brpoplpush-source-destination-timeout"><a href="#brpoplpush-source-destination-timeout" class="headerlink" title="brpoplpush source destination timeout"></a>brpoplpush source destination timeout</h2><pre><code>rpoplpush的阻塞版本。</code></pre><hr><h2 id="lpushx-key-value"><a href="#lpushx-key-value" class="headerlink" title="lpushx key value"></a>lpushx key value</h2><pre><code>作用：和lpush一样，只是当key不存在时，不会操作，而lpush当key不存在时，会创建插入数据。redis&gt; LPUSH mylist &quot;World&quot;(integer) 1redis&gt; LPUSHX mylist &quot;Hello&quot;(integer) 2redis&gt; LPUSHX myotherlist &quot;Hello&quot;(integer) 0redis&gt; LRANGE mylist 0 -11) &quot;Hello&quot;2) &quot;World&quot;redis&gt; LRANGE myotherlist 0 -1(empty list or set)redis&gt; </code></pre><h2 id="rpushx-key-value"><a href="#rpushx-key-value" class="headerlink" title="rpushx key value"></a>rpushx key value</h2><pre><code>作用：和rpush一样，只是当key不存在时，不会操作，而lpush当key不存在时，会创建插入数据。redis&gt; RPUSH mylist &quot;Hello&quot;(integer) 1redis&gt; RPUSHX mylist &quot;World&quot;(integer) 2redis&gt; RPUSHX myotherlist &quot;World&quot;(integer) 0redis&gt; LRANGE mylist 0 -11) &quot;Hello&quot;2) &quot;World&quot;redis&gt; LRANGE myotherlist 0 -1(empty list or set)redis&gt; </code></pre><hr><h2 id="面试题：setbit-的实际应用"><a href="#面试题：setbit-的实际应用" class="headerlink" title="面试题：setbit 的实际应用"></a>面试题：setbit 的实际应用</h2><p>场景: 1亿个用户 , 每个用户 登陆/做任意操作  , 记为 今天活跃 , 否则记为不活跃。</p><p>每周评出: 有奖活跃用户: 连续7天活动<br>每月评,等等…</p><p>思路: </p><pre><code>userid   dt             active1        2013-07-27     11        2013-07-26     1</code></pre><p>如果是放在表中, 1:表急剧增大, 2:要用group , sum运算 , 计算较慢。</p><p>用: 位图法 bit-map</p><pre><code>Log0721 :  ‘011001...............0’......log0726 :  ‘011001...............0’Log0727 :  ‘011000...............1’</code></pre><p>1: 记录用户登陆:<br>每天按日期生成一个位图, 用户登陆后,把user_id位上的bit值置为1</p><p>2: 把1周的位图  and 计算,<br>位上为1的,即是连续登陆的用户</p><pre><code>redis 127.0.0.1:6379&gt; setbit mon 100000000 0(integer) 0redis 127.0.0.1:6379&gt; setbit mon 3 1(integer) 0redis 127.0.0.1:6379&gt; setbit mon 5 1(integer) 0redis 127.0.0.1:6379&gt; setbit mon 7 1(integer) 0redis 127.0.0.1:6379&gt; setbit thur 100000000 0(integer) 0redis 127.0.0.1:6379&gt; setbit thur 3 1(integer) 0redis 127.0.0.1:6379&gt; setbit thur 5 1(integer) 0redis 127.0.0.1:6379&gt; setbit thur 8 1(integer) 0redis 127.0.0.1:6379&gt; setbit wen 100000000 0(integer) 0redis 127.0.0.1:6379&gt; setbit wen 3 1(integer) 0redis 127.0.0.1:6379&gt; setbit wen 4 1(integer) 0redis 127.0.0.1:6379&gt; setbit wen 6 1(integer) 0redis 127.0.0.1:6379&gt; bitop and  res mon feb wen(integer) 12500001</code></pre><p>如上例,优点:</p><p>1: 节约空间, 1亿人每天的登陆情况,用1亿bit,约1200WByte,约10M 的字符就能表示<br>2: 计算方便</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的String命令操作</title>
      <link href="/2018/12/22/redis-de-string-ming-ling-cao-zuo/"/>
      <url>/2018/12/22/redis-de-string-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>今天来学习Redis中的字符串类型操作<br><a id="more"></a></p><p>Redis字符串类型的操作</p><h2 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h2><pre><code>set key value [ex 秒数] / [px 毫秒数]  [nx不存在] /[xx存在]如: set a 1 ex 10    , 10秒有效    set a 1 px 9000  , 9秒有效注: 如果ex,px同时写 ,以后面的有效期为准如 set a 1 ex 100 px 9000 , 实际有效期是9000毫秒nx: 表示key不存在时,执行操作xx: 表示key存在时,执行操作=====================================127.0.0.1:6379&gt; set a 1 ex 10OK127.0.0.1:6379&gt; ttl a(integer) 8127.0.0.1:6379&gt; ttl a(integer) 7127.0.0.1:6379&gt; ttl a(integer) 6127.0.0.1:6379&gt; ttl a(integer) 1127.0.0.1:6379&gt; ttl a(integer) 0127.0.0.1:6379&gt; ttl a(integer) -2不能同时设置 ex 和 px127.0.0.1:6379&gt; set a 1 ex 4 px 9000(error) ERR syntax error127.0.0.1:6379&gt; set a 1 px 8000OK127.0.0.1:6379&gt; ttl a(integer) 6127.0.0.1:6379&gt; ttl a(integer) 5127.0.0.1:6379&gt; pttl a(integer) 2176127.0.0.1:6379&gt; pttl a(integer) 960127.0.0.1:6379&gt; pttl a(integer) -2=====================================127.0.0.1:6379&gt; get a&quot;1&quot;127.0.0.1:6379&gt; set a 2 nx(nil)127.0.0.1:6379&gt; set a 2 xxOK127.0.0.1:6379&gt; get a&quot;2&quot;当a存在时，使用nx不会修改a的值，必须使用xx才能修改存在的值。=====================================set key value [默认是当key不存在时，创建key，key存在时，修改key的value值]</code></pre><h2 id="setex-key-seconds-value"><a href="#setex-key-seconds-value" class="headerlink" title="setex key seconds value"></a>setex key seconds value</h2><pre><code>设置key的value的同时，并设置过期的时间，单位是秒等价于set mykey valueexpire mykey seconds=====================================redis&gt; SETEX mykey 10 &quot;Hello&quot;&quot;OK&quot;redis&gt; TTL mykey(integer) 10redis&gt; GET mykey&quot;Hello&quot;redis&gt; </code></pre><h2 id="psetex-key-milliseconds-value"><a href="#psetex-key-milliseconds-value" class="headerlink" title="psetex key milliseconds value"></a>psetex key milliseconds value</h2><pre><code>作用：设置key的同时，设置key的过期时间，单位是毫秒redis&gt; PSETEX mykey 1000 &quot;Hello&quot;&quot;OK&quot;redis&gt; PTTL mykey(integer) 999redis&gt; GET mykey&quot;Hello&quot;redis&gt; </code></pre><h2 id="setnx-key-value"><a href="#setnx-key-value" class="headerlink" title="setnx key value"></a>setnx key value</h2><pre><code>返回：key不存时，设置成功，返回1key存在时，设置失败，返回0redis&gt; SETNX mykey &quot;Hello&quot;(integer) 1redis&gt; SETNX mykey &quot;World&quot;(integer) 0redis&gt; GET mykey&quot;Hello&quot;redis&gt; </code></pre><h2 id="setrange-key-offset-value"><a href="#setrange-key-offset-value" class="headerlink" title="setrange key offset value"></a>setrange key offset value</h2><pre><code>作用:把字符串的offset偏移字节,改成valueredis 127.0.0.1:6379&gt; set greet helloOKredis 127.0.0.1:6379&gt; setrange greet 2 x(integer) 5redis 127.0.0.1:6379&gt; get greet&quot;hexlo&quot;注意: 如果偏移量&gt;字符长度, 该字符自动补0x00redis 127.0.0.1:6379&gt; setrange greet 6 !(integer) 7redis 127.0.0.1:6379&gt; get greet&quot;hexlo\x00!&quot;</code></pre><h2 id="strlen-key"><a href="#strlen-key" class="headerlink" title="strlen key"></a>strlen key</h2><pre><code>作用：返回key的value值的长度redis&gt; SET mykey &quot;Hello world&quot;&quot;OK&quot;redis&gt; STRLEN mykey(integer) 11redis&gt; STRLEN nonexisting(integer) 0redis&gt; 返回的是value值的长度，从1开始计数，不存在的key，返回0。</code></pre><hr><h2 id="get-key"><a href="#get-key" class="headerlink" title="get key"></a>get key</h2><pre><code>作用：返回key的value值redis&gt; GET nonexisting(nil)redis&gt; SET mykey &quot;Hello&quot;&quot;OK&quot;redis&gt; GET mykey&quot;Hello&quot;redis&gt;</code></pre><h2 id="get-key-start-end"><a href="#get-key-start-end" class="headerlink" title="get key start end"></a>get key start end</h2><pre><code>作用：返回key的起始与结束之间的value值，包括start与end。序号是从0开始计算的！！！末尾的序号是-1.redis&gt; SET mykey &quot;This is a string&quot;&quot;OK&quot;redis&gt; GETRANGE mykey 0 3&quot;This&quot;redis&gt; GETRANGE mykey -3 -1&quot;ing&quot;redis&gt; GETRANGE mykey 0 -1&quot;This is a string&quot;redis&gt; GETRANGE mykey 10 100&quot;string&quot;redis&gt;注意: 1: start &gt;= length , 则返回空字符串2: end &gt;= length , 则截取至字符串的结尾3: 如果start 所处位置在 end 右边, 返回空字符串</code></pre><h2 id="getset-key-value"><a href="#getset-key-value" class="headerlink" title="getset key value"></a>getset key value</h2><pre><code>作用：返回上次的旧值，并设置新的value值redis&gt; SET mykey &quot;Hello&quot;&quot;OK&quot;redis&gt; GETSET mykey &quot;World&quot;&quot;Hello&quot;redis&gt; GET mykey&quot;World&quot;redis&gt; </code></pre><h2 id="append-key-value"><a href="#append-key-value" class="headerlink" title="append key value"></a>append key value</h2><pre><code>作用：当key存在时，在value后面追加新的value值。当key不存在时，就相当于set，创建一个新的valueredis&gt; EXISTS mykey(integer) 0redis&gt; APPEND mykey &quot;Hello&quot;(integer) 5redis&gt; APPEND mykey &quot; World&quot;(integer) 11redis&gt; GET mykey&quot;Hello World&quot;redis&gt; </code></pre><hr><h2 id="incr-key"><a href="#incr-key" class="headerlink" title="incr key"></a>incr key</h2><pre><code>作用：将key的value值，增加1，前提是key的value值是数字型的字符串redis&gt; SET mykey &quot;10&quot;&quot;OK&quot;redis&gt; INCR mykey(integer) 11redis&gt; GET mykey&quot;11&quot;redis&gt;如果key不存在，incr key，会将key的value赋值为1.这里fff本身不存在。127.0.0.1:6379&gt; incr fff(integer) 1127.0.0.1:6379&gt; get fff&quot;1如果key的value值不是数字型的字符串，就会报错！！！127.0.0.1:6379&gt; set lll fdfdfOK127.0.0.1:6379&gt; get lll&quot;fdfdf&quot;127.0.0.1:6379&gt; incr lll(error) ERR value is not an integer or out of range127.0.0.1:6379&gt;注意:1:不存在的key当成0,再incr操作2: 范围为64有符号</code></pre><h2 id="incrby-key-number"><a href="#incrby-key-number" class="headerlink" title="incrby key number"></a>incrby key number</h2><pre><code>incr key：是将key的value值加1。incrby key number：是将key的value值加number。redis&gt; SET mykey &quot;10&quot;&quot;OK&quot;redis&gt; INCRBY mykey 5(integer) 15redis&gt; </code></pre><h2 id="incrbyfloat-key-floatnumber"><a href="#incrbyfloat-key-floatnumber" class="headerlink" title="incrbyfloat key floatnumber"></a>incrbyfloat key floatnumber</h2><pre><code>incrbyfloat key floatnumber:可以加浮点数127.0.0.1:6379&gt; set num 5OK127.0.0.1:6379&gt; incr num(integer) 6127.0.0.1:6379&gt; get num&quot;6&quot;127.0.0.1:6379&gt; incrbyfloat num 5.5&quot;11.5&quot;127.0.0.1:6379&gt; get num&quot;11.5&quot;=====================================redis&gt; SET mykey 10.50&quot;OK&quot;redis&gt; INCRBYFLOAT mykey 0.1&quot;10.6&quot;redis&gt; INCRBYFLOAT mykey -5&quot;5.6&quot;redis&gt; SET mykey 5.0e3&quot;OK&quot;redis&gt; INCRBYFLOAT mykey 2.0e2&quot;5200&quot;redis&gt;</code></pre><h2 id="decr-key"><a href="#decr-key" class="headerlink" title="decr key"></a>decr key</h2><pre><code>作用：将key的value值减一。redis&gt; SET mykey &quot;10&quot;&quot;OK&quot;redis&gt; DECR mykey(integer) 9redis&gt; SET mykey &quot;234293482390480948029348230948&quot;&quot;OK&quot;redis&gt; DECR mykeyERR ERR value is not an integer or out of rangeredis&gt; ==============================================127.0.0.1:6379&gt; exists number(integer) 0127.0.0.1:6379&gt; decr number(integer) -1127.0.0.1:6379&gt; get number&quot;-1&quot;127.0.0.1:6379&gt; 注意：范围是有符号64位。当key不存在时，derc就是先创建key的value值为0，然后减一为-1。</code></pre><h2 id="decrby-key-decrement"><a href="#decrby-key-decrement" class="headerlink" title="decrby key decrement"></a>decrby key decrement</h2><pre><code>作用：将key的value值，减decrement。redis&gt; SET mykey &quot;10&quot;&quot;OK&quot;redis&gt; DECRBY mykey 3(integer) 7redis&gt; </code></pre><h2 id="mset-key-value-key-value-…"><a href="#mset-key-value-key-value-…" class="headerlink" title="mset key value [key value …]"></a>mset key value [key value …]</h2><pre><code>作用：一次性设置多个key、value值redis&gt; MSET key1 &quot;Hello&quot; key2 &quot;World&quot;&quot;OK&quot;redis&gt; GET key1&quot;Hello&quot;redis&gt; GET key2&quot;World&quot;redis&gt; </code></pre><h2 id="mget-key-key-…"><a href="#mget-key-key-…" class="headerlink" title="mget key [key …]"></a>mget key [key …]</h2><pre><code>作用：一次性获取多个key的value值redis&gt; SET key1 &quot;Hello&quot;&quot;OK&quot;redis&gt; SET key2 &quot;World&quot;&quot;OK&quot;redis&gt; MGET key1 key2 nonexisting1) &quot;Hello&quot;2) &quot;World&quot;3) (nil)redis&gt; </code></pre><h2 id="msetnx-key-value-key-value-…"><a href="#msetnx-key-value-key-value-…" class="headerlink" title="msetnx key value [key value …]"></a>msetnx key value [key value …]</h2><pre><code>作用：一次性设置多个不存在的key的value值，如果有一个key存在就返回0，失败！127.0.0.1:6379&gt; msetnx a 1 b 2(integer) 1127.0.0.1:6379&gt; mget a b1) &quot;1&quot;2) &quot;2&quot;127.0.0.1:6379&gt; msetnx b 3 c 4(integer) 0127.0.0.1:6379&gt; mget a b c1) &quot;1&quot;2) &quot;2&quot;3) (nil)127.0.0.1:6379&gt; </code></pre><hr><h2 id="setbit-key-offset-value"><a href="#setbit-key-offset-value" class="headerlink" title="setbit key offset value"></a>setbit key offset value</h2><pre><code>作用：将key的value中的偏移多少位上的bit值设置为1或0。A: 0100 0001  65a：0110 0001  97偏移量是从0开始。只需要将A的第二位设置为1，就能将大写的A，变成小写的a127.0.0.1:6379&gt; set char AOK127.0.0.1:6379&gt; get char&quot;A&quot;127.0.0.1:6379&gt; setbit char 2 1(integer) 0127.0.0.1:6379&gt; get char&quot;a&quot;127.0.0.1:6379&gt;注意: 1:如果offset过大,则会在中间填充0,2: offset最大大到多少3:offset最大2^32-1,可推出最大的的字符串为512M</code></pre><h2 id="getbit-key-offset"><a href="#getbit-key-offset" class="headerlink" title="getbit key offset"></a>getbit key offset</h2><pre><code>作用:获取值的二进制表示,对应位上的值(从左,从0编号)127.0.0.1:6379&gt; set char AOK127.0.0.1:6379&gt; get char&quot;A&quot;127.0.0.1:6379&gt; getbit char 0(integer) 0127.0.0.1:6379&gt; getbit char 1(integer) 1127.0.0.1:6379&gt; getbit char 2(integer) 0127.0.0.1:6379&gt; getbit char 7(integer) 1127.0.0.1:6379&gt; </code></pre><h2 id="bitop-operation-destkey-key1-key2-…"><a href="#bitop-operation-destkey-key1-key2-…" class="headerlink" title="bitop operation destkey key1 [key2 …]"></a>bitop operation destkey key1 [key2 …]</h2><pre><code>对 key1 , key2 ... keyN 作 operation , 并将结果保存到 destkey 上。operation 可以是 AND 、 OR 、 NOT 、 XORredis 127.0.0.1:6379&gt; setbit lower 2 1(integer) 0redis 127.0.0.1:6379&gt; set char QOKredis 127.0.0.1:6379&gt; get char&quot;Q&quot;redis 127.0.0.1:6379&gt; bitop or char char lower(integer) 1redis 127.0.0.1:6379&gt; get char&quot;q&quot;注意: 对于NOT操作, key不能多个</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的key通用操作</title>
      <link href="/2018/12/22/redis-de-key-tong-yong-cao-zuo/"/>
      <url>/2018/12/22/redis-de-key-tong-yong-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis的通用操作命名。<br><a id="more"></a></p><h2 id="keys-pattern-查询相应的key"><a href="#keys-pattern-查询相应的key" class="headerlink" title="keys pattern 查询相应的key"></a>keys pattern 查询相应的key</h2><pre><code>在redis里,允许模糊查询key有3个通配符 *, ? ,[]*: 通配任意多个字符 (包括0个)?: 通配单个字符（不包括0个）[]: 通配括号内的某1个字符</code></pre><p>启动redis服务器：</p><p><code>./bin/redis-server redis.conf</code></p><p>如果不加后面的配置文件redis.conf,就会找默认的配置文件了。<br><img src="/images/QQ截图20181222115002.png"></p><p>启动redis的客户端：</p><p><code>./bin/redis-cli</code><br><img src="/images/QQ截图20181222115132.png"></p><p>使用：keys *（查看当前数据库中的所有key）<br><img src="/images/QQ截图20181222115320.png"></p><p>使用正则表达式：</p><pre><code>127.0.0.1:6379&gt; KEYS *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; set agg 20OK127.0.0.1:6379&gt; get agg&quot;20&quot;127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;3) &quot;agg&quot;现在，目前有三个key了。127.0.0.1:6379&gt; keys age*1) &quot;age&quot;说明*能匹配0个字符127.0.0.1:6379&gt; keys ag*   1) &quot;age&quot;2) &quot;agg&quot;说明*能匹配一个字符127.0.0.1:6379&gt; set aggg 25OK127.0.0.1:6379&gt; get aggg &quot;25&quot;127.0.0.1:6379&gt; keys ag*1) &quot;age&quot;2) &quot;aggg&quot;3) &quot;agg&quot;说明能*能匹配多个字符=====================================127.0.0.1:6379&gt; keys age?(empty list or set)说明？不能匹配0个字符！！！127.0.0.1:6379&gt; keys ag?1) &quot;age&quot;2) &quot;agg&quot;127.0.0.1:6379&gt; 说明？只能匹配一个字符=====================================127.0.0.1:6379&gt; keys ag[gjer]1) &quot;age&quot;2) &quot;agg&quot;[]:只能匹配[]中的一个字符127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;3) &quot;aggg&quot;4) &quot;agg&quot;127.0.0.1:6379&gt; keys ag[aekgllgg]1) &quot;age&quot;2) &quot;agg&quot;[]中有两个gg，但是还是只能匹配一个g。127.0.0.1:6379&gt; keys ag[a-h]1) &quot;age&quot;2) &quot;agg&quot;[a-h]:匹配a到h之间的一个字符</code></pre><h2 id="randomkey-返回随机key"><a href="#randomkey-返回随机key" class="headerlink" title="randomkey 返回随机key"></a>randomkey 返回随机key</h2><pre><code>127.0.0.1:6379&gt; randomkey&quot;name&quot;127.0.0.1:6379&gt; randomkey&quot;agg&quot;127.0.0.1:6379&gt; randomkey&quot;age&quot;127.0.0.1:6379&gt; randomkey&quot;aggg&quot;127.0.0.1:6379&gt; randomkey&quot;name&quot;</code></pre><h2 id="exists-key-判断key是否存在"><a href="#exists-key-判断key是否存在" class="headerlink" title="exists key [判断key是否存在]"></a>exists key [判断key是否存在]</h2><pre><code>127.0.0.1:6379&gt; exists name(integer) 1127.0.0.1:6379&gt; exists nafdjkfjd(integer) 0127.0.0.1:6379&gt; exists age name(integer) 2127.0.0.1:6379&gt; exists age narefdf(integer) 1存在返回1，不存在返0，也可以测试多个key，存在几个key的话，就返回数字几。</code></pre><h2 id="type-key-测试key的类型"><a href="#type-key-测试key的类型" class="headerlink" title="type key [测试key的类型]"></a>type key [测试key的类型]</h2><pre><code>返回key存储的值的类型有string , link , set , order set , hash127.0.0.1:6379&gt; type namestring127.0.0.1:6379&gt; type agestring</code></pre><h2 id="del-key-key-···-删除key"><a href="#del-key-key-···-删除key" class="headerlink" title="del key [key,···] 删除key"></a>del key [key,···] 删除key</h2><pre><code>del key ：删除一个keydel key1 key2 ···:删除多个key127.0.0.1:6379&gt; del aggg(integer) 1127.0.0.1:6379&gt; del aggg(integer) 0删除成功，返回1；删除失败，返回0.===========================================127.0.0.1:6379&gt; set a 1OK127.0.0.1:6379&gt; set b 2OK127.0.0.1:6379&gt; set c 3OK127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;b&quot;3) &quot;name&quot;4) &quot;c&quot;5) &quot;agg&quot;6) &quot;a&quot;删除多个keydel a b c127.0.0.1:6379&gt; del a b c(integer) 3127.0.0.1:6379&gt; del a b c(integer) 0如果要删除的多个key中，有不存在的key的话，就不会删除这个key。删除几个可以成功，就会返回数字几。如果 a b 键存在，c不存在，那么就返回2。127.0.0.1:6379&gt; del a b c(integer) 2</code></pre><h2 id="rename-key-newkey-修改key的名字"><a href="#rename-key-newkey-修改key的名字" class="headerlink" title="rename key newkey [修改key的名字]"></a>rename key newkey [修改key的名字]</h2><pre><code>127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;3) &quot;agg&quot;127.0.0.1:6379&gt; 127.0.0.1:6379&gt; rename agg jidanOK127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;jidan&quot;3) &quot;name&quot;127.0.0.1:6379&gt; rename zzz fdfdf(error) ERR no such key修改名字成功，返回ok。修改失败，返回：(error) ERR no such key注意：如果新给的名字存在的话，那么会把已经存在的key的值给覆盖。例如：如果 a 和 b 都存在的话，rename a b 的话，b里面的值就是a里面的值了。127.0.0.1:6379&gt; get a&quot;1&quot;127.0.0.1:6379&gt; get b&quot;2&quot;127.0.0.1:6379&gt; 127.0.0.1:6379&gt; rename a bOK127.0.0.1:6379&gt; get a(nil)127.0.0.1:6379&gt; get b&quot;1&quot;此时，a不存在了，b里面存在的是a以前的值。</code></pre><h2 id="renamenx-key-newkey-newkey存在的话，不覆盖"><a href="#renamenx-key-newkey-newkey存在的话，不覆盖" class="headerlink" title="renamenx key newkey [newkey存在的话，不覆盖]"></a>renamenx key newkey [newkey存在的话，不覆盖]</h2><pre><code>renamenx 与 rename 的作用是一样的。只是当newkey本身已经存在的话，是不会修改成功的。127.0.0.1:6379&gt; get a&quot;1&quot;127.0.0.1:6379&gt; get b&quot;2&quot;127.0.0.1:6379&gt; renamenx a b(integer) 0127.0.0.1:6379&gt; get a&quot;1&quot;127.0.0.1:6379&gt; get b&quot;2&quot;b已经存在了，所以不会修改名字成功。127.0.0.1:6379&gt; get c(nil)127.0.0.1:6379&gt; renamenx a c(integer) 1127.0.0.1:6379&gt; get a(nil)127.0.0.1:6379&gt; get c&quot;1&quot;c不存在，所以修改a的名字为c成功。</code></pre><h2 id="move-key-db-移动key到指定的数据库中"><a href="#move-key-db-移动key到指定的数据库中" class="headerlink" title="move key db [移动key到指定的数据库中]"></a>move key db [移动key到指定的数据库中]</h2><pre><code>前提知识点：redis默认会创建16个数据库。编号是：0~15.默认打开的是编号为0的数据库。</code></pre><p>打开redis.conf配置文件：<br><img src="/images/QQ截图20181222132858.png"></p><pre><code>127.0.0.1:6379&gt; keys *1) &quot;b&quot;2) &quot;age&quot;3) &quot;jidan&quot;4) &quot;name&quot;5) &quot;c&quot;现在将 c 这个key 移动到数据库编号为1的数据中。move c 1127.0.0.1:6379&gt; move c 1(integer) 1127.0.0.1:6379&gt; get c(nil)切换到编号为1的数据库中：select 1127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; get c&quot;1&quot;切换成功后，在端口号后面有一个数字：[1]。</code></pre><p><strong>注意：</strong>( 一个redis进程,打开了不止一个数据库, 默认打开16个数据库,从0到15编号, 如果想打开更多数据库,可以从配置文件修改)</p><h2 id="ttl-key-查看key的过期时间"><a href="#ttl-key-查看key的过期时间" class="headerlink" title="ttl key [查看key的过期时间]"></a>ttl key [查看key的过期时间]</h2><pre><code>ttl:返回的是key过期时间的单位是秒。127.0.0.1:6379&gt; keys *1) &quot;b&quot;2) &quot;age&quot;3) &quot;jidan&quot;4) &quot;name&quot;127.0.0.1:6379&gt; ttl name(integer) -1注意：如果key存在的话，-1：代表的是没有过期时间，即永久存在；如果key不存在的话，也会返回-1。所以-1会有歧义！！！Redis2.8中,对于不存在的key,返回-2。</code></pre><h2 id="pttl-key"><a href="#pttl-key" class="headerlink" title="pttl key"></a>pttl key</h2><pre><code>pttl 与 ttl一样，都是返回一个key的过期时间，只是单位是毫秒。</code></pre><h2 id="expire-key-整型值-设置key的过期时间"><a href="#expire-key-整型值-设置key的过期时间" class="headerlink" title="expire key 整型值[设置key的过期时间]"></a>expire key 整型值[设置key的过期时间]</h2><pre><code>作用: 设置key的生命周期,以秒为单位127.0.0.1:6379&gt; expire name 5(integer) 1127.0.0.1:6379&gt; get name&quot;zhangsan&quot;127.0.0.1:6379&gt; get name(nil)设置name的这个key的过期时间是：5秒。5秒过后就会删除name这个key。</code></pre><h2 id="pexpire-key-毫秒数"><a href="#pexpire-key-毫秒数" class="headerlink" title="pexpire key 毫秒数"></a>pexpire key 毫秒数</h2><pre><code>作用: 设置key的生命周期,以毫秒为单位127.0.0.1:6379&gt; pexpire age 9000(integer) 1127.0.0.1:6379&gt; ttl age(integer) 6127.0.0.1:6379&gt; ttl age(integer) 5127.0.0.1:6379&gt; ttl age(integer) 4127.0.0.1:6379&gt; ttl age(integer) 3127.0.0.1:6379&gt; ttl age(integer) 1127.0.0.1:6379&gt; ttl age(integer) -2设置age的过期时间为：9000毫秒。</code></pre><h2 id="persist-key-设置key为永久存在"><a href="#persist-key-设置key为永久存在" class="headerlink" title="persist key[设置key为永久存在]"></a>persist key[设置key为永久存在]</h2><pre><code>作用: 把指定key置为永久有效127.0.0.1:6379&gt; expire b 10(integer) 1127.0.0.1:6379&gt; ttl b(integer) 8127.0.0.1:6379&gt; ttl b(integer) 6127.0.0.1:6379&gt; ttl b(integer) 5127.0.0.1:6379&gt; ttl b(integer) 4127.0.0.1:6379&gt; ttl b(integer) 3127.0.0.1:6379&gt; persist b(integer) 1127.0.0.1:6379&gt; ttl b(integer) -1设置b这个key的过期时间为：10秒，当b这个key快要过期的时候，将其设置为永久有效。</code></pre><p>还有更多的通用keys的操作，如看redis的官网：<br><img src="/images/QQ截图20181222134910.png"></p><p>在图中，可以看到还有：expire<strong>at</strong> key timestamp [设置key的在哪个时间戳过期]、pexpire<strong>at</strong> key milliseconds-timestamp</p><pre><code>redis&gt; SET mykey &quot;Hello&quot;&quot;OK&quot;redis&gt; EXISTS mykey(integer) 1redis&gt; EXPIREAT mykey 1293840000(integer) 1redis&gt; EXISTS mykey(integer) 0redis&gt;======================================redis&gt; SET mykey &quot;Hello&quot;&quot;OK&quot;redis&gt; PEXPIREAT mykey 1555555555005(integer) 1redis&gt; TTL mykey(integer) 10097634redis&gt; PTTL mykey(integer) 10097633581redis&gt; </code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的下载与安装</title>
      <link href="/2018/12/21/redis-de-xia-zai-yu-an-zhuang/"/>
      <url>/2018/12/21/redis-de-xia-zai-yu-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>今天来学习Redis缓存，完成redis的下载与安装<br><a id="more"></a></p><h2 id="Redis的特点"><a href="#Redis的特点" class="headerlink" title="Redis的特点"></a>Redis的特点</h2><p>Redis is an open source, BSD licensed, advanced key-value store. It is often referred to as a data structure server since keys can contain strings, hashes, lists, sets and sorted sets.</p><p>redis是开源,BSD许可,高级的key-value存储系统. 可以用来存储字符串,哈希结构,链表,集合,因此,常用来提供数据结构服务.</p><h3 id="redis和memcached的对比"><a href="#redis和memcached的对比" class="headerlink" title="redis和memcached的对比"></a>redis和memcached的对比</h3><ol><li><p>redis可以用来做存储(storge), 而memcached是用来做缓存(cache)。这个特点主要因为其有<strong>”持久化”</strong>的功能.</p></li><li><p>存储的数据有”结构”,对于memcached来说,存储的数据,只有1种类型–”字符串”,而redis则可以存储字符串,链表,哈希结构,集合,有序集合.</p></li></ol><h2 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h2><h3 id="打开官网：redis-io"><a href="#打开官网：redis-io" class="headerlink" title="打开官网：redis.io"></a>打开官网：redis.io</h3><p>1.打开官网：redis.io。下载最新版本或者最新的稳定版本。</p><p><img src="/images/QQ截图20181221201926.png"></p><p>点击查看更多的安装版本：<br><img src="/images/QQ截图20181221202252.png"></p><p>往下能看到，官方提供的安装步骤：<br><img src="/images/QQ截图20181221202341.png"></p><h3 id="打开虚拟机"><a href="#打开虚拟机" class="headerlink" title="打开虚拟机"></a>打开虚拟机</h3><p>2.打开虚拟机</p><p>如果不会使用虚拟机（linux），那么请看我之前的linux教程即可。</p><p>使用Xshell来远程操作linux即可。<br><img src="/images/QQ截图20181221203308.png"></p><h3 id="下载redis的压缩包"><a href="#下载redis的压缩包" class="headerlink" title="下载redis的压缩包"></a>下载redis的压缩包</h3><p>3.下载redis的压缩包</p><p><code>wget http://download.redis.io/releases/redis-5.0.3.tar.gz</code></p><p>先切换目录到：usr/local/src/下，这个目录一般是用来安装下载的软件的。<br><img src="/images/QQ截图20181221203739.png"><br><img src="/images/QQ截图20181221203856.png"><br><img src="/images/QQ截图20181221204116.png"></p><h3 id="解压redis压缩包"><a href="#解压redis压缩包" class="headerlink" title="解压redis压缩包"></a>解压redis压缩包</h3><p>4.解压redis压缩包</p><p><code>tar zxvf redis-5.0.3.tar.gz</code><br><img src="/images/QQ截图20181221204603.png"><br><img src="/images/QQ截图20181221204719.png"></p><h3 id="不用configure"><a href="#不用configure" class="headerlink" title="不用configure"></a>不用configure</h3><p>5.<strong>不用configure</strong></p><p>因为下载好的redis压缩包，官方已经帮我们configure过了。</p><h3 id="使用make编译redis"><a href="#使用make编译redis" class="headerlink" title="使用make编译redis"></a>使用make编译redis</h3><p>6.直接make（编译redis）</p><p><code>make</code><br><img src="/images/QQ截图20181221204852.png"><br><img src="/images/QQ截图20181221205123.png"></p><p><strong>注意问题：</strong> make的过程中可能出现的问题，因为官方的redis源码是configure过的，但官方的configure时，生成的文件有时间戳的信息。</p><p>Make只能发生在configure之后，如果你的虚拟机的时间在configure之前，那么就会出现问题，比如，官方configure的时间是2018年12月10号，但是你的虚拟机的时间是2018年12月1号，在10号之前，那么就会出现问题。</p><p>解决：修改虚拟机的时间即可。</p><h3 id="测试编译情况"><a href="#测试编译情况" class="headerlink" title="测试编译情况"></a>测试编译情况</h3><p>7.可选步骤：make test 测试编译情况</p><p>（可能出现：xxx 的版本过低的问题，直接 yum install xxx）</p><h3 id="安装redis到指定的目录中"><a href="#安装redis到指定的目录中" class="headerlink" title="安装redis到指定的目录中"></a>安装redis到指定的目录中</h3><p>8.安装redis到指定的目录中，比如：/usr/local/redis</p><p><code>make PREFIX=/usr/loacl/redis install</code></p><p>注意：PREFIX是大写。<br><img src="/images/QQ截图20181221210034.png"><br><img src="/images/QQ截图20181221210129.png"><br><img src="/images/QQ截图20181221210210.png"></p><p>安装后，发现只有bin目录，是正确的。</p><p>会得到以下几个文件：</p><pre><code>redis-benchmark    性能测试工具redis-check-aof    日志文件检测工(比如断电造成日志损坏,可以检测并修复)redis-check-dump   快照文件检测工具,效果类上。redis-cli          客户端redis-server       服务端</code></pre><p><img src="/images/QQ截图20181221210353.png"></p><h3 id="复制redis的配置文件到bin目录下"><a href="#复制redis的配置文件到bin目录下" class="headerlink" title="复制redis的配置文件到bin目录下"></a>复制redis的配置文件到bin目录下</h3><p>9.复制redis的配置文件到bin目录下</p><p><code>cp /usr/local/src/redis-5.0.1/redis.conf ./</code><br><img src="/images/QQ截图20181221210857.png"><br><img src="/images/QQ截图20181221211030.png"></p><h3 id="启动redis服务器"><a href="#启动redis服务器" class="headerlink" title="启动redis服务器"></a>启动redis服务器</h3><p>10.启动redis服务器</p><p><code>./bin/redis-server ./redis.conf</code><br><img src="/images/QQ截图20181221211225.png"><br><img src="/images/QQ截图20181221211350.png"></p><p>不要：ctrl+c退出redis服务器端。</p><p>重新开启一个新的linux连接端，启动redis的客户端：</p><p><code>./bin/redis-cli</code><br><img src="/images/QQ截图20181221212336.png"></p><h3 id="简单测试redis功能"><a href="#简单测试redis功能" class="headerlink" title="简单测试redis功能"></a>简单测试redis功能</h3><p>11.简单测试redis功能</p><p>往name字符串中存入张三，然后获取张三。<br><img src="/images/QQ截图20181221212541.png"></p><h3 id="让redis以后台进程的形式运行"><a href="#让redis以后台进程的形式运行" class="headerlink" title="让redis以后台进程的形式运行"></a>让redis以后台进程的形式运行</h3><p>12.让redis以后台进程的形式运行</p><p>实际生产中，不能一直开启redis的服务端而不断开，应该是开启一个后台进程运行redis服务器。</p><p>打开redis.conf配置文件。</p><p>将daemonize 改为：yes<br><img src="/images/QQ截图20181221212956.png"></p><p>再次启动redis的服务端：</p><p><code>./bin/redis-server ./redis.conf</code></p><p>此时不会再出现那个很大的logo图标了。<br><img src="/images/QQ截图20181221213130.png"></p><p>检测redis服务端是否成功启动了呢？查找redis相关的进程</p><p><code>ps aux |grep redis</code><br><img src="/images/QQ截图20181221213435.png"><br><img src="/images/QQ截图20181221213537.png"></p><p><strong>注意：</strong>这里的name是上次保存到redis缓存中的，但是这次居然获取成功了，因为新版本的redis，默认配置了持久化操作，上次ctrl+c退出redis服务器后，会自动帮我们持久化数据，在redis目录下面，会发现多了一个<strong>dump.rdb</strong>文件，就是持久化数据后的文件。如果是以前的版本就不会帮我们持久化数据！！！</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题：如何求根号2</title>
      <link href="/2018/12/17/mian-shi-ti-ru-he-qiu-gen-hao-2/"/>
      <url>/2018/12/17/mian-shi-ti-ru-he-qiu-gen-hao-2/</url>
      
        <content type="html"><![CDATA[<p>小L最近找实习的时候，被面试官问了这样一道题：如何求根号2的值？<br><a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p><img src="/images/QQ截图20181217184933.png" style="width:80%"><br><img src="/images/QQ截图20181217185034.png" style="width:80%"></p><p><img src="/images/QQ截图20181217185312.png" style="width:80%"></p><h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p><img src="/images/QQ截图20181217185408.png" style="width:80%"><br><img src="/images/QQ截图20181217185548.png" style="width:80%"><br><img src="/images/QQ截图20181217185617.png" style="width:80%"><br><img src="/images/QQ截图20181217185703.png" style="width:80%"></p><p><img src="/images/QQ截图20181217185734.png" style="width:80%"><br><img src="/images/QQ截图20181217185806.png" style="width:80%"><br><img src="/images/QQ截图20181217185834.png" style="width:80%"><br><img src="/images/QQ截图20181217185905.png" style="width:80%"></p><p><img src="/images/QQ截图20181217185938.png" style="width:80%"><br><img src="/images/QQ截图20181217190035.png" style="width:80%"><br><img src="/images/QQ截图20181217190117.png" style="width:80%"><br><img src="/images/QQ截图20181217190227.png" style="width:80%"><br><img src="/images/QQ截图20181217190258.png" style="width:80%"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上介绍了二分法和牛顿迭代法来求解根号2，另外我们还可以通过泰勒公式法来求解。很多朋友可能会问，我们经常调用的Math库中sqrt(x)函数的实现用的是哪种方法呢？为了效率，sqrt(x)函数在底层是用C语言来实现的，实现过程非常巧妙，效率极高，用到了牛顿迭代法的思想，但又不完全是牛顿迭代法，我会将sqrt(x)库函数的代码放于文后，有兴趣可以研究。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="牛顿迭代法（JavaScript）"><a href="#牛顿迭代法（JavaScript）" class="headerlink" title="牛顿迭代法（JavaScript）"></a>牛顿迭代法（JavaScript）</h3><pre><code>//求n的算术平方根，参数n不能为负数function sqrt(n) {    //当n&gt;=1时，从n开始迭代；    //当n&lt;1时，从1开始迭代    let res = n &gt;= 1 ? n : 1;    while(res * res - n &gt; 1e-8)        res = 0.5 * (res + n / res);    return res;}</code></pre><h3 id="C语言实现的库函数（源码）"><a href="#C语言实现的库函数（源码）" class="headerlink" title="C语言实现的库函数（源码）"></a>C语言实现的库函数（源码）</h3><pre><code>//源码中求的是根号x的倒数，参数x必须大于0float invSqrt(float x){    float xhalf = 0.5f * x;    int i = *(int*)&amp;x;    //下面这句是核心，有兴趣可阅读相关论文    i = 0x5f375a86 - (i&gt;&gt;1);     x = *(float*)&amp;i;    //下面使用了三次牛顿迭代     x = x*(1.5f-xhalf*x*x);     x = x*(1.5f-xhalf*x*x);     x = x*(1.5f-xhalf*x*x);    //注：此函数返回的是根号x的倒数    return x;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端:后端,我要与你分手</title>
      <link href="/2018/12/06/qian-duan-hou-duan-wo-yao-yu-ni-fen-shou/"/>
      <url>/2018/12/06/qian-duan-hou-duan-wo-yao-yu-ni-fen-shou/</url>
      
        <content type="html"><![CDATA[<p>本篇文章，将会讲解前端、后端的架构思想。<br><a id="more"></a></p><h2 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h2><p>前后端分离已成为互联网项目开发的业界标准使用方式，通过 nginx + tomcat 的方式（也可以中间加一个nodejs）有效的进行解耦，并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。这个步骤是系统架构从猿进化成人的必经之路。</p><p><strong>核心思想</strong>：是前端<strong> html页面 </strong>通过<strong> ajax </strong>调用后端的<strong> restuful api接口 </strong>并使用<strong> json数据 </strong>进行交互。</p><font color="red"><strong>在互联网架构中，名词解释：</strong></font><p>Web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。</p><p>应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有Web服务器好。</p><p>一般都是只有Web服务器才能被外网访问，应用服务器只能内网访问。</p><h2 id="术业有专攻（开发人员分离）"><a href="#术业有专攻（开发人员分离）" class="headerlink" title="术业有专攻（开发人员分离）"></a>术业有专攻（开发人员分离）</h2><p>以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端，又搞后端。</p><p>随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。</p><p>大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。</p><p><strong>1) 对于后端java工程师：</strong></p><p>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构，弹性计算架构，微服务架构，java性能优化，以及相关的项目管理等等。</p><p>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。</p><p><strong>2) 对于前端工程师：</strong></p><p>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。</p><p>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</p><p>术业有专攻，这样你的核心竞争力才会越来越高，正所谓你往生活中投入什么，生活就会反馈给你什么。并且两端的发展都越来越高深，你想什么都会，那你毕竟什么都不精。</p><p>通过将team分成前后端team，让两边的工程师更加专注各自的领域，独立治理，然后构建出一个全栈式的精益求精的team。</p><h2 id="原始人时代（各种耦合）"><a href="#原始人时代（各种耦合）" class="headerlink" title="原始人时代（各种耦合）"></a>原始人时代（各种耦合）</h2><p>曾几何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。</p><p>大多数项目在java后端都是分了三层，控制层，业务层，持久层。控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;渲染到jsp页面。然后jsp页面上使用各种标签或者手写java表达式将后台的数据展现出来，玩的是MVC那套思路。</p><p>我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器里，对吧？</p><p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？</p><p>好，下面在浏览器中输入你的网站域名<code>（www.xxx.com）</code>，之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。</p><p>浏览器在通过域名、通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。</p><p>那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。</p><p>重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？</p><p>这就是为什么，越是大中型的web应用，他们越是要解耦。理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。</p><p>如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。（注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期哟，亲~）</p><p>此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？</p><p>正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。</p><h2 id="JSP的痛点"><a href="#JSP的痛点" class="headerlink" title="JSP的痛点"></a>JSP的痛点</h2><p>以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。</p><p>1、动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。一旦服务器出现状况，前后台一起玩完，用户体验极差。</p><p>2、UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），修改问题时需要双方协同开发，效率低下。</p><p>3、jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），性能提不上来。</p><p>4、第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。</p><p>5、每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。</p><p>6、jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。</p><p>7、如果jsp中的内容很多，页面响应会很慢，因为是同步加载。</p><p>8、需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。</p><p>基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！</p><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>以前老的方式是：</p><p>1、产品经理/领导/客户提出需求</p><p>2、UI做出设计图</p><p>3、前端工程师做html页面</p><p>4、后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）</p><p>5、集成出现问题</p><p>6、前端返工</p><p>7、后端返工</p><p>8、二次集成</p><p>9、集成成功</p><p>10、交付</p><h2 id="新的方式："><a href="#新的方式：" class="headerlink" title="新的方式："></a>新的方式：</h2><p>1、产品经理/领导/客户提出需求</p><p>2、UI做出设计图</p><p>3、前后端约定接口 &amp; 数据 &amp; 参数</p><p>4、前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高）</p><p>5、前后端集成</p><p>6、前端页面调整</p><p>7、集成成功</p><p>8、交付</p><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><font color="red"><strong>以前老的方式是：</strong></font><p>1、客户端请求</p><p>2、服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）</p><p>3、调用service,dao代码完成业务逻辑</p><p>4、返回jsp</p><p>5、jsp展现一些动态的代码</p><font color="red"><strong>新的方式是：</strong></font><p>1、浏览器发送请求</p><p>2、直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）</p><p>3、html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）</p><p>4、填充html，展现动态效果，在页面上进行解析并操作DOM。</p><p><strong>总结一下新的方式的请求步骤：</strong></p><p>大量并发浏览器请求 -→ web服务器集群(nginx) -→ 应用服务器集群(tomcat) -→ 文件/数据库/缓存/消息队列服务器集群。</p><p>同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。</p><h2 id="前后分离的优势"><a href="#前后分离的优势" class="headerlink" title="前后分离的优势"></a>前后分离的优势</h2><p>1、可以实现真正的前后端解耦，前端服务器使用nginx。前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以将css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。（这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack）</p><p>2、发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。双方互不干扰，前端与后端是相亲相爱的一家人。</p><p>3、在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。（去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。）</p><p>4、减少后端服务器的并发/负载压力。除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。且除了第一次页面请求外，浏览器会大量调用本地缓存。</p><p>5、即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。</p><p>6、也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）</p><p>7、页面显示的东西再多也不怕，因为是异步加载。</p><p>8、nginx支持页面热部署，不用重启服务器，前端升级更无缝。</p><p>9、增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。</p><p>10、提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。</p><p>11、在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），内网使用http，性能和安全都有保障。</p><p>12、前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？</p><p>2、上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。</p><p>3、加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。</p><p>4、我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。</p><p>5、如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。</p><p>6、 以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。</p><p>7、这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？</p><p>8、如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。</p><p>9、对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。类似于数据校验这种，前后端都需要做！</p><p>10、前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了，需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。前端只需要关注页面的样式与动态数据的解析&amp;渲染，而后端专注于具体业务逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
            <tag> 分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之下载与安装</title>
      <link href="/2018/11/30/linux-ji-chu-ru-men-zhi-xia-zai-yu-an-zhuang/"/>
      <url>/2018/11/30/linux-ji-chu-ru-men-zhi-xia-zai-yu-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>本篇讲解Linux系统下软件的安装方式：RPM 与 YUM。<br><a id="more"></a></p><h2 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一种用于互联网下载包的<strong>打包</strong>及<strong>安装工具</strong>，它包含在某些Linux分发版中。它生成具有<code>.RPM扩展名</code>的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似于windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</p><p>Linux的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。</p><p>rpm包管理的缺点：不能处理依赖关系，如你要安装A软件，但是A软件依赖于B、C软件的支持，因此，你必须先安装B和C软件，然后才能安装A软件。</p><h3 id="rpm包的简单查询指令"><a href="#rpm包的简单查询指令" class="headerlink" title="rpm包的简单查询指令"></a>rpm包的简单查询指令</h3><pre><code>查询已安装的rpm列表 :rpm  -qa                #查询所有的rpm软件包rpm  –qa | grep xx      #查询指定的rpm软件包rpm  -qa | grep firefox</code></pre><p><img src="/images/QQ截图20181130203440.png"></p><p><img src="/images/QQ截图20181130203539.png"></p><h3 id="rpm包名基本格式"><a href="#rpm包名基本格式" class="headerlink" title="rpm包名基本格式"></a>rpm包名基本格式</h3><pre><code>一个rpm包名：firefox-52.7.0-1.el7.centos.x86_64.rpm名称:firefox版本号：52.7.0更新发行的次数：1 适用操作系统: el7.centos.x86_64表示centos7.x的64位系统如果是i686、i386表示32位系统，x86_64表示64位的系统，noarch表示通用。</code></pre><h3 id="rpm包的其它查询指令"><a href="#rpm包的其它查询指令" class="headerlink" title="rpm包的其它查询指令"></a>rpm包的其它查询指令</h3><pre><code>rpm -qa : 查询所安装的所有rpm软件包  rpm -qa | more    rpm -qa | grep X [rpm -qa | grep firefox ]rpm -q 软件包名 : 查询软件包是否安装rpm -q firefoxrpm -qi 软件包名 ：查询软件包信息rpm -qi firefoxrpm -ql 软件包名 : 查询软件包中的文件rpm -ql firefoxrpm -qf 文件全路径名 查询文件所属的软件包rpm -qf /etc/passwdrpm -qf /root/install.log</code></pre><p><img src="/images/QQ截图20181130204147.png"><br><img src="/images/QQ截图20181130204408.png"><br><img src="/images/QQ截图20181130204547.png"><br><img src="/images/QQ截图20181130204655.png"></p><h3 id="卸载rpm包"><a href="#卸载rpm包" class="headerlink" title="卸载rpm包"></a>卸载rpm包</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>rpm -e RPM包的名称</code></pre><h4 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h4><p>删除 firefox  软件包</p><p><code>rpm -e firefox</code><br><img src="/images/QQ截图20181130211112.png"><br><img src="/images/QQ截图20181130211228.png"></p><p><strong>细节讨论:</strong></p><p>1) 如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。</p><p>如：  <code>rpm -e  foo</code> </p><p>removing these packages would break dependencies: <strong>foo is needed by bar-1.0-1</strong></p><p>2) 如果我们就是要删除 foo这个rpm包，可以增加参数 <code>--nodeps</code> , 就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行。</p><p>如： <code>rpm -e --nodeps foo</code>      [小心使用]</p><h3 id="安装rpm包"><a href="#安装rpm包" class="headerlink" title="安装rpm包"></a>安装rpm包</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>rpm -ivh  RPM包全路径名称参数说明i = install 安装v = verbose 提示h = hash    进度条</code></pre><h4 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h4><p>安装firefox浏览器</p><p><strong>提示：很多的rpm软件包，就在我们的centos安装的镜像文件中</strong></p><p>步骤：</p><p>1）首先要有Firefox的rpm软件包，才能安装。</p><p>一个小知识点，我们的centOS.iso镜像文件中，就有Firefox的rpm软件包。</p><p>挂载我们的centOS.ios镜像光驱。<br><img src="/images/QQ截图20181130210825.png"><br><img src="/images/QQ截图20181130210930.png"></p><p>光驱一般会在：/media文件夹中：<br><img src="/images/QQ截图20181130211656.png"></p><p>那么就到 /run/media/root/ 中查找：<br><img src="/images/QQ截图20181130211917.png"><br><img src="/images/QQ截图20181130212025.png"><br><img src="/images/QQ截图20181130212226.png"></p><p>将找到的Firefox软件包，拷贝到我们制定的目录下面，比如：/opt中：<br><img src="/images/QQ截图20181130212416.png"></p><p>在/opt/中安装，不在光驱中安装。</p><p><code>rpm -ivh firefox.xxx.rpm</code><br><img src="/images/QQ截图20181130212634.png"><br><img src="/images/QQ截图20181130212809.png"><br><img src="/images/QQ截图20181130212908.png"></p><p>输入：<code>eject</code>：弹出光驱<br><img src="/images/QQ截图20181130213349.png"></p><h2 id="yum包管理"><a href="#yum包管理" class="headerlink" title="yum包管理"></a>yum包管理</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Yum 是一个Shell 软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以<strong>自动处理依赖性关系</strong>，并且一次安装所有依赖的软件包。</p><p>通过yum工具配合互联网即可实现软件的安装和自动升级。</p><h3 id="yum的安装"><a href="#yum的安装" class="headerlink" title="yum的安装"></a>yum的安装</h3><p>1）查询yum是否已经安装了。</p><p><code>rpm -qa | grep yum</code><br><img src="/images/QQ截图20181130214443.png"></p><p>2) 如果没有找到，可以到CentOS镜像中找到，并安装yum软件。</p><p><code>rpm -ivh yum-*.xxx.noarch.rpm</code></p><h3 id="yum的基本指令"><a href="#yum的基本指令" class="headerlink" title="yum的基本指令"></a>yum的基本指令</h3><pre><code>查询yum服务器是否有需要安装的软件yum  list | grep xxx软件  #查询xxx软件安装指定的yum包yum  install  xxx  #下载安装xxx软件</code></pre><h3 id="yum应用实例"><a href="#yum应用实例" class="headerlink" title="yum应用实例"></a>yum应用实例</h3><p>案例：请使用yum的方式来安装firefox指令 (前提是：你能联网！！！)</p><p>1) 查询yum服务器上面是否有Firefox</p><p><code>yum list | grep firefox</code><br><img src="/images/QQ截图20181130215425.png"></p><p><code>yum install firefox</code>  //会自动的下载适合你系统的最新版本，并且下载所有的依赖软件。</p><p>原来我们的机器上就有Firefox，所以先卸载：<br><img src="/images/QQ截图20181130215537.png"></p><p>安装Firefox：（速度会慢一些，因为是联网下载）<br><img src="/images/QQ截图20181130215801.png"><br><img src="/images/QQ截图20181130215940.png"><br><img src="/images/QQ截图20181130220008.png"><br><img src="/images/QQ截图20181130220108.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之进程管理</title>
      <link href="/2018/11/30/linux-ji-chu-ru-men-zhi-jin-cheng-guan-li/"/>
      <url>/2018/11/30/linux-ji-chu-ru-men-zhi-jin-cheng-guan-li/</url>
      
        <content type="html"><![CDATA[<p>Linux系统的进程管理（重点！！！）<br><a id="more"></a></p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>1）在Linux系统中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。</p><p>2）一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。</p><p>3）每个进程都可能以两种方式存在的: <font color="red">前台 与 后台</font>，所谓<strong>前台进程</strong>就是用户目前的屏幕上可以进行操作的 ; <strong>后台进程</strong>则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行 [sshd , crond]。</p><p>4）一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才会结束。</p><h2 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h2><h3 id="ps基本介绍"><a href="#ps基本介绍" class="headerlink" title="ps基本介绍"></a>ps基本介绍</h3><p>ps命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。（可以不加任何参数）</p><pre><code>ps -a：显示当前终端的所有进程信息ps -u：以用户的格式显示进程的信息ps -x：显示后台进程运行的参数一般使用：ps -aux</code></pre><p><img src="/images/QQ截图20181130132958.png"></p><p>如果太多，看不过来的话，使用：| more。</p><p><img src="/images/QQ截图20181130133124.png"></p><h3 id="ps详解"><a href="#ps详解" class="headerlink" title="ps详解"></a>ps详解</h3><p>1）指令：ps –aux | grep xxx ，比如我要看有没有sshd服务。</p><p><img src="/images/QQ截图20181130133333.png"></p><p>2）指令说明</p><pre><code>System V展示风格USER：用户名称 PID： 进程号 %CPU：进程占用CPU的百分比 %MEM：进程占用物理内存的百分比 VSZ： 进程占用的虚拟内存大小（单位：KB） RSS： 进程占用的物理内存大小（单位：KB） TTY： 终端名称,缩写.STAT：进程状态。其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等。STARTED：进程的启动时间 TIME：   占用CPU的时间，即进程使用CPU的总时间 COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</code></pre><h3 id="查看父进程"><a href="#查看父进程" class="headerlink" title="查看父进程"></a>查看父进程</h3><pre><code>ps -ef：是以全格式显示当前所有的进程-e：显示所有进程-f：全格式</code></pre><p><img src="/images/QQ截图20181130133917.png"></p><p>1）查找特定指令的父进程id：<code>ps -ef | grep xxx</code><br><img src="/images/QQ截图20181130134150.png"></p><p>2) 详细介绍</p><pre><code>是BSD风格UID： 用户的名字 PID： 进程ID PPID：父进程ID C：   CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高 STIME：进程启动的时间 TTY：  完整的终端名称 TIME： CPU时间 CMD：  启动进程所用的命令和参数</code></pre><h2 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>kill  [选项] 进程号（功能描述：通过进程号杀死进程 -9 强制终止）killall 进程名称    （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）常用选项：-9： 表示强迫进程立即停止-2： 表示结束进程，但不是强制性的。常用的Ctrl+c就是：kill -2 的意思。-15：表示正常结束进程，是kill的默认选项。</code></pre><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>案例1：踢掉某个非法登录用户</p><p>现在使用另一个用户登入我们的linux系统，假装是非法用户，我这里使用的是liuzhuo用户：<br><img src="/images/QQ截图20181130142114.png"></p><p>现在查看liuzhuo用户的进程id，首先我们要知道进程的服务名字，因为是使用Xshell登入的，所以是sshd服务。</p><p><code>ps -aux | grep sshd</code><br><img src="/images/QQ截图20181130142341.png"></p><p><code>kill 3519</code> (liuzhuo用户的pid)<br><img src="/images/QQ截图20181130142618.png"></p><p>案例2: 终止远程登录服务sshd, 在适当时候再次重启sshd服务。</p><p>有些时候，我们的linux系统的管理员需要自己执行一些操作，不让远程用户登入，所以有这样的情况，杀死sshd服务。不再让远程登入用户！</p><p>首先找到sshd服务的pid：<br><code>ps -aux | grep sshd</code><br><img src="/images/QQ截图20181130142943.png"></p><p><code>kill 1110</code> （sshd的pid）<br><img src="/images/QQ截图20181130143119.png"></p><p>现在就只存在root用户了，其他用户想要远程登入linux系统是不能通过的：</p><p>我使用liuzhuo用户登入linux系统：失败<br><img src="/images/QQ截图20181130143309.png"></p><p>案例3: 终止多个gedit 编辑器。</p><p>kill pid：每次只能杀死一个进程，不能杀死多个进程，有些时候，我们需要一次性杀死多个进程，这个时候就需要使用：<br>killall指令了。</p><p><code>killall 进程名</code>（注意是进程名，不是进程id）<br><img src="/images/QQ截图20181130143851.png"></p><p>现在，我们一次性杀死多个gedit进程。执行：<code>killall gedit</code><br><img src="/images/QQ截图20181130144200.png"></p><p>案例4：强制杀掉一个终端  (对于:bash)</p><p>对于某些重要的进程，直接使用 kill 指令是杀不死的，需要带上参数： -9 ，强制杀死进程。</p><p>终端就是一个重要的进程。</p><p>打开两个终端，隔一段时间，否则无法区分开来的。</p><p>在第二个终端中输入：<code>ps -aux | grep bash</code><br><img src="/images/QQ截图20181130144752.png"></p><p>杀死第一个终端：<br><img src="/images/QQ截图20181130144934.png"><br><img src="/images/QQ截图20181130145124.png"></p><h2 id="查看进程树pstree"><a href="#查看进程树pstree" class="headerlink" title="查看进程树pstree"></a>查看进程树pstree</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>pstree [选项] (可以更加直观的来看进程信息)常用选项：-p :显示进程的PID-u :显示进程的所属用户</code></pre><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>案例1：请用树状的形式显示进程的pid</p><p><code>pstree -p</code><br><img src="/images/QQ截图20181130145605.png"></p><p>案例2：请用树状的形式显示进程的用户id</p><p><code>pstree –u</code>:只显示进程名，并且 合并进程名一样的进程<br><img src="/images/QQ截图20181130145944.png"></p><p><code>pstree -pu</code><br><img src="/images/QQ截图20181130150036.png"></p><h2 id="服务-service-管理"><a href="#服务-service-管理" class="headerlink" title="服务(service)管理"></a>服务(service)管理</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>服务(service) 本质就是进程，但是是运行在<font color="red"><strong>后台</strong></font>的，通常都会监听某个端口，等待其它程序的请求，比如(mysql , sshd , 防火墙等)，因此我们又称为<strong>守护进程</strong>，是Linux中非常重要的知识点。</p><h3 id="service管理指令"><a href="#service管理指令" class="headerlink" title="service管理指令"></a>service管理指令</h3><p>service  服务名 [start | stop | restart | reload | status]</p><p>在CentOS7.0后 不再使用 service , 而是 systemctl.</p><p>systemctl [start | stop | restart | reload | status] 服务名</p><p>centOS/RHEL6 系统中 System V init命令 与 centOS/RHEL7 系统中 Systemctl命令的对比:<br><img src="/images/QQ截图20181130155106.png"><br><img src="/images/QQ截图20181130155127.png"></p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>1) 查看当前防火墙的状况，关闭防火墙和重启防火墙。</p><pre><code>centOS6/RHEL6:service iptables start           # 启动service iptables stop            # 关闭service iptables restart         # 重启service iptables status          # 查看防火墙的状态chkconfig iptables on            # 开机启动chkconfig iptables off           # 取消开机启动--------------------- centOS7/RHEL7:systemctl start firewalld          # 启动systemctl stop firewalld           # 关闭systemctl restart firewalld        # 重启systemctl status firewalld         # 查看防火墙的状态systemctl enable firewalld         # 开机启动systemctl disable firewalld        # 取消开机启动firewall-cmd --list-all            #查看防火墙规则--------------------- </code></pre><p><code>service iptables status</code><br><img src="/images/QQ截图20181130153438.png"></p><p>在CentOS7 或 RHEL7 或 Fedora 中 防火墙由<strong> firewalld </strong>来管理.</p><p><code>systemctl status firewalld</code>：查看防火墙状态<br><img src="/images/QQ截图20181130160617.png"></p><p><code>systemctl stop firewalld</code> : 关闭防火墙<br><img src="/images/QQ截图20181130161040.png"></p><p><code>systemctl restart firewalld</code>：重启防火墙<br><img src="/images/QQ截图20181130161200.png"></p><hr><h3 id="CentOS切换为iptables防火墙"><a href="#CentOS切换为iptables防火墙" class="headerlink" title="CentOS切换为iptables防火墙"></a>CentOS切换为iptables防火墙</h3><p>切换到iptables首先应该关掉默认的firewalld，然后安装iptables服务。</p><p>1）关闭firewall</p><pre><code>systemctl stop firewalld          # 关闭systemctl disable firewalld       # 取消开机启动</code></pre><p>2) 安装iptables防火墙</p><pre><code>yum install iptables-services #安装</code></pre><p>3) 编辑iptables防火墙配置</p><pre><code>vi /etc/sysconfig/iptables</code></pre><p>下边是一个完整的配置文件：</p><pre><code>Firewall configuration written by system-config-firewallManual customization of this file is not recommended.*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT</code></pre><p>4）:wq! #保存退出</p><pre><code>service iptables start    #开启防火墙systemctl enable iptables #设置防火墙开机启动</code></pre><p><strong>细节：可以在windows宿主机中，使用 telnet 测试某个端口是否开启。</strong></p><h3 id="查看系统中的服务"><a href="#查看系统中的服务" class="headerlink" title="查看系统中的服务"></a>查看系统中的服务</h3><p>方式一：使用setup -&gt; 系统服务 就可以看到。<br><img src="/images/QQ截图20181130163538.png"><br><img src="/images/QQ截图20181130163606.png"><br><img src="/images/QQ截图20181130163652.png"></p><p>服务名前面带有*的，就是开机自启动的：使用空格键来切换是否开启启动，Tab键来切换到确定和取消按钮。</p><p>方式二:   systemctl list-unit-files –type=service</p><p><code>systemctl list-unit-files --type=service</code> : 列出系统有哪些服务<br><img src="/images/QQ截图20181130164926.png"></p><h3 id="服务的运行级别-runlevel"><a href="#服务的运行级别-runlevel" class="headerlink" title="服务的运行级别(runlevel)"></a>服务的运行级别(runlevel)</h3><p><strong>查看或者修改默认级别：  vi /etc/inittab </strong></p><pre><code>Linux系统有7种运行级别(runlevel)：常用的是级别3和5运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆运行级别2：多用户状态(没有NFS)，不支持网络运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式运行级别4：系统未使用，保留运行级别5：X11控制台，登陆后进入图形GUI模式运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</code></pre><p>CentOS 7 之前的版本是通过 /etc/inittab 文件来定义系统运行级别:</p><pre><code># inittab is only used by upstart for the default runlevel.## ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## System initialization is started by /etc/init/rcS.conf## Individual runlevels are started by /etc/init/rc.conf## Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf## Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,# with configuration in /etc/sysconfig/init.## For information on how to write upstart event handlers, or how# upstart works, see init(5), init(8), and initctl(8).## Default runlevel. The runlevels used are:#   0 - halt (Do NOT set initdefault to this)#   1 - Single user mode#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)#   3 - Full multiuser mode#   4 - unused#   5 - X11#   6 - reboot (Do NOT set initdefault to this)# id:5:initdefault:   #这里的数字：5就代表的是运行级别为5。修改成3后，就是多用户命令行的运行级别了。</code></pre><p>CentOS 7 版本不再使用该文件定义系统运行级别,相关运行级别设置无效:</p><pre><code># inittab is no longer used when using systemd.## ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## Ctrl-Alt-Delete is handled by /etc/systemd/system/ctrl-alt-del.target## systemd uses &#39;targets&#39; instead of runlevels. By default, there are two main targets:## multi-user.target: analogous to runlevel 3# graphical.target: analogous to runlevel 5## To set a default target, run:## ln -sf /lib/systemd/system/&lt;target name&gt;.target /etc/systemd/system/default.target#id:3:initdefault:  #无效,不要在这个配置文件中写这行代码！！！</code></pre><p>新版本的运行级别都定义在 <code>/lib/systemd/system</code>下:</p><pre><code>[root@liuzhuo01 ~]# ls -ltr /lib/systemd/system/runlevel*lrwxrwxrwx. 1 root root 15 11月 27 16:37 /lib/systemd/system/runlevel0.target -&gt; poweroff.targetlrwxrwxrwx. 1 root root 13 11月 27 16:37 /lib/systemd/system/runlevel1.target -&gt; rescue.targetlrwxrwxrwx. 1 root root 17 11月 27 16:37 /lib/systemd/system/runlevel2.target -&gt; multi-user.targetlrwxrwxrwx. 1 root root 17 11月 27 16:37 /lib/systemd/system/runlevel3.target -&gt; multi-user.targetlrwxrwxrwx. 1 root root 17 11月 27 16:37 /lib/systemd/system/runlevel4.target -&gt; multi-user.targetlrwxrwxrwx. 1 root root 16 11月 27 16:37 /lib/systemd/system/runlevel5.target -&gt; graphical.targetlrwxrwxrwx. 1 root root 13 11月 27 16:37 /lib/systemd/system/runlevel6.target -&gt; reboot.target</code></pre><p>新版本的默认运行级别定义在：<code>/etc/systemd/system/default.target</code></p><pre><code>[root@liuzhuo01 ~]# ls -l /etc/systemd/system/default.targetlrwxrwxrwx. 1 root root 36 11月 27 16:50 /etc/systemd/system/default.target -&gt; /lib/systemd/system/graphical.target</code></pre><p>可以针对不同需要设置不同的运行级别:</p><p>如设置命令行级别(init 3)方法:</p><pre><code>ln -sf /lib/systemd/system/runlevel3.target /etc/systemd/system/default.target或ln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.target或systemctl set-default multi-user.target</code></pre><p>设置窗口级别(init 5)方法:</p><pre><code>ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target或ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target或systemctl set-default graphical.target</code></pre><h3 id="chkconfig指令"><a href="#chkconfig指令" class="headerlink" title="chkconfig指令"></a>chkconfig指令</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍:"></a>介绍:</h4><p>通过chkconfig 命令 可以给<strong>每个服务</strong>的<strong>各个运行级别</strong> 设置自启动/关闭 （<strong>centOS7之前的版本使用的指令！！！</strong>）</p><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法:"></a>基本语法:</h4><pre><code>1） chkconfig  --list                         #查看所有的服务2)  chkconfig  --list | grep 服务名           #查看指定的服务   3)  chkconfig   服务名   --list               #查看指定的服务4） chkconfig   服务名   on/off               #在所有级别，开启或关闭，指定的服务    iptables 彻底关闭  ：chkconfig  iptables off  [不管是哪个级别都关闭]5)  chkconfig  --level  5   服务名   on/off   #指定某个级别，开启或关闭，指定的服务、    sshd 服务在 1 运行级别 关闭 ： chkconfig --level 1 sshd off</code></pre><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><p>1) 案例1： 请显示当前系统所有服务的各个运行级别的运行状态</p><p><code>chkconfig --list</code><br><img src="/images/QQ截图20181130171923.png"></p><p>2) 案例2 ：请查看sshd服务的运行状态</p><p><code>chkconfig sshd --list</code> 或者 <code>chkconfig --list | grep sshd</code><br><img src="/images/QQ截图20181130172752.png"></p><p>3) 案例3： 将sshd 服务在运行级别5下设置为不自动启动，看看有什么效果？</p><p><code>chkconfig –level 5 sshd off</code></p><p>4) 案例4： 当运行级别为5时，关闭防火墙。</p><p><code>chkconfig –level 5 iptables off</code></p><p>5) 案例5： 在所有运行级别下，关闭防火墙</p><p><code>chkconfig iptables off</code></p><p>6) 案例6： 在所有运行级别下，开启防火墙</p><p><code>chkconfig  iptables on</code></p><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><p>chkconfig重新设置服务后自启动或关闭，重启机器才会按设置的状态运行。</p><h2 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>top与ps命令很相似。它们都用来显示正在执行的进程。top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程(默认每3秒变化一次)。</p><h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>top [选项]选项说明:-d 秒数            ：指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令。-i         ：使用top不显示任何闲置 或者 僵死的进程。-p        ：通过指定监控进程的id来仅仅监控某个进程的状态。</code></pre><h3 id="交互操作说明"><a href="#交互操作说明" class="headerlink" title="交互操作说明"></a>交互操作说明</h3><p><img src="/images/QQ截图20181130173701.png"></p><h3 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h3><p>案例1.如何监视特定用户</p><p>top：输入此命令，按回车键，查看执行的进程。（默认3秒刷新一次）</p><p><img src="/images/QQ截图20181130174826.png"></p><pre><code>1）统计信息top -17:48:19 :表示当前的系统时间up 4:20  ：表示系统已经启动的时间（4小时20分钟）2 user   ：当前登录系统的用户数load average：表示系统的平均负载，3个数字分别表示1分钟、5分钟、15分钟到现在的系统平均负载值Tasks：227 total：表示进程的总数1 running：正在运行的进程数226 sleeping：处于休眠状态的进程数0 stopped：停止的进程数0 zombie：僵死的进程数%Cpu(s)：0.0 us：表示用户进程占用CPU的百分比0.3 sy：系统进程占用CPU的百分比0.0 ni：用户进程空间的内改变过优先级的进程占用CPU的百分比99.7 id：空闲CPU的百分比0.0 wa：等待输入、输出的进程占用CPU的百分比KiB Mem：4046020 total：系统的物理内存大小1950468 free：目前空余内存大小882624 userd：已经使用的物理内存大小1212928 buff/cache：用作内核缓冲区的内存大小KiB Swap：8388604 total：交换分区的内存大小8388604 free：交换分区空闲的内存大小0 used：交换分区已经使用的内存大小2）进程信息区PID：进程的IDUSER：进程所有者的用户名PR：进程的优先级NI：nice值。负值表示高优先级，正值表示低优先级VIRT：进程使用的虚拟内存总量，单位KBSHR：进程使用的、未被换出的物理内存大小，单位KBS：进程的状态，D-表示不可中断的睡眠状态，R-表示正在运行的状态，S-表示睡眠的状态，T-表示跟踪/停止，Z-表示僵死进程%CPU：上次更新到现在的CPU时间占用百分比%MEM：进程占用物理内存的百分比TIME+：进程总计使用的CPU时间，单位为1/100秒COMMAND：正在运行进程的命令名或者命令路径</code></pre><p>u：然后输入“u”回车，再输入用户名，即可。<br><img src="/images/QQ截图20181130181001.png"></p><p>案例2：如何终止指定的进程。</p><p>top：输入此命令，按回车键，查看执行的进程。<br>k：然后输入“k”回车，再输入要结束的进程ID号<br><img src="/images/QQ截图20181130181123.png"></p><p>案例3:指定系统状态更新的时间(每隔10秒自动更新)：<br><img src="/images/QQ截图20181130181215.png"><br><img src="/images/QQ截图20181130181233.png"></p><h2 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>查看系统网络情况netstat</p><h3 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>netstat [选项]选项说明 -an：按一定顺序排列输出-p ：显示哪个进程在调用-r ：显示路由表的信息</code></pre><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>1）查看所有服务的监听端口</p><p><code>netstat -anp | more</code><br><img src="/images/QQ截图20181130190225.png"></p><p>2) 查看服务名为 sshd 的服务的信息。</p><p><code>netstat -anp | grep sshd</code><br><img src="/images/QQ截图20181130190558.png"></p><p>3) 查看路由表的信息</p><p><code>netstat -r</code><br><img src="/images/QQ截图20181130190707.png"><br><code>netstat -rn</code><br><img src="/images/QQ截图20181130190838.png"></p><p><code>route -n</code><br><img src="/images/QQ截图20181130190948.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之网络设置</title>
      <link href="/2018/11/28/linux-ji-chu-ru-men-zhi-wang-luo-she-zhi/"/>
      <url>/2018/11/28/linux-ji-chu-ru-men-zhi-wang-luo-she-zhi/</url>
      
        <content type="html"><![CDATA[<p>Linux系统的网络设置<br><a id="more"></a></p><h2 id="桥接的方式"><a href="#桥接的方式" class="headerlink" title="桥接的方式"></a>桥接的方式</h2><p>之前，我们都是使用桥接的模式来连接虚拟机与宿主机的，桥接模式的缺点，之前我们也讲过了，会占用ip地址，引发ip地址冲突！！！</p><p>好处是，内网中的<strong>其他用户</strong>，也可以直接访问我的虚拟机，与我们的虚拟机通信。</p><p>比如：我宿主机的ip地址是：10.6.11.123。</p><p><img src="/images/QQ截图20181129100530.png"></p><p>使用桥接模式下的linux系统会自动帮我们，生成一个同网段下的ip地址：10.6.11.81<br><img src="/images/QQ截图20181129100614.png"><br><img src="/images/QQ截图20181129100853.png"></p><p>然后，现在不管是你的宿主机ping虚拟机的ip地址，还是虚拟机ping你的宿主机的ip地址，都能成功。<br><img src="/images/QQ截图20181129101126.png"><br><img src="/images/QQ截图20181129101401.png"></p><p><strong>注意：你的同事、同学也能ping通你的虚拟机，因为你的宿主机、虚拟机、你的同事都在一个网段里面。</strong></p><p>下面，我使用我同学的Mac机远程登录我的虚拟机，成功：<br><img src="/images/QQ截图20181129101910.png"></p><p><strong>坏处：如果每个人，都在虚拟机中使用桥接模式的话，那么该网段下的ip地址就会用光，某一天，当你开启你的虚拟机的linux系统时，你会听到你的同事说，又是哪个王八羔子抢了我本机的ip地址！！！</strong></p><h2 id="Nat模式"><a href="#Nat模式" class="headerlink" title="Nat模式"></a>Nat模式</h2><p>介绍：NAT网络主要作用是用于虚拟机与外网互通，它是宿主机内部的local网络，只有本主机内部可见，不能跨宿主机。</p><p>好处：虚拟机不占用其他的ip,所以不会ip冲突。</p><p>坏处：内网的其他人宿主机不能和虚拟机通讯。</p><h3 id="单独使用NAT网络"><a href="#单独使用NAT网络" class="headerlink" title="单独使用NAT网络"></a>单独使用NAT网络</h3><p>1）创建NAT网络</p><p>在创建虚拟机并为其指定NAT网络时，会弹出如下图所示的界面，其中包含<strong>网络地址转换（NAT）</strong>与<strong>NAT网络</strong>两个选项，这两个选项有什么区别呢？可以这样理解，网络地址转换（NAT）为VirtualBox内置的已经创建好的NAT网络，其网段为10.0.2.0/24，<strong>这个网络不允许用户管理</strong>，为了直观起见，在本例中创建自己的NAT网络。<br><img src="/images/QQ截图20181129103000.png"></p><p>点击菜单中的管理按键，选择全局设定，再从对话框中选择网络，然后点击界面上的加号图标，弹出NAT网络明细对话框。其中网络名称随意，网络CIDR一栏的地址不能与宿主机所属的任何一个物理网络冲突，也不能与宿主机中已经存在的其它虚拟网络冲突。</p><p><img src="/images/QQ截图20181129103626.png"></p><p>现在，新增NAT网络：点击界面上的加号图标。</p><p>下图中，CIDR为10.6.28.0/24，VirtualBox会将10.6.28.1这个IP设置成网关，并且选中支持DHCP选择。这样就创建了网络号为10.6.28、具备DHCP功能、默认网关为10.6.28.1的NAT网络，这些功能都是Virtualbox通过一个服务进程实现的。</p><p><img src="/images/QQ截图20181129104140.png"><br><img src="/images/QQ截图20181129104230.png"></p><p>现在，将我们的centOS_7.5系统的网络模式，改为我们刚刚设置的NAT网络：<br><img src="/images/QQ截图20181129104722.png"><br><img src="/images/QQ截图20181129104802.png"></p><p>设置完毕后，启动我们的centOS_7.5系统。<br><img src="/images/QQ截图20181129105404.png"></p><p>测试是否能上网 和 与我们的宿主机是否连通：<br><img src="/images/QQ截图20181129105550.png"></p><p><strong>注意：前提是你的宿主机本身能联网。</strong></p><p>虚拟机ping宿主机成功：<br><img src="/images/QQ截图20181129105825.png"></p><p>宿主机ping虚拟机超时：<br><img src="/images/QQ截图20181129161346.png"></p><p><strong>为啥，在使用NAT的模式下，虚拟机能够访问宿主机，能够通过宿主机上网成功，而宿主机却不能连通虚拟机呢？</strong></p><p>在NAT模式下，virtualBox帮我们创建的一个虚拟的内部网络，使用同一个NAT网络的内部虚拟机之间可以互相访问。</p><p>测试：使用virtualBox打开另一台Linux系统并且使用相同的NAT网络。</p><p>第二台的虚拟机的ip地址是：10.6.28.7<br><img src="/images/QQ截图20181129162644.png"></p><p>第一台的虚拟机的ip应该是10.6.28.4的，但是我重启了系统，现在变成了：10.6.28.6<br><img src="/images/QQ截图20181129162815.png"></p><p>现在互相ping。</p><p>第二台虚拟机ping第一台虚拟机：（成功）<br><img src="/images/QQ截图20181129163024.png"></p><p>第一台虚拟机ping第二台虚拟机：（成功）<br><img src="/images/QQ截图20181129163353.png"></p><p><strong>说明：使用相同的NAT网络，内部的虚拟机之间是可以互相访问的！！！</strong></p><p>到现在还是没有解释，我们的虚拟机能够联网呢？请看下图：<br><img src="/images/QQ截图20181129164646.png"></p><p>首先，VirtualBox为我们创建了一个虚拟的二层交换机，两台虚拟机中的网卡都联接在这台交换机上。同时，此交换机具备DHCP功能，管理10.6.28.0/24的地址池，它的网关地址是10.6.28.1。另外DHCP还负责管理DNS地址，这里的DNS地址的来源是宿主机，VirtualBox从宿主机拿到后设置在这里。当虚拟机启动时，DHCP服务会为它分配IP地址，设置网关，设置DNS服务器地址。</p><p>我们来查看，我们的虚拟机的DNS服务器地址与我们的宿主机的DNS服务器地址是否一致：</p><p>虚拟机的DNS服务的地址：<br><code>cat /etc/resolv.conf</code><br><img src="/images/QQ截图20181129164958.png"></p><p>宿主机的DNS服务器的地址：<br><img src="/images/QQ截图20181129165117.png"></p><p>发现是一样的，验证了我们的理论正确！！！</p><p>其次，VirtualBox为创建了一个三层的虚拟路由器，路由器中的路由表来源于宿主机，其实是与宿主机共享路由表。同时，因为创建的是NAT网络，这个路由器除了一般的路由功能，还是一个配置了NAT功能的路由器，实现宿主机IP地址+端口号与虚拟机IP地址+端口号之间的映射，最终实现与外部网络的通信。</p><p>可以看出，已经实现了一个完整的内部网络，包括带DHCP功能的二层交换机与带NAT功能的三层路由器。</p><p>所以，我们的虚拟机能够通过宿主机来访问外网。</p><p>但是，我们的宿主机是不知道虚拟机的存在的，所以宿主机ping不通我们的虚拟机。</p><h3 id="NAT-Host-only-的模式"><a href="#NAT-Host-only-的模式" class="headerlink" title="NAT + Host-only 的模式"></a>NAT + Host-only 的模式</h3><p>单独使用NAT网络的时候，是能很方便的连接外网的，但是宿主机与虚拟机是不能互通的，如果，我们想要互通怎么呢？</p><p>1）增加一个网卡，使用桥接的模式，宿主机与虚拟机通过桥接生成的ip地址互通。</p><p>不知道的话，请看桥接模式即可。</p><p>2）增加一个网卡，使用Host-only网络。</p><p>当你增加Host-only网络时，发现界面名称是：未指定时，需要我们自己来创建一个Host-only网卡。<br><img src="/images/QQ截图20181129170122.png"></p><p>一般，我们下载完VirtualBox后，会自动生成一个Host-only网卡。默认的ip地址是：192.168.56.1</p><p>点击virtualBox的管理，然后点击主机网络管理器，新增一个网卡。<br><img src="/images/QQ截图20181129170734.png"></p><p>此时，我们的宿主机上面，就会多出一个网络：<br><img src="/images/QQ截图20181129170933.png"></p><p>修改我们的centOS网络，添加新的网卡（Host-only）：<br><img src="/images/QQ截图20181129171051.png"></p><p>重新启动我们的centOS系统：</p><p><code>ifconfig 一下：</code><br><img src="/images/QQ截图20181129171407.png"></p><p>此时会多出一个网卡：enp0s8：就是我们刚刚设置的Host-only网卡。</p><p>来测试是否能上网：<br><img src="/images/QQ截图20181129171617.png"><br><img src="/images/QQ截图20181129171645.png"></p><p>来测试，宿主机与虚拟机是否能互通：</p><p>虚拟机ping宿主机：<br><img src="/images/QQ截图20181129171846.png"></p><p>宿主机ping虚拟机：</p><p><strong>注意：这里宿主机是ping那个Host-only生成的ip地址！！！</strong><br><img src="/images/QQ截图20181129172312.png"></p><p>接下来，我们使用Xshell来连接我们的虚拟机试试：</p><p>新建连接，主机写：虚拟机中的host-only生成的ip地址。<br><img src="/images/QQ截图20181129172946.png"><br><img src="/images/QQ截图20181129173102.png"></p><p><strong>总结：使用 NAT + Host-only的模式，虚拟机通过NAT来连通外网，通过Host-only来与宿主机互通。</strong></p><h3 id="最佳方案"><a href="#最佳方案" class="headerlink" title="最佳方案"></a>最佳方案</h3><p>上面，我们已经学习了，NAT + Host-only的模式来连通外网，并且宿主机与虚拟机互通。</p><p>但是，上面的方案是DHCP的方式，即自动生成ip地址，这样的话，我们的ip会随时变动的，作为服务器的是不行的，我们需要设置静态的ip地址来作为服务器。</p><p>编辑我们的网卡配置文件：</p><p><code>/etc/sysconfig/network-scripts/</code><br><img src="/images/QQ截图20181129174545.png"></p><p>在该目录下，应该有两个配置文件：ifcfg-enp0s3 和 ifcfg-enp0s8</p><p><strong>ifcfg-enp0s3：</strong>就是NAT网络生成的ip地址</p><pre><code>vim ifcfg-enp0s3</code></pre><p><img src="/images/QQ截图20181129175402.png"></p><p>ifcfg-enp0s3:动态生成ip地址就行，我们主要设置ifcfg-enp0s8，改为静态分配ip地址。</p><pre><code>vim ifcfg-enp0s8</code></pre><p><img src="/images/QQ截图20181129180212.png"></p><p>注意上面的网关地址写错了，应该是：<strong>192.168.69.1</strong>！！！,不然重启网络会失败的。</p><p>保存并退出。</p><p><code>systemctl restart network</code> : 重启我们的网络！！！</p><p><img src="/images/QQ截图20181129191233.png"><br><img src="/images/QQ截图20181129192721.png"></p><p>IP地址修改成功了，改成了静态配置，而且ip地址是我们自己输入的：<strong>192.168.69.200</strong></p><p>如果你重启网络的时候，出现异常，请查看你的Mac地址，网关是否配置有问题！！！</p><p>现在，重新修改我们的Xshell连接的主机ip地址：<br><img src="/images/QQ截图20181129193012.png"><br><img src="/images/QQ截图20181129193144.png"></p><p>以后，不管我们去哪里连接虚拟机都会成功了，因为现在是静态分配的ip了，不会变了。</p><hr><p>如果，我们是带有图形化界面的linux系统的话，其实可以直接图形化的方式修改ip地址。<br><img src="/images/QQ截图20181129193541.png"><br><img src="/images/QQ截图20181129193821.png"><br><img src="/images/QQ截图20181129194101.png"><br><img src="/images/QQ截图20181129194309.png"></p><p>修改完后，点击应用后，退出到网络设置页面，重新启动一下，就会更新我们的设置了！！！<br><img src="/images/QQ截图20181129194506.png"></p><p><strong>PS：不建议使用图形化的方式修改ip设置，我们学习，当然是以命令行为基准，图形化只是为了验证我们的配置是否正确而存在的！！！</strong></p><p><strong> NAT + Host-only的方式，是只能我们的宿主机与虚拟网络中的虚拟机互通，在该宿主机网络中的其他同事、同学是不能访问我们的虚拟机的，而桥接模式是可以的，注意两者之间的区别！！！</strong></p><h2 id="网络设置的几个重要配置文件"><a href="#网络设置的几个重要配置文件" class="headerlink" title="网络设置的几个重要配置文件"></a>网络设置的几个重要配置文件</h2><h3 id="网卡的配置文件"><a href="#网卡的配置文件" class="headerlink" title="网卡的配置文件"></a>网卡的配置文件</h3><pre><code>/etc/sysconfig/network-scripts/</code></pre><p>有几个网卡，就应该有几个：ifcfg-enp0s3、ifcfg-enp0s8等配置文件，有几个网卡就有几个配置文件，否则重启网络会出现异常！！！</p><p>配置文件的大概内容：</p><pre><code>DEVICE=enp0s3                  #接口名（设备,网卡的唯一标识，不能乱写的！！！）HWADDR=00:0C:2x:6x:0x:xx       #MAC地址 TYPE=Ethernet                  #网络类型（通常是Ethemet）UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44  #网卡的唯一标识。（自动生成的，要唯一！！！）ONBOOT=yes                     #系统启动的时候网络接口是否有效（yes/no）# IP的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议）BOOTPROTO=static      IPADDR=192.168.69.200          #IP地址PREFIX=24                      #设置子网掩码GATEWAY=192.168.69.1           #网关 DNS1=192.168.69.1              #域名解析器</code></pre><p><strong>PS：在centOS7之后的版本，可以在配置文件中设置多个ip地址，IPADDR0=xxx.xxx.xxx.xxx，IPADDR1=xxx.xxx.xxx.xxx，依次类推。</strong></p><p><strong>PREFIX：子网掩码也是一样的，PREFIX0，PREFIX1，与上面的ip地址对应；24：代表255.255.255.0 , 26：代表255.255.255.192</strong></p><p>GATEWAY:网关，可以在这里配置，也可以在 /etc/sysconfig/network中配置，如果没有在网卡配置文件中设置网关，那么/etc/sysconfig/network中的网关地址会生效。默认情况下，网卡配置文件中的网关配置会覆盖/etc/sysconfig/network中的网关设置。</p><h3 id="网关的配置文件"><a href="#网关的配置文件" class="headerlink" title="网关的配置文件"></a>网关的配置文件</h3><pre><code>/etc/sysconfig/network</code></pre><p>配置文件中的内容：</p><pre><code>GATEWAY=192.168.69.1</code></pre><h3 id="主机名的配置文件"><a href="#主机名的配置文件" class="headerlink" title="主机名的配置文件"></a>主机名的配置文件</h3><pre><code>/etc/hostname</code></pre><p>配合文件中的内容：</p><pre><code>liuzhuo01    #主机名</code></pre><p>查看主机名：直接使用 hostname指令即可。</p><h3 id="ip和主机映射的文件"><a href="#ip和主机映射的文件" class="headerlink" title="ip和主机映射的文件"></a>ip和主机映射的文件</h3><pre><code>/etc/hosts</code></pre><p>配置文件中的内容：</p><pre><code>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>有些时候，我们想直接ping主机名来访问，不想ping我们虚拟机的ip地址，不好记。</p><p>现在，我们尝试直接ping主机名：</p><p><img src="/images/QQ截图20181129203255.png"></p><p>现在添加新的 ip 与 主机名的映射信息：</p><pre><code>vim /etc/hosts</code></pre><p><img src="/images/QQ截图20181129213529.png"><br><img src="/images/QQ截图20181129213635.png"></p><p>这里，虚拟机自己ping自己的域名没有什么意义，我们想要在windows宿主机也能ping通虚拟机的主机名，该怎么呢？<br><img src="/images/QQ截图20181129214028.png"></p><p>修改windows下的：</p><pre><code>C:\Windows\System32\drivers\etc\hosts</code></pre><p><img src="/images/QQ截图20181129214230.png"><br><img src="/images/QQ截图20181129214441.png"><br><img src="/images/QQ截图20181129214543.png"></p><p>现在，使用Xshell的时候，创建一个新的连接，主机：填写你的虚拟机的主机名也可以连接成功。<br><img src="/images/QQ截图20181129214732.png"><br><img src="/images/QQ截图20181129214802.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之任务调度与磁盘分区</title>
      <link href="/2018/11/28/linux-ji-chu-ru-men-zhi-ren-wu-diao-du/"/>
      <url>/2018/11/28/linux-ji-chu-ru-men-zhi-ren-wu-diao-du/</url>
      
        <content type="html"><![CDATA[<p>定时任务调度、磁盘分区<br><a id="more"></a></p><h2 id="Linux的crond任务调度"><a href="#Linux的crond任务调度" class="headerlink" title="Linux的crond任务调度"></a>Linux的crond任务调度</h2><p>crontab 进行 定时任务的设置。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>任务调度：是指系统在某个时间执行的特定的命令或程序。 </p><p>任务调度分类：</p><p>1.系统工作：有些重要的工作必须周而复始地执行，比如病毒扫描等。<br>2.个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。</p><h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p><img src="/images/QQ截图20181128131351.png"></p><p>如果，我们需要备份mysql数据，而且是在晚上凌晨两点的时候执行效率才会高，我们不可能每天凌晨两点去执行备份mysql数据的命令，所以可以使用crontab任务调用机制，帮助我们每天凌晨两点自动执行备份mysql数据的命令。</p><p>使用步骤：</p><p>1）编写我们特殊的脚本（shell编程）</p><p>2）使用crontab任务调用我们的脚本执行。</p><p><strong>注意：简单的脚本，可以不用写，直接使用crontab就可以帮助我们执行了。</strong></p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>crontab [选项]常用选项-e：编辑crontab定时任务-l：查询crontab任务-r：删除当前用户所有的crontab任务</code></pre><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>设置任务调度文件：/etc/crontab<br>设置个人任务调度: 执行 crontab –e 命令。<br>接着输入任务到调度文件：</p><pre><code>如：*/1 * * * * ls –l  /home/ &gt;&gt; /home/tmp/to.txt</code></pre><p>意思是说：当前时间每隔一分钟就执行 ls –l /home/ &gt;&gt; /home/tmp/to.txt命令.</p><p>步骤如下：</p><p>1）crontab -e</p><p>2）输入：<code>*/1 * * * * ls –l  /home/ &gt;&gt; /home/tmp/to.txt</code></p><p>3) 当保存退出后就执行定时任务。</p><p>4）在每一分钟都会自动的调用：ls –l  /home/ &gt;&gt; /home/tmp/to.txt</p><hr><p><img src="/images/QQ截图20181128133356.png"><br><img src="/images/QQ截图20181128133518.png"></p><p>保存退出：<br><img src="/images/QQ截图20181128133600.png"><br><img src="/images/QQ截图20181128133720.png"></p><p>之后每隔一分钟都会往 /home/tmp/to.txt 文件中，追加：ls -l /home/ 的信息。</p><h3 id="参数细节说明"><a href="#参数细节说明" class="headerlink" title="参数细节说明"></a>参数细节说明</h3><p>1）5个占位符的说明<br><img src="/images/QQ截图20181128134026.png"></p><p>2）特殊符号的说明<br><img src="/images/QQ截图20181128134119.png"></p><p>3）特定时间执行任务案例<br><img src="/images/QQ截图20181128134542.png"></p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>案例1：每隔1分钟，就将当前的日期信息，追加到 /home/tmp/mydate.log 文件中</p><p>1) 在/home下：编写一个文件（shell）mytask1.sh</p><p><code>date &gt;&gt; /home/tmp/mydate.log</code></p><p>2) 给mytask1.sh分配一个可执行的权限</p><p><code>chmod 744 /home/mytask1.sh</code></p><p>3）crontab -e</p><p><code>*/1 * * * *  /home/mytask1.sh</code></p><p>4）保存退出即可。</p><hr><p><img src="/images/QQ截图20181128138836.png"><br><img src="/images/QQ截图20181128140946.png"><br><img src="/images/QQ截图20181128141112.png"><br><img src="/images/QQ截图20181128141317.png"><br><img src="/images/QQ截图20181128141248.png"><br><img src="/images/QQ截图20181128141507.png"></p><p>案例2：每隔1分钟， 将当前日期和日历都追加到 /home/mycal.log 文件中</p><p><code>*/1 * * * *  date &gt;&gt; /home/mycal.log</code><br><code>*/1 * * * *  cal &gt;&gt; /home/mycal.log</code></p><p>案例3: 每天凌晨2:00 将mysql数据库 testdb ，备份到文件中。</p><pre><code>步骤：1， 首先编写一个 脚本 backupdb.sh#!/bin/bash   #备份路径BACKUP=/data/backup/sql/dy#当前时间DATETIME=$(date +%Y-%m-%d_%H%M%S)echo &quot;===备份开始===&quot;echo &quot;备份文件存放于${BACKUP}/$DATETIME.tar.gz&quot;#数据库地址HOST=localhost#数据库用户名DB_USER=root#数据库密码DB_PW=Ces123456#创建备份目录[ ! -d &quot;${BACKUP}/$DATETIME&quot; ] &amp;&amp; mkdir -p &quot;${BACKUP}/$DATETIME&quot;#后台系统数据库DATABASE=dy_backgroundmsmysqldump -u${DB_USER} -p${DB_PW} --host=$HOST -q -R --databases $DATABASE | gzip &gt; ${BACKUP}/$DATETIME/$DATABASE.sql.gz#投入品监管数据库DATABASE=dy_firipmysqldump -u${DB_USER} -p${DB_PW} --host=$HOST -q -R --databases $DATABASE | gzip &gt; ${BACKUP}/$DATETIME/$DATABASE.sql.gz#压缩成tar.gz包cd $BACKUPtar -zcvf $DATETIME.tar.gz $DATETIME#删除备份目录rm -rf ${BACKUP}/$DATETIME#删除30天前备份的数据find $BACKUP -mtime +30 -name &quot;*.tar.gz&quot; -exec rm -rf {} \;echo &quot;===备份成功===&quot;</code></pre><h3 id="crond-相关指令"><a href="#crond-相关指令" class="headerlink" title="crond 相关指令:"></a>crond 相关指令:</h3><pre><code>1) crontab -e：创建任务调度。2) crontab –l：列出当前有那些任务调度。3) conrtab –r：终止任务调度。4) service crond restart ： [重启任务调度]   &lt;=====&gt; systemctl restart crond</code></pre><p><img src="/images/QQ截图20181128135000.png"></p><h2 id="Linux的磁盘分区、挂载"><a href="#Linux的磁盘分区、挂载" class="headerlink" title="Linux的磁盘分区、挂载"></a>Linux的磁盘分区、挂载</h2><h3 id="分区基础知识"><a href="#分区基础知识" class="headerlink" title="分区基础知识"></a>分区基础知识</h3><h4 id="分区的方式-知道即可"><a href="#分区的方式-知道即可" class="headerlink" title="分区的方式(知道即可)"></a>分区的方式(知道即可)</h4><p>1) mbr分区:</p><p>1.最多支持四个主分区<br>2.系统只能安装在主分区<br>3.扩展分区要占一个主分区<br>4.MBR最大只支持2TB，但拥有最好的兼容性</p><p>2) gtp分区:</p><p>1.支持无限多个主分区（但操作系统可能会限制，比如 windows下最多128个分区）<br>2.最大支持18EB的大容量（1EB=1024 PB，1PB=1024 TB ）<br>3.windows7 64位以后支持gtp</p><h4 id="windows下的磁盘分区"><a href="#windows下的磁盘分区" class="headerlink" title="windows下的磁盘分区"></a>windows下的磁盘分区</h4><p><img src="/images/QQ截图20181128144519.png"></p><h4 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h4><p>原理介绍：</p><p>1）对Linux来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux中每个分区都是用来组成整个文件系统的一部分。</p><p>2）Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p><p>3）示意图【分区和文件目录】<br><img src="/images/QQ截图20181128145010.png"></p><h4 id="Linux硬盘说明"><a href="#Linux硬盘说明" class="headerlink" title="Linux硬盘说明"></a>Linux硬盘说明</h4><p>1）Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是<strong>SCSI硬盘</strong>。</p><p>2）对于IDE硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“~”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。</p><p>例如，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区 , hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。 </p><p>3）对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。<br>sdb1 [表示第2块scsi 硬盘的第1个分区]</p><h4 id="查看所有设备挂载情况"><a href="#查看所有设备挂载情况" class="headerlink" title="查看所有设备挂载情况"></a>查看所有设备挂载情况</h4><p>命令：<code>lsblk</code> 或者 <code>lsblk -f</code><br><img src="/images/QQ截图20181128150000.png"></p><h3 id="挂载的经典案例"><a href="#挂载的经典案例" class="headerlink" title="挂载的经典案例"></a>挂载的经典案例</h3><p>说明：</p><p>下面我们以增加一块硬盘 2G 为例来熟悉下磁盘的相关指令和深入理解：磁盘分区、挂载、卸载的概念。</p><p>如何增加一块硬盘：</p><pre><code>步骤：1）虚拟机添加硬盘2）分区3）格式化4）挂载5）设置可以自动挂载 。</code></pre><h4 id="增加硬盘"><a href="#增加硬盘" class="headerlink" title="增加硬盘"></a>增加硬盘</h4><p>1）虚拟机增加硬盘</p><p>在虚拟机关闭的情况的下，点击设置，找到存储，点击控制器：SATA右边的第二个加号！<br><img src="/images/QQ截图20181128165053.png"><br><img src="/images/QQ截图20181128165215.png"><br><img src="/images/QQ截图20181128165251.png"><br><img src="/images/QQ截图20181128165510.png"><br><img src="/images/QQ截图20181128165619.png"></p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>2）使用fdisk命令分区</p><p>重启我们的linux系统：<br><img src="/images/QQ截图20181128170120.png"><br><img src="/images/QQ截图20181128170250.png"></p><p>使用：<code>fdisk /dev/sdb</code><br><img src="/images/QQ截图20181128170533.png"><br><img src="/images/QQ截图20181128170702.png"><br><img src="/images/QQ截图20181128170851.png"><br><img src="/images/QQ截图20181128171009.png"><br><img src="/images/QQ截图20181128171209.png"></p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>3) 使用 <code>mkfs -t xfs /dev/sdb1</code> [把sdb1格式化为：xfs格式的文件系统]<br><img src="/images/QQ截图20181128171435.png"></p><p>4）创建挂载点：/home/newdisk<br><img src="/images/QQ截图20181128171637.png"></p><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>5) 使用 <code>mount /dev/sdb1 /home/newdisk</code> [将sdb1分区，挂载到/home/newdisk中]<br><img src="/images/QQ截图20181128172131.png"></p><p>此时，就已经完成了，磁盘的分区、格式化、挂载了，就可以使用/home/newdisk来操作硬盘了。但是这种挂载是临时的，当我们重启之后，挂载点就会消失。<br><img src="/images/QQ截图20181128172245.png"><br><img src="/images/QQ截图20181128172634.png"></p><h4 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h4><p>6）永久性的挂载成功</p><p>通过修改/etc/fstab实现永久性挂载。添加完后，需要执行：<code>mount -a</code>即刻生效！<br><img src="/images/QQ截图20181128172906.png"><br><img src="/images/QQ截图20181128173000.png"></p><p><strong>技巧：在正常模式下，yy+p会复制粘贴当前行！！！</strong></p><p>保存修改后，执行：<code>mount -a</code>,即刻生效！<br><img src="/images/QQ截图20181128173503.png"></p><p>现在，你重启后，也会自动挂载成功！！！</p><h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><h4 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h4><p>基本语法：</p><pre><code>df -h</code></pre><p>应用实例：</p><p>查询系统整体磁盘使用情况<br><img src="/images/QQ截图20181128175623.png"></p><h4 id="查询指定目录的磁盘占用情况"><a href="#查询指定目录的磁盘占用情况" class="headerlink" title="查询指定目录的磁盘占用情况"></a>查询指定目录的磁盘占用情况</h4><p>基本语法</p><pre><code>du -h  /目录查询指定目录的磁盘占用情况，默认为当前目录-s 指定目录占用大小汇总-h 带计量单位-a 含文件--max-depth=1  子目录深度-c 列出明细的同时，增加汇总值</code></pre><p>应用实例：</p><p>查询 /usr目录的磁盘占用情况，深度为1。</p><p><code>du  -ach  --max-depth=1  /usr</code><br><img src="/images/QQ截图20181128180112.png"></p><h4 id="磁盘情况-工作实用指令"><a href="#磁盘情况-工作实用指令" class="headerlink" title="磁盘情况-工作实用指令"></a>磁盘情况-工作实用指令</h4><p>1) 统计 /home 文件夹下<strong>文件</strong>的个数</p><p><code>ls –l /home/ | grep &quot;^-&quot; | wc -l</code><br><img src="/images/QQ截图20181128193317.png"></p><p>2) 统计 /home 文件夹下<strong>目录</strong>的个数。</p><p><code>ls –l /home/ | grep &quot;^d&quot; | wc -l</code><br><img src="/images/QQ截图20181128193601.png"></p><p>3) 统计 /home文件夹下文件的个数，包括<strong>子文件夹</strong>里的。</p><p><code>ls –lR /home/ | grep &quot;^-&quot; | wc -l</code><br><img src="/images/QQ截图20181128193831.png"><br>4) 统计 /home文件夹下目录的个数，包括子文件夹里的。</p><p><code>ls –lR /home/ | grep &quot;^d&quot; | wc -l</code><br><img src="/images/QQ截图20181128193922.png"></p><p>5) 以树状显示：home目录结构。[没有tree指令咋办, 使用yum 来安装]<br><img src="/images/QQ截图20181128194037.png"><br><img src="/images/QQ截图20181128194147.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之权限</title>
      <link href="/2018/11/27/linux-ji-chu-ru-men-zhi-quan-xian/"/>
      <url>/2018/11/27/linux-ji-chu-ru-men-zhi-quan-xian/</url>
      
        <content type="html"><![CDATA[<p>组管理和权限管理<br><a id="more"></a></p><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><h3 id="linux组的基本介绍"><a href="#linux组的基本介绍" class="headerlink" title="linux组的基本介绍"></a>linux组的基本介绍</h3><p>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件都有：所有者、所在组、其它组 的概念。</p><h3 id="文件-目录-所有者"><a href="#文件-目录-所有者" class="headerlink" title="文件/目录 所有者"></a>文件/目录 所有者</h3><p>一般为文件的创建者 ， 谁创建了该文件，就自然的成为该文件的所有者。</p><p>1）查看文件的所有者</p><p>指令：ls –ahl</p><p>应用实例 :创建一个组police,再创建一个用户tom,将tom放在police组 ,然后使用 tom来创建一个文件 ok.txt，看看情况如何？<br><img src="/images/QQ截图20181127195335.png"></p><p>2）修改文件所有者</p><p>指令：chown 用户名 文件名 </p><p>应用案例要求：使用root 创建一个文件apple.txt ，然后将其所有者修改成 tom。<br><img src="/images/QQ截图20181127195757.png"></p><h3 id="文件-目录-所在组"><a href="#文件-目录-所在组" class="headerlink" title="文件/目录 所在组"></a>文件/目录 所在组</h3><p>当某个用户创建了一个文件后，默认情况下，这个文件的所在组就是该用户所在的组。</p><p>1）查看文件/目录所在组</p><p>基本指令：ls –ahl </p><p>2）修改文件所在的组</p><p>基本指令：</p><p><code>chgrp</code> 组名 文件名</p><p>应用实例：</p><p>使用root用户创建文件 orange.txt ,看看当前这个文件属于哪个组【root】，然后将这个文件所在组，修改到 police组。<br><img src="/images/QQ截图20181127200619.png"></p><h3 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a>其它组</h3><p>除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</p><h3 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h3><p>在添加用户时，可以指定将该用户添加到哪个组中，同样的，使用root的管理权限可以改变某个用户所在的组。</p><p>1）改变用户所在组</p><pre><code>1) usermod   –g   组名  用户名2) usermod   –d   目录名  用户名  改变该用户登陆的初始目录。</code></pre><p>2) 应用实例</p><p>创建一个土匪组（bandit）将 tom 这个用户从原来所在的police组，修改到 bandit(土匪) 组中。</p><p><code>usermod  -g  bandit  tom</code><br><img src="/images/QQ截图20181127201505.png"></p><hr><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><pre><code>ls  -l 中显示的内容如下：-rwxrw-r-- 1 root police 1213 Feb 2 09:39 ok.txt</code></pre><p>0-9位说明:</p><p>1) 第0位确定文件类型(说明: -:普通文件, d:目录，l : 连接文件, c: 字符设备文件[键盘,鼠标] b: 块设备文件[硬盘] )</p><p>2) 第1-3位确定所有者（该文件的所有者）拥有该文件的权限。r: 读 , w : 写权限 , x:  执行权限  </p><p>3) 第4-6位确定所属组（同用户组的）拥有该文件的权限</p><p>4) 第7-9位确定其他用户拥有该文件的权限 </p><p>5) <code>1</code>: 如果是文件，表示硬链接的数目， 如果是目录，则表示有多少个子目录（不包含文件）</p><p>6) 1213： 表示文件大小(字节)，如果是目录，则统一为 4096。</p><p>7）Feb 2 09:39：文件最后的修改时候。</p><h3 id="rwx权限详解"><a href="#rwx权限详解" class="headerlink" title="rwx权限详解"></a>rwx权限详解</h3><h4 id="rwx作用到文件-重要"><a href="#rwx作用到文件-重要" class="headerlink" title="rwx作用到文件(重要)"></a>rwx作用到文件(重要)</h4><p>1) [ r ] 代表可读(read): 可以读取,查看<br>2) [ w ] 代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.<br>3) [ x ] 代表可执行(execute):可以被执行</p><h4 id="rwx作用到目录-重要"><a href="#rwx作用到目录-重要" class="headerlink" title="rwx作用到目录(重要)"></a>rwx作用到目录(重要)</h4><p>1) [ r ] 代表可读(read): 可以读取，ls查看目录内容<br>2) [ w ] 代表可写(write): 可以修改,目录内创建+删除+重命名目录<br>3) [ x ] 代表可执行(execute):可以进入该目录  </p><h4 id="文件及目录权限实际案例"><a href="#文件及目录权限实际案例" class="headerlink" title="文件及目录权限实际案例"></a>文件及目录权限实际案例</h4><p>ls  -l 中显示的内容如下：<br>-<font color="red">rwx</font><font color="blue">rw-</font><code>r--</code>. 1 root root 1213 Feb 2 09:39 abc</p><p>10个字符确定不同用户能对文件的权限：</p><p> 第一个字符代表文件类型： 文件 (-) , 目录(d) , 链接(l)</p><p> 其余字符每3个一组(rwx) 读(r) 写(w) 执行(x)<br> 第一组<font color="red">rwx</font> : 文件拥有者的权限是读、写和执行<br> 第二组<font color="blue">rw-</font> : 与文件所在组的用户的权限是读、写但不能执行<br> 第三组<code>r--</code> :  不与文件拥有者同组的其他用户的权限是读不能写和执行</p><p>可用数字表示为: r=4 , w=2 , x=1 因此 rwx = 4 + 2 + 1 = 7 .</p><p>r: 100 , w: 010 ,  x: 001</p><p>   1        文件：硬连接数 或  目录：子目录数<br>   root          用户<br>   root          组<br>   1213                  文件大小(字节)，如果是目录的话，显示 4096字节<br>   Feb 2 09:39      最后修改日期<br>   abc                    文件名 </p><h3 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限-chmod"></a>修改权限-chmod</h3><p>基本说明：</p><p>通过chmod指令，可以修改文件或者目录的权限。</p><h4 id="第一种方式：-、-、-变更权限"><a href="#第一种方式：-、-、-变更权限" class="headerlink" title="第一种方式：+ 、- 、= 变更权限"></a>第一种方式：+ 、- 、= 变更权限</h4><p> <code>u:所在者</code>  <code>g:所在组</code>  <code>o:其他组</code>  <code>a:所有人</code>(u、g、o的总和)</p><p> 1) chmod   u=rwx , g=rx , o=x　　文件、目录 【表示：给所有者rwx, 给所在组的用户 rx , 给其他人 x】<br> 2) chmod   o+w    文件、目录 【表示：给其它用户增加w 的权限】<br> 3) chmod   a-x    文件、目录    【表示：给所有用户 去掉 x权限】</p><p>案例演示：</p><p>1) 给abc文件的 <strong>所有者</strong>读写执行的权限 ，给<strong>所在组</strong>读执行权限 ，给<strong>其它组</strong>读执行权限。</p><p>chmod  u=rwx , g=rx , o=rx   abc</p><p><img src="/images/QQ截图20181127205641.png"><br>2) 给abc文件的 <strong>所有者</strong>除去执行的权限，<strong>所在组</strong>增加写的权限</p><p>chmod  u-x, g+w abc<br><img src="/images/QQ截图20181127205833.png"></p><p>3) 给abc文件的<strong>所有用户</strong>添加读的权限 </p><p>chmod  a+r  abc<br><img src="/images/QQ截图20181127205959.png"></p><h4 id="第二种方式：通过数字变更权限"><a href="#第二种方式：通过数字变更权限" class="headerlink" title="第二种方式：通过数字变更权限"></a>第二种方式：通过数字变更权限</h4><p>r=4 w=2 x=1　　　　　rwx=4+2+1=7</p><p>chmod <code>u=rwx , g=rx , o=x</code> 　文件、目录  《==》   chmod   <code>751</code>  文件、目录</p><p>因为 rwx：111=7 ， rx：101=5 ， x：001=1</p><p>案例演示</p><p>要求：将 /home/abc.txt 文件的权限修改成  <code>rwxr-xr-x</code>, 使用给数字的方式实现：</p><p>chmod　　u=rwx , g=xr ,  o=x　　/home/abc.txt<br>chmod　　751　　/home/abc.txt<br><img src="/images/QQ截图20181127210926.png"></p><h3 id="修改文件所有者-chown"><a href="#修改文件所有者-chown" class="headerlink" title="修改文件所有者-chown"></a>修改文件所有者-chown</h3><p>基本介绍</p><p>chown　newowner　file　　改变文件的所有者</p><p>chown　newowner : newgroup　　file　　改变用户的所有者和所有组</p><p><code>-R</code>  如果是目录 则使其下所有子文件或目录递归生效</p><p>案例演示：</p><p>1) 请将 /home/abc.txt 文件的所有者修改成 tom.</p><p>chown   tom  /home/abc.txt<br><img src="/images/QQ截图20181127212038.png"></p><p>2) 请将 /home/kkk 目录下所有的文件和目录的所有者都修改成tom.</p><p>chown <code>–R</code> tom  /home/kkk<br><img src="/images/QQ截图20181127212509.png"></p><p>3) 将/home/aaa下的所有文件和目录的所有者都改成 tom，将所在组改成police.</p><p>chown <code>–R  tom:police</code>   /home/aaa<br><img src="/images/QQ截图20181127212710.png"></p><h3 id="修改文件所在组-chgrp"><a href="#修改文件所在组-chgrp" class="headerlink" title="修改文件所在组-chgrp"></a>修改文件所在组-chgrp</h3><p>基本介绍</p><p>chgrp newgroup file  改变文件的所有组</p><p>案例演示：</p><p>1) 请将 /home/abc.txt 文件的所在组修改成 bandit (土匪)</p><p>chgrp  bandit  /home/abc.txt<br><img src="/images/QQ截图20181127213015.png"></p><p>2) 请将 /home/kkk 目录下所有的文件和目录的所在组都修改成 bandit(土匪)</p><p>chgrp  -R  bandit /home/kkk<br><img src="/images/QQ截图20181127213340.png"></p><h3 id="最佳实践-警察和土匪游戏"><a href="#最佳实践-警察和土匪游戏" class="headerlink" title="最佳实践-警察和土匪游戏"></a>最佳实践-警察和土匪游戏</h3><p>police（警察） ， bandit（土匪） </p><p>jack , jerry: 警察<br>xh , xq: 土匪</p><p>1）创建组 </p><pre><code>[root@liuzhuo01 home]# groupadd police[root@liuzhuo01 home]# groupadd bandit</code></pre><p><img src="/images/QQ截图20181127214046.png"><br>2）创建用户 </p><pre><code>[root@liuzhuo01 home]# useradd -g police jack[root@liuzhuo01 home]# useradd -g police jerry[root@liuzhuo01 home]# useradd -g bandit xh[root@liuzhuo01 home]# useradd -g bandit xq</code></pre><p><img src="/images/QQ截图20181127215156.png"></p><p>并给四个用户，添加密码。<br><img src="/images/QQ截图20181127215523.png"></p><p>3）jack 创建一个文件，自己可以读写，本组人可以读，其它组没人任何权限</p><p>使用Xshell创建一个新的连接，使用jack登录。然后创建一个jack.txt文件。<br><img src="/images/QQ截图20181127215732.png"></p><p>使用：<code>chmod 640 jack.txt</code><br><img src="/images/QQ截图20181127220010.png"></p><p>4）jack 修改该文件，让本组人可以读写 , 其它组人可以读</p><p>使用：<code>chmod g=rw,o=r jack.txt</code><br><img src="/images/QQ截图20181127220327.png"></p><p>5）<strong>xh 投靠 警察，看看是否可以读写jack.txt文件（重点）.</strong></p><p>首先使用xh连接，登入到linux系统中：<br><img src="/images/QQ截图20181127220458.png"></p><p>进入jack.txt所在的目录，才能修改jack.txt文件。<br><img src="/images/QQ截图20181127220643.png"></p><p>会发现权限不够，根本不能进入jack目录中，因为jack是police组，xh是bandit，组不同，而jack目录对其他组的权限无。</p><p>题目的要求是让我们把xh改为police组，所以，我们必须让jack对所在组police修改为：rx的权限，xh才能进入到jack目录中，修改jack.txt文件。</p><p>在root用户下，修改xh所在组为police组：<br><img src="/images/QQ截图20181127221209.png"></p><p>在jack用户下，修改jack目录的所在组police有rx的权限：<br><img src="/images/QQ截图20181127221427.png"></p><p>在xh用户下，进入jack目录<br><img src="/images/QQ截图20181127221545.png"></p><p>发现还是权限不够，我们的理论错了嘛？ 不是的，是需要我们注销，重新登入xh用户。<br><img src="/images/QQ截图20181127221731.png"></p><p>修改jack.txt文件：<br><img src="/images/QQ截图20181127222032.png"><br><img src="/images/QQ截图20181127221902.png"></p><p>使用jack查看jack.txt文件，看是否修改成功：<br><img src="/images/QQ截图20181127222225.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之指令</title>
      <link href="/2018/11/25/linux-ji-chu-ru-men-zhi-zhi-ling/"/>
      <url>/2018/11/25/linux-ji-chu-ru-men-zhi-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>本篇会介绍Linux系统的常用指令<br><a id="more"></a></p><h2 id="Linux实操指令"><a href="#Linux实操指令" class="headerlink" title="Linux实操指令"></a>Linux实操指令</h2><p>在我们实际工作中，是不会直接到服务器机房去登录linux系统，然后在上操作的，也不会操作图形化界面。</p><p>所以，我们必须掌握一些实用的指令，通过命令来操作linux系统。</p><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>1）基本介绍</p><p>运行级别说明： </p><p>0 ：关机<br>1 ：单用户  [类似安全模式， 这个模式可以帮助<strong>找回root密码</strong>]<br>2：多用户状态没有网络服务<br><strong>3：多用户状态有网络服务 [字符界面]</strong><br>4：系统未使用保留给用户<br><strong>5：图形界面 </strong><br>6：系统重启  </p><p>常用运行级别是 3 和 5 ，要修改默认的运行级别可改配置文件【/etc/inittab】。</p><p><strong>/etc/inittab</strong> 文件中： <strong>id:5:initdefault: </strong>   //这一行中的数字就是默认的运行级别</p><p>命令：init  [012356]  ：切换运行级别</p><hr><p><img src="/images/QQ截图20181125212656.png"></p><p>以上是CentOS 7.x版本之前的系统中使用的。而CentOS 7.x版本中，由于采用了systemd管理体系，因此以前运行级别（runlevel）的概念被新的运行目标（target）所取代，target的命名类似于 “ multi-user.target “ 这种形式.</p><p>比如原来的运行级别：3（runlevel3）对应于新的多用户目标 “ multi-user.target “,运行级别5就对应于” graphical.target “。因为systemd机制中不再使用runlevel的概念，所以/etc/inittab也不再被系统使用。</p><p>在新的systemd管理体系中，默认的target通过软连接来实现的。</p><p>2) 要查看系统的默认target，可以执行如下：</p><pre><code>ll /etc/systemd/system/default.target</code></pre><p><img src="/images/QQ截图20181125220550.png"></p><p>由此可知，现在系统的默认target为 “ graphical.target “ , 相当于 runlevel5.</p><p>3) 修改默认的运行级别为3</p><p>如果要修改默认的target为 “multi-user.target”,可以先删除存在的软链接，然后重新建立软链接指向到 “ multi-user.target “ 即可。</p><p>操作过程如下：<strong>(下面会有更简单的修改方式)</strong></p><pre><code>rm -rf /etc/systemd/system/default.targetln -sf /lib/systemd/system/multi-user.target  /etc/systemd/system/default.targetll /etc/systemd/system/default.target</code></pre><p><img src="/images/QQ截图20181125221432.png"></p><p>重启linux系统，reboot</p><p>你会发现我们的linux系统启动后，直接进入了字符界面，没有图形化界面。<br><img src="/images/QQ截图20181125221515.png"></p><hr><p>4）查看运行级别与target的对应关系，可以执行</p><pre><code>ll /lib/systemd/system/runlevel*.target</code></pre><p><img src="/images/QQ截图20181125222306.png"></p><p>即：</p><p>poweroff.target 对应 runlevel0：关机模式。</p><p>rescue.target 对应 runlevel1：单用户或救援模式。</p><p>multi-user.target 对应 runlevel2、runlevel3、runlevel4：字符界面多用户模式。</p><p>graphical.target 对应 runlevel5：图形界面多用户模式。</p><p>reboot.target 对应 runlevel6：重启模式。</p><hr><p>以前修改默认的运行级别是，通过修改 /etc/inittab文件来实现的，</p><p>在以前的/etc/inittab文件的最后一行是：</p><p>id:5:initdefault:  //表示默认的运行级别是5，图形界面多用户模式。只需要修改这个数字就可以修改默认的运行级别了。</p><p>而CentOS7.x版本的 /etc/inittab文件为：<br><img src="/images/QQ截图20181125223455.png"></p><p>只能通过上述修改软链接的方式来修改默认的target。</p><p>现在我们把 “ multi-user.target “ 修改为：” graphical.target “</p><font color="red"><strong>简便的方式：</strong></font><h3 id="查看默认的-target-运行级别-："><a href="#查看默认的-target-运行级别-：" class="headerlink" title="查看默认的 target(运行级别)："></a>查看默认的 target(运行级别)：</h3><pre><code>systemctl get-default</code></pre><p><img src="/images/QQ截图2018112522423.png"></p><h3 id="修改默认的-target-运行级别-："><a href="#修改默认的-target-运行级别-：" class="headerlink" title="修改默认的 target(运行级别)："></a>修改默认的 target(运行级别)：</h3><pre><code>systemctl set-default graphical.target</code></pre><p><img src="/images/QQ截图20181125224511.png"></p><hr><p>以前的版本，使用： init [0213456] 来切换运行级别，现在的版本使用：systemctl isolate xxx.target （以前的init也适用）</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>在忘记了root的密码的情况下，怎么登入系统，并修改root的密码？</p><p>重启我们的linux系统，首先我们进入开机界面.</p><h4 id="错误操作"><a href="#错误操作" class="headerlink" title="错误操作"></a>错误操作</h4><p>1) 按e进行选择，选择编辑选项启动<br><img src="/images/QQ截图20181126105206.png"></p><p>看上图的底部，有：Press e 进入编辑界面。</p><p><img src="/images/QQ截图20181126102855.png"></p><p>2) 使用键盘上面的向下的按钮，找到：linux16 开头的那行。<br><img src="/images/QQ截图20181126105357.png"></p><p><img src="/images/QQ截图20181126110106.png"></p><p>3) 看到上图的底部，使用 Ctrl + x 去开始启动系统。</p><p><img src="/images/QQ截图20181126110315.png"></p><p>现在已经进入了系统了，而且是单用户的模式，所以不需要输入密码，就进入root用户了。</p><p>4) 然后使用：passwd root 修改root的密码。<br><img src="/images/QQ截图20181126110507.png"></p><p>5) 修改root密码成功后，退出我们的单用户模式，输入：<code>exec /sbin/init</code> 回车<br><img src="/images/QQ截图20181126110721.png"></p><p>6）输入我们的修改后的root密码<br><img src="/images/QQ截图20181126111121.png"><br><img src="/images/QQ截图20181126111301.png"></p><p>此时，你会发现，你刚刚修改的root密码居然不好使了，其他用户的密码也不好使了，因为上述的操作是在救援模式下的操作，实际上还是改变不了我们实际的linux系统的。</p><h4 id="正确操作"><a href="#正确操作" class="headerlink" title="正确操作"></a>正确操作</h4><p>1）按e进行选择，选择编辑选项启动<br><img src="/images/QQ截图20181126105206.png"></p><p>2）找到linux16开头的那行：修改 ro 为： rw init=/sysroot/bin/sh<br><img src="/images/QQ截图20181126112147.png"></p><p>3) Ctrl + x 执行<br><img src="/images/QQ截图20181126113403.png"></p><p>进入系统后，其实只是进入了一个安全模式下的内存系统，并不是真正的咱们正常使用的linux系统。</p><p><code>ls /sysroot/</code> 下才是我们正常的linux系统里面的文件。<br><img src="/images/QQ截图20181126113642.png"></p><p><strong>4）使用命令 chroot /sysroot 切换到正常系统中</strong><br><img src="/images/QQ截图20181126113933.png"></p><p>5）使用 passwd root 修改root的密码<br><img src="/images/QQ截图20181126114105.png"></p><p><strong>6）修改密码成功后，一定要使用 touch /.autorelabel 指令</strong></p><p>如果不使用的话，会导致系统无法正常登陆！！！<br><img src="/images/QQ截图20181126114406.png"></p><p>7）退出救援模式，ctrl + d</p><p>输入ctrl + d 后，屏幕上会出现：logout<br><img src="/images/QQ截图20181126114848.png"></p><p>8）重启系统，在屏幕上输入：reboot</p><p>输入新修改的root密码，就能进入linux系统了。</p><p><strong>简单说明一下：</strong></p><p>上面的修改的ro，ro=readonly权限，只要读的权限，所以修改成rw，读和写的功能。</p><p>touch /.autorelabel 这句是为了selinux生效。</p><h4 id="这样进入linux的单用户模式修改密码安全吗？"><a href="#这样进入linux的单用户模式修改密码安全吗？" class="headerlink" title="这样进入linux的单用户模式修改密码安全吗？"></a>这样进入linux的单用户模式修改密码安全吗？</h4><p>大家都说，linux系统的安全意识最强，但是这样就轻易的修改root的密码，安全意识强吗？这样的前提是你能够进入你们公司的服务器机房，然后打开linux系统，在linux系统机器上面直接操作才行，不然你的远程登录linux是进入不了刚刚的画面的，你都能进入服务器机房了，你的权限已经很大了，所有linux开发者认为你有权这样修改root密码。</p><hr><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><h3 id="man获得帮助信息"><a href="#man获得帮助信息" class="headerlink" title="man获得帮助信息"></a>man获得帮助信息</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>man [命令或配置文件]（功能描述：获得帮助信息）</code></pre><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例：查看ls命令的帮助信息<br><img src="/images/QQ截图20181126175357.png"></p><p><img src="/images/QQ截图20181126175501.png"></p><p>使用回车：Enter，看到更多的内容。</p><p><img src="/images/QQ截图20181126175700.png"></p><p>输入q退出查看。</p><h3 id="help指令"><a href="#help指令" class="headerlink" title="help指令"></a>help指令</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>help  命令 （功能描述：获得shell内置命令的帮助信息）</code></pre><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例：查看cd命令的帮助信息</p><p><img src="/images/QQ截图20181126180007.png"></p><h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><h3 id="pwd-指令"><a href="#pwd-指令" class="headerlink" title="pwd 指令"></a>pwd 指令</h3><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>pwd (功能描述：显示当前工作目录的绝对路径)</code></pre><h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例：显示当前工作目录的绝对路径</p><p><img src="/images/QQ截图20181126183105.png"></p><h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h3><h4 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code> ls  [选项]  [目录或是文件]常用选项-a  ：显示当前目录所有的文件和目录，包括隐藏的 (文件名以.开头就是隐藏)。-l  ：以列表的方式显示信息-h  : 显示文件大小时，以 k , m,  G单位显示</code></pre><h4 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h4><p><img src="/images/QQ截图20181126183222.png"></p><h3 id="cd-指令"><a href="#cd-指令" class="headerlink" title="cd 指令"></a>cd 指令</h3><h4 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>cd  [参数] (功能描述：切换到指定目录)常用参数绝对路径【从 / 开始定位】和 相对路径【从当前的位置开始定位】 cd ~   或者 cd     回到自己的家目录cd ..  或者 cd ../ 回到当前目录的上一级目录</code></pre><h4 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h4><p>理解绝对路径和相对路径</p><p><img src="/images/QQ截图20181126184038.png"></p><p>案例1：使用绝对路径切换到root目录　　[cd /root]<br>案例2：使用相对路径到/root 目录　　　　[cd ../root]<br>案例3：表示回到当前目录的上一级目录 　[ cd ..]<br>案例4：回到家目录  　[ cd ~ ]</p><h3 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h3><p><strong>说明</strong></p><p>mkdir指令用于创建目录</p><h4 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>mkdir  [选项]  要创建的目录常用选项-p ：创建多级目录</code></pre><h4 id="应用实例-5"><a href="#应用实例-5" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 创建一个目录 /home/dog</p><p><code>mkdir  /home/dog</code><br><img src="/images/QQ截图20181126185934.png"></p><p>案例2: 创建多级目录 /home/animal/tiger</p><p><code>mkdir  -p  /home/animal/tiger</code></p><p>注意这里的animal目录是不存在的！！！<br><img src="/images/QQ截图20181126190302.png"></p><h3 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h3><p>说明</p><p>rmdir指令删除<strong>空目录</strong></p><h4 id="基本语法-6"><a href="#基本语法-6" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>rmdir  [选项]  要删除的空目录</code></pre><h4 id="应用实例-6"><a href="#应用实例-6" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 删除一个空目录 /home/dog</p><p><code>rmdir  /home/dog</code> [要求 /home/dog 是空目录]<br><img src="/images/QQ截图20181126191051.png"></p><p>案例2: 删除一个不是空的目录 /home/animal</p><p>animal里面还有一个tiger目录。</p><p>rmdir：只能删除空目录，不能删除非空目录；只能使用rm指令来删除非空目录。</p><p><code>rm -rf /home/animal</code><br><img src="/images/QQ截图20181126191512.png"></p><h3 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h3><p>说明</p><p>touch指令创建空文件， 还可以更新文件的访问和修改时间。</p><h4 id="基本语法-7"><a href="#基本语法-7" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>touch [选项] 文件名称常用选项-a 改变文件的访问时间为当前时间-m 改变文件的修改时间为当前时间-c 如果文件不存在，不创建也不提示-d或者-t 使用指定的日期或时间无 创建一个不存在的文件</code></pre><h4 id="应用实例-7"><a href="#应用实例-7" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 创建一个空文件 hello.txt</p><p><img src="/images/QQ截图20181126192008.png"></p><p>案例2: 修改一个已存在的文件的时间修改时间<br><img src="/images/QQ截图20181126193143.png"></p><h3 id="cp指令-重要"><a href="#cp指令-重要" class="headerlink" title="cp指令[重要]"></a>cp指令[重要]</h3><p>说明</p><p>cp 指令：拷贝文件到指定目录</p><h4 id="基本语法-8"><a href="#基本语法-8" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>cp [选项] source【源文件】 dest【目的文件】常用选项-r ：递归复制整个文件夹-a ：在复制目录时使用，它保留所有的信息。包括文件链接、文件属性、并递归地复制目录-d ：复制时保留链接，这样不会失去链接文件-i ：如果已经存在相同文件名的目标文件，则提示用户是否覆盖</code></pre><h4 id="应用实例-8"><a href="#应用实例-8" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 将 /home/aaa.txt 拷贝到  /home/bbb 目录下：<br><img src="/images/QQ截图20181126195012.png"></p><p>案例2：将 /home/text文件，拷贝到 /home/zsf中：</p><p>text文件：里面还有三个文件，a.txt , b.txt , c.txt.<br><img src="/images/QQ截图20181126200111.png"></p><p><strong>注意细节：当你复制到的目的文件夹中有复制过来的文件时，会提示你是否覆盖，很烦，使用\cp强制复制。</strong><br><img src="/images/QQ截图20181126200206.png"></p><h3 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h3><p>说明</p><p>rm 指令：移除文件或目录</p><h4 id="基本语法-9"><a href="#基本语法-9" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>rm  [选项]  要删除的文件或目录常用选项-r ：递归删除整个文件夹-f ：强制删除不提示-i : 交互式删除，即在删除之前进行确认</code></pre><h4 id="应用实例-9"><a href="#应用实例-9" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 将 /home/aaa.txt 删除</p><p><code>rm  /home/aaa.txt</code></p><p><img src="/images/QQ截图20181126201427.png"></p><p>案例2: 递归删除整个文件夹 /home/bbb</p><p><code>rm –r  /home/bbb</code><br><img src="/images/QQ截图20181126201742.png"></p><p><strong>使用细节</strong></p><p>强制删除不提示的方法：带上 -f 参数即可 <code>rm –rf  /home/bbb</code></p><h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h3><p>说明</p><p>mv ：移动文件到目录 或 重命名文件或目录。</p><h4 id="基本语法-10"><a href="#基本语法-10" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>mv  oldNameFile newNameFile     (功能描述：重命名)mv /temp/movefile /targetFolder (功能描述：移动文件或目录)常用选项-i：交互式操作，在对已经存在的文件或目录覆盖时，系统会发出询问。-f：禁止交互，强制覆盖。</code></pre><h4 id="应用实例-10"><a href="#应用实例-10" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 将 /home/aaa.txt 文件 重新命名为 bbb.txt<br><img src="/images/QQ截图20181126203428.png"></p><p>案例2: 将 /home/text目录 重新命名为 big目录<br><img src="/images/QQ截图20181126203513.png"></p><p>案例3: 将 /home/bbb.txt文件 移动到 big目录中：<br><img src="/images/QQ截图20181126203846.png"></p><p>思考，能不能将一个目录移动到另一个目录中呢？（可以）<br><img src="/images/QQ截图20181126204015.png"></p><h3 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h3><p>说明</p><p>cat 查看文件内容（只读），同时也可以合并文件。</p><h4 id="基本语法-11"><a href="#基本语法-11" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>cat  [选项] 要查看的文件     //查看文件的内容cat  文件1  文件2  &gt; 文件3   //将文件1和文件2的内容合并后，存储到文件3中。常用选项-n ：显示行号</code></pre><h4 id="应用实例-11"><a href="#应用实例-11" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1:  查看 /ect/profile  文件内容，并显示行号。</p><p><code>cat /etc/profile</code></p><p>直接查看完毕，跳转到文件的底部。<br><img src="/images/QQ截图20181126205206.png"></p><p><code>cat -n /etc/profile</code> ：显示行号。</p><p>所以，一般配合more指令来分页显示。</p><p><code>cat -n /etc/profile | more</code><br><img src="/images/QQ截图20181126205442.png"></p><p>敲击：空格键来翻页。</p><p>案例2:  将a.txt文件和b.txt文件合并，放到f.txt文件中（a和b文件存在，f不存在）</p><p>a.txt文件中的内容：aaaaa<br>b.txt文件中的内容：bbb</p><p><code>cat a.txt b.txt &gt; f.txt</code> ：自动帮我们创建f.txt文件，并把a和b内容合并到f文件中<br><img src="/images/QQ截图20181126209028.png"></p><p>案例3:  将a.txt文件和b.txt文件合并，放到c.txt文件中</p><p>a、b、c文件都存在，而且里面都有数据。<br>a.txt文件中的内容：aaaaa<br>b.txt文件中的内容：bbb<br>c.txt文件中的内容：ccc</p><p><code>cat a.txt b.txt &gt; c.txt</code> ：c文件中的内容会被覆盖<br><img src="/images/QQ截图20181126210504.png"></p><p><code>cat a.txt b.txt &gt;&gt; c.txt</code> : c文件中的内容不会被覆盖<br><img src="/images/QQ截图20181126210728.png"></p><h3 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h3><p>说明</p><p>more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。</p><h4 id="基本语法-12"><a href="#基本语法-12" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>more 要查看的文件</code></pre><h4 id="应用实例-12"><a href="#应用实例-12" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例: 采用more查看文件 /etc/profile</p><p><code>more /etc/profile</code></p><h4 id="快捷键说明"><a href="#快捷键说明" class="headerlink" title="快捷键说明"></a>快捷键说明</h4><p><img src="/images/QQ截图20181126211914.png"></p><h3 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h3><p>说明</p><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，<strong>对于显示大型文件具有较高的效率</strong>。</p><h4 id="基本语法-13"><a href="#基本语法-13" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>less 要查看的文件</code></pre><h4 id="应用实例-13"><a href="#应用实例-13" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例: 采用less查看一个大文件文件(体验一下速度)</p><h4 id="快捷键说明-1"><a href="#快捷键说明-1" class="headerlink" title="快捷键说明"></a>快捷键说明</h4><p><img src="/images/QQ截图20181126212212.png"></p><h3 id="gt-指令-和-gt-gt-指令"><a href="#gt-指令-和-gt-gt-指令" class="headerlink" title="&gt; 指令 和 &gt;&gt; 指令"></a>&gt; 指令 和 &gt;&gt; 指令</h3><p>说明</p><p><code>&gt; 输出重定向 和 &gt;&gt; 追加</code></p><pre><code>&gt;  输出重定向：就是覆盖的意思&gt;&gt; 追加：在文件末尾追加内容</code></pre><h4 id="基本语法-14"><a href="#基本语法-14" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>1) ls -l &gt;文件       （功能描述：列表的内容写入文件a.txt中（覆盖写））2) ls -al &gt;&gt;文件     （功能描述：列表的内容追加到文件aa.txt的末尾）3) cat 文件1 &gt; 文件2 （功能描述：将文件1的内容覆盖到文件2）4) echo &quot;内容&quot;&gt;&gt; 文件</code></pre><h4 id="应用实例-14"><a href="#应用实例-14" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 将 /home 目录下的文件列表 写入到 /home/info.txt 中</p><p><code>ls –l  /home/   &gt;  /home/info.txt  [如果info.txt文件不存在，则会自动创建]</code><br><img src="/images/QQ截图20181126213707.png"></p><p>案例2: 将当前日历信息 追加到  /home/mycal 文件中 </p><p><code>date  &gt;&gt; /home/mycal</code><br><img src="/images/QQ截图20181126213830.png"></p><h3 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h3><p>说明</p><p>echo输出内容到控制台。</p><p>是一种最常用的与广泛使用的内置于Linux的bash和C shell的命令，通常用在脚本语言和批处理文件中来在标准输出或者文件中显示一行文本或者字符串。</p><h4 id="基本语法-15"><a href="#基本语法-15" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>echo  [选项]  [输出内容]1. 输入一行文本并显示在标准输出上# echo Tecmint is a community of Linux Nerds Tecmint is a community of Linux Nerds 2. 输出一个声明的变量值比如，声明变量x并给它赋值为10。# x=10# echo The value of variable x = $x The value of variable x = 103. 使用&#39;\b&#39;选项&#39;-e &#39; 后带上 &#39;\b&#39; 会删除字符间的所有空格。注意： Linux中的选项 &#39;-e&#39; 扮演了转义字符反斜线的翻译器。# echo -e &quot;Tecmint \bis \ba \bcommunity \bof \bLinux \bNerds&quot; TecmintisacommunityofLinuxNerds4. 使用&#39;\n&#39;选项&#39;-e&#39;后面的带上&#39;\n&#39;行会在遇到的地方作为新的一行# echo -e &quot;Tecmint \nis \na \ncommunity \nof \nLinux \nNerds&quot;Tecmint is a community of Linux Nerds 5. 使用&#39;\t&#39;选项&#39;-e&#39;后面跟上&#39;\t&#39;会在空格间加上水平制表符。# echo -e &quot;Tecmint \tis \ta \tcommunity \tof \tLinux \tNerds&quot; Tecmint     is  a   community   of  Linux   Nerds6. &#39;-n&#39;会在echo完后不会输出新行# echo -n &quot;Tecmint is a community of Linux Nerds&quot; Tecmint is a community of Linux Nerds[root@liuzhuo01 home]# </code></pre><p><img src="/images/QQ截图20181127120437.png"></p><h4 id="echo-选项列表"><a href="#echo-选项列表" class="headerlink" title="echo 选项列表"></a>echo 选项列表</h4><p><img src="/images/QQ截图20181126221404.png"></p><h4 id="应用实例-15"><a href="#应用实例-15" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例: 使用 echo 指令输出环境变量</p><p><code>echo $PATH</code><br><img src="/images/QQ截图20181127122013.png"></p><h3 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h3><p>说明</p><p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容。</p><h4 id="基本语法-16"><a href="#基本语法-16" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>head  文件          (功能描述：查看文件头10行内容)head -n 5 文件      (功能描述：查看文件头5行内容，5可以是任意行数)</code></pre><h4 id="应用实例-16"><a href="#应用实例-16" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例: 查看 /etc/profile 的前面5行代码<br><img src="/images/QQ截图20181127123821.png"></p><h3 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h3><p>说明</p><p>tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。</p><h4 id="基本语法-17"><a href="#基本语法-17" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>1) tail  文件         (功能描述：查看文件尾10行内容）2) tail  -n 5 文件   （功能描述：查看文件尾5行内容，5可以是任意行数）3) tail  -f  文件    （功能描述：实时追踪该文档的所有更新） 重要！！！</code></pre><h4 id="应用实例-17"><a href="#应用实例-17" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 查看 /etc/profile 最后5行的代码<br><img src="/images/QQ截图20181127124007.png"></p><p>案例2: 实时监控date.log , 看看文件有变化时，能否看到变化的内容(实时的追加日期)。<br><img src="/images/QQ截图20181127125020.png"></p><h3 id="ln-指令-link"><a href="#ln-指令-link" class="headerlink" title="ln 指令 (link)"></a>ln 指令 (link)</h3><p>说明</p><p>Linux下的链接有两种，一种是硬链接（Hard Link），另一种是软链接（Sysmbolie Link），默认情况下 ln 命令产生的是硬链接。</p><p>硬链接：是指通过文件的inode来进行链接。在Linux的文件系统中，保存在磁盘的所有类型的文件都会分配一个编号，这个编号称为inode号。硬链接的作用是允许一个文件拥有多个有效的路径名，这样用户就可以对一些重要文件建立多个硬链接，以防止误删除操作。只有最后一个硬链接删除，文件才会真正的删除。</p><p>软链接也成为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径。</p><h4 id="基本语法-18"><a href="#基本语法-18" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>ln [选项] [原文件或目录] [链接名] （功能描述：给原文件创建一个链接）常用选项-f：如果在目标位置存在与链接名相同的文件，会删除这个同名的文件-s: 进行软链接不带：硬链接</code></pre><h4 id="应用实例-18"><a href="#应用实例-18" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 在/home 目录下创建一个软链接 linkToRoot，连接到 /root 目录<br><img src="/images/QQ截图20181127130927.png"></p><p>案例2: 删除软连接 linkToRoot<br><img src="/images/QQ截图20181127131232.png"></p><p>案例3: 给date.log创建硬链接info.txt , 但是info.txt文件已经存在了。<br><img src="/images/QQ截图20181127131547.png"><br><img src="/images/QQ截图20181127131622.png"></p><p><strong>细节说明：</strong></p><p>当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录。</p><h3 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h3><p>说明</p><p>查看已经执行过历史命令,也可以执行历史指令。</p><h4 id="基本语法-19"><a href="#基本语法-19" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>history    （功能描述：查看已经执行过历史命令)</code></pre><h4 id="应用实例-19"><a href="#应用实例-19" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 显示所有的历史命令<br><img src="/images/QQ截图20181127132716.png"></p><p>案例2: 显示最近使用过的10个指令。<br><img src="/images/QQ截图20181127132820.png"></p><p>案例3: <strong>执行</strong>历史编号为474的指令  (!474)<br><img src="/images/QQ截图20181127133041.png"></p><h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><h3 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h3><p>说明</p><p>显示当前的日期</p><h4 id="基本语法-20"><a href="#基本语法-20" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>1) date       (功能描述：显示当前时间）2) date +%Y   (功能描述：显示当前年份）3) date +%m   (功能描述：显示当前月份）4) date +%d   (功能描述：显示当前是哪一天）5) date &quot;+%Y-%m-%d %H:%M:%S&quot;      (功能描述：显示年月日时分秒）6) date -s &quot;2018-11-27 11:11:11&quot;  (功能描述：设置年月日时分秒）注意：这里的+是不能掉的，而且：Y m d H M S 年月日时分秒也是固定的写法，除了中间的分隔符可以随意写。</code></pre><h4 id="应用实例-20"><a href="#应用实例-20" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 显示当前时间信息<br><img src="/images/QQ截图20181127134447.png"><br>案例2: 显示当前时间年月日<br><img src="/images/QQ截图20181127134736.png"><br>案例3: 显示当前时间年月日时分秒<br><img src="/images/QQ截图20181127134806.png"></p><p>案例4: 设置系统当前时间 ，比如设置成 2020-11-11 11:22:22<br><img src="/images/QQ截图20181127135115.png"></p><h3 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h3><p>说明</p><p>查看日历指令</p><h4 id="基本语法-21"><a href="#基本语法-21" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>cal  [选项]   (功能描述：不加选项，显示本月日历）</code></pre><h4 id="应用实例-21"><a href="#应用实例-21" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 显示当前日历<br><img src="/images/QQ截图20181127135545.png"></p><p>案例2: 显示2020年日历<br><img src="/images/QQ截图20181127135844.png"></p><h2 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类(!!)"></a>搜索查找类(!!)</h2><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h3><p>说明</p><p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p><h4 id="基本语法-22"><a href="#基本语法-22" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>find  [搜索范围]  [选项]  </code></pre><h4 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h4><p><img src="/images/QQ截图20181127140046.png"></p><h4 id="应用实例-22"><a href="#应用实例-22" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 按文件名：根据名称查找 /home 目录下的 hello.txt文件</p><p><code>find  /home  -name  hello.txt</code><br><img src="/images/QQ截图20181127141106.png"></p><p>案例2：按拥有者：查找/opt目录下，用户名称为 liuzhuo的文件</p><p><code>find  /opt  -user  liuzhuo</code><br><img src="/images/QQ截图20181127141250.png"></p><p>案例3：查找整个linux系统下大于20M的文件（+n 大于  -n小于   n等于）</p><p><code>find  /  -size  +20M</code> : 兆：M ，kb：k<br><img src="/images/QQ截图20181127141538.png"></p><h3 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h3><p>说明</p><p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的<strong>locate数据库</strong>实现快速定位给定的文件。Locate指令无需遍历整个文件系统，<strong>查询速度较快</strong>。为了保证查询结果的准确度，管理员必须<strong>定期更新locate时刻</strong>。</p><h4 id="基本语法-23"><a href="#基本语法-23" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>locate  搜索文件</code></pre><h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><p>由于locate指令基于数据库进行查询，所以第一次运行前，必须使用<strong>updatedb指令创建locate数据库</strong>。</p><h4 id="应用实例-23"><a href="#应用实例-23" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 请使用locate 指令快速定位 hello.txt 文件所在目录</p><p>updatedb // 创建locate的数据库<br>locate  hello.txt<br><img src="/images/QQ截图20181127141603.png"></p><h3 id="grep指令和-管道符号"><a href="#grep指令和-管道符号" class="headerlink" title="grep指令和 管道符号 |"></a>grep指令和 管道符号 |</h3><p>说明</p><p>grep 过滤查找 ； 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</p><h4 id="基本语法-24"><a href="#基本语法-24" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>grep  [选项]  查找内容  源文件常用选项-n：显示匹配行以及行号-i：忽略字母大小写</code></pre><h4 id="应用实例-24"><a href="#应用实例-24" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 请在 /etc/profile 文件中，查找  “if”  所在行，并且显示行号</p><p>grep –n   if  /etc/profile  [在/etc/profile 中查找 if ,并显示行，区别大小写]<br>grep –ni   if  /etc/profile  [在/etc/profile 中查找 if ,并显示行，不区别大小写]<br><img src="/images/QQ截图20181127143642.png"></p><p>案例2: 请在 /home/hello.txt 文件中，查找  “yes”  所在行，并且显示行号<br><img src="/images/QQ截图20181127143926.png"></p><h2 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h2><h3 id="gzip与gunzip"><a href="#gzip与gunzip" class="headerlink" title="gzip与gunzip"></a>gzip与gunzip</h3><p>说明</p><p>gzip 用于压缩文件， gunzip 用于解压的。</p><p><strong>gzip：只能对文件进行压缩，不能压缩目录，即使指定压缩的目录，也只能压缩目录内的所有文件。</strong></p><h4 id="基本语法-25"><a href="#基本语法-25" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>gzip [选项] 文件名 （功能描述：压缩文件，只能将文件压缩为*.gz文件）常用选项-r：递归压缩目录下的文件-d：将压缩文件进行解压   等价于：gunzip 压缩的文件名gunzip 压缩的文件名 （功能描述：解压缩文件命令）</code></pre><h4 id="应用实例-25"><a href="#应用实例-25" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: gzip压缩， 将 /home下的 hello.txt文件进行压缩。<br><img src="/images/QQ截图20181127145146.png"></p><p>案例2: gunzip解压缩， 将 /home下的 hello.txt.gz 文件进行解压缩。<br><img src="/images/QQ截图20181127145225.png"></p><p>案例3: gzip压缩， 将 /home下的 big 目录进行压缩。（原则上不能进行压缩目录）<br><img src="/images/QQ截图20181127145707.png"></p><p>案例4: gunzip解压缩， 将 /home下的 big 目录进行解压缩。（原则上不能进行解压缩目录）<br><img src="/images/QQ截图20181127150135.png"></p><h3 id="zip-unzip-指令"><a href="#zip-unzip-指令" class="headerlink" title="zip/unzip 指令"></a>zip/unzip 指令</h3><p>说明</p><p>zip 用于压缩文件， unzip 用于解压的，<strong>这个在项目打包发布中很有用的。</strong></p><p>将一般的文件或目录进行压缩或者解压，默认生成以 “.zip”为后缀的压缩包。</p><h4 id="基本语法-26"><a href="#基本语法-26" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>zip     [选项]   XXX.zip   需要压缩的内容（功能描述：压缩文件和目录的命令）unzip   [选项]   XXX.zip      (功能描述：解压缩文件）</code></pre><h4 id="zip的选项"><a href="#zip的选项" class="headerlink" title="zip的选项"></a>zip的选项</h4><pre><code>-r：递归压缩目录-m：将文件加入到压缩文件中后，删除原始文件</code></pre><h4 id="unzip的选项"><a href="#unzip的选项" class="headerlink" title="unzip的选项"></a>unzip的选项</h4><pre><code>-d 目录名: 将解压的文件放到指定的目录中-n：解压时不覆盖已经存在的文件-o：解压时覆盖已经存在的文件，并且不要求用户确认</code></pre><h4 id="应用实例-26"><a href="#应用实例-26" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1:  将 /home/big下的 所有文件进行压缩成 mybig.zip</p><p><code>zip  -r  mybig.zip  /home/big</code><br><img src="/images/QQ截图20181127151643.png"><br><img src="/images/QQ截图20181127151916.png"></p><p>案例2:  将 mybig.zip 解压到 /opt/tmp 目录下 [如果/opt/tmp 不存在，会自动创建]</p><p><img src="/images/QQ截图20181127152316.png"></p><h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h3><p>说明</p><p>tar是linux系统下经常使用的归档工具，对文件或目录进行打包归档，归档成一个文件，但是并不是进行压缩。</p><p>最后打包后的文件是 .tar.gz 的文件。 [可以压缩，和解压]</p><h4 id="基本语法-27"><a href="#基本语法-27" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>tar  [选项]  XXX.tar.gz  要打包的内容/目录   (功能描述：打包目录，压缩后的文件格式.tar.gz)常用选项-c：产生.tar打包文件-v：显示详细信息-f：指定压缩后的文件名，一定是最后的选项-z：打包同时压缩-x：解包.tar文件常用的组合-zcvf：打包压缩-zxvf：解压缩</code></pre><h4 id="应用实例-27"><a href="#应用实例-27" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1:  压缩多个文件，将 /home/a1.txt 和 /home/a2.txt 压缩成  a.tar.gz。    【-zcvf】：打包压缩  【-zxvf】：解压<br><img src="/images/QQ截图20181127153502.png"></p><p>案例2:  将/home 的文件夹 压缩成 myhome.tar.gz<br><img src="/images/QQ截图20181127154733.png"><br><img src="/images/QQ截图20181127154801.png"><br>案例3:   将 a.tar.gz  解压到当前目录<br><img src="/images/QQ截图20181127154950.png"><br>案例4: 将myhome.tar.gz  解压到 /opt/tmp目录下 【-C】<br><img src="/images/QQ截图20181127155204.png"><br><img src="/images/QQ截图20181127155235.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之用户</title>
      <link href="/2018/11/25/linux-ji-chu-ru-men-zhi-shi-cao/"/>
      <url>/2018/11/25/linux-ji-chu-ru-men-zhi-shi-cao/</url>
      
        <content type="html"><![CDATA[<p>本篇文章，将会讲解Linux的用户管理、实用指令等。<br><a id="more"></a></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p><img src="/images/QQ截图20181125135424.png"></p><p>注意：Linux用户需要至少属于一个组。</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>useradd [选项] 用户名useradd  用户名  //默认会在/home下创建同名的家目录useradd -d 新的家目录的路径 用户名  //会在指定的路径下创建家目录，不要提前创建文件夹</code></pre><h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p>打开，我们的Xshell远程登录我们的centOS系统。<br><img src="/images/QQ截图20181125141201.png"></p><p>现在:<br><img src="/images/QQ截图20181125141406.png"><br><img src="/images/QQ截图20181125141558.png"><br><img src="/images/QQ截图20181125141727.png"></p><p><strong>使用细节</strong></p><p>1) 当创建用户成功后，会自动的创建和用户同名的家目录 【/home/用户名】</p><p>2) 也可以通过 useradd -d   指定目录   新的用户名jack 【给新创建的用户指定新的家目录】</p><p>现在创建一个新的用户jack，并把它的家目录放到 /home/rose下，默认是放在/home/jack文件夹中。<br><img src="/images/QQ截图20181125142852.png"><br>验证jack用户是否创建成功，开启一个新的连接：<br><img src="/images/QQ截图20181125143053.png"></p><p><img src="/images/QQ截图20181125143109.png"></p><p><img src="/images/QQ截图20181125143433.png"></p><p><strong>此时/home/rose，就是jack的家目录了。</strong></p><h3 id="指定-修改密码"><a href="#指定-修改密码" class="headerlink" title="指定/修改密码"></a>指定/修改密码</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>passwd 用户名         //如果没有带用户名，则是给当前登录的用户修改密码</code></pre><h4 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h4><p><img src="/images/QQ截图20181125143821.png"></p><p>将xm用户的密码设置为：xm<br><img src="/images/QQ截图20181125144013.png"></p><p>创建一个新的连接，或者直接使用虚拟机登入系统，输入用户：xm，密码：xm，即可登入成功；这里就不演示了。</p><p><strong>注意：添加、设置密码、删除用户，都必须是下root用户下才行！！！</strong></p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>userdel   用户名   //不会删除家目录userdel -r 用户名  //会删除家目录</code></pre><h4 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a>案例演示</h4><p>1）删除xm用户，但不删除他的家目录【/home/xm】<br><img src="/images/QQ截图20181125144853.png"></p><p>2）删除jack用户，并且删除他的家目录</p><p>注意这里：我们创建jack用户的时候，将他的家目录修改成了/home/rose，所以删除他的家目录，就是删除/home/rose.<br><img src="/images/QQ截图20181125145649.png"></p><p><strong>使用细节</strong></p><p>在实际开发中，一般员工离职后，直接删除用户即可，不要删除他的家目录，因为里面会有他写的代码，资源很珍贵的！！！</p><h3 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h3><h4 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>id 用户名</code></pre><h4 id="案例演示-3"><a href="#案例演示-3" class="headerlink" title="案例演示"></a>案例演示</h4><p>查看root用户的信息<br><img src="/images/QQ截图20181125150310.png"></p><p>查看不存在的用户<br><img src="/images/QQ截图20181125150459.png"></p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>介绍</p><p>在操作linux系统时，如果当前用户没有权限的时候，可以通过 su - 指令 ，来切换到高权利的用户，比如：root用户。</p><h4 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>su - 要切换的用户名</code></pre><h4 id="案例演示-4"><a href="#案例演示-4" class="headerlink" title="案例演示"></a>案例演示</h4><p>创建一个zs用户，指定密码，然后切换到root用户。<br><img src="/images/QQ截图20181125151061.png"></p><p><strong>注意细节：</strong></p><p>1）普通用户前面是：$ , 超级用户前面是：# 。</p><p>2）su root 切换root用户时，如果没有带 - 的话，只是会切换到root用户，但是不会加载root用户的环境变量，这样会导致一个命令会 not found。</p><p>3）从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。</p><p>4）当需要返回到原来用户时，使用exit指令。</p><p>5）如果 su – 没有带用户名，则默认切换到root用户</p><h3 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h3><h4 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>whoami/ who am I</code></pre><h4 id="案例演示-5"><a href="#案例演示-5" class="headerlink" title="案例演示"></a>案例演示</h4><p><img src="/images/QQ截图20181125152055.png"></p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>类似于角色，系统可以对有共性的多个用户进行统一的管理。</p><h4 id="新增组"><a href="#新增组" class="headerlink" title="新增组"></a>新增组</h4><pre><code>groupadd  组名</code></pre><h4 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h4><pre><code>groupdel 组名</code></pre><p><strong>注意：这里有一个前提，就是这个组没有用户，才能删除。</strong></p><h4 id="添加用户到指定的组"><a href="#添加用户到指定的组" class="headerlink" title="添加用户到指定的组"></a>添加用户到指定的组</h4><pre><code>useradd -g 组名 用户名</code></pre><p><img src="/images/QQ截图20181125154110.png"></p><h4 id="修改用户的到其他组"><a href="#修改用户的到其他组" class="headerlink" title="修改用户的到其他组"></a>修改用户的到其他组</h4><pre><code>usermod -g 新的组名 用户名</code></pre><p><img src="/images/QQ截图20181125154256.png"></p><h3 id="用户和组的相关文件"><a href="#用户和组的相关文件" class="headerlink" title="用户和组的相关文件"></a>用户和组的相关文件</h3><h4 id="etc-passwd-文件"><a href="#etc-passwd-文件" class="headerlink" title="/etc/passwd 文件"></a>/etc/passwd 文件</h4><p>用户（user）的配置文件，记录用户的各种信息。</p><p>每行的含义：用户名 : 口令 : 用户标识号 : 组标识号 : 注释性描述 : 主目录 : 登录Shell的工具</p><pre><code>vim /etc/passwd</code></pre><p><img src="/images/QQ截图20181125155926.png"></p><h4 id="etc-shadow-文件"><a href="#etc-shadow-文件" class="headerlink" title="/etc/shadow 文件"></a>/etc/shadow 文件</h4><p>口令的配置文件</p><p>每行的含义：登录名 : 加密口令 : 最后一次修改时间 : 最小时间间隔 : 最大时间间隔 : 警告时间 : 不活动时间 : 失效时间 : 保留</p><pre><code>vim /etc/shadow</code></pre><p><img src="/images/QQ截图20181125160306.png"></p><h4 id="etc-group-文件"><a href="#etc-group-文件" class="headerlink" title="/etc/group 文件"></a>/etc/group 文件</h4><p>组(group)的配置文件，记录Linux包含的组的信息</p><p>每行含义：组名 : 口令 : 组标识号 : 组内用户列表</p><pre><code>vim /etc/group</code></pre><p><img src="/images/QQ截图20181125160725.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之进阶</title>
      <link href="/2018/11/23/linux-ji-chu-ru-men-zhi-jin-jie/"/>
      <url>/2018/11/23/linux-ji-chu-ru-men-zhi-jin-jie/</url>
      
        <content type="html"><![CDATA[<p>Linux基础入门的目录结构、远程登入等<br><a id="more"></a></p><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><h3 id="Linux的基本介绍"><a href="#Linux的基本介绍" class="headerlink" title="Linux的基本介绍"></a>Linux的基本介绍</h3><p>linux的文件系统是采用级层式的<strong>树状目录结构</strong>，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。</p><p>深刻理解linux树状文件目录是非常重要的，这里我给大家说明一下。</p><p>记住一句经典的话：<font color="red"><strong>在Linux世界里，一切皆文件（即使是一个硬件设备，也是使用文件来标志）</strong></font></p><h3 id="linux的目录结构图"><a href="#linux的目录结构图" class="headerlink" title="linux的目录结构图"></a>linux的目录结构图</h3><p><img src="/images/QQ截图20181123210048.png"></p><p>打开我们的centOS虚拟机，点击计算机，也会出现：根目录下的目录结构：<br><img src="/images/QQ截图20181123210800.png"></p><p><strong>PS：如果你想使用VirtualBox的全屏功能，需要安装增强功能。</strong></p><p>点击设备：<br><img src="/images/QQ截图20181123211621.png"></p><p>然后点击：安装增强功能：<br><img src="/images/QQ截图20181123211805.png"></p><p>然后：输入root的密码。</p><p>安装完后，<strong>按下回车键</strong>，就安装成功了。</p><p>如果你的安装失败，是因为你的系统需要安装：gcc, kernel, kernel-devel。</p><p>于是使用yum安装：<code>yum install -y gcc kernel kernel-devel</code></p><p>桌面上面，就会出现一个VBox_GAs_xxx的光盘图标。</p><p><img src="/images/QQ截图20181123212208.png"></p><p>双击那个光盘：<br><img src="/images/QQ截图20181123213629.png"></p><p>切换成root用户，在终端下面进入那个光盘下面，然后：<code>sh VBoxLinuxAdditions.run</code></p><p><img src="/images/QQ截图20181123220916.png"></p><p>安装成功后，重启虚拟机就好了：就可以使用全屏的功能了。</p><hr><p>回到我们的Linux目录结构：</p><p>基本介绍：<br><img src="/images/QQ截图20181123214545.png"></p><h3 id="具体的目录说明"><a href="#具体的目录说明" class="headerlink" title="具体的目录说明"></a>具体的目录说明</h3><p><img src="/images/QQ截图20181123214859.png"><br><img src="/images/QQ截图20181123215006.png"><br><img src="/images/QQ截图20181123215252.png"><br><img src="/images/QQ截图20181123215959.png"><br><img src="/images/QQ截图20181123220105.png"></p><h3 id="对linux目录结构的小结"><a href="#对linux目录结构的小结" class="headerlink" title="对linux目录结构的小结"></a>对linux目录结构的小结</h3><p>1)在linux中，目录结构 有一个  根目录 / , 其他的目录都是在 / 目录分支。</p><p>2)在linux中，有很多目录，是安装后，自动生成的目录，每个目录都会存放相应的内容，不要去修改.</p><p>3)在linux中，所有的设备都可以通过文件来体现(字符设备文件[比如键盘，鼠标]，块设备文件[硬盘])</p><p>4)<strong>在学习linux时，要尽快的在脑海中，形成一个 目录树</strong></p><h2 id="Linux系统之远程登录与上传下载"><a href="#Linux系统之远程登录与上传下载" class="headerlink" title="Linux系统之远程登录与上传下载"></a>Linux系统之远程登录与上传下载</h2><p>为啥要远程登录呢？我们不能直接在我们的虚拟机上面操作吗？登录账户和密码后，就可以直接操作呀？<br><img src="/images/QQ截图20181124100504.png"></p><p>那是因为，在我们实际上班的时候，我们不是使用Windows电脑安装虚拟机来操作Linux系统的，linux服务器是在机房里面，我们每个开发人员，不可能每次要操作linux服务器就去机房，那样太麻烦，而且效率极低。所以，我们需要在自己的windows电脑上面远程登录到机房中的linux服务器。<br><img src="/images/QQ截图20181124100938.png"></p><p>常见的远程登录软件有：Xshell、SecureCRT、SmartTTY等等</p><h3 id="远程登录之Xshell"><a href="#远程登录之Xshell" class="headerlink" title="远程登录之Xshell"></a>远程登录之Xshell</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Xshell 是目前最好的远程登录到Linux操作的软件，流畅的速度并且完美解决了<strong>中文乱码</strong>的问题， 是目前程序员首选的软件。</p><p>Xshell 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及 Microsoft Windows 平台的 TELNET 协议</p><p>Xshell 可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。</p><h4 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h4><p>1）到Xshell官网上面去下载</p><p><code>http://www.netsarang.com/</code><br><img src="/images/QQ截图20181124111119.png"><br><img src="/images/QQ截图20181124111225.png"><br><img src="/images/QQ截图20181124111343.png"></p><p>2) 安装Xshell软件</p><p>傻瓜式安装即可。</p><p>安装完毕后，双击Xshell软件：<br><img src="/images/QQ截图20181124112122.png"></p><p>点击新建会话：<br><img src="/images/QQ截图20181124112212.png"></p><p>填写相关信息：<br><img src="/images/QQ截图20181124112620.png"></p><p>连接：<br><img src="/images/QQ截图20181124112738.png"></p><p><img src="/images/QQ截图20181124124930.png"></p><p>如果出现连接失败的话，看看你的linux的sshd服务是否开启：</p><p>在虚拟机中的终端中输入：setup<br>如果不是root用户，会让你先输入root的密码。<br><img src="/images/QQ截图20181124123720.png"></p><p>选择系统服务后，回车。<br><img src="/images/QQ截图20181124123855.png"></p><p>在其中找到sshd.service,看它的前面是否有 * 号，有的话，说明已经开启了，没有的话，使用<strong>空格</strong>开启。<br><img src="/images/QQ截图20181124124037.png"></p><p>然后使用：tab键进入到确定，然后回车确定即可。<br><img src="/images/QQ截图20181124124357.png"></p><p>然后使用tab键到退出。此时sshd服务就开启了。</p><p>验证sshd服务是否开启：<code>service sshd status</code></p><p>出现：active的绿色字体，说明开启成功！<br><img src="/images/QQ截图20181124124648.png"></p><p>再次使用Xshell连接我们的虚拟机：<br><img src="/images/QQ截图20181124124930.png"></p><p>发现还是连接失败，这是因为我们的宿主机的ip地址是：10.6.11.123，而我们的linux的ip地址是：10.0.2.15<br><img src="/images/QQ截图20181124125343.png"></p><p>在宿主机下，ping我们的虚拟机的linux的ip，发现超时，即：宿主机与虚拟机的linux不连通<br><img src="/images/QQ截图20181124125524.png"></p><p>所以，只要我们的宿主机与虚拟机的linux服务器能够连通的话，Xshell才能连接成功。</p><p>现在修改我们的linux的网络配置，添加网桥模式：<br><img src="/images/QQ截图20181124125734.png"></p><p>重启我们的centOS虚拟机：</p><p>发现，现在我们已经有了两个网卡：<br><img src="/images/QQ截图20181124125911.png"><br><img src="/images/QQ截图20181124130023.png"><br><img src="/images/QQ截图20181124130141.png"></p><p>现在使用我们的宿主机 ping 网桥模式下分配的ip地址，我这里就是：10.6.11.104<br><img src="/images/QQ截图20181124130405.png"></p><p>最后，修改我们的Xshell下的主机的ip地址（网桥模式下的ip地址）<br><img src="/images/QQ截图20181124130556.png"></p><p>点击确定，连接：<br><img src="/images/QQ截图20181124130641.png"></p><p>然后，会让你输入连接的用户名和密码：<br><img src="/images/QQ截图20181124130728.png"><br><img src="/images/QQ截图20181124130819.png"></p><p><strong>PS：如果以上还是不能成功，请你关闭防火墙</strong></p><p>systemctl disable 服务名 service    永久关闭防火墙<br>systemctl status firewalld.service    查看防火墙<br>systemctl stop firewalld.service    关闭防火墙<br>systemctl start firewalld service    打开防火墙</p><hr><p>验证我们的远程登录是否有效，在Xshell界面中，进入Desktop，然后创建一个hello文件：<br><img src="/images/QQ截图20181124140900.png"></p><p>然后在我们的root用户的桌面下，就会出现一个hello的文件：<br><img src="/images/QQ截图20181124140951.png"></p><h3 id="远程上传下载之Xftp"><a href="#远程上传下载之Xftp" class="headerlink" title="远程上传下载之Xftp"></a>远程上传下载之Xftp</h3><h4 id="Xftp的简单介绍"><a href="#Xftp的简单介绍" class="headerlink" title="Xftp的简单介绍"></a>Xftp的简单介绍</h4><p>是一个基于 windows 平台的功能强大的 SFTP、FTP 文件传输软件。使用了 Xftp 以后，windows 用户能安全地在 UNIX/Linux 和 Windows PC 之间传输文件。</p><h4 id="Xftp的安装配置"><a href="#Xftp的安装配置" class="headerlink" title="Xftp的安装配置"></a>Xftp的安装配置</h4><p>到官网上面下载：<code>https://www.netsarang.com/products/xfp_overview.html</code><br><img src="/images/QQ截图20181124151724.png"></p><p>和Xshell的安装类似，我就不演示了。</p><p>下载完成后：打开Xftp软件：<br><img src="/images/QQ截图20181124153248.png"></p><p>新建我们的会话：<br><img src="/images/QQ截图20181124153555.png"></p><p>连接：<br><img src="/images/QQ截图20181124153720.png"></p><p>输入root的密码：<br><img src="/images/QQ截图20181124153803.png"></p><p>成功后的效果图：（左边windows的桌面，右边linux系统的用户根目录）<br><img src="/images/QQ截图20181124153946.png"></p><p>如果你的右边的linux系统出现中文乱码的话：点击绿色的小齿轮<br><img src="/images/QQ截图20181124154117.png"></p><p>然后，点击选项，编码选择utf-8即可：<br><img src="/images/QQ截图20181124154214.png"></p><p>在右边的linux系统中右键刷新后，就不会中文乱码了。</p><h4 id="Xftp的简单使用"><a href="#Xftp的简单使用" class="headerlink" title="Xftp的简单使用"></a>Xftp的简单使用</h4><p>1）从windows系统中，上传图片到linux系统中</p><p>在左边的windows界面下，随便找到一个图片，右键选择<strong>传输</strong>即可。<br><img src="/images/QQ截图20181124154555.png"></p><p>完成后，在右边的linux系统中，就会多出一张图片<br><img src="/images/QQ截图20181124154724.png"></p><p>打开我们的虚拟机，也能看到那张图片：<br><img src="/images/QQ截图20181124154838.png"></p><p>2）从linux系统下载文件到我们的windows系统中</p><p>一样的操作，在右边的linux系统中，随便上传一个文件即可。<br><img src="/images/QQ截图20181124155039.png"></p><p><img src="/images/QQ截图20181124155236.png"></p><p>打开我们的windows桌面：<br><img src="/images/QQ截图20181124155351.png"></p><p><strong>注意：在上传文件的时候，文件上传的目的地就是你现在的打开的目的地的目录，比如你的目的地linux打开在home目下，那么从windows系统下上传的文件就会传输到linux的home目录下</strong></p><p><strong>PS：</strong>当我们在实际工作中，如果需要部署一个项目，则应当先压缩后，再上传，上传后，使用linux的相关的解压缩命令，来解压。</p><h3 id="SecureCRT的安装和使用"><a href="#SecureCRT的安装和使用" class="headerlink" title="SecureCRT的安装和使用"></a>SecureCRT的安装和使用</h3><h4 id="基本的介绍"><a href="#基本的介绍" class="headerlink" title="基本的介绍"></a>基本的介绍</h4><p>是用于远程登录Linux的软件。SecureCRT 也是一款常用的远程登录Linux的软件，在<strong>大数据开发</strong>中使用较多。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>下载绿色安装板即可，直接拷贝整个目录就可以用了。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>打开SecureCRT的运行文件<br><img src="/images/QQ截图20181124161136.png"></p><p>新建连接：<br><img src="/images/QQ截图20181124161258.png"></p><p>新建会话：<br><img src="/images/QQ截图20181124161419.png"><br><img src="/images/QQ截图20181124161604.png"><br><img src="/images/QQ截图20181124161645.png"></p><p>连接：<br><img src="/images/QQ截图20181124161719.png"><br><img src="/images/QQ截图20181124161741.png"></p><p>输入root密码即可：<br><img src="/images/QQ截图20181124162002.png"></p><p>出现中文乱码问题：<br><img src="/images/QQ截图20181124162055.png"></p><p>解决中文乱码问题：<br><img src="/images/QQ截图20181124162224.png"></p><p>再次连接：<br><img src="/images/QQ截图20181124162521.png"></p><p>测试：</p><p>直接输入：<code>touch hello</code><br><img src="/images/QQ截图20181124162827.png"></p><p>打开我们的虚拟机：<br><img src="/images/QQ截图20181124162918.png"></p><h2 id="Vi和Vim编辑器"><a href="#Vi和Vim编辑器" class="headerlink" title="Vi和Vim编辑器"></a>Vi和Vim编辑器</h2><h3 id="vi和vim的简单介绍"><a href="#vi和vim的简单介绍" class="headerlink" title="vi和vim的简单介绍"></a>vi和vim的简单介绍</h3><p>所有的 Linux 系统都会内建 vi 文本编辑器。</p><p>Vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。我们只需要掌握它的基本使用即可。</p><h3 id="vi和vim的三种模式"><a href="#vi和vim的三种模式" class="headerlink" title="vi和vim的三种模式"></a>vi和vim的三种模式</h3><h4 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h4><p>以 vim 打开一个文件就直接进入正常模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。在正常模式下可以使用快捷键。</p><h4 id="插入模式-编辑模式"><a href="#插入模式-编辑模式" class="headerlink" title="插入模式(编辑模式)"></a>插入模式(编辑模式)</h4><p>按下<strong>i（insert）</strong>, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按<strong>i</strong>即可.</p><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！<br>（ Esc + ：进入该模式 ）</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>在linux系统下，编写一个java程序</p><p>打开Xshell软件：<br><img src="/images/QQ截图20181124164946.png"></p><p>此时，桌面上面还没有hello.java文件。</p><p>输入：<code>vim hello.java</code><br><img src="/images/QQ截图20181124165113.png"></p><p>此时，就进入了正常模式，你会发现，此时，不管你在键盘上面怎么输入，都不会输入进去。我们需要切换到编辑模式下：输入i</p><p>就会进入插入模式：<br><img src="/images/QQ截图20181124165446.png"></p><p>现在怎么保存退出呢？需要切换到命令行模式下：（ Esc + ：）</p><p>然后输入：wq（保存并退出）<br><img src="/images/QQ截图20181124165701.png"></p><p>回车后，就回到我们的终端下面，再次输入：ll<br><img src="/images/QQ截图20181124165845.png"></p><p>查看我们刚刚编写的hello.java文件：（cat hello.java）<br><img src="/images/QQ截图20181124165954.png"></p><p>说明刚刚的hello.java文件，保存成功！</p><h3 id="vi和vim模式的互相切换"><a href="#vi和vim模式的互相切换" class="headerlink" title="vi和vim模式的互相切换"></a>vi和vim模式的互相切换</h3><p><img src="/images/QQ截图20181124170148.png"></p><p>：wq 修改保存并退出</p><p>：q  你打开一个文件，然后觉得没有修改的，直接输入q退出即可</p><p>：q！你打开一个文件，然后修改了，但是觉得不想保存修改的内容，那就q！强制退出并不保存之前修改的内容</p><h3 id="vim和vi的快捷键的使用"><a href="#vim和vi的快捷键的使用" class="headerlink" title="vim和vi的快捷键的使用"></a>vim和vi的快捷键的使用</h3><p>常用的快捷键的使用：</p><p>1) 拷贝当前行（yy） , 拷贝当前行向下的5行  （5yy），并粘贴（ p ）。【快捷键在正常模式下使用】</p><p>2) 删除当前行（dd）  , 删除当前行向下的5行 （5dd）。【快捷键在正常模式下使用】</p><p>3) 在文件中查找某个单词 [命令模式下输入 <strong>/关键字</strong> ， 回车 查找 ,  正常模式下输入 n 就是查找下一个 ]</p><p>4) 设置文件的行号，取消文件的行号. [命令行下  : set nu  和  :set nonu]</p><p>5) 编辑 /etc/profile 文件，使用快捷键到底文档的 <strong>最末行[G]</strong>和 <strong>最首行[gg]</strong> 【正常模式下】</p><p>6) 在一个文件中输入 “hello” , 然后又撤销这个动作 u  【正常模式下】</p><p>先是在插入模式下，修改了文件的内容，然后觉得不想修改，那么切换到正常模式下，输入u。</p><p>7) 编辑  /etc/profile 文件，并将光标移动到  20行 shift + g</p><p>先在命令行模式下：set nu，看到行号，然后在正常模式下，输入：20 + shift + g ，就会跳转到第20行号的位置。</p><hr><p>更多快捷键的使用：</p><p>正常模式下：<br><img src="/images/QQ截图20181124173155.png"></p><p>编辑模式下：<br><img src="/images/QQ截图20181124173454.png"></p><p>命令行模式下：<br><img src="/images/QQ截图20181124173621.png"></p><h2 id="开机、重启和用户登录注销"><a href="#开机、重启和用户登录注销" class="headerlink" title="开机、重启和用户登录注销"></a>开机、重启和用户登录注销</h2><h3 id="关机-amp-重启命令"><a href="#关机-amp-重启命令" class="headerlink" title="关机&amp;重启命令"></a>关机&amp;重启命令</h3><p>基本介绍:</p><p>shutdown:</p><pre><code>shutdown    –h    now         立该进行关机  【halt】shudown     -h     1              1分钟后会关机了shutdown    –r     now        现在重新启动计算机  [reboot]</code></pre><p>halt：立即关机</p><p>reboot：现在重新启动计算机</p><p>sync：把内存的数据同步到磁盘.</p><p><strong>注意细节：</strong></p><p>不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中，防止数据丢失！</p><h3 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1）登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后<br>再用 “su - 用户名” 命令来切换成系统管理员身份.</p><p>2）在提示符下输入 logout 即可注销用户【不同的shell 可能不同(logout  exit)】</p><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><p>1) logout 注销指令在图形运行级别(简单提一下：0-6个级别)无效，在运行级别 3下有效.</p><p>即：在我们的图形化界面下的终端，输入：logout 无效。<br><img src="/images/QQ截图20181124175449.png"></p><p>运行级别3：代表的就是远程登录。</p><p>在Xshell下，输入：logout 就退出了<br><img src="/images/QQ截图20181124175622.png"></p><p>2) 运行级别这个概念，后面给大家介绍</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之安装</title>
      <link href="/2018/11/22/linux-ji-chu-ru-men/"/>
      <url>/2018/11/22/linux-ji-chu-ru-men/</url>
      
        <content type="html"><![CDATA[<p>Linux的基础入门篇，帮助大家入门的教程<br><a id="more"></a></p><h2 id="Linux的发行版"><a href="#Linux的发行版" class="headerlink" title="Linux的发行版"></a>Linux的发行版</h2><h3 id="常见的Linux发行版"><a href="#常见的Linux发行版" class="headerlink" title="常见的Linux发行版"></a>常见的Linux发行版</h3><p>1）Red Hat Linux</p><p>　　Red Hat Linux 是 Red Hat 最早的发行的个人版本的Linux，其1.0版本于1994年11月3日发行。自从Red Hat 9.0版本发布后，Red Hat公司不再开发桌面版Linux发行版本，Red Hat Linux停止发布，而将全部的力量集中在<strong>服务器版</strong>的发布上面，也就是Red Hat Enterprise Linux版。2004年4月30号，Red Hat公司正式停止Rad Hat Linux的发行套件则与来着开源社区的Fedora进行合并，成为了<strong>Fedora Core</strong> 发行版本。</p><p>　　目前 Red Hat 分为两个系列：由Red Hat 公司提供收费技术支持和更新的 Red Hat Enterprise Linux，以及由社区开发的免费的 Fedora Core。</p><p>2）CentOS</p><p>　　CentOS全名为 “社区企业操作系统”（Community Enterprise Operating System），它由来自于 RHEL 依照开放源代码规定发布的源代码编译而成，由于 RHEL 是商业产品，因此必须将 Red Hat 的所有Logo改成自己的 CentOS标识，这就产生了CentOS操作系统。两者的不同在于，CentOS并不是包含封闭源代码软件。因此，CentOS不但可以自由使用，而且能享受CentOS提供的长期免费升级和更新服务。这是CentOS的一个很大的优势。</p><p>　　在2014年CentOS宣布与Red Hat合作，但CentOS将会在新的委员会下继续运作，并不受RHEL的影响。这个策略表明CentOS后续发展将由Red Hat作为强有力的支持。</p><p>3）SuSE Linux</p><p>　　SUSE 是德国最著名的Linux发行版，也享有很高的声誉，不过命运相当坎坷。据不完全统计，SUSE Linux现在欧洲Linux市场中占有将近80%的份额，大部分关键应用都是建立在SUSE Linux下的。</p><p>4）Ubuntu Linux</p><p>　　Ubuntu(中文谐音为：友邦拓、优般图、乌班图)是一个以桌面应用为主的Linux操作系统，基于Debian GNU/Linux，Ubuntu旨在为一般用户提供一个主要由自由软件构建而成的最新的同时又相当稳定的操作系统。Ubuntu具有庞大的社区力量，用户可以方便地从社区获取帮助。</p><hr><p><strong>总结：</strong></p><p>初学者入门首选：CentOS系列，CentOS系列可以从官网或163开源、SOHU开源、阿里云开源站下载各个版本的安装介质。</p><p>桌面平台首选：Ubuntu Linux。</p><p>企业级应用首选：RHEL/CentOS系列</p><h2 id="虚拟机技术学习Linux"><a href="#虚拟机技术学习Linux" class="headerlink" title="虚拟机技术学习Linux"></a>虚拟机技术学习Linux</h2><h3 id="虚拟机技术"><a href="#虚拟机技术" class="headerlink" title="虚拟机技术"></a>虚拟机技术</h3><p>虚拟机指通过软件模拟的具有完整硬件系统的功能的、运行在一个完全隔离环境中的完整计算机系统。</p><p>虚拟机会生成现有操作系统的全新虚拟机镜像，它与真实系统具有完全一样的功能，进入虚拟机后，所有操作都在这个全新的独立虚拟机系统里面进行，可以独立安装、运行软件，保存数据，拥有自己的独立桌面，这不会对真实的系统产生任何影响，而且能够在现有系统与虚拟机之间灵活切换。</p><h3 id="使用虚拟机的好处"><a href="#使用虚拟机的好处" class="headerlink" title="使用虚拟机的好处"></a>使用虚拟机的好处</h3><p>1）节约成本</p><p>　　如果在一台计算机上安装Linux和Windows系统，而不用虚拟机，有两个方法。一是安装多个硬盘，每个硬盘安装一个操作系统，这个方法的缺点是费用比较昂贵。二是在一个硬盘上安装双系统，这个方法的缺点是不够安全，因为系统的MBR是操作系统的必争之地，Windows更是霸道，每次重新安装系统都要重写系统的MBR，这样，几个操作系统可能会同时崩溃。而使用虚拟机软件既省钱又安全，因此对于新手来说，利用虚拟机学习Linux简直再好不过了。</p><p>2）安全便捷</p><p>　　在虚拟机上面安装Linux系统，不用担心会格式化掉自己的硬盘，甚至可以随意地对虚拟机系统进行任何设置和更新操作，可以格式化虚拟机系统硬盘，还可以重新分区虚拟机系统硬盘等等，因为虚拟机是在真实系统上运行的软件，对虚拟机系统的任何操作都是对软件的操作。</p><p>3）简单高效</p><p>　　利用虚拟机模拟出来的Linux系统和真实的Linux系统是一模一样的。现在各个公司专门的Linux服务器是不会让新生随意操作的，而供测试的Linux服务器一般有很紧缺，如果在自己的电脑上安装虚拟机Linux系统，就可以随意地学习测试，而不受任何环境影响。</p><h3 id="虚拟机的运行环境和硬件需求"><a href="#虚拟机的运行环境和硬件需求" class="headerlink" title="虚拟机的运行环境和硬件需求"></a>虚拟机的运行环境和硬件需求</h3><p>1）运行环境</p><p>流行的虚拟机软件有：VMware、<strong>VirtualBox</strong>，它们都有Windows和Linux两个版本，也就是说，它们可以安装在Windows和Linux两个平台下：在Windows平台可以虚拟出Windows、Linux、UNIX等多个操作系统，同理，在Linux平台上也可以虚拟出Windows、Linux、UNIX等多个操作系统计算机。</p><p><strong>注意：</strong>运行虚拟机软件的操作系统叫做：Host OS，在虚拟机里面运行的操作系统叫做：Guest OS。</p><p>2）硬件需求</p><p>虚拟机软件是将两台以上的计算机的任务集成到一台计算机上来的，因此对硬件的要求比较高，主要涉及的是内存、硬件和CPU。内存要足够大，因为每个虚拟机都会占用一定的内存资源，内存的总大小等于各个虚拟机系统的总和。可喜的是，现在内存已经很便宜，因此就不是问题了。同样，硬盘空间也是每个虚拟机都要占用的，CPU现在都发展到了多核阶段，硬盘也不是问题。</p><h3 id="虚拟机的安装与使用"><a href="#虚拟机的安装与使用" class="headerlink" title="虚拟机的安装与使用"></a>虚拟机的安装与使用</h3><p>1）VirtualBox虚拟机概述</p><p>VirtualBox是一款开源虚拟机软件。最初是由德国Innotek公司开发，由Sun Microsystems公司出品的软件，使用Qt编写，在Sun被Oracle收购后正式更名成Oracle VM VirtualBox。</p><p>VirtualBox可以说是最强大的免费虚拟机软件，它不仅具有丰富的特色，而且性能非常优异，并且简单易用。它可以虚拟的系统有：Windows、Mac OS X、Linux、OpenBSD、Solaris、IBM OS2，甚至Android 4.0等多种操作系统。</p><p>2）虚拟机软件的安装</p><p>VirtualBox 的官方网站是：<code>https://www.virtualbox.org</code>, 可以从此网站下载VirtualBox的稳定版本，目前最新的稳定版本的为：VirtualBox 5.2。<br><img src="/images/QQ截图20181122114300.png"></p><p>这里，我们下载Windows版本的VirtualBox。<br><img src="/images/QQ截图20181122114531.png"></p><p>Windows下安装VirtualBox软件很简单，只须要按照Windows常规方法安装方法安装即可完成，这里就不再讲述了。<br>安装完成后：<br><img src="/images/QQ截图20181122115230.png"></p><h3 id="创建虚拟机系统"><a href="#创建虚拟机系统" class="headerlink" title="创建虚拟机系统"></a>创建虚拟机系统</h3><p>打开：Oracle VM VirtualBox软件，进行虚拟机系统的创建，具体步骤如下：</p><h4 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h4><p>1）按 ctrl + N 快捷键新建虚拟机或者直接点击新建：<br><img src="/images/QQ截图20181122115614.png"></p><h4 id="填写虚拟机信息"><a href="#填写虚拟机信息" class="headerlink" title="填写虚拟机信息"></a>填写虚拟机信息</h4><p>2）填写虚拟机的名称、虚拟机的类型、虚拟机的版本。<br><img src="/images/QQ截图20181122135544.png"></p><h4 id="配置虚拟机内存"><a href="#配置虚拟机内存" class="headerlink" title="配置虚拟机内存"></a>配置虚拟机内存</h4><p>3）配置虚拟机内存大小，这里选择：4096M<br><img src="/images/QQ截图20181122133837.png"></p><h4 id="添加虚拟硬盘"><a href="#添加虚拟硬盘" class="headerlink" title="添加虚拟硬盘"></a>添加虚拟硬盘</h4><p>4）添加虚拟硬盘</p><p>选择现在创建虚拟硬盘：<br><img src="/images/QQ截图20181122134311.png"></p><h4 id="设置虚拟硬盘的文件类型"><a href="#设置虚拟硬盘的文件类型" class="headerlink" title="设置虚拟硬盘的文件类型"></a>设置虚拟硬盘的文件类型</h4><p>5）设置虚拟硬盘的文件类型：</p><p>选择VDI类型：<br><img src="/images/QQ截图20181122134414.png"></p><h4 id="设置虚拟硬盘的空间分配方式"><a href="#设置虚拟硬盘的空间分配方式" class="headerlink" title="设置虚拟硬盘的空间分配方式"></a>设置虚拟硬盘的空间分配方式</h4><p>6）设置虚拟硬盘的空间分配方式</p><p>选择动态分配：<br><img src="/images/QQ截图20181122134529.png"></p><h4 id="设置虚拟磁盘文件的位置和大小"><a href="#设置虚拟磁盘文件的位置和大小" class="headerlink" title="设置虚拟磁盘文件的位置和大小"></a>设置虚拟磁盘文件的位置和大小</h4><p>7）设置虚拟磁盘文件的位置和大小</p><p>位置：选择自己喜欢的位置<br>大小：选择实际硬盘的合理大小即可<br><img src="/images/QQ截图20181122134855.png"></p><p>8）虚拟机系统创建成功后<br><img src="/images/QQ截图20181122135649.png"></p><p>单击左侧的虚拟机名称，在右边可以看到此虚拟机的配置属性。</p><p>在设置页面中，可以对虚拟机的常规、系统、显示、存储、声音、网络、串口、USB设置、共享文件夹等多个方面进行设置。</p><h4 id="下载linux系统的ISO镜像"><a href="#下载linux系统的ISO镜像" class="headerlink" title="下载linux系统的ISO镜像"></a>下载linux系统的ISO镜像</h4><p>9）虚拟机上安装linux系统</p><p>在虚拟机上安装Linux系统，常用的方法有两种：光驱安装和ISO镜像文件安装。</p><p>这里，我使用ISO镜像文件安装。</p><p>10）到开源镜像站下载IOS镜像</p><p>推荐163镜像站、阿里云镜像站。</p><p>这里，我使用阿里云镜像站：<code>https://opsx.alibaba.com/mirror</code><br><img src="/images/QQ截图20181123100200.png"></p><p>选择：最新的版本，当前最新的是7.5。<br><img src="/images/QQ截图20181123100328.png"><br><img src="/images/QQ截图20181123100424.png"><br><img src="/images/QQ截图20181123100604.png"><br><img src="/images/QQ截图20181123100838.png"></p><p>各个版本的ISO镜像文件说明：</p><p>CentOS-7-x86_64-DVD-1804.iso　　　　　　　　标准安装版（推荐）</p><p>CentOS-7-x86_64-Everything-1804.iso　　　　 　完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像）</p><p>CentOS-7-x86_64-LiveGNOME-1804.iso　　　　GNOME桌面版  </p><p>CentOS-7-x86_64-LiveKDE-1804.iso　　　　　　KDE桌面版  </p><p>CentOS-7-x86_64-Minimal-1804.iso　　　　　　精简版，自带的软件最少</p><p>CentOS-7-x86_64-NetInstall-1804.iso　　　　 　网络安装版（从网络安装或者救援系统）</p><p>这里，下载标准安装版：<strong>CentOS-7-x86_64-DVD-1804.iso</strong></p><hr><h4 id="关联虚拟机与CentOS的ISO镜像文件"><a href="#关联虚拟机与CentOS的ISO镜像文件" class="headerlink" title="关联虚拟机与CentOS的ISO镜像文件"></a>关联虚拟机与CentOS的ISO镜像文件</h4><p>11）将我们下载的CentOS_7 和 我们创建的虚拟机系统关联<br><img src="/images/QQ截图20181123132843.png"><br><img src="/images/QQ截图20181123132945.png"><br><img src="/images/QQ截图20181123133020.png"><br><img src="/images/QQ截图20181123133116.png"><br><img src="/images/QQ截图20181123133150.png"><br><img src="/images/QQ截图20181123133224.png"></p><h4 id="linux系统的安装流程"><a href="#linux系统的安装流程" class="headerlink" title="linux系统的安装流程"></a>linux系统的安装流程</h4><p>12）启动我们的centOS_7.5</p><p>如果出现错误的话，是你的电脑没有开启虚拟机化技术。</p><p>我们需要进入BIOS，将虚拟机化技术打开：</p><p>重启我们的电脑，通常按 F2 或者 F12、Esc等进入BISO界面。选择configuration，再选择Intel virtual technology，将其改为enable即可。</p><p>再次重启电脑后，打开virtualBox，进入Linux的安装流程。</p><p><img src="/images/QQ截图20181123134107.png"></p><p>打开后，会发现centOS7有三个启动流程：Install CentOS7（立即安装），Test this mdia &amp; Install CentOS7（测试安装介质并安装），Troubleshooting（故障修复）。我们选择：<strong>Install CentOS7（立即安装）</strong><br><img src="/images/QQ截图20181123134640.png"></p><p>选择系统安装过程中的语言，这里选择English选项，当然，你可以选择简体中文，不过建议使用English安装。单击<strong>continue</strong><br><img src="/images/QQ截图20181123134841.png"></p><p>此时，进入了系统安装的总体浏览界面，从图可以看出，分为三个部分：LOCALIZATION（本地化安装）、SOFTWARE（软件安装）、SYSTEM（系统安装）。<br><img src="/images/QQ截图20181123135407.png"></p><p>进入LOCALIZATION（本地化安装）的 DATE &amp; TIME：<br><img src="/images/QQ截图20181123135942.png"></p><p>设置：Asia（亚洲）、Shanghai（上海）。点击左上角的Done。</p><p>进入LOCALIZATION（本地化安装）的 KEYBOARD（键盘设置）：<br><img src="/images/QQ截图20181123140255.png"></p><p>对于KEYBOARD选项，选择English即可，也可以添加Chinese。</p><p>进入LOCALIZATION（本地化安装）的 LANGUAGE SUPPORT（语言设置）：</p><p>添加English、简体中文。<br><img src="/images/QQ截图20181123140512.png"><br><img src="/images/QQ截图20181123140544.png"></p><hr><p>接下来，进入：软件安装设置，点击 INSTALLATION SOURCE<br><img src="/images/QQ截图20181123140817.png"></p><p>点击：SOFTWARE SELECTION（安装软件的配置信息）</p><p>我们知道，Linux系统，一般指的是Linux内核，而一些组织、公司在内核的基础上又进行了封装，即二次开发，就变成了现在的centOS、红帽等产品。这里的选项就是安装除了centOS内核外的软件。</p><ul><li>初学者选择 CNOME Desktop 或 KDE Plasma Workspaces，这两种环境提供了非常友好的、直观的Linux桌面环境。</li><li>如果在Linux上开发，建议选择Development and Creative Workspaces</li><li>如果只是一个Linux环境，选择Minimal Install即可</li><li>如果在Linux上运行虚拟化程序，选择Virtualization Host</li><li>如果是搭建一个Linux服务器，那么建议Server with GUI。</li></ul><p>在我们以后的工作中，一般我们的Linux都是作为服务器来使用的，所以，这里选择：<strong>Server with GUI</strong>。<br><img src="/images/QQ截图20181123142003.png"></p><hr><p><strong>接下来，进入磁盘分区部分，重点！！！</strong><br><img src="/images/QQ截图20181123142217.png"></p><p>出现了，我们设置虚拟机系统的磁盘空间大小的64G。</p><p>首先选中我们的64G那个的sda盘。然后在左下角会有两个分区的选项，第一个是Automaticlly configure partitioning，表示自动分区；第二个是 <strong>I will configure partitioning</strong>，表示手动分区。如果对分区不太熟的话，直接使用自动分区即可，但是，我们是学习Linux系统，所以，这里选择<strong>手动分区</strong>。</p><p>选择完毕后，单击Done。<br><img src="/images/QQ截图20181123142724.png"></p><p>分区方案：有标准分区 Standard Partition、Btrfs、LVM 和 LVM Thin Provisioning（精简分区）</p><p>这里，选择标准分区即可。</p><p>接下来就要开始创建挂载点了。在此之前，进行一些必要的说明：</p><p>Linux系统下必需的分区为：根分区（/）和 交换分区（swap）。swap分区相当于windows下的虚拟内存，当内存不够的时候，会临时使用swap分区的空间。</p><p>swap分区的大小，一般是你的本机的物理内存的2倍。物理内存小于4G，那么swap：两倍；物理内存：4G~16G，那么swap：等于物理内存；物理内存大于16G，swap：0。一般swap不建议0，设置一定大小的swap还是有一定的作用的。</p><p>虽然Linux系统默认只需要：划分根分区和swap分区就可以了，但是不建议这么做，因为如果只划分了根分区，那么当根分区遭到破坏后，系统可以无法启动，存储在根分区中的资料也有可能丢失，这样很不安全。因此，建议给独立的应用分配独立的分区，这样即使某个分区被破坏，也不影响其他分区的数据。</p><p>以下是建议在安装系统时独立分配的分区</p><p>1）/boot: 存储系统的引导信息和内核等信息</p><p>2）/usr: 存储系统应用软件安装信息</p><p>3）/var: 存储系统日志信息。</p><p>根分区包含Linux系统所有的目录。如果在安装系统时只分配了根分区，那么上面的/boot,/user,/var都包含在根分区中，也就是说，这些分区将占用根分区的空间。如果将/boot,/usr,/var等单独划分，那么这些分区将不再占用根分区的空间。</p><hr><p>先创建<strong>根分区</strong>，根分区空间尽量大点，这里，我选择了20G。<br><img src="/images/QQ截图20181123144507.png"><br><img src="/images/QQ截图20181123144901.png"></p><p>添加/boot分区：<br><img src="/images/QQ截图20181123145024.png"></p><p>添加/usr分区：<br><img src="/images/QQ截图20181123145218.png"></p><p>添加/var分区：<br><img src="/images/QQ截图20181123145341.png"></p><p>添加<strong>swap交换区</strong><br><img src="/images/QQ截图20181123145635.png"></p><p>剩下的空间，我们可以再创建一个分区，用来保存用户的数据信息：<br>添加/mydata分区：<br><img src="/images/QQ截图20181123145921.png"></p><p>最终分区分配完毕后的结果：<br><img src="/images/QQ截图20181123150055.png"></p><hr><p>点击左上角的Done。<br><img src="/images/QQ截图20181123150315.png"></p><p>点击：Accept Changes</p><hr><p>进入 SYSTEM ：KDUPM<br><img src="/images/QQ截图20181123150442.png"></p><p>kdump：主要用来记录系统出错后的信息，用来侦查系统出错的原因，开启后，会占用一定的内存资源。</p><p>这里，我们是学习，我就关闭了，如果是你是上班，开发的话，就将其开启。</p><hr><p>进入 SYSTEM ：NETWORK &amp; HOST NAME<br><img src="/images/QQ截图20181123150800.png"></p><p>默认情况下，网卡处于断开连接状态，可单击右上角的 ON/OFF（开关）按钮，将网卡激活。<br><img src="/images/QQ截图20181123151058.png"></p><p>激活后，我们看到了网卡自动帮我们配置了ip地址，网关ip地址，DNS服务地址等。</p><p>如果想自己手动配置，可以点击右下角的：Configure。</p><p>进入了设置页面：<br><img src="/images/QQ截图20181123151255.png"></p><p>可以根据连接网络的类型配置：有线、无线、VPN 或 DSL的连接，在这里选择 Automatically connect to this network when it is available 和 All uesrs may connect to this network的复选框，这样就可以实现系统启动后自动连接。</p><p>在网络配置部分，看似很多选项需要配置，其实需要配置的并不多。选择IPV4 Settings。</p><p>在Method选项中：有Automatic DHCP、Manual、Link-Local Only等，这里选择Manual。</p><p>接着就可以添加 IPv4 的ip地址，这里添加的ip地址：192.168.56.101，子网掩码：255.255.255.0，网关：192.168.56.1，然后DNS Server：223.5.5.5.<br><img src="/images/QQ截图20181123152436.png"></p><p>点save保存。网卡会自动尝试网络连通性，配置完成后的效果：<br><img src="/images/QQ截图20181123152608.png"></p><p><strong>PS：不想手工配合的话，直接开启激化网卡就好，后面的操作不用进行的</strong></p><hr><p>进入 SYSTEM ：SECURITY POLICY</p><p>安全策略，选择标准的策略即可。（不开启安全策略也行）</p><hr><p>到此为止，我们的基本设置已经完成，点击 Begin Installation。<br><img src="/images/QQ截图20181123153830.png"></p><p>在安装的过程中，我们需要设置Linux的管理员账号ROOT的密码，<strong>密码不能过于简单，否则会提示你，让你重新设置。</strong><br><img src="/images/QQ截图20181123153638.png"></p><p>在安装的过程中，也可以设置普通用户，输入用户名和密码即可。<br><img src="/images/QQ截图20181123153657.png"></p><p><strong>注意：如果要设置root和普通用户，请在安装完成之前进行，否则安装完成后，就不能设置了！！！</strong></p><hr><p>安装完成后，点击Reboot按钮重启系统。<br><img src="/images/QQ截图20181123155718.png"><br><img src="/images/QQ截图20181123155902.png"></p><p>选择接受：<br><img src="/images/QQ截图20181123155937.png"><br><img src="/images/QQ截图20181123160010.png"></p><p>用户登入界面：<br><img src="/images/QQ截图20181123160111.png"><br><img src="/images/QQ截图20181123160151.png"></p><p>进入开机引导的界面：<br><img src="/images/QQ截图20181123160307.png"></p><p>选择，你自己喜欢的语言，English，汉语等，进行引导安装</p><p>选择，键盘的输入：<br><img src="/images/QQ截图20181123160430.png"></p><p>隐私：<br><img src="/images/QQ截图20181123160520.png"></p><p>选择在线用户，没有就跳过<br><img src="/images/QQ截图20181123160620.png"></p><p>开始使用Linux系统：<br><img src="/images/QQ截图20181123160723.png"></p><hr><p>到此，Linux系统，终于安装完毕，也看到了我们Linux系统的界面了<br><img src="/images/QQ截图20181123160817.png"></p><h3 id="Linux系统下的常用指令"><a href="#Linux系统下的常用指令" class="headerlink" title="Linux系统下的常用指令"></a>Linux系统下的常用指令</h3><p>Linux系统由桌面控制台和字符控制台组成，桌面系统其实就是我们安装软件包时的X-Window视窗，而X-Window的实质是在命令行下运行的一个应用程序。字符控制台是Linux系统的核心，大部分操作都是在字符控制台下面完成的，即：终端。</p><p>默认Linux下有6个字符控制台，每个控制台可以独立作业，互不影响，这真正体现了Linux系统下的：多用户、多任务的特性。</p><p>在图形界面下要切换到字符界面时，只需要按：<strong>ctrl+alt+F2~F7组合键</strong>中的任何一个，即可进入字符界面。相反如果要从字符界面切换到图形界面的话，可以在字符界面输入：startx 或者 <strong>ctrl+alt+F1</strong>组合键.</p><p>虚拟机和物理机之间的鼠标和键盘切换问题，默认是通过：<strong>右下角的ctrl键</strong>来切换的。这个右下角的ctrl键也称为：热键或者主机（host）键。</p><p>主机键和其他键组合，可以实现对虚拟机的快捷操作，例如：Host+Del组件键：表示键盘上的ctrl+alt+del组合键，Host+R：表示重启虚拟机，Host+H：表示正常关闭虚拟机。</p><p>Linux系统的关闭过程</p><p>1）shutdown [-fFhknrc参数名称] [-t 秒数] 时间 [警告信息]</p><p>-f: 重新启动时，不执行fsck。 fsck：是Linux下的一个检查和修复文件系统的程序。</p><p>-h：将系统关机，在某种程度上功能与halt命令相当</p><p>-k：只发送信息给所有的用户，但并不会真正关机</p><p>-n：不调用init程序关机，而是由shutdown自己进行（一般关机程序是由shutdown调用init来实现关机动作的），使用此参数关机速度快，不建议</p><p>-r：关机后重启</p><p>-c：取消前一个shutdown命令。</p><p>-t[秒数]：发送警告信息和关机信息之间要延迟多少秒。警告信息将提醒用户保存当前进行的工作。</p><p>[时间]：设置多久时间后执行shutdown命令。时间参数有 hh:mm 或 +m 两种模式。例如： shutdown 16:50 :表示将在16:50关机。</p><p>now：表示立即关机。</p><p>常用指令：</p><p>立即关机</p><pre><code>shutdown -h now</code></pre><p>立即关机重启</p><pre><code>shutdown -r now</code></pre><p>设定5分钟后关机，同时发出警告信息给登录的Linux用户。</p><pre><code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code></pre><hr><h3 id="虚拟机的网络连接是三种方式"><a href="#虚拟机的网络连接是三种方式" class="headerlink" title="虚拟机的网络连接是三种方式"></a>虚拟机的网络连接是三种方式</h3><p>1）桥接模式</p><p>好处：大家都在同一个网段，相互可以通讯。<br>坏处：因为ip地址有限，可能造成ip冲突</p><p>因为桥接模式下的网络，是会帮我们的虚拟机的Linux系统，自动分配一个ip地址，这个ip地址会和我的宿主机在一个网段内，比如：我们的宿主机的ip地址是192.168.14.100 ，那么centOS虚拟机的ip就会是192.168.14.xxx（比如192.168.14.120）。在该网段下的其他宿主机，张三（192.168.14.110）就能直接访问到我的centOS虚拟机。</p><p>如果每个人都使用这种模式来开启虚拟机的网络设置，那么ip地址就不够用了，容易ip地址冲突！！！</p><p>2）Nat [网络地址转换模式]</p><p>好处：虚拟机不占用其他的ip,所以不会ip冲突<br>坏处：内网的其他人不能和虚拟机通讯</p><p>Nat模式下的话，会在我们的宿主机上面创建一个新的ip地址，会和我们的windows宿主机的ip地址不在一个网段上面，比如：我们的是192.168.14.64，那么创建的新的ip地址会是：192.168.102.1。不在一个网段上面，而且也会在centOS虚拟机上面分配一个和新的windows上面ip地址同一个网段的ip地址，比如：192.168.102.128。<br>即：centOS虚拟机ip地址与新的windows的ip地址连通，然后新的windows的ip与我们本身的windows的ip互通，这样就能访问我们的centOS虚拟机了，但是，在该网段下的其他用户，李四：192.168.14.112，就不与我们的centOS虚拟机（192.168.102.128）通信了，不过我们的centOS虚拟机（192.168.102.128）可以与李四通信，因为centOS虚拟机与本机连通，可以通过本机的ip（192.168.14.64）与李四通信，在一个网段下面。</p><p>3）仅主机模式（Host-only）</p><p>意思很明确了，就是单独一台电脑。linux不能访问外网（一般实际生产中，很少用）</p><hr><p><img src="/images/QQ截图20181123170336.png"></p><h3 id="centOS的终端使用和联网"><a href="#centOS的终端使用和联网" class="headerlink" title="centOS的终端使用和联网"></a>centOS的终端使用和联网</h3><h4 id="终端的使用"><a href="#终端的使用" class="headerlink" title="终端的使用"></a>终端的使用</h4><p>在centOS系统中，右键打开终端：<br><img src="/images/QQ截图20181123173038.png"></p><p><img src="/images/QQ截图20181123172554.png"></p><p>会发现是白色的背景，黑色的字体，看着不舒服，我们修改<br><img src="/images/QQ截图20181123172951.png"><br>选择颜色：<br><img src="/images/QQ截图20181123172854.png"></p><p>修改后：<br><img src="/images/QQ截图20181123173132.png"></p><hr><h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><p>启动：火狐浏览器<br><img src="/images/QQ截图20181123173303.png"></p><p>在浏览器中输入：<code>www.baidu.com</code><br><img src="/images/QQ截图20181123173520.png"></p><p>发现，连接不上网。</p><p>怎么联网呢？</p><p>我们的虚拟机网络设置的是：NAT[网络地址转换]<br><img src="/images/QQ截图20181123173701.png"></p><p>根据，上一节的介绍，我们的宿主机应该有两个ip地址：</p><p>打开windows下的终端：home+R：cmd</p><p>输入：ipconfig<br><img src="/images/QQ截图20181123175311.png"></p><p>能够看到，我们的ip地址。</p><p>现在打开，centOS中的终端：</p><p>在linux系统中，使用 ifconfig 来查看ip地址<br><img src="/images/QQ截图20181123175508.png"></p><p>发现，根本没有ip地址，所以我们不能联网。</p><p>现在来设置ip地址，点击右上角的声音、电池、亮度的图标<br><img src="/images/QQ截图20181123175619.png"></p><p>点击有线设置：<br><img src="/images/QQ截图20181123175819.png"></p><p>点击有线连接的上面的齿轮进行具体的设置：<br><img src="/images/QQ截图20181123175927.png"><br>点击IPv4：<br>改为：DHCP（自动设置）<br><img src="/images/QQ截图20181123180012.png"></p><p>单击：应用<br><img src="/images/QQ截图20181123180158.png"></p><p>打开有线连接：<br><img src="/images/QQ截图20181123180252.png"></p><p>进入终端：ifconfig<br><img src="/images/QQ截图20181123180417.png"></p><p>现在已经帮我们自动配合了，IP地址了，这里是：10.0.2.15</p><p>再次打开：火狐浏览器输入：<code>www.baidu.com</code><br><img src="/images/QQ截图20181123181048.png"></p><p>联网成功，只要你的宿主机能够联网，那么centOS虚拟机也就能够联网了。</p><p><strong>注意：我使用的是virtualBox，照理说NAT模式下，应该会有一个新的windows的ip地址，而且是不同的网段，但是这里在windows下ipconfig，看不到那个新产生的ip地址，在centOS下的自动生成的ip地址应该会和新生成的windows的ip在同一个网络，这里也看不出来，但是，如果你使用的是VMWare虚拟机的话，就能发现。至于什么原因，我也不清楚，以后解决了，会留言告诉大家！！！</strong></p><p><strong>PS：这里使用的是DHCP：动态帮我们配置的ip地址，每次启动都会变动，以后我们会学习静态ip分配</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与监控管理</title>
      <link href="/2018/11/21/spring-boot-yu-jian-kong-guan-li/"/>
      <url>/2018/11/21/spring-boot-yu-jian-kong-guan-li/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot与监控管理<br><a id="more"></a></p><h2 id="监控管理"><a href="#监控管理" class="headerlink" title="监控管理"></a>监控管理</h2><p>通过引入spring-boot-starter-actuator，可以使用Spring Boot为我们提供的准生产环境下的应用监控和管理功能。我们可以通过HTTP，JMX，SSH协议来进行操作，自动得到审计、健康及指标信息等.</p><p>步骤：</p><p>– 引入spring-boot-starter-actuator<br>– 通过http方式访问监控端点<br>– 可进行shutdown（POST 提交，此端点默认关闭）</p><h2 id="监控和管理端点"><a href="#监控和管理端点" class="headerlink" title="监控和管理端点:"></a>监控和管理端点:</h2><p><img src="/images/QQ截图20181121155804.png"></p><p>1) 创建新的Springboot项目：</p><p>添加：DevTools、Web、Actuator模块：</p><p><img src="/images/QQ截图20181121160723.png"><br><img src="/images/QQ截图20181121160747.png"><br><img src="/images/QQ截图20181121160816.png"></p><p>2）直接运行应用：<br><img src="/images/QQ截图20181121160955.png"><br><img src="/images/QQ截图20181121161042.png"></p><p>发现：多了很多映射的url。</p><p>这些url都是因为加入:<code>spring-boot-starter-actuator</code> 依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>3）访问这些url映射：</p><p>随便访问一个：比如：/beans<br><img src="/images/QQ截图20181121161305.png"></p><p>发现：没有权限访问！！！</p><p>4）关闭安全监测</p><p>在application配置文件中：<br><img src="/images/QQ截图20181121161735.png"></p><pre><code>#关闭安全管理检测management.security.enabled=false</code></pre><p>ctrl+F9:即可，不需要重启应用。<br><img src="/images/QQ截图20181121161833.png"></p><p>其他的监控信息：请看<strong>监控和管理端点</strong>的图片，执行测试即可。</p><h2 id="定制端点信息"><a href="#定制端点信息" class="headerlink" title="定制端点信息"></a>定制端点信息</h2><p>– 定制端点一般通过endpoints+端点名+属性名来设置。</p><p>– 修改端点id（endpoints.beans.id=mybeans）</p><p>– 开启远程应用关闭功能（endpoints.shutdown.enabled=true）</p><p>– 关闭端点（endpoints.beans.enabled=false）</p><p>– 开启所需端点<br>• endpoints.enabled=false<br>• endpoints.beans.enabled=true</p><p>– 定制端点访问根路径<br>• management.context-path=/manage</p><p>– 关闭http端点<br>• management.port=-1</p><hr><p>测试：</p><p>1）在application配置文件中：</p><pre><code>#定制端点信息endpoints.beans.id=mybeans</code></pre><p>现在，beans的访问端点就不行了，必须是mybeans了。（修改了默认的访问名）<br><img src="/images/QQ截图20181121162813.png"><br><img src="/images/QQ截图20181121162844.png"></p><p>2）在application配置文件中：</p><pre><code>#定制端点信息endpoints.beans.id=mybeansendpoints.beans.path=/b</code></pre><p>此时的beans的访问路径，就变成了/b. 默认的 /beans 和 /mybeans 都不好使了。<br><img src="/images/QQ截图20181121163113.png"></p><p>3）在application配置文件中：</p><pre><code>#定制端点信息endpoints.beans.id=mybeansendpoints.beans.path=/b#关闭了beans的端点endpoints.beans.enabled=false</code></pre><p>此时，就会把beans端点给关闭了。不管访问 /beans 和 /mybeans 和 /b 都不好使了。<br><img src="/images/QQ截图20181121163338.png"></p><p>但是其他端点好使：<br><img src="/images/QQ截图20181121163416.png"></p><p>4）如果想关闭所有的，但是只留一些端点开放：</p><pre><code>#关闭所有的端点endpoints.enabled=false#开启部分端点(beans)endpoints.beans.enabled=true</code></pre><p>其他端点都不好使了。<br><img src="/images/QQ截图20181121163647.png"><br>只要beans端点好使：<br><img src="/images/QQ截图20181121163733.png"></p><p>5）定制端点访问根路径</p><pre><code>#设置访问端点的根路径management.context-path=/manager</code></pre><p><img src="/images/QQ截图20181121163931.png"><br><img src="/images/QQ截图20181121164012.png"></p><p>6) 定制端点访问的端口号</p><pre><code>#设置访问端点的根路径management.context-path=/managermanagement.port=8081</code></pre><p><img src="/images/QQ截图20181121164156.png"><br><img src="/images/QQ截图20181121164226.png"></p><p>7) 关闭http端点</p><pre><code>#设置访问端点的根路径management.context-path=/managermanagement.port=-1</code></pre><p><img src="/images/QQ截图20181121164352.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 监控管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 监控管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与开发热部署</title>
      <link href="/2018/11/21/spring-boot-yu-kai-fa-re-bu-shu/"/>
      <url>/2018/11/21/spring-boot-yu-kai-fa-re-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot中的热部署<br><a id="more"></a></p><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p>在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。</p><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>– 在Spring Boot中开发情况下禁用模板引擎的cache<br>– 页面模板改变ctrl+F9可以重新编译当前页面并生效</p><h3 id="Spring-Loaded"><a href="#Spring-Loaded" class="headerlink" title="Spring Loaded"></a>Spring Loaded</h3><p>Spring官方提供的热部署程序，实现修改类文件的热部署<br>– 下载Spring Loaded（项目地址<a href="https://github.com/spring-projects/spring-loaded）" target="_blank" rel="noopener">https://github.com/spring-projects/spring-loaded）</a><br>– 添加运行时参数: -javaagent:C:/springloaded-1.2.5.RELEASE.jar -noverify</p><h3 id="JRebel"><a href="#JRebel" class="headerlink" title="JRebel"></a>JRebel</h3><p>– 收费的一个热部署软件<br>– 安装插件使用即可</p><h3 id="Spring-Boot-Devtools（推荐）"><a href="#Spring-Boot-Devtools（推荐）" class="headerlink" title="Spring Boot Devtools（推荐）"></a>Spring Boot Devtools（推荐）</h3><p>引入依赖:</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="演示Spring-Boot-Devtools"><a href="#演示Spring-Boot-Devtools" class="headerlink" title="演示Spring Boot Devtools"></a>演示Spring Boot Devtools</h2><p>1）创建一个Thymeleaf的Springboot的项目：<br><img src="/images/QQ截图20181121143729.png"><br><img src="/images/QQ截图20181121144641.png"><br><img src="/images/QQ截图20181121143827.png"><br><img src="/images/QQ截图20181121143851.png"><br><img src="/images/QQ截图20181121144815.png"></p><p>2) 在templates下，创建一个hello.html文件<br><img src="/images/QQ截图20181121144956.png"></p><p>3）在controller包下，创建HelloWorldController：<br><img src="/images/QQ截图20181121145141.png"></p><p>4）启动Springboot应用：<br><img src="/images/QQ截图20181121145251.png"></p><p>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="/images/QQ截图20181121145323.png"></p><p>5) 现在修改映射url：</p><p>不要关闭应用！！！<br><img src="/images/QQ截图20181121145426.png"></p><p>访问：<code>http://localhost:8080/hello</code><br><img src="/images/QQ截图20181121145529.png"></p><p>说明，根本没有热部署功能！</p><p>现在：打开target包下的：HelloWorldController：<br><img src="/images/QQ截图20181121145705.png"></p><p>说明：我们的编译后的class文件，根本没有改过。</p><p>现在，在我们的src下的HelloWorldController类中：<strong>ctrl+F9</strong></p><p>然后再次打开target下的HelloWorldController类：<br><img src="/images/QQ截图20181121145916.png"></p><p>发现，我们改变的HelloWorldController类已经改变了。</p><p>再次在浏览器中输入：<code>http://localhost:8080/hello</code><br><img src="/images/QQ截图20181121145529.png"></p><p>还是不行，这是我们需要导入spring-boot-devtools依赖：<br><img src="/images/QQ截图20181121150337.png"></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>此时，我们重启Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/hello</code><br><img src="/images/QQ截图20181121150510.png"></p><p>在把映射的url修改回来：</p><p>不停止应用！！！<br><img src="/images/QQ截图20181121150606.png"></p><p>然后：ctrl+F9</p><p>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="/images/QQ截图20181121153657.png"></p><p>热部署成功！</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>– IDEA 使用 : ctrl+F9<br>– 或做一些小调整<br>Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下<br>才会自动编译（前提是你已经设置了Auto-Compile）。</p><hr><p>• 设置自动编译（settings-compiler-make project automatically）<br><img src="/images/QQ截图20181121154016.png"></p><p>• ctrl+shift+alt+/（maintenance）<br>• 勾选compiler.automake.allow.when.app.running</p><p><img src="/images/QQ截图20181121154100.png"><br><img src="/images/QQ截图20181121154123.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 热部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 热部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与分布式</title>
      <link href="/2018/11/19/spring-boot-yu-fen-bu-shi/"/>
      <url>/2018/11/19/spring-boot-yu-fen-bu-shi/</url>
      
        <content type="html"><![CDATA[<p>分步式、Dubbo/Zookeeper、Spring Boot/Cloud<br><a id="more"></a></p><h2 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h2><p>在分布式系统中，国内常用zookeeper+dubbo组合，而Spring Boot推荐使用全栈的Spring，Spring Boot+Spring Cloud。</p><ul><li><p>单一应用架构<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p></li><li><p>垂直应用架构<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p></li><li><p>分布式服务架构<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时,用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p></li><li><p>流动计算架构<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p></li></ul><h2 id="Zookeeper和Dubbo"><a href="#Zookeeper和Dubbo" class="headerlink" title="Zookeeper和Dubbo"></a>Zookeeper和Dubbo</h2><ul><li>ZooKeeper</li></ul><p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><ul><li>Dubbo</li></ul><p>Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出 <strong>服务提供方（Provider）</strong>和 <strong>服务消费方（Consumer）</strong>两个角色。</p><p><img src="/images/QQ截图20181119102607.png"></p><p>步骤：<br>• 1、安装zookeeper作为注册中心<br>• 2、编写服务提供者<br>• 3、编写服务消费者<br>• 4、整合dubbo</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="下载zookeeper镜像"><a href="#下载zookeeper镜像" class="headerlink" title="下载zookeeper镜像"></a>下载zookeeper镜像</h3><p>1）打开我们的虚拟机，下载zookeeper镜像：<br><img src="/images/QQ截图20181119111308.png"></p><pre><code>docker pull registry.docker-cn.com/library/zookeeper</code></pre><p><img src="/images/QQ截图20181119112101.png"></p><p>查看zookeeper的docker官网，看怎么运行？<br><img src="/images/QQ截图20181119112223.png"></p><p>发现：会暴露三个端口号，2181,2888,3888。我们只需要暴露2181即可，因为我们不做集群。</p><pre><code>docker run --name zk01 -p 2181:2181 --restart always -d zookeeper的imageId </code></pre><p><img src="/images/QQ截图20181119113528.png"></p><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>2) 创建两个工程，一个服务提供者 和 一个服务消费者</p><p>打开idea，创建一个空项目，为了方便演示而已：</p><p>这个空项目里面：会包括服务提供者和服务消费者<br><img src="/images/QQ截图20181119115031.png"><br><img src="/images/QQ截图20181119115245.png"><br><img src="/images/QQ截图20181119115341.png"></p><p>在这个空项目中，添加 服务提供者 和 服务消费者 工程：</p><p>服务提供者工程：<br><img src="/images/QQ截图20181119115531.png"><br><img src="/images/QQ截图20181119115559.png"><br><img src="/images/QQ截图20181119115833.png"><br>选中Web模块，1.x.x的版本<br><img src="/images/QQ截图20181119115913.png"><br><img src="/images/QQ截图20181119120004.png"><br>创建完成后：<br><img src="/images/QQ截图20181119120056.png"><br><img src="/images/QQ截图20181119120144.png"></p><p>服务消费者工程：</p><p>类似：只是工程名字为：consume-ticket<br><img src="/images/QQ截图20181119120418.png"></p><p>最后，两个工程生成完毕后：<br><img src="/images/QQ截图20181119123653.png"></p><h3 id="编写提供者和消费者"><a href="#编写提供者和消费者" class="headerlink" title="编写提供者和消费者"></a>编写提供者和消费者</h3><p>打开dubbo官网：<a href="http://dubbo.apache.org/en-us/" target="_blank" rel="noopener">http://dubbo.apache.org/en-us/</a><br><img src="/images/QQ截图20181119124046.png"></p><p>可以学习相关的知识。</p><h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>3.1.1）在服务提供者项目中：导入dubbo的spring-boot-starter：</p><pre><code>&lt;!-- https://mvnrepository.com/artifact/com.alibaba.boot/dubbo-spring-boot-starter --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>3.1.2）导入zookeeper的相关依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;    &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="/images/QQ截图20181119125517.png"></p><p>3.1.3) 编写服务提供者的售票服务：</p><p>在service包下，创建TickerService接口：<br><img src="/images/QQ截图20181119125831.png"></p><p>在service包下，创建创建TickerService接口的实现类：TickerServiceImpl：<br><img src="/images/QQ截图20181119130029.png"></p><p>3.1.4）将我们编写的服务注册到注册中心：</p><p>在application配置文件中，配置zookeeper的信息：</p><p>dubbo是阿里提供的RPC：开源的远程调用服务，帮助我们将服务注册到Zookeeper注册中心中。<br><img src="/images/QQ截图20181119130712.png"></p><pre><code>#注册服务到zookeeper注册中心中的服务名字dubbo.application.name=provide-ticket#ip地址是你的虚拟机的ip地址，记住zookeeper服务是启动的状态dubbo.registry.address=zookeeper://10.6.11.17:2181# 扫描包，将该包下的使用的dubbo的@Service注解的类注册到注册中心中dubbo.scan.base-packages=com.liuzhuo.ticket.service</code></pre><p>3.1.5) 给我们的服务添加上<strong>dubbo的@Service</strong>注解</p><p><strong>注意：这里的@Service注解是dubbo的，不是Spring的@Service注解。</strong><br><img src="/images/QQ截图20181119131152.png"></p><p>3.6）启动服务提供者的Springboot应用：<br><img src="/images/QQ截图20181119131324.png"></p><p>启动失败的？<br><img src="/images/QQ截图20181119131548.png"></p><p>这里是因为：版本依赖的问题，Springboot 1.x 要导入：0.1.x的dubbo。<br><img src="/images/QQ截图20181119131649.png"></p><p>修改application的配置文件：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="/images/QQ截图20181119132013.png"></p><p>重启服务提供者的应用：<br><img src="/images/QQ截图20181119134051.png"></p><p>启动成功！！！</p><hr><h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><p>3.2.1）导入dubbo和Zookeeper的相关依赖：<br><img src="/images/QQ截图20181119134412.png"></p><p>3.2.2）配置application文件：<br><img src="/images/QQ截图20181119134615.png"></p><p>3.2.3）编写消费的代码：</p><p>在user/service包下，创建UserService类：<br><img src="/images/QQ截图20181119135241.png"></p><p>3.2.4）引入服务提供者的服务：</p><p><strong>关键：在服务消费者的工程下，创建服务提供者一模一样的类名的接口：TickerService</strong></p><p>即：将服务提供者的：TickerService的全类名拷贝到服务消费者中：（只要TickerService接口即可）</p><p>这就是为啥，我在创建两个项目的时候，项目的包名都是一样的原因！！！（都是com.liuzhuo.ticket）<br><img src="/images/QQ截图20181119135557.png"></p><p>3.2.5) 在UserService类中注入服务提供者的TickerService：<br><img src="/images/QQ截图20181119140053.png"></p><p>3.2.6）在测试类中，测试是否能调用到服务提供者的售票服务：<br><img src="/images/QQ截图20181119140231.png"></p><p>启动测试：</p><p><strong>注意：此时的服务提供者的Springboot应用不要停，也要一直启动！！！</strong><br><img src="/images/QQ截图20181119140404.png"></p><p>远程调用成功！！！</p><hr><h2 id="SpringBoot和SpringCloud"><a href="#SpringBoot和SpringCloud" class="headerlink" title="SpringBoot和SpringCloud"></a>SpringBoot和SpringCloud</h2><p><strong>Spring Cloud</strong><br>Spring Cloud是一个分布式的整体解决方案。Spring Cloud 为开发者提供了在<strong>分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局琐，leader选举，分布式session，集群状态）中快速构建的工具</strong>，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。</p><p><strong>SpringCloud分布式开发五大常用组件</strong></p><ul><li><p>服务发现——Netflix Eureka</p></li><li><p>客服端负载均衡——Netflix Ribbon</p></li><li><p>断路器——Netflix Hystrix</p></li><li><p>服务网关——Netflix Zuul</p></li><li><p>分布式配置——Spring Cloud Config</p></li></ul><p><img src="/images/QQ截图20181119143127.png"></p><p>微服务原文：<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">https://martinfowler.com/articles/microservices.html</a></p><p>Spring Cloud 入门</p><p>1、创建provider<br>2、创建consumer<br>3、引入Spring Cloud<br>4、引入Eureka注册中心<br>5、引入Ribbon进行客户端负载均衡</p><hr><h3 id="创建空的工程"><a href="#创建空的工程" class="headerlink" title="创建空的工程"></a>创建空的工程</h3><p>1）创建空的工程：<br><img src="/images/QQ截图20181119143436.png"><br><img src="/images/QQ截图20181119143545.png"></p><h3 id="创建三个工程"><a href="#创建三个工程" class="headerlink" title="创建三个工程"></a>创建三个工程</h3><p>2）添加三个工程：</p><p>Eureka注册中心工程、服务提供者工程、服务消费者工程。</p><h4 id="创建Eureka注册中心"><a href="#创建Eureka注册中心" class="headerlink" title="创建Eureka注册中心"></a>创建Eureka注册中心</h4><p>2.1）创建Eureka注册中心<br><img src="/images/QQ截图20181119144149.png"></p><p>添加：Eureka Server模块（因为是注册模块）<br><img src="/images/QQ截图20181119144408.png"></p><h4 id="创建服务提供者"><a href="#创建服务提供者" class="headerlink" title="创建服务提供者"></a>创建服务提供者</h4><p>2.2）创建服务提供者<br><img src="/images/QQ截图20181119144658.png"></p><p>添加：Eureka Discovery模块（发现服务的模块）<br><img src="/images/QQ截图20181119144840.png"></p><h4 id="创建服务消费者"><a href="#创建服务消费者" class="headerlink" title="创建服务消费者"></a>创建服务消费者</h4><p>2.3）创建服务消费者<br><img src="/images/QQ截图20181119145013.png"></p><p>添加：Eureka Discovery模块（发现服务的模块）<br><img src="/images/QQ截图20181119144840.png"></p><p>最后三个工程都创建完毕后：<br><img src="/images/QQ截图20181119145128.png"></p><hr><h3 id="配置Eureka-server模块："><a href="#配置Eureka-server模块：" class="headerlink" title="配置Eureka server模块："></a>配置Eureka server模块：</h3><p>在eureka-server工程中，配置Application文件：<br><img src="/images/QQ截图20181119153233.png"></p><pre><code>#配置服务的端口号：server:  port: 8761#配置eureka信息eureka:  instance:    hostname: eureka-server  # eureka实例的主机名  client:    register-with-eureka: false # 不注册自己到eureka上    fetch-registry: false # 不从eureka上面获取服务的注册信息    service-url:     # 是一个map结构      defaultZone: http://localhost:8761/eureka/  # 注册中心的地址</code></pre><p>在在eureka-server工程中的启动类上，添加Eureka的注解启动功能：@EnableEurekaServer<br><img src="/images/QQ截图20181119153514.png"></p><p>启动Eureka-Server项目：<br><img src="/images/QQ截图20181119153754.png"></p><p><strong>启动成功后，就不要关闭了。</strong></p><p>在浏览器中输入：<code>http://localhost:8761/</code><br><img src="/images/QQ截图20181119153920.png"></p><p>到目前为止，我们的Eureka服务注册中心启动成功！</p><hr><h3 id="配置服务提供者模块："><a href="#配置服务提供者模块：" class="headerlink" title="配置服务提供者模块："></a>配置服务提供者模块：</h3><p>在privoder-ticket项目中：</p><p>在service包下，创建TicketService服务:<br><img src="/images/QQ截图20181119154409.png"></p><p>在controller包下，创建TicketController：<br><img src="/images/QQ截图20181119154648.png"></p><p>将我们的服务注册到服务中心中：</p><p>编写privoder-ticket项目中的Application配置文件：<br><img src="/images/QQ截图20181119155034.png"></p><pre><code>#项目的端口号server:  port: 8001#项目的名字spring:  application:    name: provider-ticket#配置eureka信息eureka:  instance:    prefer-ip-address: true # 注册服务到Eureka服务中心的时候，使用ip地址  client:    service-url:     # 是一个map结构      defaultZone: http://localhost:8761/eureka/  # 注册中心的地址</code></pre><p>启动privoder-ticket项目：<br><img src="/images/QQ截图20181119155314.png"></p><p>在浏览器中输入：<code>http://localhost:8001/ticket</code><br><img src="/images/QQ截图20181119155415.png"></p><p>服务启动成功！</p><p>打开 <code>http://localhost:8761/</code><br><img src="/images/QQ截图20181119155524.png"></p><p>在Eureka服务注册中心中，发现了我们的注册的服务提供者：privoder-ticket。</p><p>以上就是，注册服务到服务中心中。</p><hr><p>一个项目，我们可以注册多个服务到服务中心中。</p><p>现在，停止我们的：privoder-ticket 项目。改用：java - jar 的方式来启动应用。</p><p>现在，将我们的项目打包成jar包：<br><img src="/images/QQ截图20181119155930.png"></p><p>双击：package<br><img src="/images/QQ截图20181119160049.png"><br><img src="/images/QQ截图20181119160213.png"></p><p>将target中的打包成功的jar包，保存到桌面的service文件夹中：<br><img src="/images/QQ截图20181119160333.png"></p><p>将jar包的名字后面加上了8001，是为了区分。</p><hr><p>现在，将privoder-ticket 项目中的Application配置文件中的端口号，改为8002，然后打成jar包。<br><img src="/images/QQ截图20181119160559.png"></p><p>然后，使用 java -jar 的形式来启动这两个jar包：</p><pre><code>java -jar privoder-ticket-0.0.1-SNAPSHOT-8001.jar和java -jar privoder-ticket-0.0.1-SNAPSHOT-8002.jar</code></pre><p><img src="/images/QQ截图20181119160914.png"><br><img src="/images/QQ截图20181119161158.png"></p><p><strong>注意：这里是开启两个windows的终端窗口！！！</strong></p><p>验证：</p><p>分别在浏览器中输入：<code>http://localhost:8001/ticket</code> 和 <code>http://localhost:8002/ticket</code></p><p>出现：<br><img src="/images/QQ截图20181119161615.png"></p><p>而且在 <code>http://localhost:8761/</code> 中：</p><p>会发现，两个privoder-ticket服务。<br><img src="/images/QQ截图20181119161750.png"></p><hr><h3 id="配置服务消费者模块："><a href="#配置服务消费者模块：" class="headerlink" title="配置服务消费者模块："></a>配置服务消费者模块：</h3><p>配置application文件：<br><img src="/images/QQ截图20181119162326.png"></p><pre><code>#项目的端口号server:  port: 8200#项目的名字spring:  application:    name: consume-user#配置eureka信息eureka:  instance:    prefer-ip-address: true # 注册服务到Eureka服务中心的时候，使用ip地址  client:    service-url:     # 是一个map结构      defaultZone: http://localhost:8761/eureka/  # 注册中心的地址</code></pre><p>在启动类上，添加@EnableDiscoveryClient注解：开启发现服务的功能。<br><img src="/images/QQ截图20181119162555.png"></p><p>因为Springcloud是用restful的形式来发现、调用服务的。 所以，我们需要注入一个RestTemplate类来操作发送http请求。<br><img src="/images/QQ截图20181119162917.png"></p><p><strong>@LoadBalanced：发送http请求时，起到负载均衡的作用</strong></p><p>配置消费功能：</p><p>在controller包下，创建UserController类：<br><img src="/images/QQ截图20181119163401.png"></p><pre><code>@RestControllerpublic class UserController {    @Autowired    private RestTemplate restTemplate;    @GetMapping(&quot;/buy&quot;)    public String buyTicket(String name){        /**         * 第一个参数：http的请求地址：PROVIDER-TICKET 服务中心中的服务名字         * 第二个参数：返回值的类型         */        String ticket = restTemplate.getForObject(&quot;http://PROVIDER-TICKET/ticket&quot;, String.class);        return name+&quot;:购买了：ticket&quot;;    }}</code></pre><p>PROVIDER-TICKET: 是Eureka服务中心的服务的名字：<br><img src="/images/QQ截图20181119163555.png"></p><p><code>http://PROVIDER-TICKET/ticket</code>   就是调用服务中心中PROVIDER-TICKET的项目，发送/ticket请求，就会获取电影票的功能。</p><p>启动consume-user项目：<br><img src="/images/QQ截图20181119163858.png"><br><img src="/images/QQ截图20181119163955.png"></p><p>在 <code>http://localhost:8761/</code> 中：<br><img src="/images/QQ截图20181119164036.png"></p><hr><p>现在，在浏览器中输入：<code>http://localhost:8200/buy?name=zhangsan</code><br><img src="/images/QQ截图20181119164317.png"></p><p>成功：我们的 consume-user项目 通过http请求，调用Eureka服务中心中的 PROVIDER-TICKET 项目，获取到了《你的名字》的电影票。</p><p><strong>PS：我们的服务提供者还是负载均衡的，因为我们有两个PROVIDER-TICKET，加上@LoadBalanced</strong></p><p>刷新 <code>http://localhost:8200/buy?name=zhangsan</code> 页面 ：</p><p>服务中心，会帮我们轮询调用PROVIDER-TICKET服务，这里，我们没有在privoder-ticket项目中的TicketService方法中，添加输出语句，所以看不到效果。</p><p>不信的话，你添加输出语句就会看到效果了。</p><pre><code>@Servicepublic class TicketService {    public String ticketService(){        System.out.println(&quot;8001端口的privoder-ticket服务&quot;);        return &quot;《你的名字》&quot;;    }}和@Servicepublic class TicketService {    public String ticketService(){        System.out.println(&quot;8002端口的privoder-ticket服务&quot;);        return &quot;《你的名字》&quot;;    }}</code></pre><p><img src="/images/QQ截图20181119165751.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与安全</title>
      <link href="/2018/11/18/spring-boot-yu-an-quan/"/>
      <url>/2018/11/18/spring-boot-yu-an-quan/</url>
      
        <content type="html"><![CDATA[<p>安全、Spring Security. 比如身份认证，用户权限等，市面上有两大主流安全框架：第一个是Apache的 <strong>Shiro</strong>，第二个就是Spring的<strong>Security</strong>。<br><a id="more"></a></p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p><strong>Spring Security</strong>是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。</p><p>几个类：</p><ul><li>WebSecurityConfigurerAdapter：自定义Security策略</li><li>AuthenticationManagerBuilder：自定义认证策略</li><li>@EnableWebSecurity：开启WebSecurity模式</li></ul><p>应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。</p><p>• “认证”（Authentication），是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。</p><p>• “授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。</p><p>• 这个概念是通用的而不只在Spring Security中。</p><p>1) 创建新的Springboot项目，添加Web、Themleaf模块：<br><img src="/images/QQ截图20181118110926.png"></p><p>2) 在resources中书写页面：<br><img src="/images/QQ截图20181118111136.png"></p><p>3）书写一个java类：(KungfuController)<br><img src="/images/QQ截图20181118111658.png"></p><pre><code>@Controllerpublic class KungfuController {    private final String PREFIX = &quot;pages/&quot;;    /**     * 欢迎页     *     * @return     */    @GetMapping(&quot;/&quot;)    public String index() {        return &quot;welcome&quot;;    }    /**     * 登陆页     *     * @return     */    @GetMapping(&quot;/userlogin&quot;)    public String loginPage() {        return PREFIX + &quot;login&quot;;    }    /**     * level1页面映射     *     * @param path     * @return     */    @GetMapping(&quot;/level1/{path}&quot;)    public String level1(@PathVariable(&quot;path&quot;) String path) {        return PREFIX + &quot;level1/&quot; + path;    }    /**     * level2页面映射     *     * @param path     * @return     */    @GetMapping(&quot;/level2/{path}&quot;)    public String level2(@PathVariable(&quot;path&quot;) String path) {        return PREFIX + &quot;level2/&quot; + path;    }    /**     * level3页面映射     *     * @param path     * @return     */    @GetMapping(&quot;/level3/{path}&quot;)    public String level3(@PathVariable(&quot;path&quot;) String path) {        return PREFIX + &quot;level3/&quot; + path;    }}</code></pre><p>这里，大家可以有自己的页面，和controller类，只是简单的访问页面而已，没有什么业务逻辑。</p><p>4）启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="/images/QQ截图20181118112006.png"><br><img src="/images/QQ截图20181118112040.png"></p><p>这里是，thymeleaf的版本比较低。<br><img src="/images/QQ截图20181118112604.png"></p><p>我们要切换成3版本以上的。切换thymeleaf的时候，不要忘记thymeleaf-layout的版本。<br><img src="/images/QQ截图20181118113001.png"></p><p>5）重启Springboot应用：<br><img src="/images/QQ截图20181118113131.png"></p><p>页面解析成功。</p><hr><p>上面，是没有使用Spring Security的功能，页面上的所有超链接都能访问。</p><h3 id="整合Spring-Security模块"><a href="#整合Spring-Security模块" class="headerlink" title="整合Spring Security模块"></a>整合Spring Security模块</h3><p>现在，我们加入Spring Security模块。</p><p>1）导入：spring-boot-starter-security<br><img src="/images/QQ截图20181118122302.png"></p><p>2）打开Spring的官网，找到Spring Security模块：<br><img src="/images/QQ截图20181118122433.png"><br><img src="/images/QQ截图20181118122802.png"></p><p><a href="https://docs.spring.io/spring-security/site/docs/4.2.8.RELEASE/guides/html5/helloworld-boot.html" target="_blank" rel="noopener">官方参考文档</a></p><p>说明，第一步，我们需要写一个Spring Security的配置类，标记@EnableWebSecurity注解，并且继承 WebSecurityConfigurerAdapter</p><p>在我们的项目中，添加config包，并创建MySecurityConfig类：<br><img src="/images/QQ截图20181118140618.png"></p><pre><code>@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter {    //设置访问权限的    @Override    protected void configure(HttpSecurity http) throws Exception {        //super.configure(http);        http.authorizeRequests().mvcMatchers(&quot;/&quot;).permitAll()                .mvcMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;)                .mvcMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;)                .mvcMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;);    }}</code></pre><p>以上的方法的，就是访问”/“: 所有的人都可以访问，而访问”/level1/**”下的请求，必须是”VIP1”用户，其他类似。</p><p>现在重启Springboot应用：<br><img src="/images/QQ截图20181118140836.png"></p><p>访问普通武功秘籍下的超链接：罗汉拳、武当长拳、全真剑法其中的任意一个。</p><p><strong>PS：普通武功秘籍是level1，高级武功秘籍是level2，绝世武功秘籍是level3</strong></p><p>比如访问：罗汉拳(/level1/1)<br><img src="/images/QQ截图20181118141225.png"></p><p>现在出现了，403：拒绝访问，即没有访问权限！</p><p>接下来，我们配置授权的用户：</p><p>修改configure方法：<br><img src="/images/QQ截图20181118141803.png"></p><p>此时重启，访问罗汉拳的话，会重定向到/login请求，请求登入：(Spring Security 自动帮我们配合的)<br><img src="/images/QQ截图20181118141855.png"></p><p>此时，还没有配置用户信息，在MySecurityConfig类：添加新的方法：<br><img src="/images/QQ截图20181118142152.png"></p><pre><code>    @Autowired    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {        auth.inMemoryAuthentication()                .withUser(&quot;zhangsan&quot;).password(&quot;123456&quot;).roles(&quot;VIP1&quot;,&quot;VIP2&quot;)                .and()                .withUser(&quot;lisi&quot;).password(&quot;123456&quot;).roles(&quot;VIP2&quot;,&quot;VIP3&quot;)                .and()                .withUser(&quot;wangwu&quot;).password(&quot;123456&quot;).roles(&quot;VIP1&quot;,&quot;VIP3&quot;);    }</code></pre><p><strong>注意：</strong>使用inMemoryAuthentication：是在内存中配合用户的信息，这里是简单起见，我们一般需要将配置保存到数据库中。</p><p>这里，配置了用户名：zhangsan，密码：123456，用户的角色是:VIP1,VIP2. 其他类似。</p><p>重启应用，访问罗汉拳：<br><img src="/images/QQ截图20181118142453.png"><br>登入用户和密码：zhangsan，123456<br><img src="/images/QQ截图20181118142545.png"><br><img src="/images/QQ截图20181118142639.png"><br>访问成功，有level1的权限。</p><p>点击返回，访问<strong>普通武功秘籍</strong> 和 <strong>高级武功秘籍</strong> 下的，<strong>其他秘籍</strong>，此时都不会被拦截了。</p><p>因为张三用户，有level1 和 level2 的访问权限。如果访问 <strong>绝世武功秘籍(level3)</strong>，就会出现403.</p><h3 id="注销登入"><a href="#注销登入" class="headerlink" title="注销登入"></a>注销登入</h3><p>现在，我们只能登入用户，还不能注销，怎么注销用户呢？</p><p>1）修改MySecurityConfig的：configure(HttpSecurity http)<br><img src="/images/QQ截图20181118144712.png"></p><pre><code>    //设置访问权限的    @Override    protected void configure(HttpSecurity http) throws Exception {        //super.configure(http);        http.authorizeRequests().mvcMatchers(&quot;/&quot;).permitAll()                .mvcMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;)                .mvcMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;)                .mvcMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;)                .and()                //自动配置了授权的,当没有权限的时候，会让你登入                //自动重定向到/login请求，请求登陆。                .formLogin();        //自动帮我们注销登入。        //1.需要在页面发一个/logout的post请求        //2.注销成功后，会重定向到：login?logout，会让你重新登入。        http.logout();    }</code></pre><p>2）在welcome页面中，添加注销的按钮：<br><img src="/images/QQ截图20181118144334.png"></p><p>3）启动程序</p><p>先登入用户成功，访问能访问的权限，都可以！然后点击注销按钮：<br><img src="/images/QQ截图20181118144520.png"><br><img src="/images/QQ截图20181118144648.png"></p><p>注销成功。</p><p>如果，我们不想让注销成功后，返回登入页面呢？那可以修改配置：<br><img src="/images/QQ截图20181118144937.png"></p><p>此时，注销成功后会跳转到主页了。</p><h3 id="完成我们的security模块"><a href="#完成我们的security模块" class="headerlink" title="完成我们的security模块"></a>完成我们的security模块</h3><p>现在，我们想让登入成功后，显示XX登入成功，给他看见能够访问的页面信息，不能访问的就不显示出来。</p><p>1）这里我们需要thymeleaf提供的安全的标签功能，需要导入相关的模块：<br><img src="/images/QQ截图20181118150104.png"></p><p>2）在我们的welcome页面中。添加安全的命名空间：</p><pre><code>xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot;</code></pre><p><img src="/images/QQ截图20181118150442.png"></p><p>接下来：我们就可以使用 sec 前缀的标签了。</p><p>给 登入 和 注销 添加 div 然后判断是否有权限：<br><img src="/images/QQ截图20181118150837.png"></p><p>给三大武功秘籍，添加用户权限：<br><img src="/images/QQ截图20181118151321.png"></p><p><img src="/images/QQ截图20181118151330.png"></p><p><img src="/images/QQ截图20181118151342.png"></p><p>重启应用：</p><p>观察我们的应用效果！</p><h3 id="记住我"><a href="#记住我" class="headerlink" title="记住我"></a>记住我</h3><p>只要在：MySecurityConfig 类中的：configure(HttpSecurity http)方法中：</p><pre><code>http.rememberMe();</code></pre><p>这样的话，spring Security就会记住密码，下次不需要登入，直接进入。原理就是发了一个remember-me的cookie而已。</p><hr><p>如果，想要修改登入界面，使用我们自己定义的登入页面：</p><pre><code>http.formLogin().loginPage(&quot;/userlogin&quot;);</code></pre><p>这样的话，就是发送这个/userlogin请求，跳转到我们自定义的页面，然后：使用 post请求的：/userlogin来登入。<br><img src="/images/QQ截图20181118164447.png"></p><p>这里的 用户名 和 密码的 name属性怎么设置呢？</p><p>使用：usernameParameter 和 passwordParameter 来修改。</p><p>默认是：username 和 password</p><p>即：不配置的话<br><img src="/images/QQ截图20181118164712.png"></p><p>配置的话：<br><img src="/images/QQ截图20181118164847.png"></p><pre><code>        //自动配置了授权的,当没有权限的时候，会让你登入        //自动重定向到/login请求，请求登陆。        http.formLogin().loginPage(&quot;/userlogin&quot;)                        .usernameParameter(&quot;uName&quot;)                        .passwordParameter(&quot;pName&quot;);</code></pre><p><img src="/images/QQ截图20181118164936.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与任务</title>
      <link href="/2018/11/17/spring-boot-yu-ren-wu/"/>
      <url>/2018/11/17/spring-boot-yu-ren-wu/</url>
      
        <content type="html"><![CDATA[<p>异步任务、定时任务、邮件任务<br><a id="more"></a></p><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>异步任务，是Spring帮我们开启线程池，创建一个新的线程来执行我们的方法，就不会有卡顿的现象。</p><p>在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用多线程来完成此类任务，其实，在Spring 3.x之后，就已经内置了@Async来完美解决这个问题。</p><p><font color="red"><strong>两个注解：</strong></font><br>@EnableAysnc、@Aysnc</p><p>1）创建Springboot项目，添加Web模块。<br><img src="/images/QQ截图20181117105809.png"></p><p>2) 创建service、controller模块<br><img src="/images/QQ截图20181117110232.png"><br><img src="/images/QQ截图20181117110258.png"></p><p>3）启动Springboot应用</p><p>在浏览器中输入：<code>http://localhost:8080/async</code><br><img src="/images/QQ截图20181117110457.png"><br><img src="/images/QQ截图20181117110539.png"></p><p>4) 修改成异步执行</p><p>添加@Async注解：表示是异步方法。<br><img src="/images/QQ截图20181117110723.png"></p><p>在启动类上，添加@EnableAsync注解<br><img src="/images/QQ截图20181117110835.png"></p><p>5）重启应用</p><p>在浏览器中输入：<code>http://localhost:8080/async</code></p><p>会发现，页面会瞬速响应，而控制台的执行任务的输出会停顿三秒。起到了异步的效果！</p><hr><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前一天的日志信息。Spring为我们提供了异步执行任务调度的方式，提供<strong>TaskExecutor 、TaskScheduler 接口</strong>。</p><p><font color="red"><strong>两个注解</strong>：</font><strong>@EnableScheduling、@Scheduled</strong></p><p><strong>cron表达式：</strong><br><img src="/images/QQ截图20181117111444.png" style="width:50%"><br><img src="/images/QQ截图20181117111511.png" style="width:50%"></p><p>1）在service包：创建ScheduledService：<br><img src="/images/QQ截图20181117113534.png"></p><pre><code>@Servicepublic class ScheduledService {    /**     * second(秒) , minute(分), hour(时), day of month(日), month(月) , day of week.(周几)     * 例子：[0 * * * * MON-SAT]:代表每月，每日，每时，每分每秒的周一到周六的0秒执行     */    @Scheduled(cron =&quot;0 * * * * MON-SAT&quot;)    public void hello(){        System.out.println(&quot;hello ···&quot;);    }}</code></pre><p>2）在启动类上，添加@EnableScheduling：<br><img src="/images/QQ截图20181117113223.png"></p><p>3）启动应用<br><img src="/images/QQ截图20181117113757.png"></p><p>更多写法：参考上面的<strong>cron表达式</strong></p><pre><code>,(逗号)：枚举的意思，[0,1,2,3,4 * * * * *]:就是0、1、2、3、4秒执行一次-(减号):区间的意思，[0-4 * * * * *] : 和上面的意思一样/(斜杆):步长的意思，[0/4 * * * * *]:就是0秒开始执行，每隔4秒执行一次当每日与周几冲突时，请使用 ？代替 *。</code></pre><p>案例：</p><pre><code>[0 0/5 14,18 * * ?]:每天14整点，和18整点，每隔5分钟执行一次。[0 15 10 ? * 1-6]: 每个月的周一到周六10:15:00执行一次[0 0 2 ？* 6L]:每个月的最后一个周六凌晨两点执行一次[0 0 2 LW * ?]:每个月的最后一个工作日凌晨两点执行一次[0 0 2-4 ? * 1#1]:每一个月的第一个周一凌晨2点到4点期间，每个整点，整秒执行一次。（ps：1#4 就是每个月的第四个周一）</code></pre><hr><h2 id="邮件任务"><a href="#邮件任务" class="headerlink" title="邮件任务"></a>邮件任务</h2><p>• 邮件发送需要引入spring-boot-starter-mail<br>• Spring Boot 自动配置MailSenderAutoConfiguration<br>• 定义MailProperties内容，配置在application.yml中<br>• 自动装配JavaMailSender<br>• 测试邮件发送</p><p>接下来，我们演示：使用QQ邮箱给163邮箱发送邮件的案例</p><p>1）导入spring-boot-starter-mail依赖：<br><img src="/images/QQ截图20181117120605.png"></p><p>2）配置邮件的信息：</p><p>spring.mail.username：设置发送者的邮箱的用户名</p><p>spring.mail.password：不是登入邮箱的密码，而是你的邮箱的服务器的生成的密码。</p><p>如果使用的是qq邮箱的话，打开qq邮箱，点击设置：<br><img src="/images/QQ截图20181117121032.png"></p><p>然后点击<strong>账号</strong>，找到POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务：<br><img src="/images/QQ截图20181117121208.png"></p><p>将POP3/SMTP服务开启，点击开启：<br><img src="/images/QQ截图20181117121406.png"></p><p>发送短信：点击我已发送：<br><img src="/images/QQ截图20181117121551.png"></p><p>看到下面的密码了，就是你的设置密码了。</p><p>spring.mail.password=eaqltjcbbababcje</p><p>spring.mail.host：配置的是你的邮箱服务器的SMTP地址<br><img src="/images/QQ截图20181117121909.png"><br><img src="/images/QQ截图20181117121941.png"></p><p>spring.mail.host=smtp.qq.com</p><p>完整的application配置文件内容：</p><pre><code>#qq邮箱的用户名spring.mail.username=575920824@qq.com#你的服务器生成的POP3安全密码spring.mail.password=eaqltjcbbababcje#配置的是你的邮箱服务器的SMTPspring.mail.host=smtp.qq.com</code></pre><p>3) 在测试类下，编写发送邮件的测试方法<br><img src="/images/QQ截图20181117123107.png"></p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot04TaskApplicationTests {    @Autowired    private JavaMailSenderImpl javaMailSender;    @Test    public void sendSimpleMail(){        SimpleMailMessage mailMessage = new SimpleMailMessage();        //设置主题        mailMessage.setSubject(&quot;今天下午7点到9点开会&quot;);        //设置正文        mailMessage.setText(&quot;关于XXX的会议&quot;);        //设置接受者：你的163邮箱的账号        mailMessage.setTo(&quot;18896991176@163.com&quot;);        //设置发送者        mailMessage.setFrom(&quot;575920824@qq.com&quot;);        javaMailSender.send(mailMessage);    }}</code></pre><p>4) 测试运行：<br><img src="/images/QQ截图20181117123236.png"></p><p>发送成功：如果你的出现异常，请在application配置文件中：</p><p>添加：spring.mail.properties.mail.smtp.sst.enable=true</p><p>打开你的163邮箱：<br><img src="/images/QQ截图20181117123535.png"><br><img src="/images/QQ截图20181117123558.png"><br><img src="/images/QQ截图20181117123648.png"></p><p>以上就是发送简单邮箱的方法，现在我们来发送复杂邮件，携带附件的邮箱：</p><pre><code>    @Test    public void sendMail() throws Exception{        //创建复杂邮件        MimeMessage mimeMessage = javaMailSender.createMimeMessage();         //new一个复杂邮件的工具类        //第二个参数：true，表示发送附件的邮箱        MimeMessageHelper message = new MimeMessageHelper(mimeMessage,true);        //设置主题        message.setSubject(&quot;今天下午7点到9点开会&quot;);        //设置正文,第二个参数：表示发送的是html的文本        message.setText(&quot;&lt;b style=&#39;color:red&#39;&gt;关于XXX的会议&lt;/b&gt;&quot;,true);        //设置接受者        message.setTo(&quot;18896991176@163.com&quot;);        //设置发送者        message.setFrom(&quot;575920824@qq.com&quot;);        //上传附件        message.addAttachment(&quot;1.jpg&quot;,new File(&quot;C:\\Users\\liuzhuo\\Pictures\\Saved Pictures\\123.jpg&quot;));        message.addAttachment(&quot;2.jpg&quot;,new File(&quot;C:\\Users\\liuzhuo\\Pictures\\Saved Pictures\\gakki.jpg&quot;));        //发送邮件        javaMailSender.send(mimeMessage);    }</code></pre><p>测试：<br><img src="/images/QQ截图20181117125016.png"><br><img src="/images/QQ截图20181117125041.png"><br><img src="/images/QQ截图20181117125238.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与检索</title>
      <link href="/2018/11/16/spring-boot-yu-jian-suo/"/>
      <url>/2018/11/16/spring-boot-yu-jian-suo/</url>
      
        <content type="html"><![CDATA[<p>ElasticSearch<br><a id="more"></a></p><h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><p>我们的应用经常需要添加检索功能，开源的 ElasticSearch 是目前全文搜索引擎的首选。他可以快速的存储、搜索和分析海量数据。Spring Boot通过整合SpringData ElasticSearch为我们提供了非常便捷的检索功能支持；</p><p>Elasticsearch是一个分布式搜索服务，提供Restful API，底层基于Lucene，采用多shard（分片）的方式保证数据安全，并且提供自动resharding的功能，github等大型的站点也是采用了ElasticSearch作为其搜索服务。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>以 <font color="red"><strong>员工文档</strong></font> 的形式存储为例：一个<font color="red"><strong>文档</strong></font>代表一个员工数据。存储数据到ElasticSearch 的行为叫做 <font color="red"><strong>索引</strong></font> ，但在索引一个文档之前，需要确定将文档存储在哪里。</p><p>一个 ElasticSearch 集群可以 包含多个 <font color="red"><strong>索引</strong></font> ，相应的每个索引可以包含多个 <font color="red"><strong>类型</strong></font> 。 这些不同的类型存储着多个 <font color="red"><strong>文档</strong> </font>，每个文档又有 多个 <font color="red"><strong>属性</strong> </font></p><p>类似关系：<br>– 索引-数据库<br>– 类型-表<br>– 文档-表中的记录<br>– 属性-列</p><p><img src="/images/QQ截图20181116154034.png"></p><p>打开官网 <a href="https://www.elastic.co/cn/products/elasticsearch" target="_blank" rel="noopener">ElasticSearch</a><br><img src="/images/QQ截图20181116155202.png"></p><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">《Elasticsearch: 权威指南》中文版</a></p><h2 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h2><p>打开我们的虚拟机，下载ElasticSearch镜像</p><pre><code>docker pull registry.docker-cn.com/library/elasticsearch</code></pre><p><img src="/images/QQ截图20181116161527.png"></p><p>elasticsearch:默认是使用2g的堆内存，直接启动的话，我们的虚拟机有可能不够，所以，我们需要设置elasticsearch的堆内存的大小：</p><p>使用 -e ES_JAVA_OPTS=”-Xms256m -Xmx256m” 来设置堆的最大、最小都是256兆。</p><p>完整的启动命令：<br>elasticsearch的默认端口号是9200，和分布式的节点之间通信的端口号：9300</p><pre><code>docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9200:9200 -p 9300:9300 --name ESO1 elasticsearch的镜像id</code></pre><p><img src="/images/QQ截图20181116161744.png"></p><p>打开浏览器，输入：<code>http://10.6.11.17:9200/</code><br><img src="/images/QQ截图20181116162123.png"></p><p>以上，说明ElasticSearch启动成功！</p><hr><h2 id="ElasticSearch简单操作"><a href="#ElasticSearch简单操作" class="headerlink" title="ElasticSearch简单操作"></a>ElasticSearch简单操作</h2><p>ElasticSearch：使用 RESTful API 通过端口 9200 进行通信，使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式。</p><p>考虑一下这个 JSON 文档，它代表了一个 user 对象：<br><img src="/images/QQ截图20181116162822.png"></p><hr><p>打开我们的postman工具<br><img src="/images/QQ截图20181116162539.png"></p><p>在Elasticsearch: 权威指南的基础入门中：适应新环境</p><p>例子为：创建一个雇员目录<br><img src="/images/QQ截图20181116163020.png"></p><p>对于雇员目录，我们将做如下操作：</p><ul><li><p>每个雇员索引一个文档，包含该雇员的所有信息。</p></li><li><p>每个文档都将是 employee 类型 。</p></li><li><p>该类型位于 索引 megacorp 内。</p></li><li><p>该索引保存在我们的 Elasticsearch 集群中。</p></li></ul><p>实践中这非常简单（尽管看起来有很多步骤），我们可以通过一条命令完成所有这些动作：</p><h3 id="创建雇员信息"><a href="#创建雇员信息" class="headerlink" title="创建雇员信息"></a>创建雇员信息</h3><p>在postman中：输入 <code>10.6.11.17:9200/megacorp/employee/1</code></p><p>选择：PUT请求 –&gt; Body –&gt; raw –&gt; JSON:</p><pre><code>{    &quot;first_name&quot; : &quot;John&quot;,    &quot;last_name&quot; :  &quot;Smith&quot;,    &quot;age&quot; :        25,    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]}</code></pre><p>点击Send发送：<br>响应数据：</p><pre><code>{    &quot;_index&quot;: &quot;megacorp&quot;,    &quot;_type&quot;: &quot;employee&quot;,    &quot;_id&quot;: &quot;1&quot;,    &quot;_version&quot;: 1,    &quot;result&quot;: &quot;created&quot;,    &quot;_shards&quot;: {        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    },    &quot;created&quot;: true}</code></pre><p><img src="/images/QQ截图20181116163804.png"></p><p>以上：我们就插入数据成功了。</p><p>注意，路径 /megacorp/employee/1 包含了三部分的信息：</p><p>megacorp：索引名称</p><p>employee：类型名称</p><p>1：特定雇员的ID</p><p>请求体 —— JSON 文档 —— 包含了这位员工的所有详细信息，他的名字叫 John Smith ，今年 25 岁，喜欢攀岩。</p><p>很简单！无需进行执行管理任务，如创建一个索引或指定每个属性的数据类型之类的，可以直接只索引一个文档。Elasticsearch 默认地完成其他一切，因此所有必需的管理任务都在后台使用默认设置完成。</p><p>进行下一步前，让我们增加更多的员工信息到目录中：<br><img src="/images/QQ截图20181116164222.png"><br><img src="/images/QQ截图20181116164537.png"></p><hr><h3 id="简单检索"><a href="#简单检索" class="headerlink" title="简单检索"></a>简单检索</h3><p>目前我们已经在 Elasticsearch 中存储了一些数据， 接下来就能专注于实现应用的业务需求了。第一个需求是可以检索到单个雇员的数据。</p><p>这在 Elasticsearch 中很简单。简单地执行 一个 HTTP GET 请求并指定文档的地址——索引库、类型和ID。 使用这三个信息可以返回原始的 JSON 文档：</p><p>GET /megacorp/employee/1<br><img src="/images/QQ截图20181116164722.png"></p><p>返回结果包含了文档的一些元数据，以及 _source 属性，内容是 John Smith 雇员的原始 JSON 文档：</p><pre><code>{  &quot;_index&quot; :   &quot;megacorp&quot;,  &quot;_type&quot; :    &quot;employee&quot;,  &quot;_id&quot; :      &quot;1&quot;,  &quot;_version&quot; : 1,  &quot;found&quot; :    true,  &quot;_source&quot; :  {      &quot;first_name&quot; :  &quot;John&quot;,      &quot;last_name&quot; :   &quot;Smith&quot;,      &quot;age&quot; :         25,      &quot;about&quot; :       &quot;I love to go rock climbing&quot;,      &quot;interests&quot;:  [ &quot;sports&quot;, &quot;music&quot; ]  }}</code></pre><p><strong>PS:将 HTTP 命令由 PUT 改为 GET 可以用来检索文档，同样的，可以使用 DELETE 命令来删除文档，以及使用 HEAD 指令来检查文档是否存在。如果想更新已存在的文档，只需再次 PUT 。</strong></p><h3 id="轻量检索"><a href="#轻量检索" class="headerlink" title="轻量检索"></a>轻量检索</h3><p>一个 GET 是相当简单的，可以直接得到指定的文档。 现在尝试点儿稍微高级的功能，比如一个简单的搜索！</p><p>第一个尝试的几乎是最简单的搜索了。我们使用下列请求来搜索所有雇员：</p><p>GET /megacorp/employee/_search</p><p><img src="/images/QQ截图20181116165326.png"></p><p>可以看到，我们仍然使用索引库 megacorp 以及类型 employee，但与指定一个文档 ID 不同，这次使用 _search 。返回结果包括了所有三个文档，放在数组 hits 中。一个搜索默认返回十条结果。</p><p>注意：返回结果不仅告知匹配了哪些文档，还包含了整个文档本身：显示搜索结果给最终用户所需的全部信息。</p><p>接下来，尝试下搜索姓氏为 <code>Smith</code> 的雇员。为此，我们将使用一个 高亮 搜索，很容易通过命令行完成。这个方法一般涉及到一个 查询字符串 （<em>query-string</em>） 搜索，因为我们通过一个URL参数来传递查询信息给搜索接口：</p><p>GET /megacorp/employee/_search?q=last_name:Smith</p><p>我们仍然在请求路径中使用 _search 端点，并将查询本身赋值给参数 q= 。返回结果给出了所有的 Smith：<br><img src="/images/QQ截图20181116165612.png"></p><hr><h3 id="使用查询表达式搜索"><a href="#使用查询表达式搜索" class="headerlink" title="使用查询表达式搜索"></a>使用查询表达式搜索</h3><p>Query-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性（参见 轻量 搜索 ）。Elasticsearch 提供一个丰富灵活的查询语言叫做 查询表达式 ， 它支持构建更加复杂和健壮的查询。</p><p>领域特定语言 （DSL）， 指定了使用一个 JSON 请求。我们可以像这样重写之前的查询所有 Smith 的搜索 </p><pre><code>GET /megacorp/employee/_search{    &quot;query&quot; : {        &quot;match&quot; : {            &quot;last_name&quot; : &quot;Smith&quot;        }    }}</code></pre><p>因为 GET请求，无法带这样格式的json请求参数，所以我们使用POST请求即可：<br><img src="/images/QQ截图20181116170032.png"></p><p>返回结果与之前的查询一样，但还是可以看到有一些变化。其中之一是，不再使用 query-string 参数，而是一个请求体替代。这个请求使用 JSON 构造，并使用了一个 match 查询（属于查询类型之一，后续将会了解）。</p><p><strong>更多的查询操作，请看ElasticSearch的官方文档即可</strong>：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><h2 id="整合Springboot与ElasticSearch"><a href="#整合Springboot与ElasticSearch" class="headerlink" title="整合Springboot与ElasticSearch"></a>整合Springboot与ElasticSearch</h2><p>1）创建Springboot的项目，添加web、ElasticSearch模块：<br><img src="/images/QQ截图20181116170704.png"><br><img src="/images/QQ截图20181116170735.png"><br><img src="/images/QQ截图20181116172604.png"></p><p>2）在autoconfig包下：<br><img src="/images/QQ截图20181116172848.png" style="width:50%"></p><p>发现有两处ElasticSearch：</p><ol><li><p>data包下，有一个ElasticSearch</p></li><li><p>直接在ElasticSearch包，有一个jest包</p></li></ol><p>即：Springboot提供了两种方式来使用ElasticSearch。</p><p>data包下的ElasticSearch是Springboot默认提供的。 </p><p>jest默认不支持的，需要jest的工具包(io.searchbox.client.JestClient)</p><h3 id="使用jest"><a href="#使用jest" class="headerlink" title="使用jest"></a>使用jest</h3><p>1）注释掉:spring-boot-starter-data-elasticsearch</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>添加jest的依赖包：<br>在mave中央仓库：搜索：jest<br><img src="/images/QQ截图20181116173628.png"></p><p>因为我的ElasticSearch的版本是：5.6.12<br><img src="/images/QQ截图20181116173725.png"></p><p>所以，jest的版本选择5.x.x的即可：</p><pre><code>&lt;!-- https://mvnrepository.com/artifact/io.searchbox/jest --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.searchbox&lt;/groupId&gt;    &lt;artifactId&gt;jest&lt;/artifactId&gt;    &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="/images/QQ截图20181116173907.png"></p><p>2) 打开：JestAutoConfiguration类<br><img src="/images/QQ截图20181116174005.png"></p><p>导入了一个：jestClient类</p><pre><code>    @Bean(destroyMethod = &quot;shutdownClient&quot;)    @ConditionalOnMissingBean    public JestClient jestClient() {        JestClientFactory factory = new JestClientFactory();        factory.setHttpClientConfig(createHttpClientConfig());        return factory.getObject();    }</code></pre><p>3）给application配置文件中，添加ElasticSearch的相关配置：</p><p>查看JestProperties类，了解需要配置哪些信息：<br><img src="/images/QQ截图20181116174251.png"></p><p>application：</p><pre><code>#ElasticSearch的相关配置spring.elasticsearch.jest.uris=http://10.6.11.17:9200  #虚拟机的ip地址</code></pre><p>4) 启动Springboot应用：<br><img src="/images/QQ截图20181116174615.png"></p><p>5）在测试类中测试：<br><img src="/images/QQ截图20181116174851.png"></p><p>6）编写一个POJO类：</p><p>在bean包，创建一个Article类：<br><img src="/images/QQ截图20181116175201.png"></p><pre><code>public class Article {    //标记id为ElasticSearch中的id    @JestId    private Integer id;    private String author;    private String title;    private String content;    set 和 get 方法}</code></pre><p>7）创建一个测试方法：<br><img src="/images/QQ截图20181116175854.png"></p><pre><code>    @Test    public void testInsert(){        Article article = new Article();        article.setId(1);        article.setAuthor(&quot;zhangsan&quot;);        article.setTitle(&quot;好消息&quot;);        article.setContent(&quot;Hello world!&quot;);        //创建一个：索引：liuzhuo , 类型：news ,id：使用了@JestId标记了id，这里可以不用设置了        Index index = new Index.Builder(article).index(&quot;liuzhuo&quot;).type(&quot;news&quot;).build();        try {            //执行            jestClient.execute(index);        } catch (IOException e) {            e.printStackTrace();        }    }</code></pre><p>执行testInsert()方法后：<br><img src="/images/QQ截图20181116184113.png"></p><p>在浏览器中，输入：<code>http://10.6.11.17:9200/liuzhuo/news/1</code><br><img src="/images/QQ截图20181116184216.png"></p><p>插入数据成功！</p><hr><p>现在，测试搜索功能：</p><p>使用：搜索content内容为：hello</p><pre><code>{    &quot;query&quot; : {        &quot;match&quot; : {            &quot;content&quot; : &quot;hello&quot;        }    }}</code></pre><p><img src="/images/QQ截图20181116185001.png"></p><pre><code>    @Test    public void search(){        String json =&quot;{\n&quot; +                &quot;    \&quot;query\&quot; : {\n&quot; +                &quot;        \&quot;match\&quot; : {\n&quot; +                &quot;            \&quot;content\&quot; : \&quot;hello\&quot;\n&quot; +                &quot;        }\n&quot; +                &quot;    }\n&quot; +                &quot;}&quot;;        //构建搜索功能        Search search = new Search.Builder(json).addIndex(&quot;liuzhuo&quot;).addType(&quot;news&quot;).build();        try {            SearchResult result = jestClient.execute(search);            System.out.println(result.getJsonString());        } catch (IOException e) {            e.printStackTrace();        }    }</code></pre><p>运行测试：search()方法：<br><img src="/images/QQ截图20181116185155.png"></p><p>更多：jest的操作，可以看jest的文档。</p><p>打开github的官网，搜索 jest<br><img src="/images/QQ截图20181116185510.png"><br><img src="/images/QQ截图20181116185604.png"><br><img src="/images/QQ截图20181116185712.png"></p><h3 id="使用SpringData"><a href="#使用SpringData" class="headerlink" title="使用SpringData"></a>使用SpringData</h3><p>1）在pom文件中：放开spring-boot-starter-data-elasticsearch的注释</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>打开：ElasticsearchAutoConfiguration类：<br><img src="/images/QQ截图20181116190656.png"></p><p>再看：ElasticsearchDataAutoConfiguration类：<br><img src="/images/QQ截图20181116190900.png"></p><p>导入了一个：ElasticsearchTemplate 来操作ElasticSearch的模板类</p><p>使用：ElasticsearchProperties 来配置相关信息：</p><p>Client：节点的信息 clusterName：名字，clusterNodes：操作的节点ip地址</p><p>编写了一个ElasticSearchRepository的子接口来操作ES。</p><p>2）在application配置文件中：添加SpringData的ES信息<br><img src="/images/QQ截图20181116195934.png"></p><pre><code>#使用SprigData的ES配置信息spring.data.elasticsearch.cluster-name=elasticsearch #默认也elasticsearch#使用9300端口通信，与jest不同！！！spring.data.elasticsearch.cluster-nodes=10.6.11.17:9300</code></pre><p>spring.data.elasticsearch.cluster-name:怎么确定的呢？</p><p>在浏览器中输入：<code>http://10.6.11.17:9200/</code><br><img src="/images/QQ截图20181116191639.png"></p><p>3) 启动Springboot应用：<br><img src="/images/QQ截图20181116200034.png"></p><p>出现了异常！！！异常错误，连接超时！！！</p><p>why？ 这是因为我们的ElasticSearch是5.6.12，而导入的SpringData的ElasticSearch依赖是2.4.6<br><img src="/images/QQ截图20181116192036.png"><br><img src="/images/QQ截图20181116192001.png" style="width:50%"></p><p>版本不一致产生的异常。</p><p>怎样确定 SpringData-ElasticSearch 与 ElasticSearch 的版本对应关系呢？</p><p>打开Spring的官网，找到Spring data模块<br><img src="/images/QQ截图20181116193409.png"><br><img src="/images/QQ截图20181116193435.png"><br><img src="/images/QQ截图20181116193714.png"><br><img src="/images/QQ截图20181116193935.png"><br><img src="/images/QQ截图20181116194020.png"></p><p>所以，现在有两种方案：</p><p>1）升级Springboot的版本，将Springboot升级到3.0.x以后。</p><p>2）下载2.x.x的ElasticSearc</p><p>我这里选择下载第二种方案：</p><p>打开docker的hub仓库，搜索ElasticSearch<br><img src="/images/QQ截图20181116194312.png"><br><img src="/images/QQ截图20181116194414.png"></p><p>打开虚拟机的客户端：</p><p>输入：</p><pre><code>docker pull registry.docker-cn.com/library/elasticsearch:2.4.6</code></pre><p><img src="/images/QQ截图20181116194702.png"></p><p>启动 2.4.6 版本的ElasticSearch。</p><p>因为 9200 和 9300 的docker端口号已经被 5版本的ElasticSearch占领了，所以选择 9201 和 9301端口号</p><pre><code>docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9201:9200 -p 9301:9300 --name ESO2 elasticsearch的镜像id</code></pre><p><img src="/images/QQ截图20181116195123.png"></p><p>在浏览器中输入：<code>http://10.6.11.17:9201/</code><br><img src="/images/QQ截图20181116195248.png"></p><p>以上，2.4.6 的ElasticSearch启动成功。</p><p>4）修改application配置文件：<br><img src="/images/QQ截图20181116200335.png"></p><pre><code>#ElasticSearch的相关配置spring.elasticsearch.jest.uris=http://10.6.11.17:9200#使用SprigData的ES配置信息spring.data.elasticsearch.cluster-name=elasticsearch#使用9300端口通信，与jest不同！！！spring.data.elasticsearch.cluster-nodes=10.6.11.17:9301</code></pre><p>5）启动Springboot应用：<br><img src="/images/QQ截图20181116200556.png"></p><p>两种使用ElasticSearch的配置，都启动成功了。现在我们只使用SpringData操作ElasticSearch的方式。</p><p>SpringData：提供了两种方式来操作ElasticSearc：</p><p>1）使用 ElasticsearchRepository</p><p>2）使用 ElasticsearchTemplate</p><hr><p>6）使用 ElasticsearchRepository</p><p>在bean包下，创建Book类：<br><img src="/images/QQ截图20181116200928.png"></p><p>在repository包下，创建bookRepository接口，继承ElasticsearchRepository：<br><img src="/images/QQ截图20181116201218.png"></p><p>在test类下，注入bookRepository<br><img src="/images/QQ截图20181116201453.png"></p><p>但是，发现index方法，没法设置 索引，类型，id。其实我们需要在Book类上，添加@Document注解，来设置索引和类型</p><pre><code>@Document(indexName = &quot;liuzhuo&quot;,type = &quot;book&quot;)public class Book {</code></pre><p>启动测试方法：<br><img src="/images/QQ截图20181116201909.png"></p><p>在浏览器中输入：<code>http://10.6.11.17:9201/liuzhuo/book/_search</code> 查询索引是liuzhuo，类型是book的所有数据：<br><img src="/images/QQ截图20181116202042.png"></p><p>修改测试方法：</p><pre><code>    @Test    public void test() {        Book book = new Book();        book.setId(1);        book.setBookName(&quot;西游记&quot;);        book.setAuthor(&quot;罗贯中&quot;);        bookRepository.index(book);    }</code></pre><p>运行测试方法：<br><img src="/images/QQ截图20181116202244.png"></p><p>我们还有可以直接在BookRepository接口中，编写接口，就和JPA一样：<br><img src="/images/QQ截图20181116202524.png"></p><pre><code>//泛型上面的参数：查找的类型 和 id的类型public interface BookRepository extends ElasticsearchRepository&lt;Book,Integer&gt; {    //根据book的名字来模糊匹配所有的book    public List&lt;Book&gt; findByBookNameLike(String bookName);}</code></pre><pre><code>    @Test    public void searchBook(){        List&lt;Book&gt; bookList = bookRepository.findByBookNameLike(&quot;游&quot;);        for (Book book : bookList) {            System.out.println(book);        }    }</code></pre><p><img src="/images/QQ截图20181116202952.png"></p><p>更多用法：请看官方文档：<a href="https://docs.spring.io/spring-data/elasticsearch/docs/2.1.16.RELEASE/reference/html/" target="_blank" rel="noopener">https://docs.spring.io/spring-data/elasticsearch/docs/2.1.16.RELEASE/reference/html/</a><br><img src="/images/QQ截图20181116203116.png"><br><img src="/images/QQ截图20181116203245.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与消息</title>
      <link href="/2018/11/15/spring-boot-yu-xiao-xi/"/>
      <url>/2018/11/15/spring-boot-yu-xiao-xi/</url>
      
        <content type="html"><![CDATA[<p>JMS、AMQP、RabbitMQ的消息处理机制<br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>1）大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力</p><p>2）消息服务中两个重要概念：<font color="red">消息代理（message broker）</font> 和 <font color="red">目的地（destination）</font></p><p>　 当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息并且传递信息到指定目的地。</p><p>3）消息队列主要有两种形式的目的地</p><p>　　1）<font color="red">队列</font>：点对点消息通信（point-to-point）<br>　　2）<font color="red">主题</font>：发布（publish）/订阅（subscribe）消息通信</p><p>4）点对点式</p><p>　　消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列<br>　　<strong>消息只有唯一的发送者和接受者，但并不是说只能有一个接收者。</strong></p><p>5）发布订阅式</p><p>　　发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息。</p><p>6）JMS（Java Message Service）JAVA消息服务</p><p>　　基于JVM消息代理的规范。<strong>ActiveMQ</strong>、HornetMQ是JMS实现。</p><p>7）AMQP（Advanced Message Queuing Protocol）</p><p>　　高级消息队列协议，也是一个消息代理的规范，兼容JMS。<strong>RabbitMQ</strong>是AMQP的实现。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p><img src="/images/QQ截图20181115131013.png"></p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p><img src="/images/QQ截图20181115131131.png"></p><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p><img src="/images/QQ截图20181115131347.png"></p><h2 id="JMS与AMQP的区别"><a href="#JMS与AMQP的区别" class="headerlink" title="JMS与AMQP的区别"></a>JMS与AMQP的区别</h2><p><img src="/images/QQ截图20181115131921.png"></p><p>主要区别：JMS是基于javaEE规范的，所以不跨语言，不跨平台，如果你的系统都是基于java开发的，那么使用JMS没有问题。<br>AMQP：跨语言，跨平台。</p><hr><h2 id="Spring支持消息服务"><a href="#Spring支持消息服务" class="headerlink" title="Spring支持消息服务"></a>Spring支持消息服务</h2><p>　　spring-jms提供了对JMS的支持</p><p>　　spring-rabbit提供了对AMQP的支持</p><p>　　需要ConnectionFactory的实现来连接消息代理</p><p>　　<strong>提供JmsTemplate、RabbitTemplate来发送消息</strong></p><p>　　<strong>@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息</strong></p><p>　　<strong>@EnableJms、@EnableRabbit开启支持</strong></p><h2 id="Springboot自动配置消息服务"><a href="#Springboot自动配置消息服务" class="headerlink" title="Springboot自动配置消息服务"></a>Springboot自动配置消息服务</h2><p>　　<strong>JmsAutoConfiguration</strong></p><p>　　<strong>RabbitAutoConfiguration</strong></p><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><p><strong>RabbitMQ简介：</strong></p><p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</p><p><strong>核心概念</strong></p><p><font color="blue">Message：</font><br>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><p><font color="blue">Publisher:</font><br>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><p><font color="blue">Exchange:</font><br>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别.</p><p><font color="blue">Queue：</font><br>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><font color="blue">Binding：</font><br>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由。Exchange 和Queue的绑定可以是多对多的关系。</p><p><font color="blue">Connection：</font><br>网络连接，比如一个TCP连接。</p><p><font color="blue">Channel：</font><br>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><p><font color="blue">Consumer：</font><br>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><p><font color="blue">Virtual Host：</font><br>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><p><font color="blue">Broker：</font><br>表示消息队列服务器实体。</p><p><img src="/images/QQ截图20181115133357.png"></p><h2 id="RabbitMQ运行机制"><a href="#RabbitMQ运行机制" class="headerlink" title="RabbitMQ运行机制"></a>RabbitMQ运行机制</h2><p>AMQP 中的消息路由：</p><p>　　AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了<strong>Exchange</strong> 和 <strong>Binding</strong> 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。<br><img src="/images/QQ截图20181115135917.png"></p><p>Exchange 类型：</p><p>　　 Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：<strong>direct、fanout、topic</strong>、headers 。headers 匹配 AMQP 消息的 header，而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p><h3 id="direct："><a href="#direct：" class="headerlink" title="direct："></a>direct：</h3><p>消息中的路由键（routing key）如果和 Binding 中的 bindingkey 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。<strong>它是完全匹配、单播的模式。</strong><br><img src="/images/QQ截图20181115140202.png"></p><h3 id="fanout："><a href="#fanout：" class="headerlink" title="fanout："></a>fanout：</h3><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网<strong>广播</strong>，每台子网内的主机都获得了一份复制的消息。<strong>fanout 类型转发消息是最快的。</strong><br><img src="/images/QQ截图20181115140400.png"></p><h3 id="topic："><a href="#topic：" class="headerlink" title="topic："></a>topic：</h3><p>topic 交换器通过<strong>模式匹配</strong>分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些 单词之间用点隔开。它同样也会识别两个通配符：符号“ <code>#</code> ”和符号“ <code>*</code> ”。 # 匹配 0 个或多个单词， * 匹配一个单词。<br><img src="/images/QQ截图20181115140644.png"></p><h2 id="RabbitMQ整合"><a href="#RabbitMQ整合" class="headerlink" title="RabbitMQ整合"></a>RabbitMQ整合</h2><p>全局整合步骤：</p><ol><li><p><strong>引入 spring-boot-starter-amqp</strong></p></li><li><p><strong>application.yml配置</strong></p></li><li><p><strong>测试RabbitMQ</strong></p><ol><li><p>AmqpAdmin：管理组件</p></li><li><p>RabbitTemplate：消息发送处理组件</p></li></ol></li></ol><hr><h3 id="安装rabbitmq：docker镜像"><a href="#安装rabbitmq：docker镜像" class="headerlink" title="安装rabbitmq：docker镜像"></a>安装rabbitmq：docker镜像</h3><p>打开虚拟机，连接虚拟机：<br><img src="/images/QQ截图20181115143023.png"></p><p>在docker hub中：搜索rabbitmq：<br><img src="/images/QQ截图20181115143549.png"></p><p>点击tags：选择带有manager的标签，因为这样的rabbitmq会带有管理消息队列的界面。</p><p>我这里就选择：3.6-management<br><img src="/images/QQ截图20181115143811.png"></p><p>在虚拟机客户端：输入 <code>docker pull registry.docker-cn.com/library/rabbitmq:3.6-management</code></p><p>前缀：registry.docker-cn.com/library/   是加速的功能！！！</p><p>下载完成：<br><img src="/images/QQ截图20181115144251.png"></p><p>运行rabbitmq镜像：</p><p>输入：<code>docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq registry.docker-cn.com/library/rabbitmq:3.6-management</code></p><p><strong>注意：这里有两个端口号，5672是rabbitmq的默认端口号，15672是rabbitmq的界面管理的端口号</strong><br><img src="/images/QQ截图20181115175455.png"></p><p>验证是否启动成功：</p><p>在浏览器中输入：<code>http://10.6.11.17:15672/</code> 这里的ip地址是你的虚拟机的ip地址。<br><img src="/images/QQ截图20181115145020.png"></p><p>用户名和密码都是：guest<br><img src="/images/QQ截图20181115145130.png"></p><p>这里，我们主要关注 Exchanges 和 Queues。</p><p>现在我们来根据下图的 Exchange 和 Queue 来设置、验证。<br><img src="/images/QQ截图20181115145557.png"></p><p>图中，我们有三个类型的Exchange：</p><p>exchange.direct ：direct类型的Exchange</p><p>exchange.fanout：fanout类型的Exchange</p><p>exchange.topic：topic类型的Exchange</p><p>四个Queue：</p><p>liuzhuo、liuzhuo.news、liuzhuo.emps、gakki.news</p><hr><p>现在，我们在rabbitmq管理界面中，添加上诉的 Exchange 和 Queue</p><p>点击：Exchanges，然后点击：Add a new exchange<br><img src="/images/QQ截图20181115150037.png"><br><img src="/images/QQ截图20181115150358.png"><br><img src="/images/QQ截图20181115150454.png"><br><img src="/images/QQ截图20181115150521.png"></p><p>三个类型的Exchange添加成功后：<br><img src="/images/QQ截图20181115150616.png"></p><hr><p>点击：Queues，然后点击：Add a new queue<br><img src="/images/QQ截图20181115150740.png"><br><img src="/images/QQ截图20181115150835.png"><br><img src="/images/QQ截图20181115150916.png"><br><img src="/images/QQ截图20181115150941.png"><br><img src="/images/QQ截图20181115151007.png"></p><p>四个queue添加成功后：<br><img src="/images/QQ截图20181115151047.png"></p><hr><p>现在，将Exchange和queue绑定在一起：</p><p>点击：exchange.direct，再点击Bindings：<br><img src="/images/QQ截图20181115151512.png"><br><img src="/images/QQ截图20181115151546.png"><br><img src="/images/QQ截图20181115151612.png"><br><img src="/images/QQ截图20181115151639.png"></p><p>exchange.direct 绑定四个队列成功后：</p><p><img src="/images/QQ截图20181115151828.png"></p><p>现在，在exchange.direct下，发送消息：（点击Publish message）<br><img src="/images/QQ截图20181115152200.png"></p><p>direct类型的Exchange，是一对一的形式，虽然exchange.direct绑定了四个队列，但是只要liuzhuo路由键的队列才能收到消息：</p><p>点击Queues<br><img src="/images/QQ截图20181115152416.png"><br>点击liuzhuo队列，查看具体的消息<br><img src="/images/QQ截图20181115152548.png"></p><hr><p>给 exchange.fanout 也绑定 四个队列：<br><img src="/images/QQ截图20181115152858.png"><br>类推：四个队列绑定成功后：<br><img src="/images/QQ截图20181115153100.png"></p><p>现在，在exchange.fanout下，发送消息：<br><img src="/images/QQ截图20181115153320.png"></p><p>发送消息之后，四个消息队列都会收到消息：<br><img src="/images/QQ截图20181115153426.png"><br><img src="/images/QQ截图20181115153536.png"></p><hr><p>给 exchange.topic 绑定模式匹配的消息队列：<br><img src="/images/QQ截图20181115153958.png"><br><img src="/images/QQ截图20181115154107.png"><br><img src="/images/QQ截图20181115154137.png"></p><p>最后：<br><img src="/images/QQ截图20181115154227.png"></p><p>在 exchange.topic 下 ，发送消息：<br><img src="/images/QQ截图20181115154442.png"></p><p>查看消息队列：<br><img src="/images/QQ截图20181115154546.png"><br><img src="/images/QQ截图20181115154656.png"></p><p><strong>大家有可能看不到topic的消息，因为你们没有移除消息，看到都是第一条消息，看不到后面的消息。</strong><br><img src="/images/QQ截图20181115155028.png"></p><p>改为false后，点击Get Message(s)后，会 <strong>获取当前消息</strong> 并 <strong>移除当前消息</strong>。</p><h3 id="整合rabbitmq到Springboot中"><a href="#整合rabbitmq到Springboot中" class="headerlink" title="整合rabbitmq到Springboot中"></a>整合rabbitmq到Springboot中</h3><p>1）创建新的Springboot工程：<br><img src="/images/QQ截图20181115163556.png"><br><img src="/images/QQ截图20181115163639.png"><br><img src="/images/QQ截图20181115170221.png"></p><p>只要导入了amqp的starter，Springboot就会自动帮我们配置rabbitmq。</p><p>原理：</p><p>打开：RabbitAutoConfiguration<br><img src="/images/QQ截图20181115170518.png"></p><ol><li>帮我们创建了RabbitConnectionFactoryCreator：rabbitmq的工厂连接器。</li><li><p>使用RabbitProperties类，来配置rabbitmq。<br><img src="/images/QQ截图20181115170755.png"></p></li><li><p>创建rabbitTemplate来操作rabbitmq<br><img src="/images/QQ截图20181115170904.png"></p></li><li><p>创建了AmqpAdmin：来管理rabbitmq的组件<br><img src="/images/QQ截图20181115171113.png"></p></li></ol><hr><p>现在，我们来使用Springboot帮我们注入的rabbitTemplate来操作rabbitmq：</p><p>在application配置文件中：<br><img src="/images/QQ截图20181115172810.png"></p><pre><code>#配置rabbitmq的信息spring.rabbitmq.host=10.6.11.17spring.rabbitmq.username=guestspring.rabbitmq.password=guest#spring.rabbitmq.port=5672        //默认就是5672，可以不配置#spring.rabbitmq.virtual-host=/   //默认就是/的虚拟主机，可以不配置</code></pre><p>在test包下，测试我们的rabbitTemplate：<br><img src="/images/QQ截图20181115171844.png"></p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot02AmqpApplicationTests {    @Autowired    private RabbitTemplate rabbitTemplate;    @Test    public void test01(){                //exchange:Exchange交换机        //routingKey:路由键        //message:消息体，需要自己实现。        //rabbitTemplate.send(exchange,routingKey,message);        //object:消息的内容，我们不需要自己写消息头，消息体了，自动帮我们        //解析。所以一般我们使用：convertAndSend        //rabbitTemplate.convertAndSend(exchange,routingKey,object);        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;id&quot;,&quot;1&quot;);        map.put(&quot;name&quot;,&quot;zhangsan&quot;);        rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;liuzhuo.news&quot;,map);    }    @Test    public void contextLoads() {    }}</code></pre><p>清空，我们消息队列中的消息：<br><img src="/images/QQ截图20181115172310.png"></p><p>执行test01：<br><img src="/images/QQ截图20181115175833.png"></p><p>打开：Queues<br><img src="/images/QQ截图20181115180117.png"><br><img src="/images/QQ截图20181115180249.png"></p><p>消息发送成功，只是是以jdk序列化的形式序列化消息的。</p><p>从消息队列中，获取消息：</p><p>再写一个测试方法：</p><pre><code>@Testpublic void test02(){    //参数：队列的名字    Object o = rabbitTemplate.receiveAndConvert(&quot;liuzhuo.news&quot;);    System.out.println(o.getClass());    System.out.println(o);}</code></pre><p>执行该测试方法：<br><img src="/images/QQ截图20181115180643.png"></p><hr><p>现在，我们修改一下，序列化的方式：</p><p>默认的序列化的是：</p><pre><code>private volatile MessageConverter messageConverter = new SimpleMessageConverter();</code></pre><p>在config下：创建RabbitmqConfig配置类：</p><p>配置：json的序列化器：<br>org.springframework.amqp.support.converter.MessageConverter<br>在MessageConverter上，ctrl+H：<br><img src="/images/QQ截图20181115184655.png" style="width:50%"><br>Springboot已经帮我们，创建好了json的序列化器。</p><p>直接注册到容器即可：<br><img src="/images/QQ截图20181115184554.png"></p><p>现在，容器就会使用Jackson2JsonMessageConverter()，不会使用默认的new SimpleMessageConverter()。</p><hr><p>再次运行test01():<br><img src="/images/QQ截图20181115185107.png"></p><p>再次运行test02():<br><img src="/images/QQ截图20181115185214.png"></p><hr><p>在bean包下，创建person类：<br><img src="/images/QQ截图20181115185350.png"></p><p><strong>注意：提供get和set方法</strong></p><p>修改test01方法：</p><pre><code>    @Test    public void test01(){        Person person = new Person(&quot;dengjie&quot;,18);        rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;liuzhuo.news&quot;,person);    }</code></pre><p>修改test02方法：</p><pre><code>@Testpublic void test02(){    //参数：队列的名字    Person person = (Person) rabbitTemplate.receiveAndConvert(&quot;liuzhuo.news&quot;);    System.out.println(person.getClass());    System.out.println(person);}</code></pre><p>运行test01：<br><img src="/images/QQ截图20181115190126.png"></p><p>运行test02：<br><img src="/images/QQ截图20181115190228.png"></p><p>json序列化成功！！！</p><hr><p>以上都是我们发送消息，然后手动获取消息。现在我们使用rabbitmq的注解监听器来自动帮我们获取消息队列中的消息。</p><p>在service包下，创建PersonService：<br><img src="/images/QQ截图20181115191858.png"></p><p>在启动类中，开启rabbitmq的注解启动功能：<br>@EnableRabbit<br><img src="/images/QQ截图20181115191955.png"></p><p>启动Springboot应用：</p><p>然后运行test01：给liuzhuo.news队列中，发送一个消息。<br><img src="/images/QQ截图20181115192156.png"></p><p>打开控制台：<br><img src="/images/QQ截图20181115192236.png"></p><p>监听liuzhuo.news队列成功。</p><p>如果，我们想要获取消息的更多信息，比如消息头、消息体。</p><p>在PersonService中：(使用Message参数)</p><pre><code>    //监听liuzhuo队列中的消息    @RabbitListener(queues = &quot;liuzhuo&quot;)    public void messager(Message message){        //获取消息头的信息        System.out.println(message.getMessageProperties());        //获取消息体的内容        System.out.println(message.getBody());    }</code></pre><p>打开queues的界面:(查看liuzhuo队列)<br><img src="/images/QQ截图20181115192855.png"></p><p>里面已经有两个数据了，现在我们重启Springboot应用：<br>在启动的过程中：<br><img src="/images/QQ截图20181115193013.png"></p><hr><p>以上的操作，都是基于：Exchange 和 queue 存在的情况下。这么组件的创建都是基于rabbitmq的界面操作，如果我们想要在代码中创建呢？</p><p>这样，我们可以使用Springboot帮自动注入的AmqpAdmin组件，AmqpAdmin可以创建、删除、绑定：Exchange 和 queue。</p><p>在test包下的测试类中：<br><img src="/images/QQ截图20181115194641.png"></p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot02AmqpApplicationTests {    @Autowired    private RabbitTemplate rabbitTemplate;    @Autowired    private AmqpAdmin rabbitAmqpAdmin;    @Test    public void testRabbitAdmin(){        //创建exchange        rabbitAmqpAdmin.declareExchange(new DirectExchange(&quot;amqp.exchange&quot;));        //创建queue        rabbitAmqpAdmin.declareQueue(new Queue(&quot;amqp.queue&quot;));    }    ····}</code></pre><p>运行测试方法：testRabbitAdmin()<br><img src="/images/QQ截图20181115194827.png"><br><img src="/images/QQ截图20181115194855.png"></p><p>test:</p><pre><code>    @Test    public void bing(){        //绑定exchange与queue        rabbitAmqpAdmin.declareBinding(new Binding(&quot;amqp.queue&quot;, Binding.DestinationType.QUEUE,&quot;amqp.exchange&quot;,&quot;amqp.key&quot;,null));    }</code></pre><p>运行该测试方法：<br><img src="/images/QQ截图20181115195315.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 消息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与缓存</title>
      <link href="/2018/11/13/spring-boot-yu-huan-cun/"/>
      <url>/2018/11/13/spring-boot-yu-huan-cun/</url>
      
        <content type="html"><![CDATA[<p>JSR-107、Spring缓存抽象、整合Redis<br><a id="more"></a></p><h2 id="JSR107"><a href="#JSR107" class="headerlink" title="JSR107"></a>JSR107</h2><p>Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。</p><ol><li><p>CachingProvider：定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可<br>以在运行期访问多个CachingProvider。</p></li><li><p>CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache<br>存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。</p></li><li><p>Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个<br>CacheManager所拥有。</p></li><li><p>Entry 是一个存储在Cache中的key-value对。</p></li><li><p>Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期<br>的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。</p></li></ol><p><img src="/images/QQ截图20181113103324.png"></p><p>JSR107:定义的缓存规范，比较复杂，一般我们很少使用，接下来我们看看Spring的缓存抽象。</p><h2 id="Spring缓存抽象"><a href="#Spring缓存抽象" class="headerlink" title="Spring缓存抽象"></a>Spring缓存抽象</h2><p>Spring从3.1开始定义了org.springframework.cache.<strong>Cache</strong>和org.springframework.cache.<strong>CacheManager</strong>接口来统一不同的缓存技术；并支持使用JCache（JSR-107）<strong>注解</strong>简化我们开发；</p><ul><li><p>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；</p></li><li><p>Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache,ConcurrentMapCache等；</p></li><li><p>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</p></li><li><p>使用Spring缓存抽象时我们需要关注以下两点；</p></li></ul><p>　　1.确定方法需要被缓存以及他们的缓存策略</p><p>　　2.从缓存中读取之前缓存存储的数据</p><hr><p><img src="/images/QQ截图20181113103919.png"></p><h2 id="几个重要概念-amp-缓存注解"><a href="#几个重要概念-amp-缓存注解" class="headerlink" title="几个重要概念&amp;缓存注解"></a>几个重要概念&amp;缓存注解</h2><p><img src="/images/QQ截图20181113104138.png"><br><img src="/images/QQ截图20181113104254.png"><br><img src="/images/QQ截图20181113104630.png"></p><h2 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h2><ol><li><p>引入spring-boot-starter-cache模块</p></li><li><p>@EnableCaching开启缓存</p></li><li><p>使用缓存注解</p></li><li><p>切换为其他缓存</p></li></ol><hr><h3 id="搭建基本环境"><a href="#搭建基本环境" class="headerlink" title="搭建基本环境"></a>搭建基本环境</h3><p>1）导入数据库文件，创建出department和employee表：</p><p>打开Navicat：mysql客户端。创建本地的数据库spring_cache</p><p><img src="/images/QQ截图20181113114130.png"></p><p>将spring_cache.sql文件导入到spring_cache数据库中</p><p>spring_cache.sql:</p><pre><code>SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `departmentName` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Table structure for employee-- ----------------------------DROP TABLE IF EXISTS `employee`;CREATE TABLE `employee` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `lastName` varchar(255) DEFAULT NULL,  `email` varchar(255) DEFAULT NULL,  `gender` int(2) DEFAULT NULL,  `d_id` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><p>导入成功后，会生成 department和employee表。（大家实在不会，手动创建也行）<br><img src="/images/QQ截图20181113114431.png"></p><p>2）打开idea创建Springboot项目。选择cache、web、mysql、mybatis模块<br><img src="/images/QQ截图20181113115000.png"><br><img src="/images/QQ截图20181113115035.png"><br><img src="/images/QQ截图20181113115102.png"></p><p><img src="/images/QQ截图20181113115139.png"><br><img src="/images/QQ截图20181113150553.png"></p><p>3）创建对应的 javaBean对象：（ department 和 employee ）<br><img src="/images/QQ截图20181113150738.png"><br><img src="/images/QQ截图20181113150806.png"></p><p>4）配置数据库信息</p><p>在application配置文件中：<br><img src="/images/QQ截图20181113151529.png"></p><pre><code>#数据库连接spring.datasource.url=jdbc:mysql://localhost:3306/spring_cachespring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver#mybatis的驼峰命令:dId=d_idmybatis.configuration.map-underscore-to-camel-case=true</code></pre><p>5) 整合mybatis</p><p>创建mapper包：并创建 DepartmentMapper 和 EmployeeMapper</p><p>如果不清楚Mybatis与Springboot的整合，去看Springboot的基础里面的数据部分。<a href="https://gakkil.top/2018/11/11/SpringBoot-day-08/#%E6%95%B4%E5%90%88MyBatis" target="_blank" rel="noopener">Mybatis整合</a></p><p><img src="/images/QQ截图20181113152057.png"></p><pre><code>@Mapperpublic interface EmployeeMapper {    //获取Employee对象    @Select(&quot;select * from employee where id =#{id}&quot;)    public Employee getEmployeeById(Integer id);    //更新Employee对象    @Update(&quot;update employee set lastName=#{lastName},email=#{email},gender=#{gender},d_id=#{dId} where id=#{id}&quot;)    public Employee updateEmployee(Employee employee);    //删除employee对象    @Delete(&quot;delete from employee where id=#{id}&quot;)    public void deleteEmployeeById(Integer id);    //增加employee对象    @Insert(&quot;insert into employee(lastName,email,gender,d_id) values(#{lastName},#{email},#{gender},#{dId})&quot;)    public void insertEmployee(Employee employee);}</code></pre><p>6) 编写service和controller层：</p><p>EmployeeService：<br><img src="/images/QQ截图20181113153826.png"></p><p>EmployeeController：<br><img src="/images/QQ截图20181113154057.png"></p><p>7）启动应用，验证我们的应用是否成功：</p><p>然后在我们的数据库中，随便手动插入一条数据：<br><img src="/images/QQ截图20181113155237.png"></p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181113155303.png"></p><p><strong>PS：如果控制台出现Establishing SSL警告</strong>：是因为在MYSQL5.5.45+, 5.6.26+ and 5.7.6+版本中需要携带服务器身份验证的SSL连接。<br>解决办法：<br>1）在数据库连接的url中添加useSSL=false;（不使用ssl连接）<br>2）url中添加useSSL=true，并且提供服务器的验证证书。</p><p>我们这里就直接不使用了，在url后面加上？useSSL=false即可。<br><code>spring.datasource.url=jdbc:mysql://localhost:3306/spring_cache?useSSL=false</code></p><h3 id="缓存的快速体验"><a href="#缓存的快速体验" class="headerlink" title="缓存的快速体验"></a>缓存的快速体验</h3><p>步骤：</p><p>1）开启缓存的注解，@EnableCaching<br>2）使用缓存的注解来添加缓存的功能</p><hr><p>在没有使用缓存的时候，每次发送请求都会到数据库中，查询数据：<br>现在，给EmployeeService添加输出语句：<br><img src="/images/QQ截图20181113162215.png"><br>修改日志的级别：<br>logging.level.com.liuzhuo.cache=debug</p><p>启动Springboot应用：在浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181113162510.png"><br><img src="/images/QQ截图20181113162536.png"></p><p>刷新页面，还是会打印出 输出语句 和 sql的查询信息。<br><img src="/images/QQ截图20181113162657.png"></p><hr><p>使用缓存：</p><p>1）给启动类上面，加上@EnableCaching<br><img src="/images/QQ截图20181113162019.png"></p><p>2）给 EmployeeService 中 findEmployeeById 方法添加缓存的注解:( @Cacheable ）</p><pre><code>@Servicepublic class EmployeeService {    @Autowired    private EmployeeMapper employeeMapper;    //获取Employee对象    /**     *  Cacheable:查询时候缓存，第一次会到数据库中查询数据，以后都只会到     *  缓存中获取数据。     *  几个重要的属性：     *   1）cacheName/value: 指定缓存组件的名字。     *   2）key：缓存数据使用的key。默认是使用方法参数的值，比如这里id=1的话，默认key=1     *           可以使用SpEl表达式：#id获取的参数的值，#a0 #p0都是获取第一个参数的值     *           #root.args[0]:也是获取第一个参数的值     *   3）keyGenerator:key的生成器，可以自己指定key的生成器的组件的id     *            key或keyGenerator：二选一     *   4) cacheManager:指定缓存管理器     *   5) cacheResolver:指定缓存解析器。和cacheManager二选一     *   6) condition:指定符合条件的情况下，才缓存数据.     *             可以使用SpEl表达式：condition=&quot;#id&gt;5&quot;     *   7) unless:否定缓存，与condition作用相反     *   8) sync:是否使用异步模式     */    @Cacheable    public Employee findEmployeeById(Integer id) {        System.out.println(&quot;查询:&quot;+id+&quot;号的信息&quot;);        return employeeMapper.getEmployeeById(id);    }}</code></pre><p>3）启动SpringBoot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p><p>只有第一次会打印 输出语句。之后都不会打印输出语句，说明数据已经被缓存到缓存当中了。</p><hr><h3 id="SpringBoot的缓存原理："><a href="#SpringBoot的缓存原理：" class="headerlink" title="SpringBoot的缓存原理："></a>SpringBoot的缓存原理：</h3><p>1）打开CacheAutoConfiguration：</p><p><img src="/images/QQ截图20181113171128.png"></p><p>2）观察导入@Import(CacheConfigurationImportSelector.class)<br><img src="/images/QQ截图20181113171308.png"></p><p>3）CacheConfigurationImportSelector帮我们缓存了哪些类呢？</p><p>打上断点，debug一下：<br><img src="/images/QQ截图20181113171503.png"></p><pre><code>org.springframework.boot.autoconfigure.cache.GenericCacheConfigurationorg.springframework.boot.autoconfigure.cache.JCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.EhCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.HazelcastCacheConfigurationorg.springframework.boot.autoconfigure.cache.InfinispanCacheConfigurationorg.springframework.boot.autoconfigure.cache.CouchbaseCacheConfigurationorg.springframework.boot.autoconfigure.cache.RedisCacheConfigurationorg.springframework.boot.autoconfigure.cache.CaffeineCacheConfigurationorg.springframework.boot.autoconfigure.cache.GuavaCacheConfigurationorg.springframework.boot.autoconfigure.cache.SimpleCacheConfigurationorg.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration</code></pre><p>4)而注入的这里类，哪些会生效呢？</p><p>Application配置：debug=true.</p><p>发现：只有 SimpleCacheConfiguration 生效。<br><img src="/images/QQ截图20181113171946.png"></p><p>5）SimpleCacheConfiguration给容器中注入了一个cacheManager：ConcurrentMapCacheManager<br><img src="/images/QQ截图20181113172101.png"><br><img src="/images/QQ截图20181113172457.png"></p><p>6）ConcurrentMapCacheManager：实质上就是一个ConcurrentHashMap。</p><p>然后使用ConcurrentMapCache（实质ConcurrentMap）将数据保存在ConcurrentMap中。</p><hr><h3 id="缓存的运行流程"><a href="#缓存的运行流程" class="headerlink" title="缓存的运行流程"></a>缓存的运行流程</h3><p>给 EmployeeService 的 findEmployeeById 方法 打上断点：<br><img src="/images/QQ截图20181113173709.png"></p><p>给 ConcurrentMapCacheManager getCache 方法 打上断点：<br><img src="/images/QQ截图20181113173817.png"></p><p>给 ConcurrentMapCache 的lookup、get、set 打上断点：<br><img src="/images/QQ截图20181113173929.png"><br><img src="/images/QQ截图20181113173941.png"></p><p>debug运行一下：</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p><p>进入断点处：</p><p>当首次进入该方法时，不会执行该方法，会先进入缓存中获取数据<br>根据 cacheNames/value 来获取cache。<br>这里 cacheNames=’empl’<br><img src="/images/QQ截图20181113183208.png"></p><p>第一次查询，名称为empl的’cache’一定是null，所以会创建名称为’empl’的cache<br><img src="/images/QQ截图20181113183458.png"><br><img src="/images/QQ截图20181113183641.png"></p><p>创建’empl’的cache成功后，这里的cache就是ConcurrentMapCache，放到ConcurrentMapCacheManager中。<br><img src="/images/QQ截图20181113183804.png"></p><p>然后在ConcurrentMapCache中，寻找key等于我们默认参数值的value值：<br><img src="/images/QQ截图20181113184208.png"></p><p>没有找key=1的缓存值，所以执行 findEmployeeById 方法：<br><img src="/images/QQ截图20181113184329.png"></p><p>从数据库中获取数据，将数据放到缓存当中。<br><img src="/images/QQ截图20181113184515.png"></p><hr><p>当再次，刷新页面时。</p><p>name=’empl’的cache已经存在了<br><img src="/images/QQ截图20181113184712.png"></p><p>然后在name=’empl’的cache中寻找key=1的缓存：<br><img src="/images/QQ截图20181113184920.png"></p><p>然后直接就找到了key=1的缓存了，直接返回对象，不在执行 findEmployeeById 方法了。</p><p>直接来了到控制层，return语句，返回视图。<br><img src="/images/QQ截图20181113185435.png"></p><p><strong>总结：@cacheable标注的方法执行之前，先来检查缓存中有么有我们的定义的name的cache缓存，按照默认的key生成策略的值去查询对应的缓存，如果没有就运行该方法，并放入缓存中。以后调用就直接使用缓存中的数据。</strong></p><p>核心：</p><p>1）使用cacheManager[ConcurrentMapCacheManager]按照名字name来获取cache[ConcurrentMapCache]组件</p><p>2）key使用keyGenerator生成的，默认是SimpleGenerator。</p><p>3）cache使用生成的key来获取缓存或者放入缓存当中。</p><h3 id="Cacheable属性的使用"><a href="#Cacheable属性的使用" class="headerlink" title="@Cacheable属性的使用"></a>@Cacheable属性的使用</h3><p>1）cacheNames/value: 指定缓存组件的名字。<br><img src="/images/QQ截图20181113192119.png"></p><p>是数组的属性，所以是花括号的形式：cacheNames = {“empl”} 或 value={“empl”}</p><p>2）key：缓存数据使用的key。</p><p>默认是使用方法参数的值，比如这里id的值为1的话，key就等于1<br><img src="/images/QQ截图20181113192337.png"></p><p>多个参数的话，key默认就是 SimpleKey [参数值1，参数值2]</p><p>SimpleKey [1,jack]<br><img src="/images/QQ截图20181113192725.png"></p><p>还可以使用SpEl表达式：</p><p><code>#id获取的参数的值。id就是参数的名字</code>：key=1.</p><p><code>#a0、#p0 都是获取第一个参数的值，#a1 就是获取第二参数的值</code></p><p> <code>#root.args[0]:也是获取第一个参数的值</code></p><p>举例：如果想要生成 方法名+参数值 的 key。比如这里的 findEmployeeById[1]</p><p>key = “#root.methodName+’[‘+#id+’]’”<br><img src="/images/QQ截图20181113193620.png"><br><img src="/images/QQ截图20181113193828.png"></p><p>3）keyGenerator: key的生成器，可以自己指定key的生成器的组件的id</p><p><strong>key 或 keyGenerator：二选一</strong></p><p>现在在config下，创建CacheConfig类：<br><img src="/images/QQ截图20181113194259.png"></p><pre><code>@Configurationpublic class CacheConfig {    @Bean(&quot;myKeyGenerator&quot;)    public KeyGenerator keyGenerator(){        return new KeyGenerator() {            @Override            public Object generate(Object o, Method method, Object... objects) {                return method.getName()+&quot;[&quot;+ Arrays.asList(objects)+&quot;]&quot;;            }        };    }}</code></pre><p>注意这里的 KeyGenerator：org.springframework.cache.interceptor.KeyGenerator</p><p>然后，在 keyGenerator = “myKeyGenerator” ：填写key的生成器的bean的id<br><img src="/images/QQ截图20181113194347.png"></p><p>debug下：<br><img src="/images/QQ截图20181113194813.png"></p><p>4) cacheManager:指定缓存管理器</p><p> 以后整合其他缓存框架时，使用。</p><p>5) cacheResolver:指定缓存解析器。和cacheManager二选一</p><p>6) condition:指定符合条件的情况下，才缓存数据.</p><p>可以使用SpEl表达式：condition=”#id&gt;5”. 当参数值大于5时，才会缓存数据。</p><p>7) unless:否定缓存，<strong>与condition作用相反</strong></p><p>unless = “#id&lt;2” 的话，就是参数值小于2时，不缓存</p><p>8) sync:是否使用异步模式</p><p>不过，当使用sync的话，unless是不能使用的。</p><h3 id="CachePut的使用"><a href="#CachePut的使用" class="headerlink" title="@CachePut的使用"></a>@CachePut的使用</h3><p>@CachePut：是用来更新缓存的，始终是先执行方法，然后更新缓存。</p><p>1）在 EmployeeService 添加 更新employee的方法：<br><img src="/images/QQ截图20181113204129.png"></p><p>2）在 EmployeeController 添加 更新employee的映射方法：<br><img src="/images/QQ截图20181113203603.png"></p><p>3）启动程序。</p><p>首先：输入：<code>http://localhost:8080/empl/1</code> : 查询1号员工的信息<br><img src="/images/QQ截图20181113203724.png"><br><img src="/images/QQ截图20181113203745.png"></p><p>再次，访问1号员工的信息：</p><p>控制台，什么也不打印，但是界面有数据，说明，我们缓存数据成功！</p><p>现在，我们修改1号员工的信息：输入：<code>http://localhost:8080/empl?id=1&amp;lastName=zhangsan&amp;gender=0</code></p><p>我们就修改了性别，从1变成0.<br><img src="/images/QQ截图20181113204245.png"><br><img src="/images/QQ截图20181113204305.png"><br><img src="/images/QQ截图20181113204337.png"></p><p>更新成功！！！</p><hr><p>现在，我们再次，访问1号员工的信息，是从缓存中取？还是从数据库中取呢？如果从缓存中取，是旧的数据，还是新的数据？</p><p>反正，我们的最终目的是现在获取更新后的1号员工的信息。</p><p>我们来，测试一下，访问1号员工的信息：<code>http://localhost:8080/empl/1</code></p><p>发现，控制台没有打印输出语句，说明现在还是从缓存中取数据。但是好像返回的数据是旧的？<br><img src="/images/QQ截图20181113204707.png"></p><p>这是为啥呢？ 因为，虽然我们的获取缓存的名字 和 更新缓存的缓存的名字 都是empl。但是key不同呀！！！<br><img src="/images/QQ截图20181113204927.png"></p><p>所以，现在名字为’empl’的cache中，有两个缓存，一个是key=1的缓存，另一个key=employee值的缓存。所以现在获取的是key=1的缓存(旧的数据)</p><p><strong>要想达到我们想要的效果，必须key一致！！！</strong><br><img src="/images/QQ截图20181113205251.png"></p><p><strong>注意：@Cacheable的key，不能使用#result，因为@Cacheable是先执行缓存，再执行方法，而@CachePut总是先执行方法，再执行缓存。</strong></p><hr><p>重启应用，再次测试一次：</p><p>先访问1号员工：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181113205902.png"></p><p>再修改1号员工：<code>http://localhost:8080/empl?id=1&amp;lastName=张三&amp;gender=0&amp;email=zhangsan@qq.com</code><br><img src="/images/QQ截图20181113205710.png"></p><p>再次访问1号员工：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181113205937.png"></p><p>到达，我们的效果！！！</p><p><strong>注意：这里我们的缓存的name是一致的，都是’empl’才行，如果你更改了name，不一致的话，效果就达不到了，原因， 你懂的</strong></p><p><strong>PS：如果张三在数据库中看是乱码的话，需要在数据库连接中添加 &amp;characterEncoding=utf-8：</strong></p><p><strong>spring.datasource.url=jdbc:mysql://localhost:3306/spring_cache?useSSL=false&amp;characterEncoding=utf-8</strong></p><h3 id="CacheEvict的使用"><a href="#CacheEvict的使用" class="headerlink" title="@CacheEvict的使用"></a>@CacheEvict的使用</h3><p>@CacheEvict：是用来删除缓存的。</p><p>通过key：来删除指定的缓存。</p><p>allEntries = true. 删除所有的缓存，默认是为false。<br>当allEntries = true，就不用指定key了。</p><p>beforeInvocation = true。先清空缓存，再执行方法。默认是为false。<br>作用：默认情况下，当方法出现异常，缓存就不会清除。当beforeInvocation = true时，不管方法是否出现异常，都会清除缓存。 </p><h3 id="Caching的使用"><a href="#Caching的使用" class="headerlink" title="@Caching的使用"></a>@Caching的使用</h3><p>@Caching：组合注解：<br><img src="/images/QQ截图20181113213321.png"><br><img src="/images/QQ截图20181113213634.png"></p><h3 id="CacheConfig的使用"><a href="#CacheConfig的使用" class="headerlink" title="@CacheConfig的使用"></a>@CacheConfig的使用</h3><p>@CacheConfig：是作用在<strong>类上面的</strong>，相当于全局配置。<br><img src="/images/QQ截图20181113213950.png"></p><p>此时，就不需要在每个方法上的缓存注解中，写cacheNames=’empl’. 如果写了，就使用方法上面的cacheNames。</p><h2 id="整合Redis缓存"><a href="#整合Redis缓存" class="headerlink" title="整合Redis缓存"></a>整合Redis缓存</h2><h3 id="搭建redis环境"><a href="#搭建redis环境" class="headerlink" title="搭建redis环境"></a>搭建redis环境</h3><p>1）使用我们安装的虚拟机工具安装Redis</p><p>如果不清楚的话，看之前的SpringBoot基础篇，<a href="https://gakkil.top/2018/11/09/SpringBoot-day-07/#%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">docker学习</a></p><p>打开虚拟机：<br><img src="/images/QQ截图20181114100415.png"></p><p>打开连接虚拟机的客户端：SmarTTY<br><img src="/images/QQ截图20181114100537.png"><br><img src="/images/QQ截图20181114100653.png"></p><p>在docker hub中搜索Redis的镜像<br><img src="/images/QQ截图20181114101037.png"></p><p>docker官方的镜像在国外，下载镜像会很慢，所以使用国内的docker镜像：<a href="https://www.docker-cn.com/" target="_blank" rel="noopener">https://www.docker-cn.com/</a><br><img src="/images/QQ截图20181114101241.png"><br><img src="/images/QQ截图20181114101523.png"><br><img src="/images/QQ截图20181114101749.png"></p><p>运行我们下载的redis镜像：</p><pre><code>docker run -d -p 6379:6379 --name myredis registry.docker-cn.com/library/redis</code></pre><p><img src="/images/QQ截图20181114102027.png"><br><img src="/images/QQ截图20181114102152.png"></p><p>2) 打开redis的客户端：RedisDesktopManager（自行下载）<br><img src="/images/QQ截图20181114102449.png"><br><img src="/images/QQ截图20181114102754.png"></p><p>默认redis：16个数据库<br><img src="/images/QQ截图20181114102848.png"></p><p>3）简单试试redis的命令</p><p>在myredis上面，右键选择：Console<br><img src="/images/QQ截图20181114103104.png"></p><p>打开redis中文网：<a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a><br><img src="/images/QQ截图20181114103332.png"></p><p>以String类型为例：<br><img src="/images/QQ截图20181114103450.png"></p><p>其他命令，请读者自行学习啦~</p><h3 id="整合redis"><a href="#整合redis" class="headerlink" title="整合redis"></a>整合redis</h3><p>SpringBoot，默认的配置类是：SimpleCacheConfiguration</p><p>默认使用的CacheManager：ConcurrentMapCacheManager</p><p>默认使用的Cache：ConcurrentMapCache</p><p>现在，整合redis到SpringBoot中。</p><p>1）导入redis的stars依赖</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>2) 在Application配置文件中，添加redis的连接</p><pre><code>#设置redis的连接spring.redis.host=10.6.11.17</code></pre><p>这里的 host: 写你自己的虚拟机的ip地址。</p><p>3）打开RedisAutoConfiguration<br><img src="/images/QQ截图20181114115036.png"></p><p>发现：导入了两个模板类，方便我们操作。</p><p>4）在SpringBoot01CacheApplicationTests类中：</p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot01CacheApplicationTests {    @Autowired    private EmployeeMapper employeeMapper;    @Autowired    private RedisTemplate redisTemplate;  //操作k-v，都是对象的    @Autowired    private StringRedisTemplate stringRedisTemplate; //操作k-v：k是字符串的    /**     * redis:5种数据结构：     * 字符串String，list（列表），hash（哈希），set（集合），ZSet（有序集合）     * opsForValue()：String     * opsForList():list     * opsForHash():hash     * opsForSet():set     * opsForZSet():ZSet     */    @Test    public void test01(){        stringRedisTemplate.opsForValue().append(&quot;mgs&quot;,&quot;hello&quot;);    }    @Test    public void contextLoads() {    }}</code></pre><p>清空：redis中的数据。执行test01<br><img src="/images/QQ截图20181114115954.png"><br><img src="/images/QQ截图20181114120032.png"></p><p>其他命令，自行执行测试。</p><p>现在测试RedisTemplate：</p><pre><code>    @Test    public void test02() {        Employee employee = employeeMapper.getEmployeeById(1);        //将对象放入到redis中        redisTemplate.opsForValue().set(&quot;empl&quot;, employee);    }</code></pre><p>运行测试方法：<br><img src="/images/QQ截图20181114125203.png"></p><p>出现无法序列化异常，因为对象保存到redis中，是以序列化的形式。而我们的Employee没有实现序列化。<br><img src="/images/QQ截图20181114125342.png"></p><p>再次运行：<br><img src="/images/QQ截图20181114125447.png"><br><img src="/images/QQ截图20181114125504.png"></p><p>虽然成功了，但是是序列化的形式，看着不爽。</p><p>默认是jdk的序列化形式：<br><img src="/images/QQ截图20181114125648.png"></p><p>我们可以自定义自己的序列化方式：</p><p>使用我们自己的redis模板，设置自己的json的序列化形式：</p><p>在config包下：<br><img src="/images/QQ截图20181114130144.png"></p><pre><code>@Configurationpublic class RedisConfig {    @Bean(&quot;myRedisTemplate&quot;)    public RedisTemplate&lt;Object, Employee&gt; redisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();        template.setConnectionFactory(redisConnectionFactory);        //使用json的序列化        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);        template.setDefaultSerializer(redisSerializer);        return template;    }}</code></pre><p>使用自己的redis模板：<br><img src="/images/QQ截图20181114130400.png"><br><img src="/images/QQ截图20181114130459.png"></p><p>运行test03方法：<br><img src="/images/QQ截图20181114130554.png"></p><p>以上我们的redis已经整合成功了。</p><hr><h3 id="使用redis缓存"><a href="#使用redis缓存" class="headerlink" title="使用redis缓存"></a>使用redis缓存</h3><p>我们知道，SpringBoot默认使用：SimpleCacheConfiguration</p><p>导入redis-starter后，就会使用 RedisAutoConfiguration。</p><p>然后默认使用：RedisTemplate模板。</p><p>现在直接启动SpringBoot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p><p><img src="/images/QQ截图20181114133854.png"><br><img src="/images/QQ截图20181114133941.png"></p><p>再次输入：<code>http://localhost:8080/empl/1</code></p><p>会从缓存中获取数据，控制台不会打印sql语句。</p><p><img src="/images/QQ截图20181114134141.png"></p><p>不是我们想要的序列化形式：</p><p>我们需要自己配置RedisCacheManager：</p><p>打开：RedisCacheConfiguration类：</p><p>发现默认的RedisCacheManager：<br><img src="/images/QQ截图20181114194646.png"></p><p>现在在我们的RedisConfig类：<br><img src="/images/QQ截图20181114195041.png"></p><pre><code>@Configurationpublic class RedisConfig {    @Bean(&quot;employeeRedisTemplate&quot;)    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean    public RedisCacheManager cacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }}</code></pre><p>我们配置了自己的RedisCacheManager，默认的就会失效，因为：<br><img src="/images/QQ截图20181114200708.png"></p><p>现在，我们使用department来测试：编写departmentMapper，departmentService，departmentController：</p><p>DepartmentMapper：</p><pre><code>@Mapperpublic interface DepartmentMapper {    @Select(&quot;select * from department where id=#{id}&quot;)    public Department getDeptById(Integer id);}</code></pre><p>DepartmentService:</p><pre><code>@Servicepublic class DepartmentService {    @Autowired    private DepartmentMapper departmentMapper;    @Cacheable(cacheNames = &quot;dept&quot;)    public Department getDeptById(Integer id){        return departmentMapper.getDeptById(id);    }}</code></pre><p>DepartmentController:</p><pre><code>@RestControllerpublic class DepartmentController {    @Autowired    private DepartmentService departmentService;    @GetMapping(&quot;/dept/{id}&quot;)    public Department getDeptById(@PathVariable(&quot;id&quot;) Integer id) {        return departmentService.getDeptById(id);    }}</code></pre><p>启动应用：</p><p>清空redis数据库。</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p><p>第一次查询，会从数据库中查询数据，然后放到缓存中。</p><p><img src="/images/QQ截图20181114200147.png"><br><img src="/images/QQ截图20181114200157.png"></p><p>此时redis数据库中，是以json啦来序列化的。<br><img src="/images/QQ截图20181114200358.png"></p><p>再次：访问<code>http://localhost:8080/empl/1</code>，控制台不会打印sql语句，说明是从缓存中取的。</p><p>现在，我们来测试department。在mysql客户端中，自己手动插入一条数据：<br><img src="/images/QQ截图20181114201053.png"></p><p>在浏览器中输入：<code>http://localhost:8080/dept/1</code></p><p>第一次，会从数据库中获取数据。控制台打印sql语句。将数据放到redis缓存中。<br><img src="/images/QQ截图20181114201003.png"><br><img src="/images/QQ截图20181114201147.png"><br><img src="/images/QQ截图20181114201226.png"></p><p>当再次访问：<code>http://localhost:8080/dept/1</code>，照理应该会把department的json数据反序列化到前端，不到mysql数据库中查找。</p><p>但是出错了！！！<br><img src="/images/QQ截图20181114201422.png"></p><p>看出错的异常，是我们居然是把department的json数据反序列化到employee对象上面，当然出错呀！</p><p>打开我们的cacheConfig类：</p><pre><code>@Configurationpublic class RedisConfig {    @Bean(&quot;employeeRedisTemplate&quot;)    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean    public RedisCacheManager cacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }}</code></pre><p>我们的序列化泛型就是Employee对象，所以只能对Employee反序列化成功。</p><p>现在添加新的 RedisCacheManager 和 RedisTemplate</p><pre><code>@Configurationpublic class RedisConfig {    @Bean(&quot;employeeRedisTemplate&quot;)    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean(&quot;departmentRedisTemplate&quot;)    public RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Department&gt; template = new RedisTemplate&lt;Object, Department&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Department&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Department&gt;(Department.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean(&quot;employeeCacheManager&quot;)    public RedisCacheManager employeeCacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }    @Bean(&quot;departmentCacheManager&quot;)    public RedisCacheManager departmentCacheManager(RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(departmentRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }}</code></pre><p>现在在EmployeeService中，设置CacheManager：</p><p>在类上面的，@CacheConfig中设置统一的CacheManager<br><img src="/images/QQ截图20181114202147.png"></p><p>在DepartmentService：<br><img src="/images/QQ截图20181114202330.png"></p><p>这样，Employee 和 Department 就会使用各自的CacheManager。</p><p>删除Redis中的所有数据。再次测试一下，启动应用。</p><p>启动应用的过程中，出错了！你敢信，我们看看<br><img src="/images/QQ截图20181114202538.png"></p><p>原来是，我们设置了两个CacheManager，需要确定一个默认的CacheManager。所以我们使用默认的CacheManager当做默认的。</p><p>在redisConfig中：</p><pre><code>@Configurationpublic class RedisConfig {    @Bean(&quot;employeeRedisTemplate&quot;)    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean(&quot;departmentRedisTemplate&quot;)    public RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Department&gt; template = new RedisTemplate&lt;Object, Department&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Department&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Department&gt;(Department.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean(&quot;employeeCacheManager&quot;)    public RedisCacheManager employeeCacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }    @Bean(&quot;departmentCacheManager&quot;)    public RedisCacheManager departmentCacheManager(RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(departmentRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }    //默认的CacheManager,设置优先级最高    //即，当不配置cacheManager=&quot;xxxx&quot;的时候，就使用这个缓存管理器    @Primary    @Bean    public RedisCacheManager cacheManager(RedisTemplate&lt;Object, Object&gt; redisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);        cacheManager.setUsePrefix(true);        return cacheManager;    }}</code></pre><p>重启应用：</p><p>应用启动成功，没有出错。</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p><p>控制台打印sql语句，是到mysql数据库查询数据<br><img src="/images/QQ截图20181114203139.png"></p><p>再次访问：<code>http://localhost:8080/empl/1</code></p><p>控制台不打印sql语句，是从redis缓存中取数据。</p><p>在浏览器中输入：<code>http://localhost:8080/dept/1</code></p><p>控制台输出sql语句，是到mysql数据库中查询数据<br><img src="/images/QQ截图20181114203418.png"></p><p>再次访问：<code>http://localhost:8080/dept/1</code></p><p>不报错了，控制台不输出sql语句，是在redi数据库中获取数据。</p><p>以上就是整合 redis 到 SpringBoot 中。</p><hr><h3 id="使用编码的方式来使用Redis"><a href="#使用编码的方式来使用Redis" class="headerlink" title="使用编码的方式来使用Redis"></a>使用编码的方式来使用Redis</h3><p>以上都是使用注解的方式来使用缓存，现在我们来使用编码的方式来操作缓存。</p><pre><code>//@CacheConfig(cacheManager = &quot;departmentCacheManager&quot;)@Servicepublic class DepartmentService {    @Autowired    private DepartmentMapper departmentMapper;    @Autowired    private RedisTemplate departmentRedisTemplate;    //@Cacheable(cacheNames = &quot;dept&quot;)    public Department getDeptById(Integer id){        Department department = departmentMapper.getDeptById(id);        departmentRedisTemplate.opsForValue().set(&quot;dept&quot;+id,&quot;department&quot;);        return department;    }}</code></pre><p>将cahce的注解都注释掉，然后注入departmentRedisTemplate。</p><p>自己手动操作缓存。</p><p>重启应用，在浏览器中输入：<code>http://localhost:8080/dept/1</code><br><img src="/images/QQ截图20181114204406.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_09</title>
      <link href="/2018/11/12/springboot-day-09/"/>
      <url>/2018/11/12/springboot-day-09/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot启动配置原理：启动原理、运行流程、自动配置原理。<br><a id="more"></a></p><p>几个重要的事件回调机制</p><p>配置在META-INF/spring.factories</p><p><strong>ApplicationContextInitializer</strong></p><p><strong>SpringApplicationRunListener</strong></p><p>只需要放在ioc容器中</p><p><strong>ApplicationRunner</strong></p><p><strong>CommandLineRunner</strong></p><hr><p>启动流程：</p><p>首先创建一个web的Springboot项目：</p><p>然后给主main方法打上断点。<br><img src="/images/QQ截图20181112105657.png"></p><p>开始debug运行。</p><h3 id="创建SpringApplication对象"><a href="#创建SpringApplication对象" class="headerlink" title="创建SpringApplication对象"></a>创建SpringApplication对象</h3><p><img src="/images/QQ截图20181112105900.png"><br><img src="/images/QQ截图20181112110020.png"><br><img src="/images/QQ截图20181112110059.png"></p><pre><code>    private void initialize(Object[] sources) {        //保存主配置类        if (sources != null &amp;&amp; sources.length &gt; 0) {            this.sources.addAll(Arrays.asList(sources));        }        //判断当前是否一个web应用        this.webEnvironment = this.deduceWebEnvironment();        //从类路径下找到META‐INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来        this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));        //从类路径下找到ETA‐INF/spring.factories配置的所有ApplicationListener        this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));        //从多个配置类中找到有main方法的主配置类        this.mainApplicationClass = this.deduceMainApplicationClass();    }</code></pre><p>6个ApplicationContextInitializer：<br><img src="/images/QQ截图20181112111101.png" style="width:50%"></p><p>10个ApplicationListener：<br><img src="/images/QQ截图20181112111247.png" style="width:50%"></p><h3 id="运行run方法"><a href="#运行run方法" class="headerlink" title="运行run方法"></a>运行run方法</h3><p><img src="/images/QQ截图20181112111412.png"><br><img src="/images/QQ截图20181112113232.png"></p><pre><code>    public ConfigurableApplicationContext run(String... args) {        StopWatch stopWatch = new StopWatch();        stopWatch.start();        ConfigurableApplicationContext context = null;        FailureAnalyzers analyzers = null;        configureHeadlessProperty();         //获取SpringApplicationRunListeners；从类路径下META‐INF/spring.factories        SpringApplicationRunListeners listeners = getRunListeners(args);        //回调所有的获取SpringApplicationRunListener.starting()方法        listeners.starting();        try {           //封装命令行参数           ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);           //准备环境：创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成           ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);           //打印Spring的banner           Banner printedBanner = printBanner(environment);           //创建ApplicationContext；决定创建web的ioc还是普通的ioc           context = createApplicationContext();           analyzers = new FailureAnalyzers(context);           //准备上下文环境;将environment保存到ioc中；而且applyInitializers()；           //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法           //回调所有的SpringApplicationRunListener的contextPrepared()；           prepareContext(context, environment, listeners, applicationArguments,printedBanner);           //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded()           //刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解博客中有完整的流程           //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）           refreshContext(context);           //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调           //ApplicationRunner先回调，CommandLineRunner再回调           afterRefresh(context, applicationArguments);           //所有的SpringApplicationRunListener回调finished方法           listeners.finished(context, null);           stopWatch.stop();           if (this.logStartupInfo) {               new StartupInfoLogger(this.mainApplicationClass)                       .logStarted(getApplicationLog(), stopWatch);           }           //整个SpringBoot应用启动完成以后返回启动的ioc容器           return context;        }        catch (Throwable ex) {            handleRunFailure(context, listeners, analyzers, ex);            throw new IllegalStateException(ex);        }    }</code></pre><h3 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h3><p>上面我们已经了解了SpringBoot的启动原理，重点是里面的几个监听器：</p><p>ApplicationContextInitializer、SpringApplicationRunListener、ApplicationRunner、CommandLineRunner</p><p>现在，我们来自定义这几个监听器：</p><p>在根目录包下，创建listener包，并创建这几个接口的实现类：<br><img src="/images/QQ截图20181112130130.png"></p><p>ApplicationContextInitializer：</p><pre><code>public class MyApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {    @Override    public void initialize(ConfigurableApplicationContext configurableApplicationContext) {        System.out.println(&quot;MyApplicationContextInitializer---initialize&quot; + configurableApplicationContext);    }}</code></pre><p>SpringApplicationRunListener:</p><pre><code>public class MySpringApplicationRunListener implements SpringApplicationRunListener {    @Override    public void starting() {        System.out.println(&quot;SpringApplicationRunListener...starting...&quot;);    }    @Override    public void environmentPrepared(ConfigurableEnvironment environment) {        Object o = environment.getSystemProperties().get(&quot;os.name&quot;);        System.out.println(&quot;SpringApplicationRunListener...environmentPrepared..&quot; + o);    }    @Override    public void contextPrepared(ConfigurableApplicationContext context) {        System.out.println(&quot;SpringApplicationRunListener...contextPrepared...&quot;);    }    @Override    public void contextLoaded(ConfigurableApplicationContext context) {        System.out.println(&quot;SpringApplicationRunListener...contextLoaded...&quot;);    }    @Override    public void finished(ConfigurableApplicationContext context, Throwable exception) {        System.out.println(&quot;SpringApplicationRunListener...finished...&quot;);    }}</code></pre><p>ApplicationRunner:</p><pre><code>public class MyApplicationRunner implements ApplicationRunner {    @Override    public void run(ApplicationArguments args) throws Exception {        System.out.println(&quot;ApplicationRunner...run....&quot;);    }}</code></pre><p>CommandLineRunner:</p><pre><code>public class MyCommandLineRunner implements CommandLineRunner {    @Override    public void run(String... args) throws Exception {        System.out.println(&quot;CommandLineRunner...run...&quot; + Arrays.asList(args));    }}</code></pre><hr><p><strong>要想使以上的监听器起作用：</strong></p><p>ApplicationContextInitializer 和 SpringApplicationRunListener需要<strong>配置在META-INF/spring.factories</strong></p><p>在resources下：创建META-INF包，并创建spring.factories文件：<br><img src="/images/QQ截图20181112131010.png"></p><p>spring.factories文件：</p><pre><code># Initializersorg.springframework.context.ApplicationContextInitializer=\com.liuzhuo.springboot.listener.MyApplicationContextInitializer# SpringApplicationRunListene Listenersorg.springframework.boot.SpringApplicationRunListener=\com.liuzhuo.springboot.listener.MySpringApplicationRunListener</code></pre><p>如果不会写，随便打开一个SpringBoot的jar包，打开一个META-INF/spring.factories，照着写就行了。</p><p>ApplicationRunner 和 CommandLineRunner 只需要放到IOC容器中就行，即加上@Component即可。<br><img src="/images/QQ截图20181112131311.png"></p><hr><p>启动SpringBoot应用：<br><img src="/images/QQ截图20181112131418.png"></p><p>出现异常：</p><pre><code>MySpringApplicationRunListener.&lt;init&gt;(org.springframework.boot.SpringApplication, [Ljava.lang.String;)</code></pre><p>说明SpringApplicationRunListener，需要有一个有参的构造函数，第一个参数是SpringApplication，第二个是String类型。</p><p>不会写的话，随便打开一个SpringApplicationRunListener的实现类：</p><p>双击：SpringApplicationRunListener，然后Ctrl + H ：<br><img src="/images/QQ截图20181112131719.png" style="width:50%"><br>点击：EventPublishingRunListener<br><img src="/images/QQ截图20181112131822.png"></p><p>现在给我们的MySpringApplicationRunListener，添加有参的构造函数：<br><img src="/images/QQ截图20181112132043.png"></p><p>再次启动SpringBoot应用：<br><img src="/images/QQ截图20181112132142.png"></p><p><img src="/images/QQ截图20181112132207.png"></p><p><img src="/images/QQ截图20181112132228.png"></p><h3 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h3><p>starter：</p><p>1、这个场景需要使用到的依赖是什么？</p><p>2、如何编写自动配置</p><pre><code>@Configuration  //指定这个类是一个配置类@ConditionalOnXXX  //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter  //指定自动配置类的顺序@Bean  //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META‐INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</code></pre><p>3、模式：</p><p>启动器只用来做依赖导入；</p><p>专门来写一个自动配置模块；</p><p>启动器依赖自动配置；别人只需要引入启动器（starter）</p><p>mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter</p><p>步骤：</p><p>前提准备：</p><p>创建一个空项目：<br><img src="/images/QQ截图20181112140556.png"><br><img src="/images/QQ截图20181112140721.png"></p><p>添加我们的模块：<br><img src="/images/QQ截图20181112140815.png"></p><p>1) 创建启动器模块：</p><p>选择Maven项目：<br><img src="/images/QQ截图20181112140952.png"><br><img src="/images/QQ截图20181112141139.png"><br><img src="/images/QQ截图20181112141310.png"><br><img src="/images/QQ截图20181112141356.png"></p><p>2）创建自动配置模块<br><img src="/images/QQ截图20181112141500.png"></p><p>选择Spring Initializr：（只是为了方便快速创建模块）<br><img src="/images/QQ截图20181112141625.png"><br><img src="/images/QQ截图20181112143117.png"><br>选择web模块：<br><img src="/images/QQ截图20181112143217.png"><br><img src="/images/QQ截图20181112143246.png"><br><img src="/images/QQ截图20181112143326.png"></p><p>3）在启动器pom文件中，引入自动配置的依赖：<br><img src="/images/QQ截图20181112143647.png"></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.liuzhuo.spring&lt;/groupId&gt;    &lt;artifactId&gt;liuzhuo.spring.boot.starter&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;!--启动器--&gt;    &lt;dependencies&gt;        &lt;!--引入自动配置模块--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.liuzhuo.starter&lt;/groupId&gt;            &lt;artifactId&gt;liuzhuo-spring-boot-starter-autoconfigure&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>4) 编写自动配置模块：</p><p>删除不需要的文件：<br><img src="/images/QQ截图20181112143924.png" style="width:50%"><br>pom文件：删除test的依赖 和 插件的依赖:</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>启动类也删除：<br>最终：<br><img src="/images/QQ截图20181112144248.png" style="width:50%"></p><p>在starter包下：创建HelloService<br><img src="/images/QQ截图20181112144726.png"></p><pre><code>public class HelloService {    HelloProperties helloProperties;    public HelloProperties getHelloProperties() {        return helloProperties;    }    public void setHelloProperties(HelloProperties helloProperties) {        this.helloProperties = helloProperties;    }    public String sayHelloLiuzhuo(String name) {        return helloProperties.getPrefix() + &quot;-&quot; + name + &quot;-&quot; + helloProperties.getSuffix();    }}</code></pre><p>在starter包下：创建HelloProperties:<br><img src="/images/QQ截图20181112144829.png"></p><pre><code>@ConfigurationProperties(prefix = &quot;liuzhuo.hello&quot;)public class HelloProperties {    private String prefix;    private String suffix;    public String getPrefix() {        return prefix;    }    public void setPrefix(String prefix) {        this.prefix = prefix;    }    public String getSuffix() {        return suffix;    }    public void setSuffix(String suffix) {        this.suffix = suffix;    }}</code></pre><p>在starter包下：创建HelloServiceAutoConfiguration:<br><img src="/images/QQ截图20181112145420.png"></p><pre><code>@Configuration@ConditionalOnWebApplication    //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration {    @Autowired    private HelloProperties helloProperties;    @Bean    public HelloService helloService() {        HelloService helloService = new HelloService();        helloService.setHelloProperties(helloProperties);        return helloService;    }}</code></pre><p>在resources下：创建META-INF/spring.factories文件<br><img src="/images/QQ截图20181112145629.png" style="width:50%"></p><p>spring.factories：<br><img src="/images/QQ截图20181112145807.png"></p><pre><code># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.liuzhuo.starter.HelloServiceAutoConfiguration</code></pre><hr><p>5) 将这两个模块，导入到本地maven仓库中：</p><p>首先导入liuzhuo-spring-boot-starter-autoconfigure的依赖</p><p>因为liuzhuo-spring-boot-starter依赖于liuzhuo-spring-boot-starter-autoconfigure。</p><p>打开maven的工具窗口，点击liuzhuo-spring-boot-starter-autoconfigure模块，找到生命周期中的install。双击<br><img src="/images/QQ截图20181112150929.png"></p><p>liuzhuo-spring-boot-starter的导入本地仓库，类似。</p><p>6）创建新的SpringBoot的web项目，导入我们的liuzhuo-spring-boot-starter依赖，测试。<br><img src="/images/QQ截图20181112152031.png"></p><p>导入：liuzhuo-spring-boot-starter依赖<br><img src="/images/QQ截图20181112152435.png"></p><pre><code>        &lt;!--导入我们的启动依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.liuzhuo.starter&lt;/groupId&gt;            &lt;artifactId&gt;liuzhuo.spring.boot.starter&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p><img src="/images/QQ截图20181112152557.png" style="width:50%"></p><p>创建：HelloController<br><img src="/images/QQ截图20181112152719.png"></p><pre><code>@RestControllerpublic class HelloController {    @Autowired    HelloService helloService;    @GetMapping(&quot;/hello&quot;)    public String hello(){        return helloService.sayHelloLiuzhuo(&quot;jackLoveDj&quot;);    }}</code></pre><p>在配置文件中：<br><img src="/images/QQ截图20181112153251.png"></p><pre><code>liuzhuo.hello.prefix=欢迎liuzhuo.hello.suffix=到来</code></pre><p>启动我们的应用：<br><img src="/images/QQ截图20181112153346.png"></p><p>没有报错，说明我们的自动配置成功了。</p><p>在浏览器中输入：<code>http://localhost:8080/hello</code><br><img src="/images/QQ截图20181112153439.png"></p><hr><h3 id="更多SpringBoot整合示例"><a href="#更多SpringBoot整合示例" class="headerlink" title="更多SpringBoot整合示例"></a>更多SpringBoot整合示例</h3><p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples" target="_blank" rel="noopener">官方给出的样例代码</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_08</title>
      <link href="/2018/11/11/springboot-day-08/"/>
      <url>/2018/11/11/springboot-day-08/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot与数据访问<br><a id="more"></a></p><h2 id="JDBC-默认支持的数据源"><a href="#JDBC-默认支持的数据源" class="headerlink" title="JDBC(默认支持的数据源)"></a>JDBC(默认支持的数据源)</h2><p>1）创建新的Springboot项目，添加web模块、mysql模块、jdbc模块<br><img src="/images/QQ截图20181111110045.png"><br><img src="/images/QQ截图20181111110143.png"><br><img src="/images/QQ截图20181111110336.png"></p><p>2) 连接我们的数据库：</p><p>打开我们的虚拟机，然后启动mysql的容器<br><img src="/images/QQ截图20181111110542.png"><br><img src="/images/QQ截图20181111110735.png"><br><img src="/images/QQ截图20181111110811.png"></p><p>3）在我们的项目中，添加数据源的配置信息。</p><p>这里使用yml文件，properties文件也一样。<br>在resources下：创建application.yml文件。<br><img src="/images/QQ截图20181111111923.png"></p><pre><code>spring:  datasource:    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://10.6.11.17:3306/jdbc</code></pre><p>在mysql的客户端上面，创建jdbc数据库：<br><img src="/images/QQ截图20181111111412.png"></p><p>4）测试数据源是否配置成功<br>在test包下：<br><img src="/images/QQ截图20181111112125.png"></p><p>效果：</p><p>默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源</p><p>数据源的相关配置都在DataSourceProperties里面。</p><pre><code>@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)public class DataSourceProperties        implements BeanClassLoaderAware, EnvironmentAware, InitializingBean {</code></pre><p>5) 自动配置的原理</p><p>org.springframework.boot.autoconfigure.jdbc：</p><p>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用<br>spring.datasource.type指定自定义的数据源类型；</p><p>2、SpringBoot默认支持的数据源：</p><pre><code>org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource</code></pre><p>3、自定义数据源类型</p><pre><code>    /**     * Generic DataSource configuration.     */    @ConditionalOnMissingBean(DataSource.class)    @ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)    static class Generic {        @Bean        public DataSource dataSource(DataSourceProperties properties) {            return properties.initializeDataSourceBuilder().build();        }    }</code></pre><p>4、自动运行sql语句的原理</p><p>DataSourceAutoConfiguration:中有一个<strong>DataSourceInitializer</strong>对象。</p><pre><code>@Configuration@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })@EnableConfigurationProperties(DataSourceProperties.class)@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })public class DataSourceAutoConfiguration {    @Bean    @ConditionalOnMissingBean    public DataSourceInitializer dataSourceInitializer(DataSourceProperties properties,            ApplicationContext applicationContext) {        return new DataSourceInitializer(properties, applicationContext);    }  ···}</code></pre><p><strong>DataSourceInitializer：ApplicationListener</strong></p><pre><code>class DataSourceInitializer implements ApplicationListener</code></pre><p>作用：<br>1）、runSchemaScripts();运行建表语句；</p><p>2）、runDataScripts();运行插入数据的sql语句；</p><p>默认只需要将文件命名为：</p><pre><code>schema‐*.sql、data‐*.sql默认规则：schema.sql，schema‐all.sql；自定义名字：在配置文件中：   schema:      ‐ classpath:department.sql      指定位置</code></pre><p>验证：<br>在resources下：创建默认命名规则的：schema-all.sql文件：</p><pre><code>SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `departmentName` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p><img src="/images/QQ截图20181111113520.png"></p><p>现在jdbc中还没有department表：<br><img src="/images/QQ截图20181111113648.png"></p><p>运行我们的Springboot项目：<br><img src="/images/QQ截图20181111113737.png"><br><img src="/images/QQ截图20181111113833.png"></p><p>刷新jdbc数据库：<br><img src="/images/QQ截图20181111113923.png"></p><hr><p>使用自定义的命名规则：<br>修改schema-all.sql 的名字为：department.sql<br>在application.yml文件中：<br><img src="/images/QQ截图20181111114934.png"></p><p>删除jdbc中的department表，然后再次启动Springboot项目：<br><img src="/images/QQ截图20181111115013.png"></p><p>5、操作数据库：Springboot自动配置了JdbcTemplate操作数据库<br><img src="/images/QQ截图20181111115134.png" style="width:50%"><br><img src="/images/QQ截图20181111115401.png"></p><p>说明Springboot已经帮我们配置好了JdbcTemplate模板引擎，我们可以直接使用：<br>创建HelloController：<br><img src="/images/QQ截图20181111120407.png"></p><pre><code>@Controllerpublic class HelloController {    @Autowired    private JdbcTemplate jdbcTemplate;    @ResponseBody    @RequestMapping(&quot;/query&quot;)    public Map&lt;String, Object&gt; queryDepartment() {        List&lt;Map&lt;String, Object&gt;&gt; mapList = jdbcTemplate.queryForList(&quot;select * from department&quot;);        //返回第一条数据        return mapList.get(0);    }}</code></pre><p>启动应用：<br><img src="/images/QQ截图20181111120130.png"></p><p>打开mysql的客户端：<br>添加一条数据：<br><img src="/images/QQ截图20181111120217.png"></p><p>打开浏览器：输入：<code>http://localhost:8080/query</code><br><img src="/images/QQ截图20181111120509.png"></p><hr><h2 id="整合Druid数据源-阿里的数据源连接池"><a href="#整合Druid数据源-阿里的数据源连接池" class="headerlink" title="整合Druid数据源(阿里的数据源连接池)"></a>整合Druid数据源(阿里的数据源连接池)</h2><p>1）导入druid的依赖</p><pre><code>        &lt;!--导入druid的数据源--&gt;        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.10&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>2) 切换数据源：<br>使用type来切换数据源<br><img src="/images/QQ截图20181111123613.png"></p><pre><code>spring:  datasource:    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://10.6.11.17:3306/jdbc    type: com.alibaba.druid.pool.DruidDataSource#    schema:#      - classpath:department.sql</code></pre><p>3) 运行测试类：<br><img src="/images/QQ截图20181111123753.png"><br><img src="/images/QQ截图20181111123907.png"><br>数据源切换成功。</p><p>4）添加druid的独有配置</p><pre><code>spring:  datasource:    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://10.6.11.17:3306/jdbc    type: com.alibaba.druid.pool.DruidDataSource    #数据源其他配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500#    schema:#      - classpath:department.sql</code></pre><p>dubug一下，看是否是其他属性配置成功：</p><p>给contextLoads中的System.out.println(dataSource);打上断点<br><img src="/images/QQ截图20181111124326.png"></p><p>dubug运行该测试方法：<br><img src="/images/QQ截图20181111124538.png"></p><p>因为我们在application配置文件中配置的：spring-datasource:开头的配置信息，都是DataSourceProperties中的</p><pre><code>@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)public class DataSourceProperties</code></pre><p>而DataSourceProperties类中，根本没有druid那些独有的配置信息：<br><img src="/images/QQ截图20181111124846.png"></p><p>5）自己配置druid数据源</p><p>在config包下，创建MyDruidConfig类：<br><img src="/images/QQ截图20181111125255.png"></p><p>这样就能将application配置文件中的druid的独有配置信息调入到我们的druid数据源当中了。</p><p>如果没有添加@ConfigurationProperties(prefix = “spring.datasource”)的话：<br>需要自己手动一个一个的配置</p><pre><code>    @Bean    DataSource druid() {        DruidDataSource druidDataSource = new DruidDataSource();        druidDataSource.setInitialSize(5);        druidDataSource.setMaxActive(10);        ···        return druidDataSource;    }</code></pre><p>再次dubug测试方法：<br><img src="/images/QQ截图20181111125737.png"></p><p>6）配置druid的监控</p><p>在MyDruidConfig类中：</p><pre><code>    //配置Druid的监控    //1、配置一个管理后台的Servlet    @Bean    public ServletRegistrationBean statViewServlet() {        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;);        initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;);        initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问        initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;);//不然访问        bean.setInitParameters(initParams);        return bean;    }    //2、配置一个web监控的filter    @Bean    public FilterRegistrationBean webStatFilter() {        FilterRegistrationBean bean = new FilterRegistrationBean();        bean.setFilter(new WebStatFilter());        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);//排除静态资源        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));        return bean;    }</code></pre><p>启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/druid</code><br><img src="/images/QQ截图20181111130651.png"></p><p>输入自己配置的用户名与密码：</p><pre><code>        initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;);        initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;);</code></pre><p><img src="/images/QQ截图20181111130816.png"></p><p>在浏览器中输入：<code>http://localhost:8080/query</code></p><p>然后点击SQL监控：<br><img src="/images/QQ截图20181111131006.png"></p><p>点击Web应用：就是我们的配置WebAppStat List过滤器<br><img src="/images/QQ截图20181111131202.png"></p><p>监控成功！！！</p><hr><h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><h3 id="前期准备阶段"><a href="#前期准备阶段" class="headerlink" title="前期准备阶段"></a>前期准备阶段</h3><p>1）创建新的项目，添加web、mysql、mybatis模块：<br><img src="/images/QQ截图20181111141702.png"></p><p>导入druid依赖：</p><pre><code>        &lt;!--导入druid的数据源--&gt;        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.10&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>2）创建application.yml文件：</p><pre><code>spring:  datasource:    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://10.6.11.17:3306/mybatis    type: com.alibaba.druid.pool.DruidDataSource    #数据源其他配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500    schema:      - classpath:sql/department.sql      - classpath:sql/employee.sql</code></pre><p>3) 创建新的数据库mybatis：<br><img src="/images/QQ截图20181111142149.png"></p><p>4）在resours下：参加过sql文件夹<br>里面放入：department.sql 和 employee.sql文件：<br><img src="/images/QQ截图20181111142335.png" style="width:50%"></p><p>department.sql:</p><pre><code>/*Navicat MySQL Data TransferSource Server         : 本地Source Server Version : 50528Source Host           : 127.0.0.1:3306Source Database       : restful_crudTarget Server Type    : MYSQLTarget Server Version : 50528File Encoding         : 65001Date: 2018-03-05 10:41:40*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `departmentName` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>employee.sql文件:</p><pre><code>/*Navicat MySQL Data TransferSource Server         : 本地Source Server Version : 50528Source Host           : 127.0.0.1:3306Source Database       : restful_crudTarget Server Type    : MYSQLTarget Server Version : 50528File Encoding         : 65001Date: 2018-03-05 10:41:58*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for employee-- ----------------------------DROP TABLE IF EXISTS `employee`;CREATE TABLE `employee` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `lastName` varchar(255) DEFAULT NULL,  `email` varchar(255) DEFAULT NULL,  `gender` int(2) DEFAULT NULL,  `d_id` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>5) 创建config：DruidConfig配置类：<br><img src="/images/QQ截图20181111142702.png"></p><pre><code>@Configurationpublic class DruidConfig {    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)    @Bean    DataSource druid() {        return new DruidDataSource();    }    //配置Druid的监控    //1、配置一个管理后台的Servlet    @Bean    public ServletRegistrationBean statViewServlet() {        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;);        initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;);        initParams.put(&quot;allow&quot;, &quot;&quot;);//默认就是允许所有访问        initParams.put(&quot;deny&quot;, &quot;192.168.15.21&quot;);//不然访问        bean.setInitParameters(initParams);        return bean;    }    //2、配置一个web监控的filter    @Bean    public FilterRegistrationBean webStatFilter() {        FilterRegistrationBean bean = new FilterRegistrationBean();        bean.setFilter(new WebStatFilter());        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;);//排除静态资源        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));        return bean;    }}</code></pre><p>6) 启动Springboot应用：</p><p>打开mysql的客户端：生成了两个表：<br><img src="/images/QQ截图20181111142926.png"></p><p>注释掉，application配置文件中的schema：(防止再次启动应用，表又归零！)</p><pre><code>#    schema:#      - classpath:sql/department.sql#      - classpath:sql/employee.sql</code></pre><p>7）创建bean对象：</p><p>根据数据库mybatis中的两个表，创建对应的JavaBean对象。<br><img src="/images/QQ截图20181111143428.png"></p><p>Employee：</p><pre><code>public class Employee {    private Integer id;    private String lastName;    private Integer gender;    private String email;    private Integer dId;   ··· get和set方法}</code></pre><p>Department:</p><pre><code>public class Department {    private Integer id;    private String departmentName;    ··· get和set方法}</code></pre><hr><h3 id="mybatis的使用"><a href="#mybatis的使用" class="headerlink" title="mybatis的使用"></a>mybatis的使用</h3><h4 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h4><p>1）创建mapper文件夹：DepartmentMapper（接口）<br><img src="/images/QQ截图20181111145746.png"></p><pre><code>@Mapperpublic interface DepartmentMapper {    @Select(&quot;select * from department where id=#{id}&quot;)    public Department getDeptById(Integer id);    @Delete(&quot;delete from department where id=#{id}&quot;)    public int deleteDeptById(Integer id);    //回显主键的id。    @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)    @Insert(&quot;insert into department(departmentName) values(#{departmentName})&quot;)    public int insertDept(Department department);    @Update(&quot;update department set departmentName=#{departmentName} where id=#{id}&quot;)    public int updateDept(Department department);}</code></pre><p>2) 创建一个DepartmentController：<br><img src="/images/QQ截图20181111150310.png"></p><pre><code>@RestControllerpublic class DepartmentController {    @Autowired    private DepartmentMapper departmentMapper;    @GetMapping(&quot;/dept/{id}&quot;)    public Department findDepartmentById(@PathVariable(&quot;id&quot;) Integer id) {        return departmentMapper.getDeptById(id);    }    @GetMapping(&quot;/dept&quot;)    public Department addDepartment(Department department) {        departmentMapper.insertDept(department);        return department;    }}</code></pre><p>3) 启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/dept/1</code><br><img src="/images/QQ截图20181111151409.png"></p><p>在浏览器中输入：<code>http://localhost:8080/dept?departmentName=aa</code><br><img src="/images/QQ截图20181111151555.png"><br><img src="/images/QQ截图20181111151633.png"></p><p>问题：</p><p>我们将mysql中的departmentName改为：department_name.<br><img src="/images/QQ截图20181111151808.png"></p><p>修改我们的DepartmentMapper中的departmentName为：department_name。<br><img src="/images/QQ截图20181111151946.png"></p><p>再次启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/dept?departmentName=bb</code></p><p>如果你的mybat的依赖版本的1.3.2以上，会执行成功，因为默认支持驼峰命名了。如果失败的话，我们需要自定义mybatis的规则：</p><p>创建MybatisConfig配置类:<br><img src="/images/QQ截图20181111152708.png"></p><pre><code>@Configurationpublic class MybatisConfig {    @Bean    public ConfigurationCustomizer customizer() {        return new ConfigurationCustomizer() {            @Override            public void customize(org.apache.ibatis.session.Configuration configuration) {                //使用驼峰命名规则                configuration.setMapUnderscoreToCamelCase(true);            }        };    }}</code></pre><p>或者使用在配置文件中，配置驼峰命名规则。</p><hr><p>4）扫描多个mapper类：</p><p>在配合类上面加上：<br>@MapperScan(value = “com.liuzhuo.springboot.mapper”)</p><pre><code>使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = &quot;com.liuzhuo.springboot.mapper&quot;)@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication {public static void main(String[] args) {       SpringApplication.run(SpringBoot06DataMybatisApplication.class, args);        }    }</code></pre><p>这样，我们就必须要在每个mapper类上，加@Mapper注解了</p><h4 id="配置文件版"><a href="#配置文件版" class="headerlink" title="配置文件版"></a>配置文件版</h4><p>1）创建EmployeeMapper接口：<br><img src="/images/QQ截图20181111154909.png"></p><pre><code>//必须使用@Mapper或者@MapperScan。二者其一即可public interface EmployeeMapper {    public Employee findEmplById(Integer id);    public void insertEmpl(Employee employee);}</code></pre><p>2) 创建mybatis的全局配置文件：</p><p>在resours下创建mybatis/mapper文件夹：<br><img src="/images/QQ截图20181111155138.png" style="width:50%"></p><p>在mybatis文件夹下，创建mybatis的全局配置文件：<br>不会写的话，看mybatis的官网文档，mybatis已经被整合到github上面：<br><img src="/images/QQ截图20181111155348.png"><br><img src="/images/QQ截图20181111155424.png"><br><img src="/images/QQ截图20181111155456.png"></p><p><a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">mybatis-3的官方文档</a></p><p>其中的什么数据源，mapper的文件扫描，我们全部删除，我们已经使用application.yml文件配置了。</p><p>最终mybatis-config.xml：</p><p>就设置了一个使用驼峰命名法</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;settings&gt;    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;&lt;/configuration&gt;</code></pre><p>3）创建mapper.xml文件：</p><p>在mapper文件夹下，创建employee-mapper.xml<br><img src="/images/QQ截图20181111160017.png" style="width:50%"></p><p>文件不会写，看官方文档：<br><img src="/images/QQ截图20181111160123.png"></p><p>最终employee-mapper.xml：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.springboot.mapper.EmployeeMapper&quot;&gt;    &lt;!--        public Employee findEmplById(Integer id);        public Employee insertEmpl(Employee employee);    --&gt;    &lt;select id=&quot;findEmplById&quot; resultType=&quot;com.liuzhuo.springboot.bean.Employee&quot;&gt;        select * from employee where id = #{id}    &lt;/select&gt;    &lt;insert id=&quot;insertEmpl&quot; &gt;        INSERT INTO employee(lastName,email,gender,d_id) VALUES (#{lastName},#{email},#{gender},#{dId})    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><p>4) 在application.yml文件中，制定全局mybatis.xml和mapper.xml的映射：</p><pre><code>mybatis:  config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置  mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置</code></pre><p>5) 创建EmployeeController：<br><img src="/images/QQ截图20181111161700.png"></p><pre><code>@RestControllerpublic class EmployeeController {    @Autowired    private EmployeeMapper employeeMapper;    @GetMapping(&quot;/empl/{id}&quot;)    public Employee findEmplById(@PathVariable(&quot;id&quot;) Integer id) {        return employeeMapper.findEmplById(id);    }    @GetMapping(&quot;/empl&quot;)    public Employee insertEmpl(Employee employee) {        employeeMapper.insertEmpl(employee);        return employee;    }}</code></pre><p>6) 启动Springboot应用</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181111161941.png"></p><p>在浏览器中输入：<code>http://localhost:8080/empl?lastName=jack&amp;&amp;email=4324324@qq.com&amp;&amp;gender=1&amp;&amp;dId=2</code><br><img src="/images/QQ截图20181111163225.png"></p><p>再次浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="/images/QQ截图20181111163307.png"></p><p>最主要的就是在application配置文件中：</p><pre><code>mybatis:  config-location: classpath:mybatis/mybatis-config.xml  mapper-locations: classpath:mybatis/mapper/*.xml</code></pre><p>更多使用参照:<br><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">mybatis-spring-boot-autoconfigure</a></p><hr><h2 id="整合SpringData-JPA"><a href="#整合SpringData-JPA" class="headerlink" title="整合SpringData JPA"></a>整合SpringData JPA</h2><h3 id="SpringData简介"><a href="#SpringData简介" class="headerlink" title="SpringData简介"></a>SpringData简介</h3><p><img src="/images/QQ截图20181111165834.png"></p><h3 id="整合SpringData-JPA-1"><a href="#整合SpringData-JPA-1" class="headerlink" title="整合SpringData JPA"></a>整合SpringData JPA</h3><p>JPA:ORM（Object Relational Mapping）</p><p>1）创建新的Springboot项目，添加web、mysql、jpa模块：<br><img src="/images/QQ截图20181111170202.png"></p><p>2）在application.yml配置文件中：</p><pre><code>spring:  datasource:    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://10.6.11.17:3306/jpa  jpa:#  自动创建数据库的表    hibernate:      ddl-auto: update#  显示sql语句    show-sql: true</code></pre><p>3) 在mysql客户端中创建jpa数据库：<br><img src="/images/QQ截图20181111170624.png"></p><p>4）<strong>编写一个实体类（bean）和数据表进行映射，并且配置好映射关系</strong></p><p>在bean包下，创建User类:<br><img src="/images/QQ截图20181111171609.png"></p><pre><code>//使用JPA注解配置映射关系@Entity  //表名是一个实体与数据库中的某个表对应@Table(name = &quot;t_user&quot;) //表示User类与t_user表对象，不写的话，默认就类名小写的表名public class User {    @Id //这是一个主键：javax.persistence.Id;    @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键    private Integer id;    @Column(name = &quot;last_name&quot;, length = 50)//这是和数据表对应的一个列    private String lastName;    @Column //省略默认列名就是属性名    private String email;   ····get和set方法}</code></pre><p>5）编写一个Dao接口来操作实体类对应的数据表（Repository）：</p><p>继承JpaRepository类就行：&lt;T,U&gt;: T : 实体类， U : 主键类型<br><img src="/images/QQ截图20181111171846.png"></p><p>6）基本的配置（JpaProperties）</p><pre><code>spring:  jpa:    hibernate:#     更新或者创建数据表结构      ddl‐auto: update#    控制台显示SQL    show‐sql: true</code></pre><p>7) 编写UserController类<br><img src="/images/QQ截图20181111172435.png"></p><pre><code>@RestControllerpublic class UserController {    @Autowired    private UserRepository userRepository;    @GetMapping(&quot;/user/{id}&quot;)    public User findUserById(@PathVariable(&quot;id&quot;) Integer id) {        User user = userRepository.findOne(id);        return user;    }    @GetMapping(&quot;/user&quot;)    public User insertUser(User user) {        User save = userRepository.save(user);        return save;    }}</code></pre><p>8) 启动Springboot应用：<br>打开mysql的客户端：<br><img src="/images/QQ截图20181111172613.png"><br>自动帮我们创建了t_user表</p><p>在浏览器中输入：<code>http://localhost:8080/user/1</code><br><img src="/images/QQ截图20181111172801.png"></p><p>在浏览器中输入：<code>http://localhost:8080/user?lastName=zhangsan&amp;email=89028394@qq.com</code><br><img src="/images/QQ截图20181111172917.png"></p><p>控制台：（打印出了sql语句）<br><img src="/images/QQ截图20181111173008.png"></p><p>mysql客户端：<br><img src="/images/QQ截图20181111173129.png"></p><p>其他博客：</p><p><a href="https://blog.csdn.net/oChangWen/article/details/52788274?locationNum=3" target="_blank" rel="noopener">https://blog.csdn.net/oChangWen/article/details/52788274?locationNum=3</a></p><p><a href="https://blog.csdn.net/suo082407128/article/details/60963161" target="_blank" rel="noopener">https://blog.csdn.net/suo082407128/article/details/60963161</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_07</title>
      <link href="/2018/11/09/springboot-day-07/"/>
      <url>/2018/11/09/springboot-day-07/</url>
      
        <content type="html"><![CDATA[<p>今天，学习Docker的相关知识<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p><p>Docker支持将软件编译成一个镜像；然后在镜像中将各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p><p>运行中的这个镜像称为容器，容器启动是非常快速的。</p><p><img src="/images/QQ截图20181109095615.png" style="width:50%;heigth:50%"></p><hr><p><img src="/images/QQ截图20181109095947.png"></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p>docker客户端(Client)：连接docker主机进行操作；</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p><p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p><p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用<br><img src="/images/QQ截图20181109100109.png"></p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p><p>4）、对容器的启动停止就是对软件的启动停止；</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h3 id="安装linux虚拟机"><a href="#安装linux虚拟机" class="headerlink" title="安装linux虚拟机"></a>安装linux虚拟机</h3><p>因为，以后的服务器都是部署在linux上面的，所以我们需要使用linux虚拟机来学习Docker</p><p>1）VMWare、VirtualBox（安装）。</p><p>VMWare虚拟机：比较重量级，而且是收费的，可以破解。</p><p>VirtualBox：轻量级，免费。</p><p>大家，如果没有，提供一个软件的百度云给大家。<a href="https://pan.baidu.com/s/1K8J6ThB1ecpDoZU5IYRGDQ" target="_blank" rel="noopener">软件安装</a>，密码：0zeo</p><p>下载之后，打开<strong>软件</strong>的目录：<br><img src="/images/QQ截图20181109101823.png"></p><p>双击VirtualBox-5.1.26-117224-Win.exe.(安装linux虚拟机)</p><p>2）导入虚拟机文件centos7-atguigu.ova</p><p>打开虚拟机界面，点击管理：导入虚拟电脑。<br><img src="/images/QQ截图20181109102440.png" style="width:50%"><br><strong>一定要 勾选重新初始化所有的网卡的MAC地址</strong><br><img src="/images/QQ截图20181109102555.png" style="width:50%"><br>导入成功后：<br><img src="/images/QQ截图20181109102748.png"></p><p>3）双击启动linux虚拟机;使用 root/ 123456登陆</p><p>会出现未能启动虚拟电脑，由于物理网卡未找到：<br><img src="/images/QQ截图20181109103253.png" style="width:50%"></p><p>点击更改网络设置：<br><img src="/images/QQ截图20181109103407.png"><br><img src="/images/QQ截图20181109103712.png"></p><p>设置完毕后，虚拟机自动启动：<br><img src="/images/QQ截图20181109103900.png"></p><p>输入用户名：root，密码：123456<br><img src="/images/QQ截图20181109104044.png"></p><p>此时，已经登入成功了。</p><p>4）使用客户端连接linux服务器进行命令操作</p><p>为了操作方便，我们可以使用linux的客户端来远程操作linux虚拟机。</p><p>安装软件目录下的：SmarTTY-2.2.msi<br><img src="/images/QQ截图20181109104240.png"></p><p>安装完毕后，启动程序：<br><img src="/images/QQ截图20181109104615.png"></p><p>点击创建新的SSH连接：<br><img src="/images/QQ截图20181109104656.png"><br><img src="/images/QQ截图20181109104916.png"></p><p>虚拟机的ip地址：<br>在虚拟机中输入：</p><pre><code>ip addr</code></pre><p><img src="/images/QQ截图20181109105352.png"></p><p>查看本地的ip地址：<br><img src="/images/QQ截图20181109105439.png"></p><p><strong>发现是在一个网络里面，正确！！！</strong></p><p><img src="/images/QQ截图20181109105639.png"><br><img src="/images/QQ截图20181109105717.png"><br><img src="/images/QQ截图20181109105735.png"></p><p>到此，linux客户端连接成功，此时注意不要关闭linux的服务器。</p><h3 id="在linux虚拟机上安装docker"><a href="#在linux虚拟机上安装docker" class="headerlink" title="在linux虚拟机上安装docker"></a>在linux虚拟机上安装docker</h3><p>首先启动虚拟机：<br><img src="/images/QQ截图20181110095216.png"><br>输入用户名和密码：root/123456<br><img src="/images/QQ截图20181110095348.png"><br>查看ip地址：<br><code>ip addr</code><br><img src="/images/QQ截图20181110095509.png"><br>ip地址没有变的话，直接使用我们的linux客户端连接：<br><img src="/images/QQ截图20181110095639.png"><br>输入密码：<br><img src="/images/QQ截图20181110095732.png"><br>连接成功：<br><img src="/images/QQ截图20181110095759.png"></p><hr><p><strong>现在开始在linux上安装docker。</strong></p><p>步骤：</p><p>1）检查虚拟机的内核版本，必须是3.10及以上<br><code>uname ‐r</code></p><pre><code>[root@localhost ~]# uname -r3.10.0-327.el7.x86_64[root@localhost ~]# </code></pre><p>我当前的版本是：3.10.0-327.el7.x86_64</p><p>如果你的不是，那就必须升级内核：<br><code>yum update</code></p><p>2) 安装docker(必须联网)<br><code>yum install docker</code><br><img src="/images/QQ截图20181110100256.png"></p><p>3）输入y确认安装<br><img src="/images/QQ截图20181110100405.png"><br><img src="/images/QQ截图20181110101217.png"><br><strong>出现Complete，表示安装完成！</strong><br><img src="/images/QQ截图20181110101347.png"></p><p>4）启动docker<br><code>systemctl start docker</code></p><pre><code>[root@localhost ~]# systemctl start docker</code></pre><p>查看docker的版本：<br><code>docker -v</code></p><pre><code>[root@localhost ~]# docker -vDocker version 1.13.1, build 8633870/1.13.1</code></pre><p>5) linux开机就启动docker<br><code>systemctl enable docker</code></p><pre><code>[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</code></pre><p>6) 停止docker<br><code>systemctl stop docker</code></p><h2 id="Docker常用命令-amp-操作"><a href="#Docker常用命令-amp-操作" class="headerlink" title="Docker常用命令&amp;操作"></a>Docker常用命令&amp;操作</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><p><img src="/images/QQ截图20181110102850.png"></p><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">官方的docker仓库</a></p><p><font color="red"><strong>如果在启动的时候，出现问题</strong></font></p><pre><code>[root@localhost ~]# systemctl start dockerJob for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.</code></pre><p>然后根据提示进行systemctl status docker.service，打印出相关的日志：</p><pre><code>[root@localhost ~]# systemctl status docker.service● docker.service - Docker Application Container Engine   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)   Active: failed (Result: exit-code) since Fri 2018-04-27 21:25:13 EDT; 3min 32s ago     Docs: http://docs.docker.com  Process: 2390 ExecStart=/usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --seccomp-profile=/etc/docker/seccomp.json $OPTIONS $DOCKER_STORAGE_OPTIONS $DOCKER_NETWORK_OPTIONS $ADD_REGISTRY $BLOCK_REGISTRY $INSECURE_REGISTRY $REGISTRIES (code=exited, status=1/FAILURE) Main PID: 2390 (code=exited, status=1/FAILURE)Apr 27 21:25:12 localhost.localdomain systemd[1]: Starting Docker Application Container Engine...Apr 27 21:25:12 localhost.localdomain dockerd-current[2390]: time=&quot;2018-04-27T21:25:12.286650644-04:00&quot; level=warning msg=&quot;could no...ound&quot;Apr 27 21:25:12 localhost.localdomain dockerd-current[2390]: time=&quot;2018-04-27T21:25:12.295209148-04:00&quot; level=info msg=&quot;libcontaine...2395&quot;Apr 27 21:25:13 localhost.localdomain dockerd-current[2390]: time=&quot;2018-04-27T21:25:13.310268309-04:00&quot; level=warning msg=&quot;overlay2: the...Apr 27 21:25:13 localhost.localdomain dockerd-current[2390]: Error starting daemon: SELinux is not supported with the overlay2 grap...alseApr 27 21:25:13 localhost.localdomain systemd[1]: docker.service: main process exited, code=exited, status=1/FAILUREApr 27 21:25:13 localhost.localdomain systemd[1]: Failed to start Docker Application Container Engine.Apr 27 21:25:13 localhost.localdomain systemd[1]: Unit docker.service entered failed state.Apr 27 21:25:13 localhost.localdomain systemd[1]: docker.service failed.Hint: Some lines were ellipsized, use -l to show in full.</code></pre><p>其中：<code>Error starting daemon: SELinux is not supported with the overlay2 grap...alse</code></p><p>这是由于overlay2不支持造成的，所以我们要关闭它。</p><p>重新编辑docker配置文件：</p><p><code>vi /etc/sysconfig/docker</code></p><p>可以进行以下配置：</p><p>OPTIONS=’–selinux-enabled<strong>=false</strong>  –log-driver=journald –signature-verification=false’</p><p>将–selinux-enabled后面添加 =false 即可。<br><img src="/images/QQ截图20181110112203.png"></p><p>vi编辑器，使用i进入编辑状态，修改后：Esc，然后冒号：wq，保存退出。</p><p>然后进行重启操作：</p><p><code>systemctl  restart  docker</code></p><p>自此，Docker启动成功！</p><hr><p>我们以mysql为例：</p><p>1）查询mysql的镜像：<code>docker search mysql</code><br><img src="/images/QQ截图20181110112521.png"></p><p>INDEX：代表镜像的索引</p><p>NAME：镜像的名字</p><p>DESCRIPTION：镜像的描述信息</p><p>STARS：镜像被采纳的次数</p><p>OFFICIAL：是否官方（[OK]：官方，不写：非官方）</p><p>AUTOMATED：是否自动配置（[OK]：自动配置，不写：非自动配置）</p><p>这里搜索的镜像和官方<code>https://hub.docker.com/</code>上面搜索的一样：<br><img src="/images/QQ截图20181110112948.png"><br><img src="/images/QQ截图20181110113105.png"></p><p>2）下载mysql镜像：<code>docker pull mysql</code>(默认下载最近的版本)<br><img src="/images/QQ截图20181110115418.png"></p><p>如果下载镜像很慢，可以使用阿里云的镜像加速度：<br><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">登入阿里云</a><br><img src="/images/QQ截图20181110115602.png"></p><p>将其中的加速器地址，配置到/etc/docker/daemon.json中，然后重启docker</p><p>vi /etc/docker/daemon.json<br><img src="/images/QQ截图20181110115926.png"><br>重启docker：systemctl restart docker<br><img src="/images/QQ截图20181110120138.png"></p><hr><p>如果后面没有加tag，默认是下载最新的版本：latest。</p><p>如果想要下载其他版本，在官网上面查看自己想要下载的版本的tag：<br><img src="/images/QQ截图20181110114140.png"><br><img src="/images/QQ截图20181110114057.png"><br>比如想要下载5.6版本的mysql：<br><img src="/images/QQ截图20181110114239.png"></p><p><code>docker pull mysql:5.6</code><br><img src="/images/QQ截图2018111019173723.png"></p><p>3) 查看本地的镜像：<code>docker images</code><br><img src="/images/QQ截图20181110192115.png"><br>能发现，我们刚刚下载好的两个版本的mysql镜像</p><p>4) 删除镜像：<code>docker rmi image_id</code></p><p>其中的image_id：镜像的唯一id.</p><p>删除mysql：5.6的镜像：<br><img src="/images/QQ截图20181110194611.png"><br>查看剩余的镜像：（只剩下最新版本的mysql镜像）<br><img src="/images/QQ截图20181110194728.png"></p><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；<br><img src="/images/QQ截图20181110194920.png"><br><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">更多命令</a></p><p>现在，我们以Tomcat为例来操作演示：</p><p>1）搜索镜像</p><pre><code>[root@localhost ~]# docker search tomcat</code></pre><p>2) 拉取镜像</p><pre><code>[root@localhost ~]# docker pull tomcat</code></pre><p>3) 根据镜像启动容器(第一次启动)</p><p><code>docker run ‐‐name mytomcat ‐d tomcat:latest</code></p><pre><code>--name:自己定义的容器名字，随便写。-d:后台运行</code></pre><p><img src="/images/QQ截图20181110200332.png"></p><p>4）查看<strong>运行中</strong>的容器</p><p><code>docker ps</code><br><img src="/images/QQ截图20181110200655.png"></p><p>5) 停止运行中的容器</p><p><code>docker stop  容器的id或自定义的名字</code><br><img src="/images/QQ截图20181110200858.png"></p><p>6) 查看所有的容器（运行或者不运行）</p><p><code>docker ps ‐a</code><br><img src="/images/QQ截图20181110201121.png"></p><p>7) 启动（暂停的）容器</p><p><code>docker start 容器id</code><br><img src="/images/QQ截图20181110201246.png"></p><p>8）删除一个容器</p><p><code>docker rm 容器id</code></p><p>注意删除镜像是 ：rmi</p><p><strong>而且删除容器之前，先要停止容器的运行！！！</strong><br><img src="/images/QQ截图20181110201454.png"></p><p>9）启动一个做了端口映射的tomcat</p><p><code>docker run ‐d ‐p 8888:8080 tomcat:latest</code></p><p>-d：后台运行<br>-p：将主机的端口映射到容器中的一个端口　　主机端口：容器内部的端口</p><p>为了演示简单关闭了linux的防火墙。</p><p>service firewalld status ：查看防火墙状态</p><p>service firewalld stop：关闭防火墙</p><p>如果不映射端口号的话，启动容器，访问Tomcat的主页，是没有作用的：<br><img src="/images/QQ截图20181110201808.png"><br><img src="/images/QQ截图20181110202000.png"></p><p>发现无法访问Tomcat，因为我们只能访问到虚拟机上面的docker，不能直接访问到docker中的Tomcat，所以需要端口号映射。<br><img src="/images/QQ截图20181110202325.png"></p><p>在浏览器中访问：<code>http://10.6.11.17:8888/</code><br><img src="/images/QQ截图20181110202506.png"></p><p>Tomcat访问成功！！！</p><p>我们也可以使用一个Tomcat镜像，开启多个Tomcat容器。<br><img src="/images/QQ截图20181110202657.png"><br>又开启了，8887和8889端口号映射的Tomcat容器。</p><p>在浏览器中输入：<code>http://10.6.11.17:8887/</code> 和 <code>http://10.6.11.17:8889/</code><br><img src="/images/QQ截图20181110202836.png"><br><img src="/images/QQ截图20181110202848.png"></p><p>10）查看容器的日志</p><p><code>docker logs container_name/container_id</code><br><img src="/images/QQ截图20181110203052.png"></p><hr><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>安装以后学习时，需要的镜像。</p><h3 id="安装MySQL示例"><a href="#安装MySQL示例" class="headerlink" title="安装MySQL示例"></a>安装MySQL示例</h3><pre><code>docker pull mysql</code></pre><p>错误的启动:</p><pre><code>[root@localhost ~]# docker run ‐‐name mysql01 ‐d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps ‐aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS          NAMES42f09819908b        mysql               &quot;docker‐entrypoint.sh&quot;   34 seconds ago      Exited(1) 33 seconds ago                   mysql01//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD andMYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个</code></pre><p>查看官网：<br><img src="/images/QQ截图20181110205133.png"></p><p>正确的启动：</p><pre><code>[root@localhost ~]# docker run ‐‐name mysql01 ‐e MYSQL_ROOT_PASSWORD=123456 ‐d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS             PORTS               NAMESb874c56bec49        mysql               &quot;docker‐entrypoint.sh&quot;   4 seconds ago       Up 3seconds        3306/tcp            mysql01</code></pre><p>打开mysql的客户端（navicat）：<br><img src="/images/QQ截图20181110205647.png"><br>点击：连接测试：<br><img src="/images/QQ截图20181110205718.png"></p><p>这是因为，我们没有做端口号映射：(‐p 3306:3306)</p><pre><code>[root@localhost ~]# docker run ‐p 3306:3306 ‐‐name mysql02 ‐e MYSQL_ROOT_PASSWORD=123456 ‐d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS             PORTS                    NAMESad10e4bc5c6a        mysql               &quot;docker‐entrypoint.sh&quot;   4 seconds ago       Up 2seconds        0.0.0.0:3306‐&gt;3306/tcp   mysql02</code></pre><p>这里将虚拟机linux的3306端口映射到docker容器的3306端口。</p><p>再次尝试：mysql的客户端打开，连接我们的mysql。</p><p>如果你是mysql安装的是8.0以上的版本：会出现2059 - authentication plugin ‘caching_sha2_password’ -navicat连接异常。<br><img src="/images/QQ截图20181110213957.png"></p><p>这个错误的原因是由于MySQL8.0之后的加密规则为caching_sha2_password.而在此之前的加密规则为mysql_native_password。</p><p>可以将加密规则改成mysql_native_password来。</p><p>解决方案：</p><p>1）进入mysql容器</p><pre><code>docker exec -it 容器的id或容器的名字 /bin/bash</code></pre><p>必须在mysql启动的时候：输入上面的命令。<br><img src="/images/QQ截图20181110214454.png"></p><p>2）进入mysql：</p><pre><code>mysql -u用户名 -p密码比如：mysql -uroot -p123456</code></pre><p><img src="/images/QQ截图20181110214906.png"></p><p>3）修改密码的加密方式：</p><pre><code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;这里的password：写你自己想要定制的密码：比如：ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code></pre><p><img src="/images/QQ截图20181110215258.png"></p><p>4）执行命令flush privileges使权限配置项立即生效</p><pre><code>flush privileges;</code></pre><p><img src="/images/QQ截图20181110215401.png"></p><p>以上就修改密码的加密方式。</p><hr><p>再次测试我们的mysql客户端连接：<br><img src="/images/QQ截图20181110215450.png"></p><p>现在退出我们的容器：<br>使用：Ctrl+p+q</p><hr><p>几个其他的高级操作：(官网上面都有介绍)</p><pre><code>docker run ‐‐name mysql03 ‐v /conf/mysql:/etc/mysql/conf.d ‐e MYSQL_ROOT_PASSWORD=my‐secret‐pw ‐d mysql:tag把主机的/conf/mysql文件夹挂载到  mysqldocker容器的/etc/mysql/conf.d文件夹里面该mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run ‐‐name some‐mysql ‐e MYSQL_ROOT_PASSWORD=my‐secret‐pw ‐d mysql:tag ‐‐character‐set‐server=utf8mb4 ‐‐collation‐server=utf8mb4_unicode_ci指定mysql的一些配置参数：utf-8的编码</code></pre><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><p>自行完成</p><h3 id="安装rabbitmq"><a href="#安装rabbitmq" class="headerlink" title="安装rabbitmq"></a>安装rabbitmq</h3><p>自行完成</p><h3 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h3><p>自行完成</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_06</title>
      <link href="/2018/11/08/springboot-day-06/"/>
      <url>/2018/11/08/springboot-day-06/</url>
      
        <content type="html"><![CDATA[<p>今天，继续Web的开发，错误处理机制、配置嵌入式Servlet容器、使用外置的Servlet容器<br><a id="more"></a></p><h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><h3 id="SpringBoot默认的错误处理机制"><a href="#SpringBoot默认的错误处理机制" class="headerlink" title="SpringBoot默认的错误处理机制"></a>SpringBoot默认的错误处理机制</h3><p>默认效果：</p><p>1）浏览器，返回一个默认的错误页面</p><p><img src="/images/QQ截图20181108101934.png"></p><p>浏览器发送请求的请求头:</p><p><img src="/images/QQ截图20181108102024.png"></p><p>2) 如果是其他客户端，默认响应一个json数据</p><p><img src="/images/QQ截图20181108102057.png"></p><p>其他客户端发送请求的请求头:</p><p><img src="/images/QQ截图20181108102135.png"></p><p><strong>原理：</strong></p><p>可以参照ErrorMvcAutoConfiguration；错误处理的自动配置.</p><p>给容器中添加了以下组件:</p><p>1、DefaultErrorAttributes：</p><pre><code>帮我们在页面共享信息；@Overridepublic Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes,    boolean includeStackTrace) {                Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;();            errorAttributes.put(&quot;timestamp&quot;, new Date());            addStatus(errorAttributes, requestAttributes);            addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);            addPath(errorAttributes, requestAttributes);            return errorAttributes;        }</code></pre><p>2、BasicErrorController：处理默认/error请求</p><pre><code>@Controller@RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;)public class BasicErrorController extends AbstractErrorController {    @RequestMapping(produces = &quot;text/html&quot;)//产生html类型的数据；浏览器发送的请求来到这个方法处理    public ModelAndView errorHtml(HttpServletRequest request,HttpServletResponse response) {                  HttpStatus status = getStatus(request);                Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(                request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));                        response.setStatus(status.value());                //去哪个页面作为错误页面；包含页面地址和页面内容        ModelAndView modelAndView = resolveErrorView(request, response, status, model);                return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView);            }        @RequestMapping        @ResponseBody    //产生json数据，其他客户端来到这个方法处理；    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {            Map&lt;String, Object&gt; body = getErrorAttributes(request,                isIncludeStackTrace(request, MediaType.ALL));                        HttpStatus status = getStatus(request);                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);            } </code></pre><p>3、ErrorPageCustomizer：发送默认/error请求</p><pre><code>Value(&quot;${error.path:/error}&quot;)    private String path = &quot;/error&quot;;  系统出现错误以后，来到error请求进行处理；（web.xml注册的错误页面规则）</code></pre><p>4、DefaultErrorViewResolver：</p><pre><code>    @Override    public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,        Map&lt;String, Object&gt; model) {                    ModelAndView modelAndView = resolve(String.valueOf(status), model);                if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) {                modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);                    }                return modelAndView;             }     private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) {            //默认SpringBoot可以去找到一个页面？  error/404        String errorViewName = &quot;error/&quot; + viewName;                //模板引擎可以解析这个页面地址就用模板引擎解析        TemplateAvailabilityProvider provider = this.templateAvailabilityProviders                .getProvider(errorViewName, this.applicationContext);             if (provider != null) {                    //模板引擎可用的情况下返回到errorViewName指定的视图地址            return new ModelAndView(errorViewName, model);                     }                //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html        return resolveResource(errorViewName, model);             }</code></pre><p><strong>步骤：</strong></p><p>一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error<br>请求；就会被BasicErrorController处理；</p><p>响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的</p><pre><code>protected ModelAndView resolveErrorView(HttpServletRequest request,      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) {    //所有的ErrorViewResolver得到ModelAndView    for (ErrorViewResolver resolver : this.errorViewResolvers) {      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);      if (modelAndView != null) {         return modelAndView;      }   }   return null;}</code></pre><h3 id="如果定制错误响应"><a href="#如果定制错误响应" class="headerlink" title="如果定制错误响应"></a>如果定制错误响应</h3><h4 id="如何定制错误的页面"><a href="#如何定制错误的页面" class="headerlink" title="如何定制错误的页面"></a>如何定制错误的页面</h4><p>1) <strong>有模板引擎的情况下</strong></p><p>将错误页面命名为 : 错误状态码.html , 放在模板引擎文件夹里面的error文件夹下，发生此状态码的错误就会来到 对应的页面；</p><p>我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；</p><p>页面能获取的信息:</p><ol><li>timestamp：时间戳</li><li>status：状态码</li><li>error：错误提示</li><li>exception：异常对象</li><li>message：异常消息</li><li>errors：JSR303数据校验的错误都在这里</li></ol><p>2) 没有模板引擎（模板引擎找不到这个错误页面），在静态资源文件夹下找</p><p>3) 以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面</p><pre><code>        private final SpelView defaultErrorView = new SpelView(                &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&quot;                        + &quot;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&quot;                        + &quot;&lt;div id=&#39;created&#39;&gt;${timestamp}&lt;/div&gt;&quot;                        + &quot;&lt;div&gt;There was an unexpected error (type=${error}, status=${status}).&lt;/div&gt;&quot;                        + &quot;&lt;div&gt;${message}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;);        @Bean(name = &quot;error&quot;)        @ConditionalOnMissingBean(name = &quot;error&quot;)        public View defaultErrorView() {            return this.defaultErrorView;        }</code></pre><h4 id="如何定制错误的json数据"><a href="#如何定制错误的json数据" class="headerlink" title="如何定制错误的json数据"></a>如何定制错误的json数据</h4><p>1) 自定义异常处理&amp;返回定制json数据</p><pre><code>@ControllerAdvicepublic class MyExceptionHandler {    @ResponseBody    @ExceptionHandler(UserNotExistException.class)    public Map&lt;String,Object&gt; handleException(Exception e){        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;code&quot;,&quot;user.notexist&quot;);        map.put(&quot;message&quot;,e.getMessage());        return map;    }}//没有自适应效果...//即：浏览器和手机客户端都会返回json数据了</code></pre><p>2）转发到/error进行自适应响应效果处理</p><pre><code>　　@ExceptionHandler(UserNotExistException.class)    public String handleException(Exception e, HttpServletRequest request){        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        //传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程        /**         * Integer statusCode = (Integer) request.getAttribute(&quot;javax.servlet.error.status_code&quot;);         */        request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500);        map.put(&quot;code&quot;,&quot;user.notexist&quot;);        map.put(&quot;message&quot;,e.getMessage());　　　　//将我们自己定义的数据放到request域中　　　　request.setAttributes(&quot;ext&quot;,map);        //转发到/error        return &quot;forward:/error&quot;;    }</code></pre><p><strong>3) 将我们的定制数据携带出去</strong></p><p>出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由<br>getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）</p><p>1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中。</p><p>2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到</p><p>容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的。</p><p>自定义ErrorAttributes：</p><pre><code>//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes {    @Override    public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes,boolean includeStackTrace) {        Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes,includeStackTrace);        map.put(&quot;company&quot;,&quot;atguigu&quot;);        //从request域中获取我们自己定义的数据，0：代表request域        Map&lt;String,Object&gt; ext = (Map&lt;String,Object&gt;)requestAttributes.getAttribute(&quot;ext&quot;,0);        //放入要展示的map当中        map.put(&quot;ext&quot;,ext);        return map;    }}</code></pre><p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容：<br><img src="/images/QQ截图20181108111151.png"></p><h2 id="配置嵌入式Servlet容器"><a href="#配置嵌入式Servlet容器" class="headerlink" title="配置嵌入式Servlet容器"></a>配置嵌入式Servlet容器</h2><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器<br><img src="/images/QQ截图20181108113617.png"></p><p>问题？</p><h3 id="如何定制和修改Servlet容器的相关配置"><a href="#如何定制和修改Servlet容器的相关配置" class="headerlink" title="如何定制和修改Servlet容器的相关配置"></a>如何定制和修改Servlet容器的相关配置</h3><p>1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）</p><pre><code>server.port=8081server.context‐path=/crudserver.tomcat.uri‐encoding=UTF‐8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx</code></pre><p>2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</p><pre><code>@Bean  //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){    return new EmbeddedServletContainerCustomizer() {        //定制嵌入式的Servlet容器相关的规则        @Override        public void customize(ConfigurableEmbeddedServletContainer container) {            container.setPort(8083);        }    };}</code></pre><h3 id="注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="注册Servlet三大组件【Servlet、Filter、Listener】"></a>注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件.</p><p>注册三大组件用以下方式:</p><p>1) ServletRegistrationBean</p><pre><code>@Beanpublic ServletRegistrationBean myServlet(){    ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),&quot;/myServlet&quot;);    return registrationBean;}</code></pre><p>2) FilterRegistrationBean</p><pre><code>@Beanpublic FilterRegistrationBean myFilter(){    FilterRegistrationBean registrationBean = new FilterRegistrationBean();    registrationBean.setFilter(new MyFilter());    registrationBean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;,&quot;/myServlet&quot;));    return registrationBean;}</code></pre><p>3) ServletListenerRegistrationBean</p><pre><code>@Beanpublic ServletListenerRegistrationBean myListener(){    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener());    return registrationBean;}</code></pre><p>SpringBoot帮我们自动配置SpringMVC的时候，自动的注册SpringMVC的前端控制器；DispatcherServlet；</p><p>DispatcherServletAutoConfiguration中：</p><pre><code>@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name =DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration(      DispatcherServlet dispatcherServlet) {   ServletRegistrationBean registration = new ServletRegistrationBean(         dispatcherServlet, this.serverProperties.getServletMapping());    //默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp    //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);   registration.setLoadOnStartup(         this.webMvcProperties.getServlet().getLoadOnStartup());   if (this.multipartConfig != null) {      registration.setMultipartConfig(this.multipartConfig);   }   return registration;}</code></pre><h3 id="替换为其他嵌入式Servlet容器"><a href="#替换为其他嵌入式Servlet容器" class="headerlink" title="替换为其他嵌入式Servlet容器"></a>替换为其他嵌入式Servlet容器</h3><p><img src="/images/QQ截图20181108114843.png" style="width:50%"></p><p>默认支持：</p><p>Tomcat（默认使用）</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt;</code></pre><p>Jetty</p><pre><code>&lt;!‐‐ 引入web模块 ‐‐&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;   &lt;exclusions&gt;      &lt;exclusion&gt;         &lt;artifactId&gt;spring‐boot‐starter‐tomcat&lt;/artifactId&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;/exclusion&gt;   &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!‐‐引入其他的Servlet容器‐‐&gt;&lt;dependency&gt;   &lt;artifactId&gt;spring‐boot‐starter‐jetty&lt;/artifactId&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt;</code></pre><p>Undertow</p><pre><code>&lt;!‐‐ 引入web模块 ‐‐&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;   &lt;exclusions&gt;      &lt;exclusion&gt;         &lt;artifactId&gt;spring‐boot‐starter‐tomcat&lt;/artifactId&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;/exclusion&gt;   &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!‐‐引入其他的Servlet容器‐‐&gt;&lt;dependency&gt;   &lt;artifactId&gt;spring‐boot‐starter‐undertow&lt;/artifactId&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt;</code></pre><h3 id="嵌入式Servlet容器自动配置原理"><a href="#嵌入式Servlet容器自动配置原理" class="headerlink" title="嵌入式Servlet容器自动配置原理"></a>嵌入式Servlet容器自动配置原理</h3><p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置</p><pre><code>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration {　　　　@Configuration    @ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖；        @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =    SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的    Servlet容器工厂；作用：创建嵌入式的Servlet容器    public static class EmbeddedTomcat {        @Bean            public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory()    {    return new TomcatEmbeddedServletContainerFactory();                }          }        /**     * Nested configuration if Jetty is being used.         */        @Configuration        @ConditionalOnClass({ Servlet.class, Server.class, Loader.class,        WebAppContext.class })                @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =    SearchStrategy.CURRENT)        public static class EmbeddedJetty {            @Bean                public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() {                return new JettyEmbeddedServletContainerFactory();                    }            }     /**         * Nested configuration if Undertow is being used.         */        @Configuration        @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })        @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =    SearchStrategy.CURRENT)    public static class EmbeddedUndertow {        @Bean            public UndertowEmbeddedServletContainerFactory    undertowEmbeddedServletContainerFactory() {    return new UndertowEmbeddedServletContainerFactory();                }          } </code></pre><p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p><pre><code>public interface EmbeddedServletContainerFactory {   //获取嵌入式的Servlet容器   EmbeddedServletContainer getEmbeddedServletContainer(         ServletContextInitializer... initializers);}</code></pre><p><img src="/images/QQ截图20181108130503.png" style="width:50%"></p><p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）<br><img src="/images/QQ截图20181108130718.png" style="width:50%"></p><p>3）、<strong>以TomcatEmbeddedServletContainerFactory为例</strong></p><pre><code>@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer(      ServletContextInitializer... initializers) {   //创建一个Tomcat   Tomcat tomcat = new Tomcat();    //配置Tomcat的基本环节   File baseDir = (this.baseDirectory != null ? this.baseDirectory         : createTempDir(&quot;tomcat&quot;));   tomcat.setBaseDir(baseDir.getAbsolutePath());   Connector connector = new Connector(this.protocol);   tomcat.getService().addConnector(connector);   customizeConnector(connector);   tomcat.setConnector(connector);   tomcat.getHost().setAutoDeploy(false);   configureEngine(tomcat.getEngine());   for (Connector additionalConnector : this.additionalTomcatConnectors) {      tomcat.getService().addConnector(additionalConnector);   }   prepareContext(tomcat.getHost(), initializers);    //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器   return getTomcatEmbeddedServletContainer(tomcat);}</code></pre><p>4）、我们对嵌入式容器的配置修改是怎么生效？</p><pre><code>ServerProperties、EmbeddedServletContainerCustomizer</code></pre><p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p><p>怎么修改的原理？</p><p>5) 容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p><pre><code>//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName)      throws BeansException {    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件   if (bean instanceof ConfigurableEmbeddedServletContainer) {       //      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);   }   return bean;}private void postProcessBeforeInitialization(ConfigurableEmbeddedServletContainer bean) {                //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {        customizer.customize(bean);    }}private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() {    if (this.customizers == null) {        // Look up does not include the parent context        this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(            this.beanFactory            //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer            //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件            .getBeansOfType(EmbeddedServletContainerCustomizer.class,                            false, false)            .values());        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);        this.customizers = Collections.unmodifiableList(this.customizers);    }    return this.customizers;}ServerProperties也是定制器</code></pre><p>步骤：</p><p>1）、SpringBoot根据导入的嵌入式容器依赖情况，给容器中添加相应的<br>EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p><p>2）、容器中某个组件要创建对象就会惊动后置处理器；<br>EmbeddedServletContainerCustomizerBeanPostProcessor；<br>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p><p>3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法。</p><h3 id="嵌入式Servlet容器启动原理"><a href="#嵌入式Servlet容器启动原理" class="headerlink" title="嵌入式Servlet容器启动原理"></a>嵌入式Servlet容器启动原理</h3><p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p><p>获取嵌入式的Servlet容器工厂：</p><p>1）、SpringBoot应用启动运行run方法</p><p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一<br>个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：<br>AnnotationConfigApplicationContext</p><p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p><pre><code>public void refresh() throws BeansException, IllegalStateException {   synchronized (this.startupShutdownMonitor) {      // Prepare this context for refreshing.      prepareRefresh();      // Tell the subclass to refresh the internal bean factory.      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();      // Prepare the bean factory for use in this context.      prepareBeanFactory(beanFactory);      try {         // Allows post‐processing of the bean factory in context subclasses.         postProcessBeanFactory(beanFactory);         // Invoke factory processors registered as beans in the context.         invokeBeanFactoryPostProcessors(beanFactory);         // Register bean processors that intercept bean creation.         registerBeanPostProcessors(beanFactory);         // Initialize message source for this context.         initMessageSource();         // Initialize event multicaster for this context.         initApplicationEventMulticaster();         // Initialize other special beans in specific context subclasses.         onRefresh();         // Check for listener beans and register them.         registerListeners();         // Instantiate all remaining (non‐lazy‐init) singletons.         finishBeanFactoryInitialization(beanFactory);         // Last step: publish corresponding event.         finishRefresh();      }      catch (BeansException ex) {         if (logger.isWarnEnabled()) {            logger.warn(&quot;Exception encountered during context initialization ‐ &quot; +                  &quot;cancelling refresh attempt: &quot; + ex);         }         // Destroy already created singletons to avoid dangling resources.         destroyBeans();         // Reset &#39;active&#39; flag.         cancelRefresh(ex);         // Propagate exception to caller.         throw ex;      }      finally {         // Reset common introspection caches in Spring&#39;s core, since we         // might not ever need metadata for singleton beans anymore...         resetCommonCaches();      }   }}</code></pre><p>4）、 onRefresh(); web的ioc容器重写了onRefresh方法</p><p>5）、webIoC容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer();</strong></p><p>6）、<strong>获取嵌入式的Servlet容器工厂</strong>：</p><p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p><p>从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建<br>对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p><p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：</p><p>this.embeddedServletContainer = containerFactory.getEmbeddedServletContainer(getSelfInitializer());</p><p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器</p><p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来</strong></p><p><b>IOC容器启动创建嵌入式的Servlet容器</b></p><hr><h3 id="使用外置的Servlet容器"><a href="#使用外置的Servlet容器" class="headerlink" title="使用外置的Servlet容器"></a>使用外置的Servlet容器</h3><p>嵌入式Servlet容器：应用打成可执行的jar</p><p>优点：简单、便携</p><p>缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】<br>自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</p><p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包.</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1）创建一个War工程：<br><img src="/images/QQ截图20181108141118.png"><br><img src="/images/QQ截图20181108141218.png"><br><img src="/images/QQ截图20181108141327.png"><br><img src="/images/QQ截图20181108141425.png"><br><img src="/images/QQ截图20181108141535.png"><br><img src="/images/QQ截图20181108141805.png"></p><p>2）将项目结构构造成War的目录结构</p><p>打开项目的结构设置：（点击Web）<br><img src="/images/QQ截图20181108141932.png"></p><p><strong>添加webapp目录 和 web.xml文件</strong><br><img src="/images/QQ截图20181108142443.png"></p><p>完成后：<br><img src="/images/QQ截图20181108142615.png" style="width:50%"></p><p>打开pom.xml文件</p><p>检查是不是war：<br><img src="/images/QQ截图20181108142726.png"></p><p><strong>检查tomcat的依赖的scope是不是provided</strong><br><img src="/images/QQ截图20181108142816.png"></p><p>3）添加外部的Tomcat的容器<br><img src="/images/QQ截图20181108143051.png"><br><img src="/images/QQ截图20181108143152.png"><br><img src="/images/QQ截图20181108143441.png"></p><p>发现上面一个警告，因为还没有配置部署的项目：点击Deployment<br><img src="/images/QQ截图20181108143551.png"><br><img src="/images/QQ截图20181108143640.png"></p><p>4）启动外部的Tomcat容器：<br><img src="/images/QQ截图20181108143747.png"></p><p>启动完成后：<br><img src="/images/QQ截图20181108143904.png"><br><img src="/images/QQ截图20181108143941.png"></p><p>5）添加jsp页面，看看是否能成功</p><p>在webapp下面，直接创建index.jsp页面<br><img src="/images/QQ截图20181108144117.png"></p><p>启动应用，在浏览器中输入：<code>http://localhost:8080/</code> 或者 <code>http://localhost:8080/index.jsp</code><br><img src="/images/QQ截图20181108144330.png"></p><p>6) 编写控制器层：</p><p>一般我们的jsp.xml页面放置在WEB-INF下面，因为这样可以屏蔽直接在浏览器中输入地址直接访问我们的页面。</p><p>不信的话，我们在WEB-INF下面放置一个success.jsp页面：<br><img src="/images/QQ截图20181108144634.png"></p><p>重启应用，在浏览器中输入：<code>http://localhost:8080/WEB-INF/success.jsp</code><br><img src="/images/QQ截图20181108144754.png"></p><p>WEB-INF下面的资源，必须靠容器来帮我们访问，即：用控制层的重定向或者转发来寻找资源。</p><p>修改index.jsp页面：<br>添加一个a标签，发送/success的get请求：<br><img src="/images/QQ截图20181108150427.png"></p><p>创建controller包，并创建HelloController类：<br><img src="/images/QQ截图20181108145418.png"></p><p>重启应用，点击success的超链接<br><img src="/images/QQ截图20181108145532.png"><br><img src="/images/QQ截图20181108150604.png"></p><p>出现500，/success请求路径解析异常，因为我们没有配置视图解析器，return “success” 又会重新执行</p><pre><code>    @GetMapping(&quot;/success&quot;)    public String success() {        return &quot;success&quot;;    }</code></pre><p>该方法，就会循环调用，出现异常。</p><p>所以，需要在配置文件中，配置view的前缀路径，和后缀名。<br><img src="/images/QQ截图20181108151153.png"></p><p>重启应用，点击success超链接：<br><img src="/images/QQ截图20181108151253.png"></p><p>以上就是使用Springboot打包成war包的开发流程：</p><p><strong>注意：此时不能使用Springboot的主类应用启动方式，只能使用Tomcat容器的启动方式！！！</strong></p><hr><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p><p>war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器；</p><p>war包的启动原理，还是要归结于servlet3.0标准。</p><p>如果大家不清楚的话，看我的另一篇<a href="http://gakkil.top/2018/10/28/Servlet3-0/" target="_blank" rel="noopener">serlvet3.0</a>里面有详细的过程。</p><p>规则：</p><p>1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</p><p>2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为<br>javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</p><p>3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</p><p>流程：</p><p>1）、启动Tomcat</p><p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-<br>INF\services\javax.servlet.ServletContainerInitializer：</p><p>Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer<br><img src="/images/QQ截图20181108154339.png"></p><p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型<br>的类都传入到onStartup方法的Set集合中；为这些WebApplicationInitializer类型的类创建实例；</p><pre><code>@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer</code></pre><p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p><pre><code>        for (WebApplicationInitializer initializer : initializers) {            initializer.onStartup(servletContext);        }</code></pre><p>WebApplicationInitializer继承树：<br><img src="/images/QQ截图20181108155531.png"></p><p>我们发现了SpringBootServletInitializer是WebApplicationInitializer一个实现类。</p><p>5）我们项目中的ServletInitializer继承了SpringBootServletInitializer：(idea自己帮我们创建的一个类，名字无所谓，继承SpringBootServletInitializer即可)<br><img src="/images/QQ截图20181108155741.png"></p><p>所以服务启动的时候，会创建ServletInitializer实例并调用onStartup方法。我们没有重写onStartup方法，所以会调用父类SpringBootServletInitializer的onStartup方法。</p><p>6）SpringBootServletInitializer执行onStartup的时候会调用createRootApplicationContext：创建容器</p><pre><code>protected WebApplicationContext createRootApplicationContext(      ServletContext servletContext) {    //1、创建SpringApplicationBuilder   SpringApplicationBuilder builder = createSpringApplicationBuilder();   StandardServletEnvironment environment = new StandardServletEnvironment();   environment.initPropertySources(servletContext, null);   builder.environment(environment);   builder.main(getClass());   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);   if (parent != null) {      this.logger.info(&quot;Root context already created (using as parent).&quot;);      servletContext.setAttribute(            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);      builder.initializers(new ParentContextApplicationContextInitializer(parent));   }   builder.initializers(         new ServletContextApplicationContextInitializer(servletContext));   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);    //2.调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来   builder = configure(builder);    //3.使用builder创建一个Spring应用   SpringApplication application = builder.build();   if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils         .findAnnotation(getClass(), Configuration.class) != null) {      application.getSources().add(getClass());   }   Assert.state(!application.getSources().isEmpty(),         &quot;No SpringApplication sources have been defined. Either override the &quot;               + &quot;configure method or add an @Configuration annotation&quot;);   // Ensure error pages are registered   if (this.registerErrorPageFilter) {      application.getSources().add(ErrorPageFilterConfiguration.class);   }    //4.启动Spring应用   return run(application);}</code></pre><p>7） Spring的应用就启动并且创建IOC容器</p><pre><code>public ConfigurableApplicationContext run(String... args) {   StopWatch stopWatch = new StopWatch();   stopWatch.start();   ConfigurableApplicationContext context = null;   FailureAnalyzers analyzers = null;   configureHeadlessProperty();   SpringApplicationRunListeners listeners = getRunListeners(args);   listeners.starting();   try {      ApplicationArguments applicationArguments = new DefaultApplicationArguments(            args);      ConfigurableEnvironment environment = prepareEnvironment(listeners,            applicationArguments);      Banner printedBanner = printBanner(environment);      context = createApplicationContext();      analyzers = new FailureAnalyzers(context);      prepareContext(context, environment, listeners, applicationArguments,            printedBanner);       //刷新IOC容器      refreshContext(context);      afterRefresh(context, applicationArguments);      listeners.finished(context, null);      stopWatch.stop();      if (this.logStartupInfo) {         new StartupInfoLogger(this.mainApplicationClass)               .logStarted(getApplicationLog(), stopWatch);      }      return context;   }   catch (Throwable ex) {      handleRunFailure(context, listeners, analyzers, ex);      throw new IllegalStateException(ex);   }}</code></pre><font color="#EE2C2C"><strong>总结：启动Servlet容器，再启动SpringBoot应用</strong></font>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_05</title>
      <link href="/2018/11/06/springboot-day-05/"/>
      <url>/2018/11/06/springboot-day-05/</url>
      
        <content type="html"><![CDATA[<p>今天，学习Springboot中的SpringMVC的自动配置原理<br><a id="more"></a></p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications" target="_blank" rel="noopener">Springboot的官方参考文档</a></p><h2 id="Spring-MVC-auto-configuration"><a href="#Spring-MVC-auto-configuration" class="headerlink" title="Spring MVC auto-configuration"></a>Spring MVC auto-configuration</h2><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:（<strong>WebMvcAutoConfiguration</strong>）</p><h3 id="ContentNegotiatingViewResolver-and-BeanNameViewResolver"><a href="#ContentNegotiatingViewResolver-and-BeanNameViewResolver" class="headerlink" title="ContentNegotiatingViewResolver and  BeanNameViewResolver"></a>ContentNegotiatingViewResolver and  BeanNameViewResolver</h3><pre><code>        @Bean        @ConditionalOnBean(View.class)        @ConditionalOnMissingBean        public BeanNameViewResolver beanNameViewResolver() {            BeanNameViewResolver resolver = new BeanNameViewResolver();            resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);            return resolver;        }        @Bean        @ConditionalOnBean(ViewResolver.class)        @ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)        public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {            ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();            resolver.setContentNegotiationManager(                    beanFactory.getBean(ContentNegotiationManager.class));            // ContentNegotiatingViewResolver uses all the other view resolvers to locate            // a view so it should have a high precedence            resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);            return resolver;        }</code></pre><p>　　1) 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何<br>　　渲染（转发？重定向？））</p><p>　　2) ContentNegotiatingViewResolver：组合所有的视图解析器的；</p><p>　　3) 如何定制：<font color="#FF3E96"><strong>我们可以自己给容器中添加一个视图解析器；ContentNegotiatingViewResolver会自动将其组合进来；</strong></font></p><h3 id="Support-for-serving-static-resources-including-support-for-WebJars"><a href="#Support-for-serving-static-resources-including-support-for-WebJars" class="headerlink" title="Support for serving static resources, including support for WebJars"></a>Support for serving static resources, including support for WebJars</h3><p>　　静态资源文件夹路径,webjars（上一天，我们已经学过了）</p><h3 id="Static-index-html-support"><a href="#Static-index-html-support" class="headerlink" title="Static  index.html support"></a>Static  index.html support</h3><p>　　静态首页index.html访问.</p><h3 id="Custom-Favicon-support"><a href="#Custom-Favicon-support" class="headerlink" title="Custom  Favicon support"></a>Custom  Favicon support</h3><p>　　favicon.ico图标的访问。</p><h3 id="自动注册了-Converter、GenericConverter、Formatter-beans"><a href="#自动注册了-Converter、GenericConverter、Formatter-beans" class="headerlink" title="自动注册了 Converter、GenericConverter、Formatter beans."></a>自动注册了 Converter、GenericConverter、Formatter beans.</h3><p>　　1）Converter：转换器； public String hello(User user)：类型转换使用Converter。</p><p>　　2）Formatter：格式化器； 2017.12.17===Date。</p><pre><code>@Bean        @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date‐format&quot;)//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() {        return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件            } </code></pre><p>　　3）<font color="#FF3E96"><strong>自己添加的格式化器转换器，我们只需要放在容器中即可.</strong></font></p><h3 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h3><p>　　1) HttpMessageConverter: SpringMVC用来转换Http请求和响应的；User—Json；</p><p>　　2) HttpMessageConverters:是从容器中获取所有的HttpMessageConverter；</p><p>　　3) <font color="#FF3E96"><strong>自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）</strong></font></p><pre><code>@Configurationpublic class MyConfiguration {    @Bean    public HttpMessageConverters customConverters() {        HttpMessageConverter&lt;?&gt; additional = ...        HttpMessageConverter&lt;?&gt; another = ...        return new HttpMessageConverters(additional, another);//多参数    }}</code></pre><h3 id="MessageCodesResolver"><a href="#MessageCodesResolver" class="headerlink" title="MessageCodesResolver"></a>MessageCodesResolver</h3><p>　　定义错误代码生成规则 (参考官方文档)</p><h3 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h3><p>　　1）数据绑定的功能</p><p>　　2）<font color="#FF3E96"><strong>我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）</strong></font></p><pre><code>初始化WebDataBinder；请求数据=====JavaBean；</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><font color="red"><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></font><p><strong>如果，你想使用Springboot的默认配置的Web功能，然后添加自己额外的Web组件，就：添加一个@Configuration的配置类，然后继承WebMvcConfigurerAdapter抽象类。（不能添加@EnableWebMvc注解）</strong></p><p><strong>如果，你不想使用Springboot的默认Web功能，那么，就：添加一个@Configuration的配置类，并且加上@EnableWebMvc注解，那么就你完全自定义SpringMVC组件。</strong></p><p>官网文档中，这么说明的：</p><pre><code>If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration(interceptors, formatters, view controllers etc.) you can add your own  @Configuration class of typeWebMvcConfigurerAdapter , but without  @EnableWebMvc . If you wish to provide custom instances ofRequestMappingHandlerMapping ,  RequestMappingHandlerAdapter or  ExceptionHandlerExceptionResolveryou can declare a  WebMvcRegistrationsAdapter instance providing such components.If you want to take complete control of Spring MVC, you can add your own  @Configuration annotated with@EnableWebMvc .</code></pre><hr><h2 id="扩展SpringMVC"><a href="#扩展SpringMVC" class="headerlink" title="扩展SpringMVC"></a>扩展SpringMVC</h2><p>我们以前开发SpringMVC的时候，都会在xml中配置如下设置（自定义配置）：</p><pre><code>   &lt;mvc:view‐controller path=&quot;/hello&quot; view‐name=&quot;success&quot;/&gt;   &lt;mvc:interceptors&gt;            &lt;mvc:interceptor&gt;                &lt;mvc:mapping path=&quot;/hello&quot;/&gt;                &lt;bean&gt;&lt;/bean&gt;            &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;</code></pre><p>那么现在呢？</p><font color="#FF3E96">编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc;</font><p>既保留了所有的Springboot自动配置，也能用我们扩展的配置；</p><p>在我们的昨天的项目中，在com.liuzhuo.springboot包下，创建config包，并且创建Myconfig类：</p><pre><code>@Configurationpublic class Myconfig extends WebMvcConfigurerAdapter {    @Override    public void addViewControllers(ViewControllerRegistry registry) {        //super.addViewControllers(registry);        //浏览器发送 /liuzhuo 请求来到 success        registry.addViewController(&quot;/liuzhuo&quot;).setViewName(&quot;sucess&quot;);    }}</code></pre><p>然后在resources下的templates中：创建sucess.html文件：<br><img src="/images/QQ截图20181106141537.png"></p><p>启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/liuzhuo</code><br><img src="/images/QQ截图20181106141651.png"></p><p>说明：我们自己配置的映射url成功。</p><p>此时，我们不仅可以使用Springboot的默认Web的配置，还能使用自己额外添加的控制器映射。</p><hr><p>为什么，此时我们既能使用Springboot的默认配置，又能使用自己的配置呢？</p><p><strong>原理：</strong></p><p>1）查看WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>2）在WebMvcAutoConfiguration中，能发现一个静态内部类：WebMvcAutoConfigurationAdapter</p><pre><code>// Defined as a nested config to ensure WebMvcConfigurerAdapter is not read when not    // on the classpath    @Configuration    @Import(EnableWebMvcConfiguration.class)    @EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })    public static class WebMvcAutoConfigurationAdapter extends WebMvcConfigurerAdapter {</code></pre><p>该类上面有一个注解：@Import(EnableWebMvcConfiguration.class)。说明导入了EnableWebMvcConfiguration类。</p><p>3）打开EnableWebMvcConfiguration类：</p><pre><code>@Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration </code></pre><p>继承了DelegatingWebMvcConfiguration类，打开DelegatingWebMvcConfiguration类：</p><pre><code>@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {      private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();      //从容器中获取所有的WebMvcConfigurer          @Autowired(required = false)      public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {          if (!CollectionUtils.isEmpty(configurers)) {              this.configurers.addWebMvcConfigurers(configurers);             //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；                   @Override                 // public void addViewControllers(ViewControllerRegistry registry) {              //    for (WebMvcConfigurer delegate : this.delegates) {               //       delegate.addViewControllers(registry);               //   }              }          }} </code></pre><p>4) 容器中所有的WebMvcConfigurer都会一起起作用</p><p>5) 我们的配置类也会被调用</p><p>效果：SpringMVC的自动配置和我们的扩展配置都会起作用</p><h2 id="全面接管SpringMVC"><a href="#全面接管SpringMVC" class="headerlink" title="全面接管SpringMVC"></a>全面接管SpringMVC</h2><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可</strong></p><pre><code>//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter {    @Override    public void addViewControllers(ViewControllerRegistry registry) {       // super.addViewControllers(registry);        //浏览器发送 /atguigu 请求来到 success        registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;);    }}</code></pre><p>直接启动我们的应用：<br>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="/images/QQ截图20181106143304.png"></p><p>默认的静态主页失效了。去掉@EnableWebMvc，静态主页映射就会成功。</p><p>静态主页映射：META-INF/resources、resourcs、static、public下的index.html都会映射：/**</p><hr><p>为啥配置了@EnableWebMvc注解，SpringBoot的默认配置会失效呢？</p><p><strong>原理：</strong></p><p>1）打开@EnableWebMvc注解：</p><pre><code>@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc {}</code></pre><p>导入了DelegatingWebMvcConfiguration类。</p><p>2）打开DelegatingWebMvcConfiguration类：</p><pre><code>@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();    @Autowired(required = false)    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {        if (!CollectionUtils.isEmpty(configurers)) {            this.configurers.addWebMvcConfigurers(configurers);        }    }   ···｝</code></pre><p>DelegatingWebMvcConfiguration类：配置了SpringMVC的基本设置。</p><p>3）打开WebMvcAutoConfiguration：</p><pre><code>@Configuration@ConditionalOnWebApplication@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,        WebMvcConfigurerAdapter.class })//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,        ValidationAutoConfiguration.class })public class WebMvcAutoConfiguration {</code></pre><p>上面的一个条件注解：@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</p><p>当没有WebMvcConfigurationSupport存在时，WebMvcAutoConfiguration自动配置才会生效。</p><p>而DelegatingWebMvcConfiguration就是WebMvcConfigurationSupport。</p><p>所以@EnableWebMvc将WebMvcConfigurationSupport组件导入进来，从而使WebMvcAutoConfiguration自动配置失效。</p><hr><p><strong>总结：</strong></p><p>推荐我们使用 SpringBoot的默认配置 + 自定义的配置，即：@Configuration + 继承WebMvcConfigurerAdapter 的配置类的形式。</p><p>我们完全自定义的模式：适合于简单、不负责的Web应用。</p><h2 id="如何修改SpringBoot的默认配置"><a href="#如何修改SpringBoot的默认配置" class="headerlink" title="如何修改SpringBoot的默认配置"></a>如何修改SpringBoot的默认配置</h2><p>模式：</p><p>1）、 SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）<br>　　　如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户<br>　　　配置的和自己默认的组合起来；</p><p>2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p><p>3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p><h2 id="CRUD-restful实战"><a href="#CRUD-restful实战" class="headerlink" title="CRUD-restful实战"></a>CRUD-restful实战</h2><p><a href="https://pan.baidu.com/s/1_H3h5Vsw47R30mjldS68bA" target="_blank" rel="noopener">下载资料</a></p><p>下载完毕后。找到文档中的restful-crud-实验<br><img src="/images/QQ截图20181106150457.png"></p><h3 id="默认访问首页"><a href="#默认访问首页" class="headerlink" title="默认访问首页"></a>默认访问首页</h3><p>1）首先将目录下的静态页面，xxx.html导入到我们的项目中的template目录下：<br><img src="/images/QQ截图20181106150713.png" style="width:50%"></p><p>2）asserts目录放到static目录下：<br><img src="/images/QQ截图20181106150756.png" style="width:50%"></p><p>3) 将dao、entities放到com.liuzhuo.springboot包下：<br><img src="/images/QQ截图20181106151100.png" style="width:50%"></p><p>然后点击DepartmentDao、EmployeeDao，重写导入我们的Department、Employee的包名。</p><hr><p>4）启动应用：</p><p>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="/images/QQ截图20181106151352.png"></p><p>发现出现的页面是：static下的index.html页面，而不是template下的index.html页面。<br><img src="/images/QQ截图20181106151609.png" style="width:50%"></p><p>因为静态主页会加载：META-INF/resources、resourcs、static、public下的index.html</p><p>所以，我们不要重新映射我们的主页。</p><p>在我们的config下的Myconfig配置中：</p><pre><code>@Configurationpublic class Myconfig extends WebMvcConfigurerAdapter {    @Override    public void addViewControllers(ViewControllerRegistry registry) {        //super.addViewControllers(registry);        registry.addViewController(&quot;/liuzhuo&quot;).setViewName(&quot;sucess&quot;);        //添加主页的映射        registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);        registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;);        registry.addViewController(&quot;/login.html&quot;).setViewName(&quot;login&quot;);    }}</code></pre><p>然后，将templates下的index.html 改为 login.html</p><p>重新启动应用：</p><p>在浏览器中输入：<br><code>http://localhost:8080/</code><br><code>http://localhost:8080/login.html</code><br><code>http://localhost:8080/index.html</code></p><p>都是以下的页面：<br><img src="/images/QQ截图20181106152941.png"></p><p>5）因为我们使用thymeleaf，所以需要在每个页面头部添加命名空间：</p><p>   <code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code></p><pre><code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; &gt;</code></pre><p>6) 在我们的静态页面中使用了bootstrap，所以需要bootstrap的webjar：<br><img src="/images/QQ截图20181106153622.png"></p><pre><code>        &lt;!--bootstrap的jar包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.webjars&lt;/groupId&gt;            &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;            &lt;version&gt;4.0.0&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>在我们的login.html页面的中。找到引用bootstrap的地方：</p><p>th:href=”@{/webjars/bootstrap/4.0.0/css/bootstrap.css}”</p><pre><code>    &lt;!-- Bootstrap core CSS --&gt;    &lt;link href=&quot;asserts/css/bootstrap.min.css&quot; th:href=&quot;@{/webjars/bootstrap/4.0.0/css/bootstrap.css}&quot; rel=&quot;stylesheet&quot;&gt;</code></pre><p>查看有么有配置对？ctrl + 鼠标左键：能跳转到该文件处。</p><p>使用thymeleaf的th:href=”@{}”的好处：当我们给项目添加根目录时，也能自动帮我们添加上跟目录。</p><p>在application.properties中：</p><pre><code>server.context-path=/curd</code></pre><p>启动应用：<br>浏览器中输入：<code>http://localhost:8080/</code><br><img src="/images/QQ截图20181106154552.png"></p><p>输入：<code>http://localhost:8080/curd</code><br><img src="/images/QQ截图20181106154631.png"></p><p>右键审查元素：<br><img src="/images/QQ截图20181106154730.png"></p><p><strong>能看到：link 中 href：自动帮我们添加上了curd的根目录</strong></p><p>7）修改我们的css配置路径：</p><p>在login.html中：<br>th:href=”@{/asserts/css/signin.css}”</p><pre><code>    &lt;!-- Custom styles for this template --&gt;    &lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@{/asserts/css/signin.css}&quot; rel=&quot;stylesheet&quot;&gt;</code></pre><p>页面中的其他引入资源，依次类推改写完毕即可。</p><hr><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>以前，我们在SpringMVC中编写国际化时的步骤：</p><p>1）<strong>编写国际化配置文件</strong></p><p>2）使用ResourceBundleMessageSource管理国际化资源文件</p><p>3） 在页面使用fmt:message取出国际化内容（jsp引擎）</p><p>现在，使用Springboot开发的国际化的步骤：</p><p>1） 编写国际化配置文件，抽取页面需要显示的国际化消息</p><p>在resources下创建i18n文件来放置我们的国际化的配置文件。（国际化文件只能是properties）</p><p>然后创建login.properties（默认的国际化配置）、login_en_US.properties。</p><p>idea会帮我们自动生成 Resource Bundle ‘login’ 文件夹：<br><img src="/images/QQ截图20181106161921.png" style="width:50%"></p><p>然后，我们在 Resource Bundle ‘login’ 上面右键：new<br><img src="/images/QQ截图20181106162042.png"></p><p>点击加号：<br><img src="/images/QQ截图20181106162131.png" style="width:50%"></p><p>填写: 语言_国家（en_US）<br><img src="/images/QQ截图20181106162648.png" style="width:50%"></p><p>最后生成的效果：有三个国家化的配置文件：<br><img src="/images/QQ截图20181106162810.png" style="width:50%"></p><p>填写我们需要国际化的部分：</p><p>观察login页面，发现，我们需要五次国家化的部分。</p><p>login.tip (登入的标题)<br>login.username （用户名）<br>login.password （密码）<br>login.remembear （记住密码）<br>login.bt （登入按钮）</p><p>然后，随便点击一个国家化文件。在下角处切换视图：<strong>Resource Bund</strong><br><img src="/images/QQ截图20181106163314.png"></p><p>点击在该视图模式下的，左上角的加号：<br><img src="/images/QQ截图20181106163455.png"></p><p>填写key：<br><img src="/images/QQ截图20181106163605.png"></p><p>填写value：<br><img src="/images/QQ截图20181106165518.png"></p><p>依次类推：把<br>login.username （用户名）<br>login.password （密码）<br>login.remembear （记住密码）<br>login.bt （登入按钮）</p><p>添加上。</p><hr><p>2） SpringBoot自动配置好了管理国际化资源文件的组件(<strong>MessageSourceAutoConfiguration</strong>)</p><pre><code>@ConfigurationProperties(prefix = &quot;spring.messages&quot;)public class MessageSourceAutoConfiguration {    /**     * Comma‐separated list of basenames (essentially a fully‐qualified classpath         * location), each following the ResourceBundle convention with relaxed support for         * slash based locations. If it doesn&#39;t contain a package qualifier (such as         * &quot;org.mypackage&quot;), it will be resolved from the classpath root.         */        private String basename = &quot;messages&quot;;          //我们的配置文件可以直接放在类路径下叫messages.properties；        @Bean    public MessageSource messageSource() {        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();               if (StringUtils.hasText(this.basename)) {                     //设置国际化资源文件的基础名（去掉语言国家代码的）            messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(                        StringUtils.trimAllWhitespace(this.basename)));                            }                if (this.encoding != null) {                   messageSource.setDefaultEncoding(this.encoding.name());                    }                messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);                messageSource.setCacheSeconds(this.cacheSeconds);                messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);                return messageSource;            }</code></pre><p>如果，我们的国际化文件的名字就是messages的话，而放在类路径下的话，我们直接就可以使用了。</p><p>但是，现在我们使用了i18n文件，所以，我们需要在application.properties配置文件中：配置国际化的信息：</p><pre><code>spring.messages.basename=i18n.login</code></pre><p>i18n文件夹，login是文件的名字。</p><p>3）修改login.html中的需要国际化的部分</p><p>我们从thymeleaf的官方文档中，看到了如果使用国际化的话，使用 <strong>#{}</strong><br><img src="/images/QQ截图20181106171830.png"></p><p>4）启动应用：<br><img src="/images/QQ截图20181106172121.png"></p><p>切换我们的地域语言：打开浏览器的设置（我使用的谷歌浏览器）<br><img src="/images/QQ截图20181106172353.png"></p><p>刷新浏览器：<br><img src="/images/QQ截图20181106172433.png"></p><p>以上为止，我们的国际化就搞定成功了。</p><p>效果：根据浏览器语言设置的信息切换了国际化。</p><hr><p><strong>原理：</strong></p><p>国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；</p><p>打开WebMvcAutoConfiguration类：寻找与国际化有关的类：</p><pre><code>        @Bean        @ConditionalOnMissingBean        @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)        public LocaleResolver localeResolver() {            if (this.mvcProperties                    .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {                return new FixedLocaleResolver(this.mvcProperties.getLocale());            }            AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();            localeResolver.setDefaultLocale(this.mvcProperties.getLocale());            return localeResolver;        }</code></pre><p>通过此类：我们能发现，Springboot给我们配置的默认的国家化Locale的是一个AcceptHeaderLocaleResolver。</p><p>AcceptHeaderLocaleResolver：是通过每次请求时，在请求头在获取请求的语言来进行国际化识别的。</p><p>启动我们的应用：<br><img src="/images/QQ截图20181106174300.png"><br><img src="/images/QQ截图20181106174349.png" style="width:50%"></p><p>我们发现了Accept-Language：zh-CN.</p><p>修改我们的浏览器的语言：<br><img src="/images/QQ截图20181106174539.png"></p><p>再次访问我们的登入页面：<br><img src="/images/QQ截图20181106174658.png" style="width:50%"><br>我们发现了Accept-Language：en-US.</p><p>这就是Springboot的默认的国际化原理。</p><hr><p>我们想要自己自定义国际化配置，该怎么办呢？</p><p>Springboot的默认国际化：localeResolver上面有一个注解：@ConditionalOnMissingBean</p><p>意思就是：当我们的容器中不存在localeResolver，才会使用默认的AcceptHeaderLocaleResolver。</p><p>所以，我们只需要向容器中，添加我们的localeResolver即可，默认的localeResolver就会失效。</p><hr><p>1）在component包下：创建MyLocaleResolver类(实现LocaleResolver)：</p><p><img src="/images/QQ截图20181106175524.png"></p><pre><code>public class MyLocaleResolver implements LocaleResolver {    @Override    public Locale resolveLocale(HttpServletRequest request) {        //获取请求的参数信息        String language = request.getParameter(&quot;language&quot;);        //获取默认的地域信息。        Locale locale = Locale.getDefault();        if (!StringUtils.isEmpty(language)) {            String[] split = language.split(&quot;_&quot;);            //第一个参数：语言信息            //第二个参数：国家信息            locale = new Locale(split[0], split[1]);        }        return locale;    }    @Override    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {    }}</code></pre><p>2）将我们的LocaleResolver添加到容器中：</p><p>在Myconfig类中：</p><pre><code>    @Bean    public LocaleResolver localeResolver() {        return new MyLocaleResolver();    }</code></pre><p>3）修改login.html页面：<br><img src="/images/QQ截图20181106180204.png"></p><p>4）启动应用：</p><p>点击底下的：中文<br><img src="/images/QQ截图20181106180248.png"></p><p>点击底下的：English<br><img src="/images/QQ截图20181106180353.png"></p><p>我们自定义的国际化解析器成功！</p><hr><p><strong>发现：在此时，不管我们将浏览器中的语言设置什么，我们的默认登入都是中文的</strong></p><p>因为，此时：我们使用的是自己的LocaleResovler：</p><p>当获取的language：String language = request.getParameter(“language”);<br>为空时，我们的Locale locale = Locale.getDefault();是获取的是本地的，我们这里就是中文。<br>不再是使用请求头中的那种方式了。</p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>1）修改我们的登入页面：login.html</p><pre><code>&lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot; th:action=&quot;@{/user/login}&quot; method=&quot;post&quot;&gt;</code></pre><p>登入的action改为：/user/login。请求方式：post。</p><p>2）在controller包下，创建LoginController：</p><pre><code>@Controllerpublic class LoginController {    //@RequestMapping(value = &quot;/user/login&quot;,method = RequestMethod.POST)    @PostMapping(value = &quot;/user/login&quot;)    public String login(@RequestParam(&quot;username&quot;) String username,                        @RequestParam(&quot;password&quot;) String password,                        Map&lt;String, Object&gt; map) {        if (!StringUtils.isEmpty(username) &amp;&amp;                !StringUtils.isEmpty(password) &amp;&amp;                &quot;admin&quot;.equals(username) &amp;&amp;                &quot;123456&quot;.equals(password)) {            //登入成功！            return &quot;dashboard&quot;;        } else {            //登入失败！            map.put(&quot;msg&quot;, &quot;登入用户名或密码错误！&quot;);            return &quot;login&quot;;        }    }}</code></pre><p>3) 启动项目：</p><p>输入用户名和密码<br><img src="/images/QQ截图20181106213523.png"></p><p>报错了：<br><img src="/images/QQ截图20181106213554.png"></p><p>原来是我们的login.html页面，没有给username和password添加name属性！<br>现在添加上：<br><img src="/images/QQ截图20181106213732.png"></p><p>重启项目，并添加正确的用户名和密码（admin，123456）<br><img src="/images/QQ截图20181106213924.png"></p><p><strong>注意：</strong></p><p>1）此时有可能还是刚刚的错误，因为thymeleaf默认是开启缓存功能的，所以我们开发的时候，要记住关闭缓存的功能<br>在配置文件中：</p><pre><code>spring.thymeleaf.cache=false</code></pre><p>2）我们在项目启动的时候，修改页面后，直接刷新页面，还是不会变的，要在修改后的页面处：ctrl+F9（重新编译页面）</p><p>使用（1）和（2）之后，就可以在项目启动的时候，直接修改页面也能得到最新的体验了。</p><hr><p>现在，我们输入错误的用户名和密码：不会出现错误的信息。</p><p>怎么添加错误的信息在页面上呢？</p><p>给login.html页面添加一个</p><p>标签<br><img src="/images/QQ截图20181106214738.png"></p><p>当msg不为空时，才会出现错误的<code>&lt;p&gt;标签。</code></p><p>重启项目：输入错误的用户名和密码<br><img src="/images/QQ截图20181106214945.png"></p><p>现在错误提示也完成了，再次输入正确的用户名和密码，<strong>现在一不小心按了F5，刷新了页面</strong><br><img src="/images/QQ截图20181106215200.png"></p><p>发现出现了是否重新提交表单的情况，因为我们的后端是转发到登入成功页面的，地址栏还是之前的登入页面的地址，所以刷新会出现这种情况。</p><p>现在修改后端的代码，将其改为重定向。</p><p>在LoginController中：<br><img src="/images/QQ截图20181106215826.png"><br>在Myconfig中：<br><img src="/images/QQ截图20181106215631.png"></p><p>重启我们的应用：输入正确的用户名和密码<br><img src="/images/QQ截图20181107095619.png"></p><p>什么？404？main.html没有找到？why？</p><p>当我们看到地址栏时，发现我们重定向时：是在/user下重定向的，所以找不到main.html。</p><p><strong>所以，在控制器Controller中：<code>return &quot;redirect:main.html&quot;;</code> main的前面不加<code>/</code>的话<br>会在@PostMapping(value = “/user/login”)中去掉最后一个路径下重定向，即在/user下重定向。<br>如果是@PostMapping(value = “/user/liuzhuo/login”)的话，就在/user/liuzhuo下重定向。</strong></p><p>怎样在我们的根路径下重定向呢？即在我们的<code>/crud</code>根路径下重定向。只需在main的前面加<code>/</code>即可：<br><code>return &quot;redirect:/main.html&quot;;</code></p><p>修改完毕后，重启我们的应用：输入正确的用户名和密码：<br><img src="/images/QQ截图20181107100653.png"></p><p>发现样式也正确了。因为是重定向而来的。<strong>此时刷新页面，也不会重发请求了。</strong></p><h3 id="拦截器进行登陆检查"><a href="#拦截器进行登陆检查" class="headerlink" title="拦截器进行登陆检查"></a>拦截器进行登陆检查</h3><p>此时，我们在另一个浏览器中：直接输入<code>http://localhost:8080/curd/main.html</code>.<br><img src="/images/QQ截图20181107101109.png"></p><p>发现，没有登入就直接进来了，这是因为加拦截器的缘故。</p><p>1）在component包下：创建LoginHandleInterceptor：</p><pre><code>public class LoginHandleInterceptor implements HandlerInterceptor {    //在方法执行之前，调用。    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //从session中获取是否有loginUser属性的值        Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;);        if (StringUtils.isEmpty(loginUser)) {            //没有成功登入过。            //转发登入页面            request.getRequestDispatcher(&quot;/login.html&quot;).forward(request, response);            return false;        } else {            //成功登入过            return true;        }    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}</code></pre><p>2）将我们自己定义的拦截器添加到拦截器链中：</p><p>　　在Myconfig类中：</p><pre><code>    @Override    public void addInterceptors(InterceptorRegistry registry) {        //super.addInterceptors(registry);        //添加拦截器我们自定义的拦截器        registry.addInterceptor(new LoginHandleInterceptor())                .addPathPatterns(&quot;/**&quot;) //拦截路径：/**:拦截所有的请求                .excludePathPatterns(&quot;/&quot;,&quot;/index.html&quot;,&quot;/login.html&quot;,&quot;/user/login&quot;);//排除登入和登入请求的拦截路径    }</code></pre><p><b><code>这里虽然是拦截了所有的请求（/**），但是静态资源是不会被拦截的，Springboot已经帮我们排除掉了，所以放心使用.</code></b></p><p>3) 在我们的登入控制器LoginController中添加session的操作：</p><pre><code>        if (!StringUtils.isEmpty(username) &amp;&amp;                !StringUtils.isEmpty(password) &amp;&amp;                &quot;admin&quot;.equals(username) &amp;&amp;                &quot;123456&quot;.equals(password)) {            //登入成功！            //将用户名放入到session当中            session.setAttribute(&quot;loginUser&quot;, username);            //重定向到我们指定的登入成功的页面            return &quot;redirect:/main.html&quot;;</code></pre><p>4) 重启我们的应用。</p><p>在谷歌浏览器中，成功登入成功后，直接输入：<code>http://localhost:8080/curd/main.html</code><br><img src="/images/QQ截图20181107103005.png"></p><p>发现，可以直接直接访问，因为已经成功登入过了，在session中已经保存了我们的用户信息。</p><p>在另外的浏览器中，直接输入：<code>http://localhost:8080/curd/main.html</code><br><img src="/images/QQ截图20181107103240.png"></p><p>会转发到我们的登入页面，因为是转发，所以地址栏不变。</p><hr><h3 id="CRUD-员工列表"><a href="#CRUD-员工列表" class="headerlink" title="CRUD-员工列表"></a>CRUD-员工列表</h3><p>实验要求：</p><p>1) RestfulCRUD：CRUD满足Rest风格</p><p>URI： /资源名称/资源标识 　HTTP请求方式区分对资源CRUD操作<br><img src="/images/QQ截图20181107114154.png"></p><p>2) 实验的请求架构<br><img src="/images/QQ截图20181107114230.png"></p><p>3) 员工列表：</p><p><strong>thymeleaf公共页面元素抽取</strong></p><pre><code>1、抽取公共片段&lt;div th:fragment=&quot;copy&quot;&gt;   &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=&quot;~{footer :: copy}&quot;&gt;&lt;/div&gt;~{templatename::selector}：模板名::选择器~{templatename::fragmentname}:模板名::片段名模板名就是：aaa.html中的aaa片段名就是：th:fragment=&quot;bbb&quot;中的bbb选择器就是：id选择器，class选择器等3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~{}：行内写法必须加上：[[~{}]] ：不转义特殊字符（/n） 、  [(~{})] ：转义特殊字符</code></pre><p>三种引入公共片段的th属性：</p><p>th:insert：将公共片段整个插入到声明引入的元素中</p><p>th:replace：将声明引入的元素替换为公共片段</p><p>th:include：将被引入的片段的内容包含进这个标签中</p><pre><code>&lt;footer th:fragment=&quot;copy&quot;&gt;    &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式:&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;效果:&lt;div&gt;    &lt;footer&gt;        &amp;copy; 2011 The Good Thymes Virtual Grocery    &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;    &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;    &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;</code></pre><p>1) 将登入成功后的dashboard.html页面中的顶部和左边的侧单栏抽取出来：</p><p>在templates下：创建page文件夹，并创建两个html页面：<br><img src="/images/QQ截图20181107154114.png" style="width:50%"></p><p>top.html页面：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;nav th:fragment=&quot;top&quot; class=&quot;navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0&quot;&gt;        &lt;a class=&quot;navbar-brand col-sm-3 col-md-2 mr-0&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt;[[${session.loginUser}]]&lt;/a&gt;        &lt;input class=&quot;form-control form-control-dark w-100&quot; type=&quot;text&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot;&gt;        &lt;ul class=&quot;navbar-nav px-3&quot;&gt;            &lt;li class=&quot;nav-item text-nowrap&quot;&gt;                &lt;a class=&quot;nav-link&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt;退出&lt;/a&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>主要是其中的<code>&lt;nav&gt;&lt;/nav&gt;</code>片段，这个片段是dashboard.html中的顶部的片段复制过来的。</p><p>其中主要是在<code>&lt;nav&gt;</code>中加入了<strong>th:fragment=”top”</strong>属性</p><p>slide.html页面：<br><img src="/images/QQ截图20181107154633.png"></p><p>其中的<code>&lt;nav&gt;</code>片段：是dashboard.html中的左边的侧单栏的部分复制过来的。</p><p>其中，主要加入了：<strong>id：slide</strong> 的属性。</p><p>2）修改dashboard.html页面的顶部与左边部分：<br><img src="/images/QQ截图20181107155129.png"></p><p>3）启动应用，运行发现顶部与左部运行完好。</p><hr><p>现在，我们开始完成员工信息的部分；即：左单栏的Customer部分。</p><p>1）将templates下的list.html页面放到empl目录下，这样分文件夹管理更加合理<br><img src="/images/QQ截图20181107155615.png" style="width:50%"></p><p>2）修改dashboard.html中的Customer部分的action属性：<br>因为左部已经抽取到slide.html页面，所以到slide.html页面中修改：</p><p>修改之前：<br><img src="/images/QQ截图20181107155857.png"></p><p>修改之后：将Customer改为员工信息，修改a标签的href<br><img src="/images/QQ截图20181107160209.png"></p><p>3）controller包下，创建EmployeeController：</p><pre><code>@Controllerpublic class EmployeeController {    @Autowired    private EmployeeDao employeeDao;    @GetMapping(&quot;/emp&quot;)    public String list(Model model) {        Collection&lt;Employee&gt; employees = employeeDao.getAll();        model.addAttribute(&quot;employees&quot;, employees);        return &quot;empl/list&quot;;    }}</code></pre><p>4) 启动应用<br><img src="/images/QQ截图20181107160734.png"></p><p>点击：员工信息</p><p><img src="/images/QQ截图20181107160813.png"></p><p>此时员工信息里面还是Customer，因为没有抽取出公共部分。</p><p>修改list.html的顶部与左部，与dashboard.html类似。自己完成。</p><p>完成后的效果：<br><img src="/images/QQ截图20181107161524.png"></p><p>但是，我们发现此时<strong>左部的高亮部分还是Dashboard</strong></p><p>5）怎么修改高亮为员工信息呢？</p><p>thymeleaf模板引擎中，查看官方文档，发现可以有参数化的片段布局：8.2 Parameterizable fragment signatures<br><a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#parameterizable-fragment-signatures" target="_blank" rel="noopener">官方参考</a></p><p>引入片段的时候传入参数：</p><p><code>&lt;div th:replace=&quot;commons/bar::#sidebar(activeUri=&#39;emps&#39;)&quot;&gt;&lt;/div&gt;</code></p><p>即：就是在我们引入的同时，在后面加一个括号，里面填写：key=value。</p><p>修改dashboard.html页面：<br><img src="/images/QQ截图20181107164137.png"></p><p>修改list.html页面：<br><img src="/images/QQ截图20181107164221.png"></p><p>修改slide.html页面：</p><p>在Dashboard处：<br><img src="/images/QQ截图20181107164336.png"></p><p>在员工信息处：<br><img src="/images/QQ截图20181107164425.png"></p><p>重启我们的应用：</p><p>点击Dashboard，Dashboard高亮。</p><p><img src="/images/QQ截图20181107164640.png"></p><p>点击员工信息，员工信息高亮。</p><p><img src="/images/QQ截图20181107164704.png"></p><hr><p>6）将员工信息换成我们的后端传递过来的数据：</p><p>在list页面中：</p><pre><code>        &lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt;            &lt;h2&gt;&lt;button class=&quot;btn btn-sm btn-success&quot;&gt;员工添加&lt;/button&gt;&lt;/h2&gt;            &lt;div class=&quot;table-responsive&quot;&gt;                &lt;table class=&quot;table table-striped table-sm&quot;&gt;                    &lt;thead&gt;                    &lt;tr&gt;                        &lt;th&gt;id&lt;/th&gt;                        &lt;th&gt;lastName&lt;/th&gt;                        &lt;th&gt;email&lt;/th&gt;                        &lt;th&gt;gender&lt;/th&gt;                        &lt;th&gt;department&lt;/th&gt;                        &lt;th&gt;birth&lt;/th&gt;                        &lt;th&gt;操作&lt;/th&gt;                    &lt;/tr&gt;                    &lt;/thead&gt;                    &lt;tbody&gt;                    &lt;tr th:each=&quot;empl:${employees}&quot;&gt;                        &lt;td th:text=&quot;${empl.id}&quot;&gt;1001&lt;/td&gt;                        &lt;td&gt;[[${empl.lastName}]]&lt;/td&gt;                        &lt;td th:text=&quot;${empl.email}&quot;&gt;5589584@qq.com&lt;/td&gt;                        &lt;td th:text=&quot;${empl.gender}==&#39;0&#39;?&#39;女&#39;:&#39;男&#39;&quot;&gt;男&lt;/td&gt;                        &lt;td th:text=&quot;${empl.department.departmentName}&quot;&gt;商业提升部&lt;/td&gt;                        &lt;td th:text=&quot;${#dates.format(empl.birth, &#39;yyyy-MM-dd HH:mm:ss&#39;)}&quot;&gt;2018/11/1&lt;/td&gt;                        &lt;td&gt;                            &lt;button class=&quot;btn btn-sm btn-primary&quot;&gt;编辑&lt;/button&gt;                            &lt;button class=&quot;btn btn-sm btn-danger&quot;&gt;删除&lt;/button&gt;                        &lt;/td&gt;                    &lt;/tr&gt;                    &lt;/tbody&gt;                &lt;/table&gt;            &lt;/div&gt;        &lt;/main&gt;</code></pre><p>ctrl+F9:<br><img src="/images/QQ截图20181107170503.png"></p><h3 id="员工列表的添加"><a href="#员工列表的添加" class="headerlink" title="员工列表的添加"></a>员工列表的添加</h3><p>首先将员工信息的url换成/empls:代表获取所有的员工信息，而/empl：代表添加员工的信息。</p><p>1.将员工添加的按钮换成a标签：<br><img src="/images/QQ截图20181107172030.png"></p><p>2.在EmployeeController中：</p><pre><code>    @Autowired    private DepartmentDao departmentDao;    @GetMapping(&quot;/empl&quot;)    public String add(Model model) {        //获取所有的部门信息：        Collection&lt;Department&gt; departments = departmentDao.getDepartments();        model.addAttribute(&quot;departments&quot;, departments);        return &quot;empl/employee&quot;;    }</code></pre><p>3.在templates下的empl中添加employee.html页面：</p><p>首先，直接复制list.html为employee.html。</p><p>然后，修改其中的main标签部分：</p><pre><code>        &lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt;            &lt;form&gt;                &lt;div class=&quot;form‐group&quot;&gt;                    &lt;label&gt;LastName&lt;/label&gt;                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;Email&lt;/label&gt;                     &lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                    &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt;                    &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;                         &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot;   value=&quot;1&quot;&gt;                         &lt;label class=&quot;form‐check‐label&quot;&gt;男&lt;/label&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;                         &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot;   value=&quot;0&quot;&gt;                         &lt;label class=&quot;form‐check‐label&quot;&gt;女&lt;/label&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;department&lt;/label&gt;                     &lt;select class=&quot;form-control&quot;&gt;                        &lt;option&gt;1&lt;/option&gt;                        &lt;option&gt;2&lt;/option&gt;                        &lt;option&gt;3&lt;/option&gt;                        &lt;option&gt;4&lt;/option&gt;                        &lt;option&gt;5&lt;/option&gt;                     &lt;/select&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;Birth&lt;/label&gt;                     &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;button type=&quot;submit&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;添加&lt;/button&gt;            &lt;/form&gt;        &lt;/main&gt;</code></pre><p>4.重启应用：<br><img src="/images/QQ截图20181107174348.png"></p><p>5.此时的department部分还是死数据：</p><pre><code>&lt;div class=&quot;form‐group&quot;&gt;     &lt;label&gt;department&lt;/label&gt;     &lt;select class=&quot;form-control&quot;&gt;        &lt;option th:value=&quot;${dept.id}&quot; th:text=&quot;${dept.departmentName}&quot; th:each=&quot;dept:${departments}&quot;&gt;1&lt;/option&gt;     &lt;/select&gt;&lt;/div&gt;</code></pre><p>刷新页面：<br><img src="/images/QQ截图20181107174754.png"></p><p>6.给form表单添加action和method属性：</p><pre><code> &lt;form th:action=&quot;@{/empl}&quot; method=&quot;post&quot;&gt;</code></pre><p>7.书写添加员工的控制器</p><pre><code>    //添加员工    @PostMapping(&quot;/empl&quot;)    public String addEmployee(Employee employee) {        System.out.println(employee);        //添加员工        employeeDao.save(employee);        return &quot;redirect:/empls&quot;;    }</code></pre><p>8.重启应用，点击添加：<br><img src="/images/QQ截图20181107183750.png"><br><img src="/images/QQ截图20181107183847.png"></p><p>添加失败？因为我们的表单里面木有给属性添加name。<br>现在全部加上。</p><pre><code>   &lt;input type=&quot;text&quot; th:name=&quot;lastName&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;   &lt;input type=&quot;email&quot; th:name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot;&gt;   &lt;select class=&quot;form-control&quot; th:name=&quot;department.id&quot;&gt;    &lt;input type=&quot;text&quot; th:name=&quot;birth&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;</code></pre><p>然后再次尝试添加：<br><img src="/images/QQ截图20181107184848.png"></p><p>添加成功！！！</p><p><strong>注意：这里填写生日的格式必须是 xxxx/xx/xx 的形式。其他形式就会出错，因为Springboot默认格式化的日期格式就是xxxx/xx/xx 的形式</strong></p><p>如果，我们想改日期的格式呢？</p><p>打开WebMvcAutoConfiguration类：</p><pre><code>        @Bean        @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)        public Formatter&lt;Date&gt; dateFormatter() {            return new DateFormatter(this.mvcProperties.getDateFormat());        }</code></pre><p>默认帮我们配置好的时间格式转化器。</p><p>点击：getDateFormat()：</p><pre><code>    public String getDateFormat() {        return this.dateFormat;    }</code></pre><p>再点击：this.dateFormat</p><pre><code>    /**     * Date format to use (e.g. dd/MM/yyyy).     */    private String dateFormat;</code></pre><p>说明默认的确实是：dd/MM/yyyy的形式。</p><p>想要修改默认的格式：只需要在application.properties文件中修改spring.mvc.date-format=xxxx即可：</p><pre><code>#修改日期的格式spring.mvc.date-format=yyyy-MM-dd</code></pre><hr><h3 id="员工列表的编辑"><a href="#员工列表的编辑" class="headerlink" title="员工列表的编辑"></a>员工列表的编辑</h3><p>修改添加二合一表单</p><p>1）首先修改编辑按钮：</p><pre><code>  &lt;a th:href=&quot;@{/empl/}+${empl.id}&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;编辑&lt;/a&gt;</code></pre><p>2) EmployeeController中：</p><pre><code>    //去编辑员工的页面    @GetMapping(&quot;/empl/{id}&quot;)    public String toEditPage(@PathVariable(&quot;id&quot;) Integer id, Model model) {        //获取员工的信息：        Employee employee = employeeDao.get(id);        model.addAttribute(&quot;employee&quot;,employee);        //获取所有的部门信息：        Collection&lt;Department&gt; departments = departmentDao.getDepartments();        model.addAttribute(&quot;departments&quot;, departments);        //重定向到编辑员工的页面（add页面一样，共用）        return &quot;empl/employee&quot;;    }</code></pre><p>3) 在employee.html页面中回显员工的信息。</p><pre><code>            &lt;form th:action=&quot;@{/empl}&quot; method=&quot;post&quot;&gt;                &lt;div class=&quot;form‐group&quot;&gt;                    &lt;label&gt;LastName&lt;/label&gt;                    &lt;input type=&quot;text&quot; th:value=&quot;${employee.lastName}&quot; th:name=&quot;lastName&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;Email&lt;/label&gt;                     &lt;input type=&quot;email&quot; th:value=&quot;${employee.email}&quot; th:name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                    &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt;                    &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;                         &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:checked=&quot;${employee.gender}==1&quot;&gt;                         &lt;label class=&quot;form‐check‐label&quot;&gt;男&lt;/label&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;                         &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:checked=&quot;${employee.gender}==0&quot;&gt;                         &lt;label class=&quot;form‐check‐label&quot;&gt;女&lt;/label&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;department&lt;/label&gt;                     &lt;select class=&quot;form-control&quot; th:name=&quot;department.id&quot;&gt;                    &lt;option th:selected=&quot;${employee.department.id}==${dept.id}&quot; th:value=&quot;${dept.id}&quot; th:text=&quot;${dept.departmentName}&quot; th:each=&quot;dept:${departments}&quot;&gt;1                    &lt;/option&gt;                     &lt;/select&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;Birth&lt;/label&gt;                     &lt;input type=&quot;text&quot; th:value=&quot;${#dates.format(employee.birth, &#39;yyyy-MM-dd HH:mm:ss&#39;)}&quot; th:name=&quot;birth&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;button type=&quot;submit&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;添加&lt;/button&gt;            &lt;/form&gt;</code></pre><p>4) 重启应用，点击编辑<br><img src="/images/QQ截图20181107193709.png"></p><p><img src="/images/QQ截图20181107193721.png"></p><p>回显成功。</p><p>此时，再次点击添加时：<br><img src="/images/QQ截图20181107193842.png"></p><p>控制台：<br><img src="/images/QQ截图20181107193935.png"></p><p>这是因为，我们点击添加的时候，model对象中根本没有employee对象，所以employee.html中的：<br><strong>th:value=”${employee.lastName}”等都会出现空指针异常。</strong></p><p>5）再次修改employee.html页面：添加判断语句</p><p>${employee!=null}?</p><p>例如：</p><pre><code>th:value=&quot;${employee!=null}?${employee.lastName}&quot;</code></pre><p>此时：再次点击员工添加，就不会出现问题了。</p><p>6）button的按钮修改</p><pre><code>  &lt;button type=&quot;submit&quot; th:text=&quot;${employee!=null}?&#39;修改&#39;:&#39;添加&#39;&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;添加&lt;/button&gt;</code></pre><p>7）form表单的method的修改：</p><p>当是添加操作时，就是method=post提交。<br>当是修改操作时，就是method=put提交。</p><p>以前是SpringMVC的时候，想要使用put提交。</p><ol><li>SpringMVC中配置HiddenHttpMethodFilter;</li><li>页面创建一个post表单</li><li>创建一个input项，name=”_method”;值就是我们指定的请求方式</li></ol><p>Springboot已经默认帮我们配置好了HiddenHttpMethodFilter。在WebMvcAutoConfiguration中：</p><pre><code>    @Bean    @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {        return new OrderedHiddenHttpMethodFilter();    }</code></pre><p>所以，现在我们只需要添加一个input项，name=”_method”的标签即可：</p><pre><code>      &lt;input type=&quot;hidden&quot; name=&quot;_method&quot;  value=&quot;put&quot; th:if=&quot;${employee!=null}&quot;/&gt;      &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;${employee.id}&quot; th:if=&quot;${employee!=null}&quot;/&gt;</code></pre><p>8) EmployeeController中添加编辑的逻辑：</p><pre><code>    //修改员工    @PutMapping(&quot;/empl&quot;)    public String EditEmployee(Employee employee) {        System.out.println(employee);        //修改员工        employeeDao.save(employee);        return &quot;redirect:/empls&quot;;    }</code></pre><p>9) 随便点击一个员工进行修改：<br><img src="/images/QQ截图20181107195757.png"><br><img src="/images/QQ截图20181107195859.png"><br><img src="/images/QQ截图20181107195923.png"></p><p>修改成功！！！</p><h3 id="员工列表的删除"><a href="#员工列表的删除" class="headerlink" title="员工列表的删除"></a>员工列表的删除</h3><p>1）修改删除的按钮以delete的方式提交</p><p>不能简单的将button按钮标签改为a标签，因为a标签默认是get方式提交。</p><p>我们使用js的方式来提交表单：<br><img src="/images/QQ截图20181107202935.png"></p><p>2）添加js代码：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    $(&quot;.deleteBtn&quot;).click(function () {        var del_url = $(this).attr(&quot;del_url&quot;);        $(&quot;#deleteEmpForm&quot;).attr(&quot;action&quot;, del_url).submit();        //改变form默认的提交方式        return false;    })&lt;/script&gt;</code></pre><p>3) EmployeeController中：</p><pre><code>    //删除员工信息    @DeleteMapping(&quot;/empl/{id}&quot;)    public String deleteEmlp(@PathVariable(&quot;id&quot;) Integer id) {        //删除指定员工id的员工        employeeDao.delete(id);        return &quot;redirect:/empls&quot;;    }</code></pre><p>4) 重启应用，试试删除按钮</p><hr>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_04</title>
      <link href="/2018/11/05/springboot-day-04/"/>
      <url>/2018/11/05/springboot-day-04/</url>
      
        <content type="html"><![CDATA[<p>今天，我们开始Springboot的Web开发<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>使用SpringBoot:</p><p><strong>1）、创建SpringBoot应用，选中我们需要的模块；</strong></p><p><strong>2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来.</strong></p><p><strong>3）、自己编写业务代码；</strong></p><p>想要使用SpringBoot的自动配置的功能，我们必须熟知SpringBoot的自动配置的原理。</p><p><strong>自动配置原理：</strong></p><p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx</p><p>自动配置原理，一般我们需要看：spring-boot-autoconfigure<br><img src="/images/QQ截图20181105134252.png" style="width:50%"></p><p>然后再看我们想要的模块里面的：</p><pre><code>xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容；</code></pre><p>比如：Web模块，看DispatchServletAutoConfiguration<br><img src="/images/QQ截图20181105134739.png" style="width:50%"></p><h2 id="SpringBoot对静态资源的映射规则"><a href="#SpringBoot对静态资源的映射规则" class="headerlink" title="SpringBoot对静态资源的映射规则"></a>SpringBoot对静态资源的映射规则</h2><p>创建我们的今天的Web项目：（添加Web模块）<br><img src="/images/QQ截图20181105141110.png"></p><p>在：spring-boot-autoconfigurejar下：</p><p>web下的WebMvcAutoConfiguration：专门为我们配置了默认的Web应用的配置：<br><img src="/images/QQ截图20181105141946.png"></p><p><strong>设置：静态资源的相关配置的类：</strong></p><pre><code>@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware, InitializingBean {    private static final String[] SERVLET_RESOURCE_LOCATIONS = { &quot;/&quot; };    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = {            &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,            &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; };    private static final String[] RESOURCE_LOCATIONS;    static {        RESOURCE_LOCATIONS = new String[CLASSPATH_RESOURCE_LOCATIONS.length                + SERVLET_RESOURCE_LOCATIONS.length];        System.arraycopy(SERVLET_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS, 0,                SERVLET_RESOURCE_LOCATIONS.length);        System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS,                SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);    }   ·····  //可以设置和静态资源有关的参数，缓存时间等</code></pre><p><strong>设置静态资源映射的默认方法：</strong></p><pre><code>        @Override        public void addResourceHandlers(ResourceHandlerRegistry registry) {            if (!this.resourceProperties.isAddMappings()) {                logger.debug(&quot;Default resource handling disabled&quot;);                return;            }            Integer cachePeriod = this.resourceProperties.getCachePeriod();            if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {                customizeResourceHandlerRegistration(registry                        .addResourceHandler(&quot;/webjars/**&quot;)                        .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)                        .setCachePeriod(cachePeriod));            }            String staticPathPattern = this.mvcProperties.getStaticPathPattern();            if (!registry.hasMappingForPattern(staticPathPattern)) {                customizeResourceHandlerRegistration(                        registry.addResourceHandler(staticPathPattern)                                .addResourceLocations(                                        this.resourceProperties.getStaticLocations())                                .setCachePeriod(cachePeriod));            }        }</code></pre><h3 id="所有-webjars-，都去-classpath-META-INF-resources-webjars-找资源；"><a href="#所有-webjars-，都去-classpath-META-INF-resources-webjars-找资源；" class="headerlink" title="所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；"></a>所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；</h3><p>webjars：以jar包的方式引入静态资源.</p><p><a href="https://www.webjars.org/" target="_blank" rel="noopener">webjars官网</a></p><p>例子：引入jQuery的静态资源。</p><p>打开webjars官网，找到jQuery的Maven配置信息：<br><img src="/images/QQ截图20181105143244.png"></p><p>将拷贝的jQuery的Maven配置，导入到我们的项目中。</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.webjars&lt;/groupId&gt;            &lt;artifactId&gt;jquery&lt;/artifactId&gt;            &lt;version&gt;3.3.1-1&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>在我们的依赖jar中，找到jQuery的依赖：<br><img src="/images/QQ截图20181105143645.png" style="width:50%"></p><p>发现，这个依赖的jar的目录格式，也是classpath:/META-INF/resources/webjars/</p><font color="red">所以：当我们访问/webjars/**的url时，SpringBoot会帮我们在classpath:/META-INF/resources/webjars/选择webjars的静态jar资源。</font><p>启动我们的项目：</p><p>在浏览器中输入：<code>http://localhost:8080/webjars/jquery/3.3.1-1/jquery.js</code><br><img src="/images/QQ截图20181105144226.png"></p><p>webjar的静态资源访问成功！</p><h3 id="访问当前项目的任何资源，都去（静态资源的文件夹）找映射"><a href="#访问当前项目的任何资源，都去（静态资源的文件夹）找映射" class="headerlink" title="/**  访问当前项目的任何资源，都去（静态资源的文件夹）找映射"></a>/**  访问当前项目的任何资源，都去（静态资源的文件夹）找映射</h3><pre><code>String staticPathPattern = this.mvcProperties.getStaticPathPattern();    if (!registry.hasMappingForPattern(staticPathPattern)) {        customizeResourceHandlerRegistration(        registry.addResourceHandler(staticPathPattern)                .addResourceLocations(                        this.resourceProperties.getStaticLocations())                .setCachePeriod(cachePeriod));    }</code></pre><p>这里，注册了 staticPathPattern 和 this.resourceProperties.getStaticLocations() 的静态资源访问。</p><p>点击：staticPathPattern：<code>private String staticPathPattern = &quot;/**&quot;;</code> </p><p>点击：getStaticLocations()：</p><pre><code>    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = {            &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,            &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; };</code></pre><font color="red"><strong>总结</strong>：</font><p>对于：/** 的静态资源的访问。</p><p>会到以下的路径寻找静态资源：</p><p><strong>“classpath:/META‐INF/resources/“,</strong></p><p><strong>“classpath:/resources/“,</strong></p><p><strong>“classpath:/static/“,</strong></p><p><strong>“classpath:/public/“</strong></p><p>这里的”classpath”：就相当于我们项目的java、resources目录。</p><p>印证我们的默认的静态资源访问：</p><p>在以上的目录中随意放一张照片：<br><img src="/images/QQ截图20181105150445.png" style="width:50%"></p><p>三张，不同的照片，但是名字都是123.jpg的照片。</p><p>启动项目，在浏览器中输入：<code>http://localhost:8080/123.jpg</code></p><p><img src="/images/QQ截图20181105150124.png"></p><p>出现的是”META-INF/resources”下的123.jpg照片。 </p><p>删除”META-INF/resources”下的123.jpg照片. 再次访问是”classpath:/resources/“下的123.jpg</p><p>依次类推：再是”classpath:/static/“、”classpath:/public/“。</p><font color="red"><strong>优先级是：从上到下，依次递减</strong></font><hr><h3 id="欢迎页-静态资源文件夹下的所有index-html页面；被”-”映射"><a href="#欢迎页-静态资源文件夹下的所有index-html页面；被”-”映射" class="headerlink" title="欢迎页: 静态资源文件夹下的所有index.html页面；被”/**”映射"></a>欢迎页: 静态资源文件夹下的所有index.html页面；被”/**”映射</h3><pre><code>@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(        ResourceProperties resourceProperties) {    return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),            this.mvcProperties.getStaticPathPattern());}</code></pre><p>getWelcomePage():</p><pre><code>    private String[] getStaticWelcomePageLocations() {        String[] result = new String[this.staticLocations.length];        for (int i = 0; i &lt; result.length; i++) {            String location = this.staticLocations[i];            if (!location.endsWith(&quot;/&quot;)) {                location = location + &quot;/&quot;;            }            result[i] = location + &quot;index.html&quot;;        }        return result;    }</code></pre><p>getStaticPathPattern():</p><pre><code>private String staticPathPattern = &quot;/**&quot;;</code></pre><p><b>即对:　/**　 的访问。SpringBoot会自动到刚刚我们的提到的静态资源的文件夹下找index.html的页面</b></p><p>localhost:8080/ 找index页面</p><hr><h3 id="所有的-favicon-ico-都是在静态资源文件下找"><a href="#所有的-favicon-ico-都是在静态资源文件下找" class="headerlink" title="所有的 **/favicon.ico 都是在静态资源文件下找"></a>所有的 **/favicon.ico 都是在静态资源文件下找</h3><pre><code>@Beanpublic SimpleUrlHandlerMapping faviconHandlerMapping() {    SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();    mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);    mapping.setUrlMap(Collections.singletonMap(&quot;**/favicon.ico&quot;,            faviconRequestHandler()));    return mapping;}</code></pre><hr><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>JSP、Velocity、Freemarker、Thymeleaf<br><img src="/images/QQ截图20181105153402.png"></p><p>Springboot默认是不支持jsp模板引擎的，因为SpringBoot是打成jar包，使用嵌入式的Tomcat容器。</p><p>这里，我们使用SpringBoot官方推荐的Thymeleaf模板引擎。语法更简单，功能更强大</p><h3 id="引入thymeleaf"><a href="#引入thymeleaf" class="headerlink" title="引入thymeleaf"></a>引入thymeleaf</h3><pre><code>  &lt;!-- Springboot默认是：2.1.6 的版本 --&gt;    &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring‐boot‐starter‐thymeleaf&lt;/artifactId&gt;              &lt;/dependency&gt;   &lt;!-- 切换thymeleaf版本 --&gt;  &lt;properties&gt;     &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;             &lt;!‐‐ 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 ‐‐&gt;                &lt;thymeleaf‐layout‐dialect.version&gt;2.2.2&lt;/thymeleaf‐layout‐dialect.version&gt;          &lt;/properties&gt;</code></pre><p><strong>注意，SpringBoot默认导入的thymeleaf只是2.1.6的版本，如果想切换更高的版本，查看thymeleaf的github中的发行版</strong></p><p><a href="https://github.com/thymeleaf/thymeleaf/releases" target="_blank" rel="noopener">thymeleaf版本</a></p><p><strong>thymeleaf‐layout‐dialect.version：布局的版本，请注意，如果使用thymeleaf3以上的版本，那么布局的版本必须是2.0.0以上</strong>：<br><img src="/images/QQ截图20181105155420.png"></p><h3 id="Thymeleaf使用"><a href="#Thymeleaf使用" class="headerlink" title="Thymeleaf使用"></a>Thymeleaf使用</h3><pre><code>@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties {    private static final Charset DEFAULT_ENCODING = Charset.forName(&quot;UTF‐8&quot;);       private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(&quot;text/html&quot;);     public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;        public static final String DEFAULT_SUFFIX = &quot;.html&quot;;           //}</code></pre><p>Springboot默认的themleaf配置：</p><p>使用UTF-8字码，媒体类型：text/html，模板解析的前缀：classpath:/templates/，模板解析的后缀：.html</p><p>即：只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</p><p>使用：</p><p>1、导入thymeleaf的名称空间：(在idea中会有相应的提示功能)</p><pre><code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></pre><p>2、使用thymeleaf语法</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF‐8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;成功！&lt;/h1&gt;    &lt;!‐‐th:text 将div里面的文本内容设置为 ‐‐&gt;    &lt;div th:text=&quot;${hello}&quot;&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p><a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html" target="_blank" rel="noopener">thymeleaf参考手册</a></p><p>1）th:text；改变当前元素里面的文本内容；</p><p>th：任意html属性；来替换原生属性的值<br><img src="/images/QQ截图20181105163700.png"></p><p>2）表达式</p><p><strong>Simple expressions:（表达式语法）</strong></p><p>Variable Expressions: ${…}：获取变量值；OGNL；</p><p>1）、获取对象的属性、调用方法   </p><p>例如：＄{user.name}</p><p>2）、使用内置的基本对象：</p><p>　　　#ctx : the context object<br>　　　#vars: the context variables.<br>　　　#locale : the context locale.<br>　　　#request : (only in Web Contexts) the HttpServletRequest object.<br>　　　#response : (only in Web Contexts) the HttpServletResponse object.<br>　　　#session : (only in Web Contexts) the HttpSession object.<br>　　　#servletContext : (only in Web Contexts) the ServletContext object.</p><p>例如：${session.foo}</p><p>3）、内置的一些工具对象：</p><pre><code>#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated </code></pre><hr><p><strong>Selection Variable Expressions: *{…}：选择表达式：和 ${} 在功能上是一样；</strong></p><pre><code> 补充：配合 th:object=&quot;${session.user}：     &lt;div th:object=&quot;${session.user}&quot;&gt;    &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;    &lt;p&gt;Surname: &lt;span th:text=&quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;    &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt;   ---------------------------等价----------------------------------------  &lt;div&gt;    &lt;p&gt;Name: &lt;span th:text=&quot;${session.user.firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;    &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;    &lt;p&gt;Nationality: &lt;span th:text=&quot;${session.user.nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt;</code></pre><hr><p>其他表达式：</p><pre><code>Message Expressions: #{...}：获取国际化内容Link URL Expressions: @{...}：定义URL；@{/order/process(execId=${execId},execType=&#39;FAST&#39;)} Fragment Expressions: ~{...}：片段引用表达式&lt;div th:insert=&quot;~{commons :: main}&quot;&gt;...&lt;/div&gt;Literals（字面量）      Text literals: &#39;one text&#39; , &#39;Another one!&#39; ,…      Number literals: 0 , 34 , 3.0 , 12.3 ,…      Boolean literals: true , false      Null literal: null      Literal tokens: one , sometext , main ,…Text operations:（文本操作）    String concatenation: +    Literal substitutions: |The name is ${name}|Arithmetic operations:（数学运算）    Binary operators: + , ‐ , * , / , %    Minus sign (unary operator): ‐Boolean operations:（布尔运算）    Binary operators: and , or    Boolean negation (unary operator): ! , notComparisons and equality:（比较运算）    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )    Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符）    If‐then: (if) ? (then)    If‐then‐else: (if) ? (then) : (else)    Default: (value) ?: (defaultvalue)Special tokens:    No‐Operation: _</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_03</title>
      <link href="/2018/11/04/springboot-day-03/"/>
      <url>/2018/11/04/springboot-day-03/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot的日志框架与配置<br><a id="more"></a></p><h1 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h1><p>小张；开发一个大型系统；<br>1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？<br>2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar；<br>3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？<br>4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；<br>5、JDBC—数据库驱动；<br>写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；<br>给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p><hr><p><strong>市面上的日志框架</strong></p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p><p><img src="/images/QQ截图20181104094606.png"></p><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面： SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；</p><p><strong>SpringBoot选用 SLF4j和logback.</strong></p><h1 id="SLF4j使用"><a href="#SLF4j使用" class="headerlink" title="SLF4j使用"></a>SLF4j使用</h1><h2 id="如何在系统中使用SLF4j"><a href="#如何在系统中使用SLF4j" class="headerlink" title="如何在系统中使用SLF4j"></a>如何在系统中使用SLF4j</h2><p><a href="https://www.slf4j.org/" target="_blank" rel="noopener">SLF4j参考文档</a></p><p>以后开发的时候，日志记录方法的调用，<strong>不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</strong></p><p>给系统里面导入slf4j的jar和 logback的实现jar</p><pre><code>import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld {  public static void main(String[] args) {    Logger logger = LoggerFactory.getLogger(HelloWorld.class);    logger.info(&quot;Hello World&quot;);  }}</code></pre><p>图示:<br><img src="/images/QQ截图20181104095906.png"></p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是要用日志实现框架自己本身的配置文件；</strong></p><p>比如使用slf4j 和 logback，就用logback的配置文件，使用slf4j 和 log4j,就使用log4j的配置文件。而不是使用slf4j的配置文件。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>a系统（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>我们自己的a系统想要使用slf4j+logback做日志框架，但是我们的a系统是基于Spring、HIbernate等其他框架的，而这些其他框架底层使用的是其他日志框架，Spring使用的是commons-logging，Hibernate使用的是jboss-logging。</p><p>现在，我们想统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出，能做到吗？</p><p>slf4j官网给出了答案，<a href="https://www.slf4j.org/legacy.html" target="_blank" rel="noopener">参考答案</a></p><p><img src="/images/QQ截图20181104101357.png"></p><p><strong>如何让系统中所有的日志都统一到slf4j?</strong></p><font color="red">1、将系统中其他日志框架的日志jar包先排除出去；<br><br>2、用中间包来替换原有的日志框架的jar；<br><br>3、导入slf4j其他的实现。</font><h1 id="SpringBoot日志关系"><a href="#SpringBoot日志关系" class="headerlink" title="SpringBoot日志关系"></a>SpringBoot日志关系</h1><p>创建一个新的Springboot的应用，只需要Web模块即可。<br><img src="/images/QQ截图20181104103732.png"></p><p>现在，我们来查看一下Springboot的依赖关系。</p><p>查看依赖关系</p><p>1）使用idea的自带的maven管理器工具<br><img src="/images/QQ截图20181104103856.png" style="width:50%"></p><p>这样不够直观。</p><p>2）查看依赖图</p><p>在pom文件中，右键点击Diagrams -&gt; show dependencies<br><img src="/images/QQ截图20181104104228.png"><br><img src="/images/QQ截图20181104104542.png"></p><p>首先查看spring‐boot‐starter，因为这是Springboot的应用都必须依赖的jar包。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>然后发现，在spring‐boot‐starter下，有spring‐boot‐starter‐logging。</p><p>说明SpringBoot使用它来做日志功能</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>再来看spring-boot-starter-logging底层依赖：<br><img src="/images/QQ截图20181104105357.png"></p><p>总结：</p><p>1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p><p>2）、SpringBoot也把其他的日志都替换成了slf4j；</p><p>3）、中间替换包？</p><pre><code>@SuppressWarnings(&quot;rawtypes&quot;)public abstract class LogFactory {    static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J =&quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;;    static LogFactory logFactory = new SLF4JLogFactory();</code></pre><p><img src="/images/QQ截图20181104105601.png" style="width:50%"></p><p>其实这些jar包，本身还是原来的日志框架的jar包，只是在使用的过程中，偷换成了slf4j的日志框架，就和适配器模式很像。</p><p><strong>这些操作，Springboot已经帮我们做好了，我们只需要在引入其他框架的时候，移除掉他们本身的日志框架就行了。</strong></p><p>4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>　　　我们挑Spring来做一个列子：</p><p>　　　Spring框架用的是commons-logging；</p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring‐core&lt;/artifactId&gt;                    &lt;exclusions&gt;                        &lt;exclusion&gt;                            &lt;groupId&gt;commons‐logging&lt;/groupId&gt;                                &lt;artifactId&gt;commons‐logging&lt;/artifactId&gt;                            &lt;/exclusion&gt;                    &lt;/exclusions&gt;            &lt;/dependency&gt;</code></pre><p>发现，Springboot也帮我们剔除掉了，Springboot真方便！！！</p><font color="red"><strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要<br>把这个框架依赖的日志框架排除掉即可；</strong></font><h1 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h1><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p>直接运行，我们刚刚创建的项目：<br><img src="/images/QQ截图20181104112034.png"></p><p>发现，Springboot已经帮我们创建好了默认的配置。默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。在运行应用程序和其他例子时，你应该已经看到很多INFO级别的日志了。</p><p>从上图可以看到，日志输出内容元素具体如下：</p><ul><li>时间日期：精确到毫秒</li><li>日志级别：ERROR, WARN, INFO, DEBUG or TRACE</li><li>进程ID</li><li>分隔符：－－－ 标识实际日志的开始</li><li>线程名：方括号括起来（可能会截断控制台输出）</li><li>Logger名：通常使用源代码的类名</li><li>日志内容</li></ul><p>使用：</p><p>在测试类中：</p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot03LoggingApplicationTests {    //日志记录器    Logger logger = LoggerFactory.getLogger(getClass());    @Test    public void contextLoads() {        //System.out.println();  我们不再使用这种方法来记录了        //日志的级别，trace&lt;debug&lt;info&lt;warn&lt;error        //只会打印本级别和比本级别更高的日志        logger.trace(&quot;这是trace日志···&quot;);        logger.debug(&quot;这是debug日志···&quot;);        //Springboot默认的级别是info级别        logger.info(&quot;这是info日志···&quot;);        logger.warn(&quot;这是warn日志···&quot;);        logger.error(&quot;这error日志···&quot;);    }}</code></pre><p>运行测试方法：<br><img src="/images/QQ截图20181104113131.png"></p><p>只打印了info级别以及以上的。说明Springboot默认的日志级别是info。</p><p>1) 修改日志的级别。</p><p>在application.properties文件中。</p><pre><code>logging.level.com.liuzhuo=trace</code></pre><p>再次运行测试方法：<br><img src="/images/QQ截图20181104113410.png"></p><p>格式为：logging.level.* = LEVEL</p><ul><li>logging.level：日志级别控制前缀，*为包名或Logger名</li><li>LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF</li></ul><p>举例：</p><ul><li>logging.level.com.liuzhuo=DEBUG：com.liuzhuo包下所有class以DEBUG级别输出</li><li>logging.level.root=WARN：root日志以WARN级别输出</li></ul><p>2) 日志文件的输出</p><p>默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。</p><ul><li>logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log</li><li>logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log</li></ul><p>logging.file=xxx.log，会在项目的根目录下生成xxx.log文件<br>logging.file=G:/xxx.log，会在G盘下生xxx.log文件</p><p>logging.path=/aaa/bbb，会在项目的磁盘下，创建aaa/bbb文件夹，然后生成spring.log日志文件，<strong>日志文件的名字都是spring.log</strong></p><font color="red">注：二者不能同时使用，如若同时使用，则只有logging.file生效</font><p><strong>默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO</strong></p><p>3) 日志输出格式的设置</p><pre><code># 在控制台输出的日志的格式logging.pattern.console=%d{yyyy‐MM‐dd} [%thread] %‐5level %logger{50} ‐ %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d{yyyy‐MM‐dd} === [%thread] === %‐5level === %logger{50} ==== %msg%n</code></pre><pre><code>日志输出格式：%d表示日期时间，        %thread表示线程名，        %‐5level：级别从左显示5个字符宽度        %logger{50} 表示logger名字最长50个字符，否则按照句点分割。         %msg：日志消息，        %n是换行符      ‐‐&gt;%d{yyyy‐MM‐dd HH:mm:ss.SSS} [%thread] %‐5level %logger{50} ‐ %msg%n</code></pre><h2 id="指定配置"><a href="#指定配置" class="headerlink" title="指定配置"></a>指定配置</h2><p>在使用我们自己定义的日志配置文件之前，我们先来看看，为啥我们不用配置日志文件，Springboot中也能使用日志功能？</p><p>1) 打开org.springframework.boot:spring-boot:1.5.17.RELEASE<br>2) 打开org.springframework.boot<br>3) 打开logging、logback、base.xml<br><img src="/images/QQ截图20181104150319.png" style="width:50%"><br><img src="/images/QQ截图20181104150519.png" style="width:50%"></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Base logback configuration provided for compatibility with Spring Boot 1.1--&gt;&lt;included&gt;    &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt;    &lt;property name=&quot;LOG_FILE&quot; value=&quot;${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}}/spring.log}&quot;/&gt;    &lt;include resource=&quot;org/springframework/boot/logging/logback/console-appender.xml&quot; /&gt;    &lt;include resource=&quot;org/springframework/boot/logging/logback/file-appender.xml&quot; /&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;        &lt;appender-ref ref=&quot;FILE&quot; /&gt;    &lt;/root&gt;&lt;/included&gt;</code></pre><p>我们发现，Springboot已经帮我们默认配置好了。</p><p>我们看到root下的 level的等于INFO，所以Springboot默认是info级别。</p><p>再看<code>&lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt;</code></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Default logback configuration provided for import, equivalent to the programmaticinitialization performed by Boot--&gt;&lt;included&gt;    &lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot; /&gt;    &lt;conversionRule conversionWord=&quot;wex&quot; converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot; /&gt;    &lt;conversionRule conversionWord=&quot;wEx&quot; converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot; /&gt;    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&quot;/&gt;    &lt;property name=&quot;FILE_LOG_PATTERN&quot; value=&quot;${FILE_LOG_PATTERN:-%d{yyyy-MM-dd HH:mm:ss.SSS} ${LOG_LEVEL_PATTERN:-%5p} ${PID:- } --- [%t] %-40.40logger{39} : %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&quot;/&gt;    &lt;appender name=&quot;DEBUG_LEVEL_REMAPPER&quot; class=&quot;org.springframework.boot.logging.logback.LevelRemappingAppender&quot;&gt;        &lt;destinationLogger&gt;org.springframework.boot&lt;/destinationLogger&gt;    &lt;/appender&gt;    &lt;logger name=&quot;org.apache.catalina.startup.DigesterFactory&quot; level=&quot;ERROR&quot;/&gt;    &lt;logger name=&quot;org.apache.catalina.util.LifecycleBase&quot; level=&quot;ERROR&quot;/&gt;    &lt;logger name=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.apache.sshd.common.util.SecurityUtils&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.apache.tomcat.util.net.NioSelectorPool&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.crsh.plugin&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.crsh.ssh&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot; level=&quot;ERROR&quot;/&gt;    &lt;logger name=&quot;org.hibernate.validator.internal.util.Version&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.springframework.boot.actuate.autoconfigure.CrshAutoConfiguration&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.springframework.boot.actuate.endpoint.jmx&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;DEBUG_LEVEL_REMAPPER&quot;/&gt;    &lt;/logger&gt;    &lt;logger name=&quot;org.thymeleaf&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;DEBUG_LEVEL_REMAPPER&quot;/&gt;    &lt;/logger&gt;&lt;/included&gt;</code></pre><p>我们能看到</p><pre><code>&lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&quot;/&gt;</code></pre><p>这里就是配置控制台输出日志格式的配置，我们写在application.propertiese中的logging.pattern.console=xxx.就会覆盖这个配置中的内容，如果不配置的话，就使用默认的配置，就是冒号后面的一串：<code>-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} xxxxx</code></p><hr><p>现在我们已经了解到了Springboot的默认日志文件的配置了。当我们具体使用日志框架时，需要使用哪个配置文件呢？</p><p>打开Spring的官网，<a href="https://docs.spring.io/spring-boot/docs/1.5.17.RELEASE/reference/htmlsingle/#boot-features-logging" target="_blank" rel="noopener">logging参考文献</a></p><p>找到：<strong>26.5 Custom log configuration</strong></p><p><img src="/images/QQ截图20181104194411.png"></p><p>从图中，我们可以看出，使用logback日志框架，就使用logback-spring.xml、logback.xml等配置文件。</p><p>其他的日志框架，类似logback。</p><p><strong>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了。</strong></p><p>现在，我们在类路径下，即resources下，放入一个logback.xml的日志配置文件。<br><img src="/images/QQ截图20181104195557.png"></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan=&quot;false&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;    &lt;!-- 定义日志的根目录 --&gt;    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/app/log&quot; /&gt;    &lt;!-- 定义日志文件名称 --&gt;    &lt;property name=&quot;appName&quot; value=&quot;atguigu-springboot&quot;&gt;&lt;/property&gt;    &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt;    &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!--        日志输出格式：            %d表示日期时间，            %thread表示线程名，            %-5level：级别从左显示5个字符宽度            %logger{50} 表示logger名字最长50个字符，否则按照句点分割。             %msg：日志消息，            %n是换行符        --&gt;        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;        &lt;/layout&gt;    &lt;/appender&gt;    &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt;      &lt;appender name=&quot;appLogAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!-- 指定日志文件的名称 --&gt;        &lt;file&gt;${LOG_HOME}/${appName}.log&lt;/file&gt;        &lt;!--        当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名        TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。        --&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;!--            滚动时产生的文件的存放位置及文件名称 %d{yyyy-MM-dd}：按天进行日志滚动             %i：当文件大小超过maxFileSize时，按照i进行文件滚动            --&gt;            &lt;fileNamePattern&gt;${LOG_HOME}/${appName}-%d{yyyy-MM-dd}-%i.log&lt;/fileNamePattern&gt;            &lt;!--             可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动，            且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是，            那些为了归档而创建的目录也会被删除。            --&gt;            &lt;MaxHistory&gt;365&lt;/MaxHistory&gt;            &lt;!--             当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy            --&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;        &lt;/rollingPolicy&gt;        &lt;!-- 日志输出格式： --&gt;             &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [ %thread ] - [ %-5level ] [ %logger{50} : %line ] - %msg%n&lt;/pattern&gt;        &lt;/layout&gt;    &lt;/appender&gt;    &lt;!--         logger主要用于存放日志对象，也可以定义日志类型、级别        name：表示匹配的logger类型前缀，也就是包的前半部分        level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR        additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，        false：表示只用当前logger的appender-ref，true：        表示当前logger的appender-ref和rootLogger的appender-ref都有效    --&gt;    &lt;!-- hibernate logger --&gt;    &lt;logger name=&quot;com.atguigu&quot; level=&quot;debug&quot; /&gt;    &lt;!-- Spring framework logger --&gt;    &lt;logger name=&quot;org.springframework&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;&lt;/logger&gt;    &lt;!--     root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应，    要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。     --&gt;    &lt;root level=&quot;info&quot;&gt;        &lt;appender-ref ref=&quot;stdout&quot; /&gt;        &lt;appender-ref ref=&quot;appLogAppender&quot; /&gt;    &lt;/root&gt;&lt;/configuration&gt; </code></pre><p>现在，我们修改一下日志的输出格式：</p><pre><code> &lt;!-- 日志输出格式： --&gt;     &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;    &lt;pattern&gt;%d{yyyy-MM-dd} -----&gt; [ %thread ] -----&gt; [ %-5level ] [ %logger{50} : %line ] -----&gt; %msg%n&lt;/pattern&gt;&lt;/layout&gt;</code></pre><p><strong>把时间的时分秒去掉，然后把分隔符改为箭头。</strong></p><p>启动Springboot项目：<br><img src="/images/QQ截图20181104200138.png"></p><p>我们的日志配置文件设置成功了。</p><hr><p>我们注意到了，官网上面写了logback.xml和logback-spring.xml两种配置文件的<strong>书写方式。</strong></p><font color="red"><strong>官网推荐我们使用logback-spring.xml命名的配置文件。</strong></font><p>logback.xml: 是直接被日志框架识别，在Spring应用启动之前。不会走Spring的流程。</p><p><strong>logback-spring.xml:</strong> 日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot<br>的高级Profile功能</p><p>可以使用：在哪个环境下生效。</p><pre><code>&lt;springProfile name=&quot;staging&quot;&gt;    &lt;!‐‐ configuration to be enabled when the &quot;staging&quot; profile is active ‐‐&gt;   可以指定某段配置只在某个环境下生效  &lt;/springProfile&gt;</code></pre><p>如：</p><pre><code>&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!‐‐        日志输出格式：     %d表示日期时间，                 %thread表示线程名，                 %‐5level：级别从左显示5个字符宽度                 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。                  %msg：日志消息，                 %n是换行符                    ‐‐&gt;        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;            &lt;springProfile name=&quot;dev&quot;&gt;                &lt;pattern&gt;%d{yyyy‐MM‐dd HH:mm:ss.SSS} ‐‐‐‐&gt; [%thread] ‐‐‐&gt; %‐5level %logger{50} ‐ %msg%n&lt;/pattern&gt;            &lt;/springProfile&gt;            &lt;springProfile name=&quot;!dev&quot;&gt;                &lt;pattern&gt;%d{yyyy‐MM‐dd HH:mm:ss.SSS} ==== [%thread] ==== %‐5level %logger{50} ‐ %msg%n&lt;/pattern&gt;            &lt;/springProfile&gt;        &lt;/layout&gt;    &lt;/appender&gt;</code></pre><p>在dev环境下：使用上面的输出格式。</p><p>在非dev环境下：使用下面的输出格式。</p><p>现在运行Springboot项目：<br><img src="/images/QQ截图20181104201524.png"></p><p><strong>发现，日志框架出现错误了。因为我们的日志配置文件的名字还没有改。</strong></p><p>现在修改logback.xml —&gt; logback-spring.xml.</p><p>再次启动Springboot应用：<br><img src="/images/QQ截图20181104201940.png"></p><p>发现，启动的是非dev环境的日志控制台输出格式。</p><p>我们在配置Springboot为dev环境。</p><p>1）application.properties.</p><p>spring.profiles.active=dev</p><p>2) 配置命令行参数：<br><code>--spring.profiles.active=dev</code><br><img src="/images/QQ截图20181104202332.png"></p><p>使用上面两种方法都可以改变Springboot的环境。</p><p>然后启动Springboot应用：<br><img src="/images/QQ截图20181104202559.png"></p><h1 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h1><h2 id="切换成log4j"><a href="#切换成log4j" class="headerlink" title="切换成log4j"></a>切换成log4j</h2><p>现在，我们使用的是slf4j+logback。但是我们想换成slf4j + log4j怎么办？</p><p><strong>这里，说明一下，就是因为log4j有问题，所以才会推出logback日志框架的，这里只是做个例子演示日志框架的切换，实际情况下，直接使用logback日志框架就行。</strong></p><p>切换日志框架，我们直接参考slf4j的官网的那个图，就行。<br><img src="/images/QQ截图20181104204428.png"></p><p>现在打开我们的依赖图层：<br><img src="/images/QQ截图20181104204742.png"></p><p>去掉图中画红色框框的logback的依赖。</p><p>快速移除依赖：在想要移除的依赖上面，右键Exclude<br><img src="/images/QQ截图20181104205023.png"></p><p>移除完毕后：<br><img src="/images/QQ截图20181104205144.png" style="width:50%"></p><p>打开pom.xml文件：<br><img src="/images/QQ截图20181104205307.png"></p><p>现在需要添加log4j的依赖。</p><p>直接在pom.xml文件中添加：</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log412&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p><img src="/images/QQ截图20181104205726.png"></p><p>启动Springboot应用：<br><img src="/images/QQ截图20181104205838.png"><br><strong>发出警告，因为在类路径下，没有log4j.properties的配置文件。</strong></p><p>在resources下，添加log4j.properties的配置文件</p><pre><code>### set log levels ###log4j.rootLogger = debug ,  stdout ,  D ,  E### 输出到控制台 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern =  %d{ABSOLUTE} %5p %c{ 1 }:%L - %m%n#### 输出到日志文件 ####log4j.appender.D = org.apache.log4j.DailyRollingFileAppender#log4j.appender.D.File = logs/log.log#log4j.appender.D.Append = true#log4j.appender.D.Threshold = DEBUG ## 输出DEBUG级别以上的日志#log4j.appender.D.layout = org.apache.log4j.PatternLayout#log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n##### 保存异常信息到单独文件 ####log4j.appender.D = org.apache.log4j.DailyRollingFileAppender#log4j.appender.D.File = logs/error.log ## 异常日志文件名#log4j.appender.D.Append = true#log4j.appender.D.Threshold = ERROR ## 只输出ERROR级别以上的日志!!!#log4j.appender.D.layout = org.apache.log4j.PatternLayout#log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n</code></pre><p>再次启动应用，就会打印出日志信息了。</p><hr><h2 id="切换成log4j2"><a href="#切换成log4j2" class="headerlink" title="切换成log4j2"></a>切换成log4j2</h2><p>在官网上面，我们能发现，Springboot默认是加载logback日志框架的，我们也可以直接改成log4j2日志框架。</p><p>在pom.xml文件中：</p><pre><code>    &lt;dependency&gt;       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;          &lt;exclusions&gt;             &lt;exclusion&gt;                 &lt;artifactId&gt;spring‐boot‐starter‐logging&lt;/artifactId&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;/exclusion&gt;          &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring‐boot‐starter‐log4j2&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p>直接移除spring‐boot‐starter‐logging依赖。然后添加spring‐boot‐starter‐log4j2的依赖。</p><p>然后添加log4j2-spring.xml 或者 log4j2.xml 日志配置文件。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_02</title>
      <link href="/2018/11/03/springboot-day-02/"/>
      <url>/2018/11/03/springboot-day-02/</url>
      
        <content type="html"><![CDATA[<p>Springboot的配置文件<br><a id="more"></a></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>SpringBoot使用一个全局的配置文件，配置文件名是<strong>固定的</strong>；</p><ul><li>application.properties</li><li>application.yml</li></ul><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><p>xxx.properties文件，我们见的比较多，比较熟悉。</p><p>这里讲解yml文件。</p><p>YAML（YAML Ain’t Markup Language）<br>YAML A Markup Language：是一个标记语言<br>YAML isn’t Markup Language：不是一个标记语言；  </p><p>标记语言：<br>以前的配置文件；大多都使用的是 xxxx.xml文件；<br>YAML：以数据为中心，比json、xml等更适合做配置文件； </p><p>YAML：配置例子  </p><pre><code>server:  port: 8081</code></pre><p>XML：</p><pre><code>&lt;server&gt;   &lt;port&gt;8081&lt;/port&gt;    &lt;/server&gt;</code></pre><hr><p>1）创建新的Springboot项目，添加web模块即可：<br><img src="/images/QQ截图20181103104435.png"></p><p>2）在resources下，创建application.yml文件<br><img src="/images/QQ截图20181103104633.png"></p><p>3）启动项目<br><img src="/images/QQ截图20181103104821.png"></p><p>项目的端口号，修改成为8081.</p><h3 id="YAML语法："><a href="#YAML语法：" class="headerlink" title="YAML语法："></a>YAML语法：</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>k:(空格)v：表示一对键值对（<strong>空格必须有</strong>）；</p><p>以<strong>空格的缩进</strong>来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><p>例子：<br><img src="/images/QQ截图20181103105623.png"></p><p>注意：属性和值也是大小写敏感。</p><h4 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h4><h5 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="字面量：普通的值（数字，字符串，布尔）"></a>字面量：普通的值（数字，字符串，布尔）</h5><p>k: v：字面量直接来写；</p><p>字符串默认不用加上单引号或者双引号；</p><p>“”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><p>name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi</p><p>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi</p><h5 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h5><p>k: v：在下一行来写对象的属性和值的关系；注意缩进</p><p>对象还是k: v的方式</p><pre><code>friends:    lastName: zhangsan            age: 20 </code></pre><p>行内写法：</p><pre><code>friends: {lastName: zhangsan,age: 18}</code></pre><h5 id="数组（List、Set）："><a href="#数组（List、Set）：" class="headerlink" title="数组（List、Set）："></a>数组（List、Set）：</h5><p>用- 值表示数组中的一个元素</p><pre><code>pets: ‐ cat ‐ dog ‐ pig</code></pre><p>行内写法:</p><pre><code>pets: [cat,dog,pig]</code></pre><h3 id="配置文件值注入"><a href="#配置文件值注入" class="headerlink" title="配置文件值注入"></a>配置文件值注入</h3><h4 id="使用-ConfigurationProperties注解"><a href="#使用-ConfigurationProperties注解" class="headerlink" title="使用@ConfigurationProperties注解"></a>使用@ConfigurationProperties注解</h4><p>1) 在根包下，创建bean包，并创建Person和Dog类：</p><pre><code>public class Person {    private String lastName;    private Integer age;    private Boolean boss;    private Date birth;    private Map&lt;String, Object&gt; maps;    private List&lt;Object&gt; lists;    private Dog dog;   ····}</code></pre><pre><code>public class Dog {    private String name;    private Integer age;    ····}</code></pre><p>其中省略了，get、set、tostring的方法。</p><p>2）给application.yml文件赋值：</p><pre><code>person:  lastName: zhangSan  age: 18  boss: true  birth: 2018/11/11  maps: {k1: v1,k2: v2}  lists:    - list1    - list2  dog:    name: 小狗    age: 2</code></pre><p>3) 给Person类添加@ConfigurationProperties注解</p><pre><code>/** * 描述: * * @ConfigurationProperties: 配置文件的属性映射 * prefix：前缀。 */@ConfigurationProperties(prefix = &quot;person&quot;)public class Person {</code></pre><p>4) 测试：<br>在test包下，有一个测试类：<br>SpringBoot02ConfigApplicationTests</p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot02ConfigApplicationTests</code></pre><p>@RunWith(SpringRunner.class):使用Spring的测试驱动<br>@SpringBootTest：使用Springboot的测试</p><p>不再使用Junit测试，Spring的测试驱动，更加方便，可以使用自动注入什么的。</p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot02ConfigApplicationTests {    @Autowired    private Person person;    @Test    public void contextLoads() {        System.out.println(person);    }}</code></pre><p>这里：<code>private Person person;</code> 会报错，因为我们的Person类没有注入到容器中，所以，我们还需要在Person类上面，加上@Component注解。</p><pre><code>@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person </code></pre><p>运行测试：<br><img src="/images/QQ截图20181103114614.png"><br><img src="/images/QQ截图20181103114704.png"></p><p>在控制台，看到到了Person类的属性注入成功了。</p><p><strong>PS：想要在yml文件中书写时，有提示，我们可以加入配置文件处理器依赖：</strong></p><pre><code>        &lt;!--配置文件处理器，会给出提示--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;</code></pre><p><img src="/images/QQ截图20181103115009.png"></p><p>在yml配置文件中，person属性下：Alt+/ 会出Person类中还没有配置的属性。</p><p><strong>使用提示出现的属性，比如lastName，会是last-name的样子，都是一样的。-n 就相当于大写的N。</strong></p><hr><p>接下来，使用properties文件配置Person类：</p><p>将yml文件中的Person配置注释掉</p><p>在properties文件中：</p><pre><code>#idea中的properties文件是UTF-8的编码，而我们需要转换成ASCII编码#给person配置属性值person.last-name=张三person.age=20person.boss=falseperson.birth=2018/11/03person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=dogperson.dog.age=2</code></pre><p>运行测试：<br><img src="/images/QQ截图20181103120508.png"><br>此时出现了中文乱码的现象。</p><p>这是因为idea默认是使用utf-8的编码，不会转义成ascii。</p><p>打开idea的settings：<br><img src="/images/QQ截图20181103120858.png"></p><p>再次运行测试：<br><img src="/images/QQ截图20181103120952.png"></p><hr><h4 id="使用-Value注解"><a href="#使用-Value注解" class="headerlink" title="使用@Value注解"></a>使用@Value注解</h4><p>除了使用@ConfigurationProperties注解来给属性赋值，我们还知道可以还是要Spring的@Value注解。</p><pre><code>@Componentpublic class Person {    /**     * &lt;bean class=&quot;Person&quot;&gt;     *      &lt;property name=&quot;lastName&quot; value=&quot;字面量/${key}从环境变量、配置文件中获取值/#{SpEL}&quot;&gt;&lt;/property&gt;     * &lt;bean/&gt;     */    @Value(&quot;${person.last‐name}&quot;)    private String lastName;    @Value(&quot;#{11*2}&quot;)    private Integer age;    @Value(&quot;true&quot;)    private Boolean boss;    private Date birth;    private Map&lt;String,Object&gt; maps;    private List&lt;Object&gt; lists;    private Dog dog;</code></pre><p><strong>@Value获取值 和 @ConfigurationProperties获取值比较</strong></p><p><img src="/images/QQ截图20181103122845.png"></p><p>这里的松散绑定的意思是，lastName，last-name,last_name都可以在@ConfigurationProperties中使用，但是在@Value中，必须一模一样，比如：</p><p>在Person类中：<br>@Value(“${person.last-name}”)</p><p>在properties配置文件中，必须是：<br>person.last-name=张三</p><p>JSR303数据校验的意思是：</p><pre><code>@Component@ConfigurationProperties(prefix = &quot;person&quot;)@Validatedpublic class Person {    @Email    private String lastName;</code></pre><p>在Person类上，添加@Validated注解，开启数据校验的功能，然后在Person的属性上面，添加@Email、等其他注解，就可以提供数据校验的功能。</p><p>复杂类型封装的意思是：<br>比如：<br>使用@ConfigurationProperties(prefix = “person”)后，map类型的数据：<br>在配置文件中：maps: {k1: v1,k2: v2} 或者 person.maps.k1=v1，person.maps.k2=v2</p><p>然后自动就绑定上了，但是使用@Value注解，就不行。</p><p>@Value注入复杂的属性值：</p><p>1）使用util标签</p><pre><code>@Componentpublic class Properties {    @Value(&quot;#{testPro}&quot;)    private Properties pros;    @Value(&quot;#{testList}&quot;)    private List&lt;String&gt; myList;    @Value(&quot;#{testMap}&quot;)    private Map&lt;Integer, String&gt; myMap;</code></pre><pre><code>&lt;!-- applicationContext.xml --&gt;    &lt;!-- 扫描测试属性包中的类，要注入属性类需要被Spring管理 --&gt;&lt;context:component-scan base-package=&quot;com.xy.test2&quot; /&gt;&lt;!-- properties --&gt;&lt;util:properties id=&quot;testPro&quot; location=&quot;classpath:info/info2.properties&quot; /&gt;&lt;!-- list --&gt;&lt;util:list id=&quot;testList&quot; list-class=&quot;java.util.ArrayList&quot;&gt;    &lt;value&gt;first&lt;/value&gt;    &lt;value&gt;second&lt;/value&gt;    &lt;value&gt;third&lt;/value&gt;&lt;/util:list&gt;&lt;!-- map --&gt;&lt;util:map id=&quot;testMap&quot; map-class=&quot;java.util.HashMap&quot;&gt;    &lt;entry key=&quot;1&quot; value=&quot;first&quot; /&gt;    &lt;entry key=&quot;2&quot; value=&quot;second&quot; /&gt;    &lt;entry key=&quot;3&quot; value=&quot;third&quot; /&gt;&lt;/util:map&gt;</code></pre><p>2) 直接使用xml的形式来注入复杂的数据类型：</p><p>下边的一个java类包含了所有Map、Set、List、数组、属性集合等这些容器，主要用于演示Spring的注入配置；</p><pre><code>package com.lc.collection;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Department {    private String name;    private String [] empName;//数组    private List&lt;Employee&gt; empList;//list集合    private Set&lt;Employee&gt; empsets;//set集合    private Map&lt;String,Employee&gt; empMaps;//map集合    private Properties pp;//Properties的使用    public Set&lt;Employee&gt; getEmpsets() {        return empsets;    }    public void setEmpsets(Set&lt;Employee&gt; empsets) {        this.empsets = empsets;    }    public String[] getEmpName() {        return empName;    }    public void setEmpName(String[] empName) {        this.empName = empName;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public List&lt;Employee&gt; getEmpList() {        return empList;    }    public void setEmpList(List&lt;Employee&gt; empList) {        this.empList = empList;    }    public Map&lt;String, Employee&gt; getEmpMaps() {        return empMaps;    }    public void setEmpMaps(Map&lt;String, Employee&gt; empMaps) {        this.empMaps = empMaps;    }    public Properties getPp() {        return pp;    }    public void setPp(Properties pp) {        this.pp = pp;    }}</code></pre><p>Spring配置文件beans.xml文件:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd                http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;&lt;bean id=&quot;department&quot; class=&quot;com.hsp.collection.Department&quot;&gt;&lt;property name=&quot;name&quot; value=&quot;财务部&quot;/&gt;&lt;!-- 给数组注入值 --&gt;&lt;property name=&quot;empName&quot;&gt;    &lt;list&gt;        &lt;value&gt;小明&lt;/value&gt;        &lt;value&gt;小明小明&lt;/value&gt;        &lt;value&gt;小明小明小明小明&lt;/value&gt;    &lt;/list&gt;&lt;/property&gt;&lt;!-- 给list注入值 list 中可以有相当的对象 --&gt;&lt;property name=&quot;empList&quot;&gt;    &lt;list&gt;        &lt;ref bean=&quot;emp2&quot; /&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;    &lt;/list&gt;&lt;/property&gt;&lt;!-- 给set注入值 set不能有相同的对象 --&gt;&lt;property name=&quot;empsets&quot;&gt;    &lt;set&gt;        &lt;ref bean=&quot;emp1&quot; /&gt;        &lt;ref bean=&quot;emp2&quot;/&gt;        &lt;ref bean=&quot;emp2&quot;/&gt;        &lt;ref bean=&quot;emp2&quot;/&gt;        &lt;ref bean=&quot;emp2&quot;/&gt;    &lt;/set&gt;&lt;/property&gt;&lt;!-- 给map注入值 map只有key不一样，就可以装配value --&gt;&lt;property name=&quot;empMaps&quot;&gt;    &lt;map&gt;        &lt;entry key=&quot;11&quot; value-ref=&quot;emp1&quot; /&gt;         &lt;entry key=&quot;22&quot; value-ref=&quot;emp2&quot;/&gt;        &lt;entry key=&quot;22&quot; value-ref=&quot;emp1&quot;/&gt;    &lt;/map&gt;&lt;/property&gt;&lt;!-- 给属性集合配置 --&gt;&lt;property name=&quot;pp&quot;&gt;    &lt;props&gt;        &lt;prop key=&quot;pp1&quot;&gt;abcd&lt;/prop&gt;        &lt;prop key=&quot;pp2&quot;&gt;hello&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;emp1&quot; class=&quot;com.hsp.collection.Employee&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;北京&quot;/&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;emp2&quot; class=&quot;com.hsp.collection.Employee&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;天津&quot;/&gt;    &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><p>配置文件yml还是properties他们都能获取到值；</p><p>总结：</p><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；<br>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h4 id="PropertySource-amp-ImportResource-amp-Bean"><a href="#PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="@PropertySource &amp; @ImportResource &amp; @Bean"></a>@PropertySource &amp; @ImportResource &amp; @Bean</h4><p>@ConfigurationProperties默认加载默认的全局配置中的内容。</p><p>但是，我们并不想将所有的配置内容都放在全局的配置文件中，则使用@PropertySource注解。</p><p>@PropertySource：加载指定的配置文件。</p><pre><code>/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能； *  @ConfigurationProperties(prefix = &quot;person&quot;)默认从全局配置文件中获取值； * */@PropertySource(value = {&quot;classpath:person.properties&quot;})@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person {   ···｝</code></pre><p>@PropertySource(value = {“classpath:person.properties”})：这里指定了在类路径下的person.properties文件中内容映射到本类的属性中。</p><p><img src="/images/QQ截图20181103141521.png"></p><p><strong>注意：</strong><br>再将默认的全局配置文件中的person属性注释掉，因为全局的配置文件的优先级高于自定义的配置文件的优先级。</p><p>运行测试类：<br><img src="/images/QQ截图20181103141730.png"></p><p>此时，我们加载的就是自定义person.properties文件中的内容了。</p><p>@<strong>ImportResource</strong>：导入Spring的xml配置文件，让配置文件里面的内容生效；</p><p>Spring Boot里面没有Spring的xml配置文件，我们自己编写的配置文件，也不能自动识别；<br>想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上。</p><p>在resources下，创建beans.xml文件。<br>在service下，创建HellService类</p><p><img src="/images/QQ截图20181103142248.png"></p><p>修改测试类：<br><img src="/images/QQ截图20181103142451.png"></p><p>运行测试方法：<br><img src="/images/QQ截图20181103142633.png"></p><p>在Springboot启动类上，加上@ImportResource注解：</p><p>因为@SpringBootApplication注解本身也是一个配置类<br><img src="/images/QQ截图20181103142813.png"></p><p>再次运行测试方法：<br><img src="/images/QQ截图20181103142947.png"></p><p><strong>@Bean</strong></p><p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p><p>不来编写Spring的xml配置文件。</p><p>1）配置类@Configuration——&gt;Spring配置文件</p><p>2）使用@Bean给容器中添加组件</p><p>在config下，创建一个配置类：<br><img src="/images/QQ截图20181103143527.png"></p><p>去掉SpringBootApplication启动类上的@ImportResource注解；</p><p>运行测试方法：<br><img src="/images/QQ截图20181103142947.png"></p><hr><h4 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h4><p>1）随机数</p><pre><code>${random.value}、${random.int}、${random.long}${random.int(10)}、${random.int[1024,65536]}</code></pre><p>比如：<br><img src="/images/QQ截图20181103144510.png"></p><p>2）占位符获取之前配置的值，如果没有可以是用:指定默认值</p><pre><code>person.last‐name=张三${random.uuid}person.age=${random.int}person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=${person.hello:hello}_dogperson.dog.age=15</code></pre><p>这里的person.dog.name使用了${person.hello:hello}_dog，如果${person.hello:hello}之前没有配置，就会使用冒号后面的默认值hello。如果没有写冒号后面的值，即：person.dog.name=${person.hello}_dog。则原样输出。（没有配置${person.hello}的话）。</p><h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><h5 id="多Profile文件"><a href="#多Profile文件" class="headerlink" title="多Profile文件"></a>多Profile文件</h5><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml</p><p><strong>默认使用application.properties的配置。</strong></p><p>默认的配置文件application.properties：<br><img src="/images/QQ截图20181103150324.png"></p><p>创建dev配置文件：<br><img src="/images/QQ截图20181103150535.png"></p><p>创建prod配置文件：<br><img src="/images/QQ截图20181103150641.png"></p><p>启动SpringBoot应用：<br><img src="/images/QQ截图20181103150737.png"><br><img src="/images/QQ截图20181103150805.png"></p><p>可以看出，默认启动，application.properties的配置。端口号：8081</p><h5 id="激活指定profile"><a href="#激活指定profile" class="headerlink" title="激活指定profile"></a>激活指定profile</h5><p>1）在默认配置文件中指定 spring.profiles.active=dev<br><img src="/images/QQ截图20181103151018.png"></p><p>启动SpringBoot应用：<br><img src="/images/QQ截图20181103151137.png"></p><p>端口号：8082.</p><p>2）命令行：</p><p>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar  <strong>–spring.profiles.active=dev；</strong></p><p>这里是（两个减号）<br><img src="/images/QQ截图20181103151355.png"><br><img src="/images/QQ截图20181103151622.png"><br><img src="/images/QQ截图20181103151704.png"></p><p>端口号是：8083</p><p><strong>激活的是prod，说明命令行参数的优先级 高于 配置文件的激活的优先级。</strong></p><p>3) 虚拟机参数；</p><p>-Dspring.profiles.active=dev</p><p>（这里是一个减号）<br><img src="/images/QQ截图20181103152038.png"><br><img src="/images/QQ截图20181103152205.png"><br><img src="/images/QQ截图20181103152225.png"></p><p>端口号：8082</p><p><strong>激活的是dev。说明虚拟机参数的优先级 高于 配置文件的优先级</strong></p><hr><p>当命令行参数与虚拟机参数同时存在时，以命令行参数为准。</p><p>即：命令行的优先级最高。</p><p><img src="/images/QQ截图20181103152736.png"><br><img src="/images/QQ截图20181103152756.png"></p><p>端口号是：8083</p><p>激活的是prod。</p><h5 id="yml支持多文档块方式"><a href="#yml支持多文档块方式" class="headerlink" title="yml支持多文档块方式"></a>yml支持多文档块方式</h5><p>在yml文件中，支持多文档块方式，即在一个yml文件中，书写多个文件配置。</p><p>使用—隔开。这里是三个减号。</p><p>首先，注释掉所有的properties文件和启动的命令行与虚拟机参数。</p><p>修改yml文件：</p><p><img src="/images/QQ截图20181103153342.png"></p><p>启动SpringBoot应用：<br><img src="/images/QQ截图20181103153506.png"></p><p>端口号：8084</p><p>激活的是dev文件。</p><h4 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h4><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件。</p><p>–file:./config/<br>–file:./<br>–classpath:/config/<br>–classpath:/</p><p><strong>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</strong></p><p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置。</strong></p><p>file：代表的是项目的根路径下。</p><p>classpath：代表的是resources下。</p><p>1）application.properties中：<br><img src="/images/QQ截图20181103155025.png"><br>端口号：8081</p><p>启动项目：<br><img src="/images/QQ截图20181103155147.png"><br>端口号启动的也是8081.</p><p>2）在resources下创建config包，并创建application.properties文件：<br><img src="/images/QQ截图20181103155312.png"><br>端口号是：8082</p><p>启动项目：<br><img src="/images/QQ截图20181103155414.png"><br>启动的端口号：8082</p><p>3）在项目的根路径下创建application.properties文件：</p><p>即：在spring-boot-02-config右键创建文件。<br><img src="/images/QQ截图20181103155603.png"><br>端口号：8083</p><p>启动项目：<br><img src="/images/QQ截图20181103155649.png"><br>启动的端口号：8083</p><p>4）在项目的根路径下创建config文件夹，并application.properties文件：<br><img src="/images/QQ截图20181103155800.png"><br>端口号：8084</p><p>启动项目：<br><img src="/images/QQ截图20181103155859.png"><br>启动的端口号：8084</p><p>印证了SpringBoot加载配置文件的优先级。</p><p>当四个位置都有配置文件时，是<strong>互补配置的</strong>。</p><p>即当高优先级的配置文件中存在低优先级的配置文件中的内容时会覆盖低优先级中的内容，但是当高优先级的配置文件中，没有低优先级文件中的内容时，会直接加载低优先级文件中的内容。</p><p><strong>注意：我们还可以通过spring.config.location来改变默认的配置文件位置</strong></p><p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默<br>认加载的这些配置文件共同起作用形成互补配置；</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar  –spring.config.location=G:/application.properties</p><p>此时：G:/application.properties文件的优先级最高，然后互补配置。</p><h4 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h4><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p><font color="red">1.命令行参数</font><br>所有的配置都可以在命令行上进行指定<br>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar  <strong>–server.port=8087  –server.context-path=/abc</strong><br><br>多个配置用空格分开； –配置项 = 值 (两个减号)<br><br>2.来自java:comp/env的JNDI属性<br><br>3.Java系统属性（System.getProperties()）<br><br>4.操作系统环境变量<br><br>5.RandomValuePropertySource配置的random.*属性值<br><br><strong>由jar包外向jar包内进行寻找；</strong><br><br><strong>优先加载带profile</strong><br><br><font color="red">6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</font><br><font color="red">7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</font><p><strong>再来加载不带profile</strong></p><font color="red">8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</font><br><font color="red">9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</font><p>10.@Configuration注解类上的@PropertySource<br>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><h4 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h4><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h5 id="自动配置原理："><a href="#自动配置原理：" class="headerlink" title="自动配置原理："></a>自动配置原理：</h5><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 <strong>@EnableAutoConfiguration</strong></p><p>2）、@EnableAutoConfiguration 作用：</p><ul><li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</li><li>可以查看selectImports()方法的内容；</li><li>List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置<pre><code>SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下  META‐INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</code></pre></li></ul><p><strong>将类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；</strong></p><pre><code># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</code></pre><p>每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p>3）、每一个自动配置类进行自动配置功能；</p><p>4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；</p><pre><code>@Configuration   //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class)  //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class)  //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing =true)  //判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration {   //他已经和SpringBoot的配置文件映射了     private final HttpEncodingProperties properties;   //只有一个有参构造器的情况下，参数的值就会从容器中拿   public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {        this.properties = properties;           }    @Bean   //给容器中添加一个组件，这个组件的某些值需要从properties中获取@ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？    public CharacterEncodingFilter characterEncodingFilter() {        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();            filter.setEncoding(this.properties.getCharset().name());            filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));            filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));            return filter;        } </code></pre><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一旦这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者；配置文件能配置什么就可以参照某个功能对应的这个属性类</p><pre><code>@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)  //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties {   public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF‐8&quot;);</code></pre><p><strong>精髓：<br>1）、SpringBoot启动会加载大量的自动配置类<br>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；<br>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）<br>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这<br>些属性的值.</strong></p><p>xxxxAutoConfigurartion：自动配置类；给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><p>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效；</p><p><img src="/images/QQ截图20181103170857.png"></p><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><font color="#EE2C2C">我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</font><pre><code>=========================AUTO‐CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐   DispatcherServletAutoConfiguration matched: ‐ @ConditionalOnClass found required class&#39;org.springframework.web.servlet.DispatcherServlet&#39;; @ConditionalOnMissingClass did not findunwanted class (OnClassCondition)      ‐ @ConditionalOnWebApplication (required) found StandardServletEnvironment(OnWebApplicationCondition)Negative matches:（没有启动，没有匹配成功的自动配置类）‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐   ActiveMQAutoConfiguration:      Did not match:         ‐ @ConditionalOnClass did not find required classes &#39;javax.jms.ConnectionFactory&#39;,&#39;org.apache.activemq.ActiveMQConnectionFactory&#39; (OnClassCondition)   AopAutoConfiguration:      Did not match:         ‐ @ConditionalOnClass did not find required classes&#39;org.aspectj.lang.annotation.Aspect&#39;, &#39;org.aspectj.lang.reflect.Advice&#39; (OnClassCondition)</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_01</title>
      <link href="/2018/11/02/springboot-day-01/"/>
      <url>/2018/11/02/springboot-day-01/</url>
      
        <content type="html"><![CDATA[<p>Spring boot 来简化Spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用。<br><a id="more"></a></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>J2EE笨重的开发、繁多的配置、低下的开发效率、复杂的部署流程、第三方技术集成难度大。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>“Spring全家桶”时代.</p><p>SpringBoot -&gt; J2EE一站式解决方案</p><p>SpingCloud -&gt; 分布式整体解决方案</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>快速创建独立运行的Spring项目以及与主流框架集成  </li><li>使用嵌入式的Servlet容器，应用无需打成WAR包  </li><li>starters自动依赖与版本控制  </li><li>大量的自动配置，简化开发，也可修改默认值  </li><li>无需配置XML，无代码生成，开箱即用  </li><li>准生产环境的运行时应用监控  </li><li>与云计算的天然集成  </li></ul><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>2014，martin fowler</p><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p><p>单体应用：ALL IN ONE</p><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" title="微服务参考" target="_blank" rel="noopener">微服务参考</a></p><h3 id="环境约束："><a href="#环境约束：" class="headerlink" title="环境约束："></a>环境约束：</h3><ul><li>jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112”  </li><li>maven3.x：maven 3.3以上版本；Apache Maven 3.3.9  </li><li>IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64 、STS  </li><li>SpringBoot 1.5.9.RELEASE：1.5.9；  </li></ul><p><a href="https://pan.baidu.com/s/1ay5tPJkNJeptSkFgjiL_Zw" target="_blank" rel="noopener">环境软件下载</a></p><p>密码：jpro</p><p>统一环境；</p><p><strong>1.Maven设置</strong></p><p>给maven 的 settings.xml配置文件的profiles标签添加</p><pre><code>&lt;profile&gt;  &lt;id&gt;jdk‐1.8&lt;/id&gt;  &lt;activation&gt;    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;    &lt;jdk&gt;1.8&lt;/jdk&gt;  &lt;/activation&gt;  &lt;properties&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;  &lt;/properties&gt;&lt;/profile&gt;</code></pre><p><strong>2.IDEA设置</strong></p><p>整合maven进来</p><p><img src="/images/QQ截图20181102151849.png"><br><img src="/images/QQ截图20181102152017.png"></p><p>将maven配置成我们的maven，不使用idea自带的maven。</p><p>Maven home directory： maven的安装路径</p><p>User setting file：maven的setting配置文件的路径</p><p>Local repository：maven的本地仓库的路径。</p><h3 id="Spring-Boot-HelloWorld"><a href="#Spring-Boot-HelloWorld" class="headerlink" title="Spring Boot HelloWorld"></a>Spring Boot HelloWorld</h3><p>一个功能：</p><p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p><h4 id="创建一个maven项目-jar"><a href="#创建一个maven项目-jar" class="headerlink" title="创建一个maven项目(jar)"></a>创建一个maven项目(jar)</h4><p><img src="/images/QQ截图20181102154909.png"><br><img src="/images/QQ截图20181102155112.png"><br><img src="/images/QQ截图20181102155230.png"><br><img src="/images/QQ截图20181102155348.png"><br><img src="/images/QQ截图20181102155708.png"></p><h4 id="导入spring-boot相关的依赖"><a href="#导入spring-boot相关的依赖" class="headerlink" title="导入spring boot相关的依赖"></a>导入spring boot相关的依赖</h4><pre><code>   &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt;        &lt;version&gt;1.5.17.RELEASE&lt;/version&gt;   &lt;/parent&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p><strong>现在的spring boot的1.x的版本没有1.5.9，所以我们使用1.5.17.RELEASE。</strong></p><p>我们可以参考Spring的官网的文档。<a href="https://spring.io/" target="_blank" rel="noopener">Spring官网</a><br><img src="/images/QQ截图20181102160852.png"><br><img src="/images/QQ截图20181102161036.png"><br><img src="/images/QQ截图20181102161400.png"></p><p>添加依赖后，idea就会帮我们开始下载依赖，如果没有自动下载，可以点击idea的右边的Maven Projects，然后点击上面的循环标志。<br><img src="/images/QQ截图20181102162613.png" style="width:50%"></p><p>依赖下载完毕后，可以看到我们的依赖文件：<br><img src="/images/QQ截图20181102162819.png"></p><h4 id="编写一个主程序"><a href="#编写一个主程序" class="headerlink" title="编写一个主程序"></a>编写一个主程序</h4><p>在src/main/java下创建com.liuzhuo的包，并创建HelloWorldApplication类：<br><img src="/images/QQ截图20181102163202.png"></p><p>添加@SpringBootApplication注解，并编写一个主函数。</p><pre><code>@SpringBootApplication  //表明这是一个Springboot的启动类public class HelloWorldApplication {    public static void main(String[] args) {        //启动Springboot应用。        SpringApplication.run(HelloWorldApplication.class);    }}</code></pre><h4 id="编写相关的Controller"><a href="#编写相关的Controller" class="headerlink" title="编写相关的Controller"></a>编写相关的Controller</h4><p>在com.liuzhuo.controller下，创建HelloController</p><pre><code>@Controllerpublic class HelloController {    @ResponseBody    @RequestMapping(&quot;/hello&quot;)    public String hello(){        return &quot;Hello World!&quot;;    }}</code></pre><h4 id="运行主程序测试"><a href="#运行主程序测试" class="headerlink" title="运行主程序测试"></a>运行主程序测试</h4><p>回到Springboot的启动类中，直接运行main函数：<br><img src="/images/QQ截图20181102163832.png"><br><img src="/images/QQ截图20181102163913.png"><br><img src="/images/QQ截图20181102163946.png"></p><p>出现上图所示的效果就说明Springboot应用启动成功。</p><p>在浏览器中输入：<code>http://localhost:8080/hello</code></p><p><img src="/images/QQ截图20181102164146.png"></p><h4 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h4><p>以前，部署Web应用，需要将我们的Web项目生成War，然后在服务器中安装服务器，比如Tomcat等，然后将War放在Tomcat容器中，启动Tomcat容器。</p><p>现在，我们不需要这么麻烦了，我们直接生成jar就行。生成jar之前，我们需要在pom文件中添加Springboot的构建插件。</p><pre><code>    &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包--&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>然后生成jar包：<br><img src="/images/QQ截图20181102164849.png" style="width:50%"></p><p>双击：package。</p><p>控制台输出：BUILD SUCCESS<br><img src="/images/QQ截图20181102165053.png"></p><p>我们，可以在target包下，看到我们生成的可运行的jar。<br><img src="/images/QQ截图20181102165310.png"></p><p>拷贝这个jar到我们的桌面上面：<br><img src="/images/QQ截图20181102165410.png"></p><p>打开命令行界面：<br><img src="/images/QQ截图20181102165718.png"></p><p>我们的Springboot应用就启动了，这样是不是很简单，都不需要打成war包和安装Tomcat。</p><p>在浏览器中输入：<code>http://localhost:8080/hello</code></p><p><img src="/images/QQ截图20181102164146.png"></p><h3 id="Hello-World-的探究"><a href="#Hello-World-的探究" class="headerlink" title="Hello World 的探究"></a>Hello World 的探究</h3><h4 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h4><p>1）父项目</p><pre><code>&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt;    &lt;version&gt;1.5.17.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring‐boot‐dependencies&lt;/artifactId&gt;  &lt;version&gt;1.5.17.RELEASE&lt;/version&gt;  &lt;relativePath&gt;../../spring‐boot‐dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本；</code></pre><p>Spring Boot的版本仲裁中心；</p><p>以后我们导入依赖,默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p><p>2) 启动器</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>spring-boot-starter-web：</p><p>spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p><p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter.<br>相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器.</p><h4 id="主程序类，主入口类"><a href="#主程序类，主入口类" class="headerlink" title="主程序类，主入口类"></a>主程序类，主入口类</h4><pre><code>/** * 描述: * * @author liuzhuo * @create 2018-11-02 16:31 */@SpringBootApplication  //表明这是一个Springboot的启动类public class HelloWorldApplication {    public static void main(String[] args) {        //启动Springboot应用。        SpringApplication.run(HelloWorldApplication.class);    }}</code></pre><p><strong>@SpringBootApplication:</strong> Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot<br>就应该运行这个类的main方法来启动SpringBoot应用；</p><p>点击@SpringBootApplication注解：</p><pre><code>@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = {        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication</code></pre><p>发现@SpringBootApplication注解是一个组合注解，下面我们一一来看。</p><p><strong>@SpringBootConfiguration:</strong> Spring Boot的配置类；</p><p>标注在某个类上，表示这是一个Spring Boot的配置类；</p><pre><code>@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration {}</code></pre><p>其实就是一个@Configuration注解，只是@Configuration注解，我们是在Spring中使用，@SpringBootConfiguration是在Springboot中使用，本质都一个配置类。</p><p>配置类 —– 配置文件；配置类也是容器中的一个组件；@Component</p><p><strong>@EnableAutoConfiguration</strong>：开启自动配置功能；</p><p>以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自<br>动配置功能；这样自动配置才能生效；</p><pre><code>@SuppressWarnings(&quot;deprecation&quot;)@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration</code></pre><p><strong>@AutoConfigurationPackage</strong>：自动配置包</p><pre><code>@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage {}</code></pre><p>@Import(AutoConfigurationPackages.Registrar.class)：<br>Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class注入；</p><pre><code>    @Order(Ordered.HIGHEST_PRECEDENCE)    static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {        @Override        public void registerBeanDefinitions(AnnotationMetadata metadata,                BeanDefinitionRegistry registry) {            register(registry, new PackageImport(metadata).getPackageName());        }        @Override        public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) {            return Collections.&lt;Object&gt;singleton(new PackageImport(metadata));        }    }</code></pre><p>给这个方法打上断点。debug下</p><p><strong>会发现，Spring会把将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</strong></p><p>@<strong>Import(EnableAutoConfigurationImportSelector.class)；</strong></p><p>给容器中导入组件？</p><p>EnableAutoConfigurationImportSelector：导入哪些组件的选择器；</p><p>将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p>会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；<br><img src="/images/QQ截图20181102192759.png"></p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；<br>SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p><p>Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将<br>这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东<br>西，自动配置类都帮我们；<br><img src="/images/QQ截图20181102193127.png"></p><p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.17.RELEASE.jar；</p><p>所以，@EnableAutoConfiguration自动配置的魔法骑士就变成了：</p><p><strong>从classpath中搜寻所有的 META-INF/spring.factories 配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项</strong>  </p><p><strong>通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</strong></p><h3 id="深入探索SpringApplication执行流程"><a href="#深入探索SpringApplication执行流程" class="headerlink" title="深入探索SpringApplication执行流程"></a>深入探索SpringApplication执行流程</h3><p>SpringApplication的run方法的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下：</p><p>1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p><ul><li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li><li>推断并设置main方法的定义类。</li></ul><p>2）SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行开始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p><p>3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</p><p>4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p><p>5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。</p><p>6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p><p>7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p><p>8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p><p>9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</p><p>10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p><p>11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p><p>12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p><p>13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</p><p><strong>总结</strong></p><p>到此，SpringBoot的核心组件完成了基本的解析，综合来看，大部分都是Spring框架背后的一些概念和实践方式，SpringBoot只是在这些概念和实践上对特定的场景事先进行了固化和升华，而也恰恰是这些固化让我们开发基于Sping框架的应用更加方便高效。</p><h3 id="使用Spring-Initializer快速创建Spring-Boot项目"><a href="#使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="使用Spring Initializer快速创建Spring Boot项目"></a>使用Spring Initializer快速创建Spring Boot项目</h3><p>IDE都支持使用<strong>Spring的项目创建向导</strong>快速创建一个Spring Boot项目；<br>选择我们需要的模块；向导会联网创建Spring Boot项目；<br>默认生成的Spring Boot项目；<br>主程序已经生成好了，我们只需要我们自己的逻辑</p><p>resources文件夹中目录结构：</p><ul><li>static：保存所有的静态资源； js css images；</li><li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的- - Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li></ul><p>1）打开idea，创建一个工程Project<br><img src="/images/QQ截图20181102201430.png"></p><p>2）选择Spring Initializr<br><img src="/images/QQ截图20181102201714.png"></p><p>3) 填写Group和Artifact<br><img src="/images/QQ截图20181102202215.png"></p><p>4）选择Spring boot的版本 和 我们需要的模块（Web）<br><img src="/images/QQ截图20181102202456.png"></p><p>5）填写项目名和项目的路径<br><img src="/images/QQ截图20181102202648.png"></p><p>6）删除不需要的文件<br><img src="/images/QQ截图20181102202925.png"></p><p>7）编写逻辑控制层<br>在com.liuzhuo.springboot的包下，创建controller包，并创建HelloController：<br><img src="/images/QQ截图20181102205841.png"></p><p>8）启动Springboot应用<br><img src="/images/QQ截图20181102210019.png"></p><p>9）在浏览器中输入：<code>http://localhost:8080/hello</code><br><img src="/images/QQ截图20181102210130.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea创建maven-web工程</title>
      <link href="/2018/10/29/idea-chuang-jian-maven-web-gong-cheng/"/>
      <url>/2018/10/29/idea-chuang-jian-maven-web-gong-cheng/</url>
      
        <content type="html"><![CDATA[<p>考虑到现在大家都是使用maven来创建web工程，不再使用创建原始的Dynamic Web工程了，所以，我们开始吧~~~<br><a id="more"></a></p><h3 id="首先先创建一个project-一个project就是一个工作空间-，在这里就是创建一个maven的工作空间"><a href="#首先先创建一个project-一个project就是一个工作空间-，在这里就是创建一个maven的工作空间" class="headerlink" title="首先先创建一个project(一个project就是一个工作空间)，在这里就是创建一个maven的工作空间"></a>首先先创建一个project(一个project就是一个工作空间)，在这里就是创建一个maven的工作空间</h3><p><img src="/images/QQ截图20181029170715.png" style="width:50%"></p><h3 id="你要选择maven然后按照下面图片-的指示操作就可以了—-gt-最后点击next按钮"><a href="#你要选择maven然后按照下面图片-的指示操作就可以了—-gt-最后点击next按钮" class="headerlink" title="你要选择maven然后按照下面图片 的指示操作就可以了—&gt;最后点击next按钮"></a>你要选择maven然后按照下面图片 的指示操作就可以了—&gt;最后点击next按钮</h3><p><img src="/images/QQ截图20181029171222.png"></p><h3 id="填写，groupID、ArtifactID"><a href="#填写，groupID、ArtifactID" class="headerlink" title="填写，groupID、ArtifactID"></a>填写，groupID、ArtifactID</h3><p><img src="/images/QQ截图20181029171531.png"></p><h3 id="配置maven的本地仓库的位置"><a href="#配置maven的本地仓库的位置" class="headerlink" title="配置maven的本地仓库的位置"></a>配置maven的本地仓库的位置</h3><p>是通过修改settings.xml中的文件的位置放置问题，还有你要加上阿里巴巴的仓库，这样你的下载速度就会加快，如果你不采用阿里巴巴的仓库，你要下载你需要的jar包的话，你就要通过FQ去下载，你的速度就会变慢，是某些包！！！！<br><img src="/images/QQ截图20181029172013.png"></p><h3 id="填写项目名"><a href="#填写项目名" class="headerlink" title="填写项目名"></a>填写项目名</h3><p>一般不用改了，直接finish<br><img src="/images/QQ截图20181029172634.png"></p><h3 id="喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构"><a href="#喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构" class="headerlink" title="喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构"></a>喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构</h3><p><img src="/images/QQ截图20181029172839.png"></p><h3 id="等出结果，如果目录结构还不出来直接按图操作一波"><a href="#等出结果，如果目录结构还不出来直接按图操作一波" class="headerlink" title="等出结果，如果目录结构还不出来直接按图操作一波"></a>等出结果，如果目录结构还不出来直接按图操作一波</h3><p><img src="/images/QQ截图20181029172941.png"></p><h3 id="项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。"><a href="#项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。" class="headerlink" title="项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。"></a>项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。</h3><p><img src="/images/QQ截图20181029173041.png" style="width:50%"></p><p>点击Modules，如果你的是空的的话，就需要配置了，如果存在就不需要配置了，idea201703版本后，会自动帮我们配置的。<br><img src="/images/QQ截图20181029173524.png" style="width:50%"><br><img src="/images/QQ截图20181029173829.png"></p><p>如果你的idea的自动帮你配置了，你只需要检查那两个路径对不对即可，一般都是对的。</p><h3 id="为项目配置下Artifacts"><a href="#为项目配置下Artifacts" class="headerlink" title="为项目配置下Artifacts"></a>为项目配置下Artifacts</h3><p>和Modules一样，如果已经存在了，就不要配置了。如果没有的话<br><img src="/images/QQ截图20181029174352.png" style="width:50%"></p><p>选择我们的项目<br><img src="/images/QQ截图20181029174451.png"></p><h3 id="配置Tomcat容器"><a href="#配置Tomcat容器" class="headerlink" title="配置Tomcat容器"></a>配置Tomcat容器</h3><p><img src="/images/QQ截图20181029174611.png"></p><p>出现这个画面，然后按图再操作一波<br><img src="/images/QQ截图20181029174659.png" style="width:50%"></p><p>接着出现这个画面，继续看图操作<br><img src="/images/QQ截图20181029175057.png"></p><p>然后你选择右边第二个选项，Deployment，还是看图操作。。。<br><img src="/images/QQ截图20181029175151.png"><br><img src="/images/QQ截图20181029175319.png"></p><p>最后点击ok完成Tomcat配置，现在就可以启动tomcat跑跑我们的helloWorld了！</p><h3 id="启动tomcat，看效果"><a href="#启动tomcat，看效果" class="headerlink" title="启动tomcat，看效果"></a>启动tomcat，看效果</h3><p><img src="/images/QQ截图20181029175623.png"><br><img src="/images/QQ截图20181029175655.png"></p><h3 id="配置src-main-java"><a href="#配置src-main-java" class="headerlink" title="配置src/main/java"></a>配置src/main/java</h3><p>如上图，src/main目录下缺少java目录，我们可以右键创建目录java，然后再modules中配置为Sources目录</p><p><img src="/images/QQ截图20181030112516.png"></p><p>这样src/main/java图标就变成了蓝色，作为java源代码区了。</p><h3 id="配置src-main-resources"><a href="#配置src-main-resources" class="headerlink" title="配置src/main/resources"></a>配置src/main/resources</h3><p>如上图，src/main目录下缺少resources目录，我们可以右键创建目录resources，然后再modules中配置为Resources目录<br><img src="/images/QQ截图20181030112807.png"></p><p>这样src/main/resources图标就变成了右下角有黄标了，作为resources资源区了。</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
          <category> maven </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> idea </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决idea控制台输出乱码问题</title>
      <link href="/2018/10/29/jie-jue-idea-kong-zhi-tai-shu-chu-luan-ma-wen-ti/"/>
      <url>/2018/10/29/jie-jue-idea-kong-zhi-tai-shu-chu-luan-ma-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>解决IntelliJ IDEA 控制台输出乱码问题<br><a id="more"></a></p><h3 id="找到安装Intellij-idea目录bin下面的idea-exe-vmoptions和idea64-exe-vmoptions文件，我的安装目录是D-IntelliJ-IDEA-IntelliJ-IDEA-15-0-2-bin"><a href="#找到安装Intellij-idea目录bin下面的idea-exe-vmoptions和idea64-exe-vmoptions文件，我的安装目录是D-IntelliJ-IDEA-IntelliJ-IDEA-15-0-2-bin" class="headerlink" title="找到安装Intellij idea目录bin下面的idea.exe.vmoptions和idea64.exe.vmoptions文件，我的安装目录是D:\IntelliJ IDEA\IntelliJ IDEA 15.0.2\bin"></a>找到安装Intellij idea目录bin下面的idea.exe.vmoptions和idea64.exe.vmoptions文件，我的安装目录是D:\IntelliJ IDEA\IntelliJ IDEA 15.0.2\bin</h3><p><img src="/images/QQ截图20181029164601.png"></p><h3 id="修改idea-exe-vmoptions和idea64-exe-vmoptions文件，在末尾添加-Dfile-encoding-UTF-8"><a href="#修改idea-exe-vmoptions和idea64-exe-vmoptions文件，在末尾添加-Dfile-encoding-UTF-8" class="headerlink" title="修改idea.exe.vmoptions和idea64.exe.vmoptions文件，在末尾添加                -Dfile.encoding=UTF-8"></a>修改idea.exe.vmoptions和idea64.exe.vmoptions文件，在末尾添加                -Dfile.encoding=UTF-8</h3><p><img src="/images/QQ截图20181029164704.png"></p><h3 id="设置idea-file编码。在菜单栏找到”File-gt-settings-gt-搜索File-Encodeing”-设置utf-8。如图所示"><a href="#设置idea-file编码。在菜单栏找到”File-gt-settings-gt-搜索File-Encodeing”-设置utf-8。如图所示" class="headerlink" title="设置idea file编码。在菜单栏找到”File-&gt;settings-&gt;搜索File Encodeing” 设置utf-8。如图所示"></a>设置idea file编码。在菜单栏找到”File-&gt;settings-&gt;搜索File Encodeing” 设置utf-8。如图所示</h3><p><img src="/images/QQ截图20181029164741.png"></p><h3 id="设置idea-server编码。在菜单栏找到”run-gt-editconfigration”-找到”server”选项卡-设置-vm-option为-Dfile-encoding-utf-8，如图所示"><a href="#设置idea-server编码。在菜单栏找到”run-gt-editconfigration”-找到”server”选项卡-设置-vm-option为-Dfile-encoding-utf-8，如图所示" class="headerlink" title="设置idea server编码。在菜单栏找到”run-&gt;editconfigration” 找到”server”选项卡 设置 vm option为 -Dfile.encoding=utf-8，如图所示"></a>设置idea server编码。在菜单栏找到”run-&gt;editconfigration” 找到”server”选项卡 设置 vm option为 -Dfile.encoding=utf-8，如图所示</h3><p><img src="/images/QQ截图20181029164814.png"></p><h3 id="重启Intellij-IDEA"><a href="#重启Intellij-IDEA" class="headerlink" title="重启Intellij IDEA"></a>重启Intellij IDEA</h3>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
          <category> 乱码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet3.0与SpringMVC整合</title>
      <link href="/2018/10/29/servlet3-0-yu-springmvc-zheng-he/"/>
      <url>/2018/10/29/servlet3-0-yu-springmvc-zheng-he/</url>
      
        <content type="html"><![CDATA[<p>Servlet3.0与SpringMVC的整合，永久告别web.xml的配置文件啦~~<br><a id="more"></a></p><h3 id="创建maven-web工程"><a href="#创建maven-web工程" class="headerlink" title="创建maven-web工程"></a>创建maven-web工程</h3><p>如果大家对idea创建maven-web工程不熟悉的话，去看我的另一篇博客<a href="https://gakkil.top/2018/10/29/idea%E5%88%9B%E5%BB%BAmaven-web%E5%B7%A5%E7%A8%8B/" target="_blank" rel="noopener">idea创建maven-web工程</a></p><p><img src="/images/QQ截图20181029201934.png" style="width:50%"></p><h3 id="打开pom-xml文件"><a href="#打开pom-xml文件" class="headerlink" title="打开pom.xml文件"></a>打开pom.xml文件</h3><p>添加两个依赖，Springmvc和servlet的依赖</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;4.1.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;  &lt;!-- 3.0以上的版本都可以--&gt;            &lt;scope&gt;provided&lt;/scope&gt;   &lt;!-- 因为Tomcat容器中有servlet的jar，所以打成war包的时候，不需要这个--&gt;        &lt;/dependency&gt;</code></pre><h3 id="现在开始整合SpringMVC开发。打开Spring的官网。"><a href="#现在开始整合SpringMVC开发。打开Spring的官网。" class="headerlink" title="现在开始整合SpringMVC开发。打开Spring的官网。"></a>现在开始整合SpringMVC开发。打开Spring的官网。</h3><p>找到相关的文档处<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#spring-web" target="_blank" rel="noopener">Spring-web</a></p><p>我们能发现在servlet3.0以后，官网推不再使用web.xml开发，直接使用java的配置类来替代web.xml文件。</p><p>我们只需要编写一个类实现<strong>WebApplicationInitializer</strong>接口，就相当于web.xml文件了。</p><pre><code>public class MyWebApplicationInitializer implements WebApplicationInitializer {    @Override    public void onStartup(ServletContext servletCxt) {        // Load Spring web application configuration        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();        ac.register(AppConfig.class);        ac.refresh();        // Create and register the DispatcherServlet        DispatcherServlet servlet = new DispatcherServlet(ac);        ServletRegistration.Dynamic registration = servletCxt.addServlet(&quot;app&quot;, servlet);        registration.setLoadOnStartup(1);        registration.addMapping(&quot;/app/*&quot;);    }}</code></pre><p>容器启动后，会执行这个实现WebApplicationInitializer接口的实现类。然后执行onStartup()方法。</p><p>在该方法中，创建了注解式配置应用上下文，传入spring的配置文件。然后向该容器中注入DispatcherServlet，来完成SpringMVC的前端控制器。</p><p><font color="red"><strong>重点</strong></font>:</p><p>那为啥实现了WebApplicationInitializer接口的实现类，在容器启动时调用呢？</p><p>首先打开这个接口：</p><pre><code>public interface WebApplicationInitializer {    /**     * Configure the given {@link ServletContext} with any servlets, filters, listeners     * context-params and attributes necessary for initializing this web application. See     * examples {@linkplain WebApplicationInitializer above}.     * @param servletContext the {@code ServletContext} to initialize     * @throws ServletException if any call against the given {@code ServletContext}     * throws a {@code ServletException}     */    void onStartup(ServletContext servletContext) throws ServletException;}</code></pre><p>只有一个方法，看不出什么头绪。但是，在这个包下有另外一个类，SpringServletContainerInitializer。它的实现如下：</p><pre><code>@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer {    @Override    public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)            throws ServletException {        List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;();        if (webAppInitializerClasses != null) {            for (Class&lt;?&gt; waiClass : webAppInitializerClasses) {                // Be defensive: Some servlet containers provide us with invalid classes,                // no matter what @HandlesTypes says...                if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) {                    try {                        initializers.add((WebApplicationInitializer) waiClass.newInstance());                    }                    catch (Throwable ex) {                        throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);                    }                }            }        }        if (initializers.isEmpty()) {            servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);            return;        }        AnnotationAwareOrderComparator.sort(initializers);        servletContext.log(&quot;Spring WebApplicationInitializers detected on classpath: &quot; + initializers);        for (WebApplicationInitializer initializer : initializers) {            initializer.onStartup(servletContext);        }    }}</code></pre><p>这个类就比较有意思了，先不管其他的，读一下这段代码，可以得到这样的意思。</p><p>先判断webAppInitializerClasses这个Set是否为空。如果不为空的话，找到这个set中不是接口，不是抽象类，并且是WebApplicationInitializer接口实现类的类，将它们保存到list中。当这个list为空的时候，直接return。不为空的话就按照一定的顺序排序，并将它们按照一定的顺序实例化。调用<strong>其onStartup方法执行</strong>。到这里，就可以解释WebApplicationInitializer实现类的工作过程了。</p><p><strong>但是，在web项目运行的时候，SpringServletContainerInitializer这个类又是怎样被调用的呢？</strong></p><p>再看被它实现的ServletContainerInitializer这个接口<br>它只有一个接口方法onStartup()，通过它就可以解释SpringServletContainerInitializer是如何被调用的。它的内容如下：</p><pre><code>package javax.servlet;import java.util.Set;public interface ServletContainerInitializer {    void onStartup(Set&lt;Class&lt;?&gt;&gt; var1, ServletContext var2) throws ServletException;}</code></pre><p>首先，这个接口是javax.servlet下的，官方的解释是这样的：</p><p>为了支持可以不使用web.xml。提供了ServletContainerInitializer，它可以通过SPI机制。</p><p>当启动web容器的时候，会自动到添加的相应jar包下找到META-INF/services/javax.servlet.ServletContainerInitializer文件。</p><p>它的内容为ServletContainerInitializer实现类的全路径，将它们实例化。</p><p>既然这样的话，那么SpringServletContainerInitializer作为ServletContainerInitializer的实现类，它的jar包下也应该有相应的文件。<br><img src="/images/QQ截图20181029211845.png"></p><p>哈，现在就可以解释清楚了。首先，SpringServletContainerInitializer作为ServletContainerInitializer的实现类，通过SPI机制，在web容器加载的时候会自动的被调用。（这个类上还有一个注解@HandlesTypes，它的作用是将感兴趣的一些类注入到ServletContainerInitializer）， 而这个类的方法又会扫描找到WebApplicationInitializer的实现类，调用它的onStartup方法，从而起到启动web.xml相同的作用。</p><hr><p>等价于web.xml文件：</p><pre><code>&lt;web-app&gt;    &lt;!-- 注册这个监听器来注入Spring的父容器--&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!-- 注册这个Servlet来注入SpringMVC的子容器--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;app&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;app&lt;/servlet-name&gt;        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>总结：</p><p>1）servlet3.0以后的Web容器在启动的时候，会扫描每个jar包下的META-INF/services/javax.servlet.ServletContainerInitializer文件</p><p>2）加载这个文件指定的类(实现了ServletContainerInitializer接口)，并调用这个接口的onStartup()方法。<br>void onStartup(Set&lt;Class&lt;?&gt;&gt; var1, ServletContext var2) throws ServletException;</p><p>3）现在，我们在pom.xml文件中加入了spring-mvc的依赖，其中有一个jar：<br><img src="/images/QQ截图20181029214152.png" style="width:50%"></p><p>在该META-INF/services/javax.servlet.ServletContainerInitializer文件下，有一个：org.springframework.web.SpringServletContainerInitializer的全路径。</p><p>打开SpringServletContainerInitializer类。</p><pre><code>@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer {  ···}</code></pre><p>该类上面有一个@HandlesTypes注解，该注解会在web容器启动的时候，传入我们感兴趣的类型，这里会传入WebApplicationInitializer的类型。</p><p>然后在该类的onStartup()方法中：</p><pre><code>        if (webAppInitializerClasses != null) {            for (Class&lt;?&gt; waiClass : webAppInitializerClasses) {                // Be defensive: Some servlet containers provide us with invalid classes,                // no matter what @HandlesTypes says...                if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) {                    try {                        initializers.add((WebApplicationInitializer) waiClass.newInstance());                    }                    catch (Throwable ex) {                        throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);                    }                }            }        }</code></pre><p>这里的webAppInitializerClasses就是传入的我们感兴趣的类型，判断该传入的类型，在不是接口，不是抽象类，而且是WebApplicationInitializer类型的时候，实例化该传入的类型。</p><pre><code>for (WebApplicationInitializer initializer : initializers) {    initializer.onStartup(servletContext);}</code></pre><p>最后调用WebApplicationInitializer的<br>onStartup(ServletContext servletContext) throws ServletException;</p><hr><p>我们可以直接实现WebApplicationInitializer接口，像Spring官网一样整合SpringMVC。</p><p>但是，这里，我们来看看WebApplicationInitializer的继承体系：<br>会发现有三个抽象类：<br>AbstractContextLoaderInitializer<br>AbstractDispatcherServletInitializer<br>AbstractAnnotationConfigDispatcherServletInitializer</p><p>AbstractContextLoaderInitializer：</p><pre><code>public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer {    /** Logger available to subclasses */    protected final Log logger = LogFactory.getLog(getClass());    @Override    public void onStartup(ServletContext servletContext) throws ServletException {        registerContextLoaderListener(servletContext);    }    protected void registerContextLoaderListener(ServletContext servletContext) {        WebApplicationContext rootAppContext = createRootApplicationContext();        if (rootAppContext != null) {            servletContext.addListener(new ContextLoaderListener(rootAppContext));        }        else {            logger.debug(&quot;No ContextLoaderListener registered, as &quot; +                    &quot;createRootApplicationContext() did not return an application context&quot;);        }    }    protected abstract WebApplicationContext createRootApplicationContext();}</code></pre><p>这里，我们可以看到：首先执行onStartup(),然后执行registerContextLoaderListener().</p><p>在然后执行registerContextLoaderListener中，调用createRootApplicationContext()方法来获取Spring的根容器。该方法需要我们来实现。</p><p>然后将我们创建的根容器注入到ServletContext中。</p><hr><p>AbstractDispatcherServletInitializer：</p><pre><code>public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer {    public static final String DEFAULT_SERVLET_NAME = &quot;dispatcher&quot;;    public AbstractDispatcherServletInitializer() {    }    public void onStartup(ServletContext servletContext) throws ServletException {        super.onStartup(servletContext);        this.registerDispatcherServlet(servletContext);    }    protected void registerDispatcherServlet(ServletContext servletContext) {        String servletName = this.getServletName();        Assert.hasLength(servletName, &quot;getServletName() must not return empty or null&quot;);        WebApplicationContext servletAppContext = this.createServletApplicationContext();        Assert.notNull(servletAppContext, &quot;createServletApplicationContext() did not return an application context for servlet [&quot; + servletName + &quot;]&quot;);        DispatcherServlet dispatcherServlet = new DispatcherServlet(servletAppContext);        Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);        Assert.notNull(registration, &quot;Failed to register servlet with name &#39;&quot; + servletName + &quot;&#39;.&quot; + &quot;Check if there is another servlet registered under the same name.&quot;);        registration.setLoadOnStartup(1);        registration.addMapping(this.getServletMappings());        registration.setAsyncSupported(this.isAsyncSupported());        Filter[] filters = this.getServletFilters();        if (!ObjectUtils.isEmpty(filters)) {            Filter[] var7 = filters;            int var8 = filters.length;            for(int var9 = 0; var9 &lt; var8; ++var9) {                Filter filter = var7[var9];                this.registerServletFilter(servletContext, filter);            }        }        this.customizeRegistration(registration);    }</code></pre><p>第一，创建Spring的WebApplicationContext容器。</p><p><code>protected abstract WebApplicationContext createServletApplicationContext();</code></p><p>需要我们自己实现，这个方法，返回一个WebApplicationContext容器。</p><p>第二，帮我们创建了一个dispatcherServlet，然后注入到ServletContext中。</p><p>第三，registration.addMapping(this.getServletMappings());添加映射，Filter[] filters = this.getServletFilters();注入过滤器等。</p><p><code>protected abstract String[] getServletMappings();</code></p><p>映射器也需要我们重写。</p><hr><p>AbstractAnnotationConfigDispatcherServletInitializer:</p><p>注解版注册DispatcherServlet的版本</p><pre><code>public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServletInitializer {    public AbstractAnnotationConfigDispatcherServletInitializer() {    }    protected WebApplicationContext createRootApplicationContext() {        Class&lt;?&gt;[] configClasses = this.getRootConfigClasses();        if (!ObjectUtils.isEmpty(configClasses)) {            AnnotationConfigWebApplicationContext rootAppContext = new AnnotationConfigWebApplicationContext();            rootAppContext.register(configClasses);            return rootAppContext;        } else {            return null;        }    }    protected WebApplicationContext createServletApplicationContext() {        AnnotationConfigWebApplicationContext servletAppContext = new AnnotationConfigWebApplicationContext();        Class&lt;?&gt;[] configClasses = this.getServletConfigClasses();        if (!ObjectUtils.isEmpty(configClasses)) {            servletAppContext.register(configClasses);        }        return servletAppContext;    }    protected abstract Class&lt;?&gt;[] getRootConfigClasses();    protected abstract Class&lt;?&gt;[] getServletConfigClasses();}</code></pre><p>里面就重写了两个方法：</p><p>createRootApplicationContext():创建配置类的根容器<br>重写getRootConfigClasses():传入一个配置类。</p><p>createServletApplicationContext():创建Web的ioc容器<br>重写getServletConfigClasses():获取Web版的配置类。</p><hr><p>总结：</p><p>以注解方法来启动SpringMVC的话：继承AbstractAnnotationConfigDispatcherServletInitializer；</p><p>实现抽象方法指定DispatcherServlet的配置信息。</p><h3 id="Servlet3-0与SpringMVC的整合"><a href="#Servlet3-0与SpringMVC的整合" class="headerlink" title="Servlet3.0与SpringMVC的整合"></a>Servlet3.0与SpringMVC的整合</h3><p>1) 在src下的main下面的java里面写我们的源代码：</p><p>如果还不知道怎么配置，看我的<strong>idea创建maven-web</strong>的博客，最后有说明。</p><p>创建com.liuzhuo包，并在该包下面，创建MyWebAppInitializer类，继承AbstractAnnotationConfigDispatcherServletInitializer：</p><pre><code>//Web容器启动的时候创建对象；调用方法来初始化容器以前的前端控制器public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {    //获取根容器的配置类；（Spring的配置文件）父容器。    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return new Class[]{RootConfig.class};    }    //获取Web容器的配置类（SpringMVC配置文件）子容器    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() {        return new Class[]{AppConfig.class};    }    //获取DispatchServlet的映射信息    // /:拦截所有请求（包括静态资源（XX.js,XX.png））,但是不包括*.jsp    // /*:拦截所有请求；连*.jsp页面都拦截；jsp页面需要Tomcat的jsp引擎解析的。    @Override    protected String[] getServletMappings() {        return new String[]{&quot;/&quot;};    }}</code></pre><p>2) 在com.liuzhuo.config包下，创建RootConfig、AppConfig类：</p><pre><code>@ComponentScan(value = &quot;com.liuzhuo&quot;, excludeFilters = {        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = {Controller.class})})//Spring的根容器（父容器）,扫描排除含有Controller注解的bean对象public class RootConfig {}</code></pre><pre><code>@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = {        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = {Controller.class})}, useDefaultFilters = false)//SpringMVC的子容器，只扫描含有Controller注解的Bean对象//禁用默认的规则(扫描所有)：useDefaultFilters = falsepublic class AppConfig {}</code></pre><p>这样配置，是根据Spring的官方给的建议：<br><img src="/images/QQ截图20181030134334.png" style="width:50%"></p><p>父容器:配置@service、@repository，数据连接池，事务管理等。<br>子容器：配置@Controller层，视图解析器，映射配置。</p><p>3）在com.liuzhuo.service包下，创建HelloService：</p><pre><code>@Servicepublic class HelloService {    public String sayHello(String name) {        return &quot;Hello:&quot; + name;    }}</code></pre><p>4) 在com.liuzhuo.controller包下，创建HelloController：</p><pre><code>@Controllerpublic class HelloController {    @Autowired    private HelloService helloService;    @ResponseBody    @RequestMapping(&quot;/hello&quot;)    public String hello() {        String hello = helloService.sayHello(&quot;tomcat·····&quot;);        return hello;    }}</code></pre><p>整体的项目结构：<br><img src="/images/QQ截图20181030134808.png" style="width:50%"></p><p>5) 启动项目，运行</p><p>浏览器输入：<br><code>http://localhost:8080/hello</code><br><img src="/images/QQ截图20181030134940.png"></p><p>到现在为止，Servlet3.0与SpringMVC整合完成。</p><h3 id="定性配置SpringMVC"><a href="#定性配置SpringMVC" class="headerlink" title="定性配置SpringMVC"></a>定性配置SpringMVC</h3><p>打开官网，查看 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config" target="_blank" rel="noopener">MVC Config</a>章节。</p><p>开启MVC的高级功能，需要@EnableWebMvc注解。</p><p>比如：</p><pre><code>@Configuration@EnableWebMvcpublic class WebConfig {}</code></pre><p>相等于xml文件：<code>&lt;mvc:annotation-driven/&gt;</code></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;/beans&gt;</code></pre><p>只有开启了@EnableWebMvc或者<code>&lt;mvc:annotation-driven/&gt;</code>才能定制SpringMVC的其他信息。</p><p>在官网中，我们使用配置实现 WebMvcConfigurer 接口，然后实现其中的所有方法来定制其他组件(视图解析器、拦截器、过滤器等)。</p><pre><code>@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer {    // Implement configuration methods...}</code></pre><p>但是，这样，我们就必须实现其中的所有方法了，为了方便，我们可以继承WebMvcConfigurerAdapter 适配器，其中所有的方法帮我们实现了，只是返回空方法。然后我们通过重写自己想要定制的方法来完成自身的需求。</p><h4 id="定制视图解析器"><a href="#定制视图解析器" class="headerlink" title="定制视图解析器"></a>定制视图解析器</h4><p>1）改写我们的AppConfig配置类：</p><p>添加@EnableWebMvc、并且继承WebMvcConfigurerAdapter抽象类</p><pre><code>@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = {        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = {Controller.class})}, useDefaultFilters = false)//SpringMVC的子容器，只扫描含有Controller注解的Bean对象//禁用默认的规则(扫描所有)：useDefaultFilters = false@EnableWebMvcpublic class AppConfig extends WebMvcConfigurerAdapter {}</code></pre><p>2）添加自定义的视图解析器</p><p>都是在AppConfig类中，直接重写方法</p><pre><code>    //配置视图解析器    @Override    public void configureViewResolvers(ViewResolverRegistry registry) {        //定制jsp的视图解析器        //参数一：视图的前缀路径        //参数二：视图的后缀名        registry.jsp(&quot;WEB-INF/views/&quot;, &quot;.jsp&quot;);    }</code></pre><p>3）在HelloController中</p><pre><code>    @RequestMapping(&quot;/suc&quot;)    public String sucess() {        return &quot;sucess&quot;;    }</code></pre><p>4) 在WEB-INF/views下，添加一个sucess.jsp的文件</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;sucess!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>5) 运行项目</p><p>在浏览器中输入：<code>http://localhost:8080/suc</code><br><img src="/images/QQ截图20181030150751.png"></p><p>成功定制了jsp的视图解析器了。</p><hr><h4 id="定制静态资源"><a href="#定制静态资源" class="headerlink" title="定制静态资源"></a>定制静态资源</h4><p>没有配置之前：</p><p>1）在webapp根目录下：</p><p>放入一张图片，随便一张就行。<br><img src="/images/QQ截图20181030151708.png" style="width:50%"></p><p>2）在index.jsp中，添加img标签<br><img src="/images/QQ截图20181030151855.png" style="width:50%"></p><p>3) 启动项目</p><p>浏览器中输入：<code>http://localhost:8080</code><br><img src="/images/QQ截图20181030152023.png" style="width:50%"></p><p>发现，我们的照片出不来，这是为啥呢？这是因为，我们的静态资源也会被DispatchServlet拦截。</p><p>在控制台中能发现：</p><pre><code>30-Oct-2018 15:20:00.904 警告 [http-nio-8080-exec-4] org.springframework.web.servlet.PageNotFound.noHandlerFound No mapping found for HTTP request with URI [/gakki.jpg] in DispatcherServlet with name &#39;dispatcher&#39;</code></pre><p><img src="/images/QQ截图20181030152314.png"></p><p>发现 /gakki.jpg 也被DispatchServlet拦截了。</p><p>现在，我们需要不让DispatchServlet拦截我们的静态资源，使用Tomcat容器来加载静态资源。</p><p>4）在AppConfig下：</p><pre><code>    //静态资源访问    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {        //默认是匹配路径：/**        configurer.enable();    }</code></pre><p>相等于xml中的：<code>&lt;mvc:default-servlet-handler/&gt;</code></p><p>5) 启动项目<br><img src="/images/QQ截图20181030153052.png"></p><hr><h4 id="定制拦截器"><a href="#定制拦截器" class="headerlink" title="定制拦截器"></a>定制拦截器</h4><p>1）在com.liuzhuo.interceptors在，创建MyInterceptor，实现HandlerInterceptor接口</p><pre><code>//自定义的拦截器public class MyInterceptor implements HandlerInterceptor {    //拦截之前调用    @Override    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {        //放行        System.out.println(&quot;preHandle·······&quot;);        return true;    }    //处理之后调用    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;postHandle·······&quot;);    }    //成功处理后调用    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {        System.out.println(&quot;afterCompletion·······&quot;);    }}</code></pre><p>2）在AppConfig类下：</p><pre><code>    //添加拦截器    @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;);    }</code></pre><p>3) 启动项目</p><p>在浏览器中输入：<code>http://localhost:8080/suc</code><br><img src="/images/QQ截图20181030155103.png"></p><p>拦截成功。</p><p>如果还想定制其他功能，请查看<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config" target="_blank" rel="noopener">Spring的官方文档</a>。<br><img src="/images/QQ截图20181030155351.png"></p>]]></content>
      
      
      <categories>
          
          <category> servlet3.0 </category>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet3.0 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet3.0</title>
      <link href="/2018/10/28/servlet3-0/"/>
      <url>/2018/10/28/servlet3-0/</url>
      
        <content type="html"><![CDATA[<p>以前，编写servlet，filter，Listener等，还是编写SpringMVC的前端控制器，都是在web.xml中编写的。Servlet3.0版本之后，只需要使用注解就可以完成组件的注解，还有运行时的组件式插拔开发。<br><a id="more"></a></p><p><strong>注意：</strong> servlet3.0的容器Tomcat 必须是<strong>7.0.x以上版本</strong>才能使用servlet3.0。</p><h3 id="创建dynamic-Web项目"><a href="#创建dynamic-Web项目" class="headerlink" title="创建dynamic Web项目"></a>创建dynamic Web项目</h3><p>我这里使用的是idea，大家也可以使用eclipse开发。大家估计都对eclipse开发熟悉，如果对idea创建动态web项目不熟悉的话，可以看我另一篇博客<a href="https://gakkil.top/2018/10/28/idea-%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81Web%E9%A1%B9%E7%9B%AE/" target="_blank" rel="noopener">idea 创建动态Web项目</a>。</p><p>创建好工程后如下：<br><img src="/images/QQ截图20181029114758.png" style="width:50%"></p><h4 id="使用web-xml的方式"><a href="#使用web-xml的方式" class="headerlink" title="使用web.xml的方式"></a>使用web.xml的方式</h4><p>1）在src下创建com.liuzhuo.servlet包，并创建HelloServlet</p><pre><code>public class HelloServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        super.doPost(request, response);    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        response.getWriter().write(&quot;hello world servlet3.0 ~~~&quot;);    }}</code></pre><p>2) 在WBE-INF下的index.jsp中：</p><p>添加：<code>&lt;a href=&quot;hello&quot;&gt;hello&lt;/a&gt;</code></p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;servlet3.0&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;hello&quot;&gt;hello&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>3) 在web.xml中配置servlet的映射关系</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;         version=&quot;3.1&quot;&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.liuzhuo.servlet.HelloServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>4) 运行web应用<br><img src="/images/QQ截图20181029124916.png"></p><p>点击hello的超链接<br><img src="/images/QQ截图20181029124951.png"></p><p>以上就是servlet3.0之前的版本开发web工程的演示。</p><hr><h4 id="不使用web-xml-servlet3-0"><a href="#不使用web-xml-servlet3-0" class="headerlink" title="不使用web.xml(servlet3.0)"></a>不使用web.xml(servlet3.0)</h4><p>1) 去掉web.xml中的servlet的配置：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;         version=&quot;3.1&quot;&gt;&lt;/web-app&gt;</code></pre><p>2) 此时再运行web项目，点击hello超链接<br><img src="/images/QQ截图20181029125311.png"></p><p>3）使用@WebServlet注解</p><p>在HelloServlet类上面写上@WebServlet注解<br>name : 就是servlet的名字<br>value：就是映射的路径</p><p>@WebServlet上的name  &lt;==&gt; <code>&lt;servlet-name&gt;hello&lt;/servlet-name&gt;</code><br>@WebServlet上的value &lt;==&gt; <code>&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</code></p><pre><code>@WebServlet(value =&quot;/hello&quot; )public class HelloServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        super.doPost(request, response);    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        response.getWriter().write(&quot;hello world servlet3.0 ~~~&quot;);    }}</code></pre><p>4) 重新启动web项目</p><p>会发现，项目启动正常了。</p><p><strong>ps：在idea中，有一个web的窗口，在编辑器的左下角，点开，会看见当前web项目的映射信息，很方便排错。</strong><br><img src="/images/QQ截图20181029130641.png" style="width:50%"></p><p>其他注解：</p><p>@WebFilter   ：注解过滤器<br>@WebListener ：注解监听器<br>@WebInitParam：注解初始化的参数</p><p>具体的使用情况：看官方文档即可。</p><hr><h3 id="servlet3-0的共享库和运行时插件"><a href="#servlet3-0的共享库和运行时插件" class="headerlink" title="servlet3.0的共享库和运行时插件"></a>servlet3.0的共享库和运行时插件</h3><p>Shared libraries / runtimes pluggability</p><p>1）在Servlet容器启动的时候，会扫描当前应用里面的每一个jar包的ServletContainerInitializer的实现类</p><p>2）提供ServletContainerInitializer的实现类</p><p>必须绑定在：META-INF/services/javax.servlet.ServletContainerInitializer文件中。<br><strong>文件名就是 javax.servlet.ServletContainerInitializer 没有后缀。</strong></p><p>文件中的内容就是：ServletContainerInitializer实现类的<strong>全类名</strong>。</p><p>总结：容器在启动的时候，会扫描当前应用中每一个jar包里面的：META-INF/services/javax.servlet.ServletContainerInitializer文件中ServletContainerInitializer实现类，启动并运行这个实现类中的方法和传入感兴趣的类型。</p><p>3）测试</p><p>3.1) 这里就不创建jar包了，直接在src下创建META-INF/services目录，然后在该目录下，创建javax.servlet.ServletContainerInitializer文件。<br><img src="/images/QQ截图20181029135845.png" style="width:50%"></p><p><strong>注意：目录和文件名称不要打错！！！</strong></p><p>3.2）在src下的com.liuzhuo.servlet下创建MyServletContainerInitializer，并实现ServletContainerInitializer接口。</p><pre><code>@HandlesTypes(value = {HelloService.class})public class MyServletContainerInitializer implements ServletContainerInitializer {    /**     * @param set：感兴趣的类型的所有子类型.@HandlesTypes注解中的value即为感兴趣的类型。     * @param servletContext :代表当前Web应用的ServletContext,一个Web应用一个上下文     * @throws ServletException     */    @Override    public void onStartup(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext) throws ServletException {        System.out.println(&quot;感兴趣的类型：&quot;);        for (Class&lt;?&gt; aClass : set) {            System.out.println(aClass);        }    }}</code></pre><p>3.3) 在src下的com.liuzhuo.service下创建<br>HelloService：接口<br>HelloServiceExt：实现了HelloService的子接口<br>AbstractHelloService：实现了HelloService的抽象类<br>HelloServiceImpl：HelloService的实现类<br><img src="/images/QQ截图20181029140510.png" style="width:50%"></p><p>3.4）将MyServletContainerInitializer的全类名添加到javax.servlet.ServletContainerInitializer文件中<br><img src="/images/QQ截图20181029140722.png"></p><p>3.5）运行web项目<br><img src="/images/QQ截图20181029140828.png"></p><p>能看到，输出感兴趣的类型：</p><pre><code>class com.liuzhuo.service.HelloServiceImplinterface com.liuzhuo.service.HelloServiceExtclass com.liuzhuo.service.AbstractHelloService</code></pre><p><strong>注意感兴趣的类型：不包括本身（HelloService接口）！！！</strong></p><hr><h3 id="使用ServletContainerInitializer给容器添加组件"><a href="#使用ServletContainerInitializer给容器添加组件" class="headerlink" title="使用ServletContainerInitializer给容器添加组件"></a>使用ServletContainerInitializer给容器添加组件</h3><p>根据上文，我们已经了解到了，我们使用@WebServlet注解，给容器添加我们自己写的Servlet类，但是无法添加第三方的组件。只能使用Web.xml文件来添加。</p><p>现在，我们了解了Servlet3.0的共享库和运行时机制，可以使用ServletContainerInitializer的机制来注册Web组件(Servlet、Filter、Listener)，不必使用Web.xml配置文件。</p><p>接着现有的项目继续开发。</p><p>1）在com.liuzhuo.servlet下创建UserServlet、UserFilter、UserListener三大组件<br><img src="/images/QQ截图20181029143900.png" style="width:50%"></p><p>UserServlet:</p><pre><code>public class UserServlet extends HttpServlet {    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        response.getWriter().write(&quot;UserServlet ·····&quot;);    }}</code></pre><p>UserFilter:</p><pre><code>public class UserFilter implements Filter {    public void destroy() {    }    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {        //执行过滤的方法        System.out.println(&quot;UserFilter ~~~&quot;);        //放行        chain.doFilter(req, resp);    }    public void init(FilterConfig config) throws ServletException {    }}</code></pre><p>UserListener:</p><pre><code>public class UserListener implements ServletContextListener {    //容器初始化的时候    @Override    public void contextInitialized(ServletContextEvent servletContextEvent) {        //获取ServletContext容器的上下文，这里也可以注册Servlet、Fliter、Listener组件        ServletContext servletContext = servletContextEvent.getServletContext();        System.out.println(servletContext);        System.out.println(&quot;UserListener监听ServletContextListener的初始化&quot;);    }    //容器销毁的时候    @Override    public void contextDestroyed(ServletContextEvent servletContextEvent) {        System.out.println(&quot;UserListener监听ServletContextListener的销毁&quot;);    }}</code></pre><p>2) 在MyServletContainerInitializer中的onStartup方法中使用ServletContext注册三大组件：</p><pre><code>@HandlesTypes(value = {HelloService.class})public class MyServletContainerInitializer implements ServletContainerInitializer {    /**     * @param set：感兴趣的类型的所有子类型.@HandlesTypes注解中的value即为感兴趣的类型。     * @param servletContext :代表当前Web应用的ServletContext：一个Web应用一个上下文     * @throws ServletException     */    @Override    public void onStartup(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext) throws ServletException {        System.out.println(&quot;感兴趣的类型：&quot;);        for (Class&lt;?&gt; aClass : set) {            System.out.println(aClass);        }        //添加userServelt组件。        ServletRegistration.Dynamic userServelt = servletContext.addServlet(&quot;userServelt&quot;, new UserServlet());        //添加Servlet的映射路径        userServelt.addMapping(&quot;/user&quot;);        //添加监听器        servletContext.addListener(UserListener.class);        //添加过滤器        FilterRegistration.Dynamic userFilter = servletContext.addFilter(&quot;userFilter&quot;, UserFilter.class);        //添加拦截规则        //EnumSet&lt;DispatcherType&gt; var1 :拦截的请求类型        // boolean var2                ：true        // String... var3              ：拦截的路径        userFilter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), true, &quot;/*&quot;);    }}</code></pre><p>3) 运行Web项目<br><img src="/images/QQ截图20181029150012.png"></p><p>说明userListener监听器注册成功。</p><p>在浏览器中输入：<code>http://localhost:8080/user</code><br><img src="/images/QQ截图20181029150247.png"><br><img src="/images/QQ截图20181029150400.png"></p><p>说明UserServlet和userFliter注册也成功了。</p><p>停止Web项目：<br><img src="/images/QQ截图20181029150554.png"></p><p>以上，就是不使用Web.xml的注册Servlet、Filter、Listener三大组件的过程，使用硬编码的形式。</p><p><strong>注意：servlet3.0动态注册，只能在webapp启动时进行注册,可能是为了安全考虑吧.不能在运行时完成对servlet的注册和销毁</strong></p><p>在初始化情况下的注册Servlet组件有除了上面的方式，还有另外一种方式：<br>就是在实现ServletContextListener接口,在contextInitialized方法中完成注册.</p><p>就是在上述UserListener中contextInitialized方法中获取：<br> ServletContext servletContext = servletContextEvent.getServletContext();<br>然后进行三大组件的注册。</p>]]></content>
      
      
      <categories>
          
          <category> servlet3.0 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet3.0 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea 创建动态Web项目</title>
      <link href="/2018/10/28/idea-chuang-jian-dong-tai-web-xiang-mu/"/>
      <url>/2018/10/28/idea-chuang-jian-dong-tai-web-xiang-mu/</url>
      
        <content type="html"><![CDATA[<p>intellij idea这个开发工具功能强大，但是大部分人都习惯eclipse 开发，所以对这个工具还不是太了解。今天就使用idea来创建动态web项目。</p><a id="more"></a><h3 id="idea-创建动态Web项目"><a href="#idea-创建动态Web项目" class="headerlink" title="idea 创建动态Web项目"></a>idea 创建动态Web项目</h3><p>打开idea</p><p>我使用的是2017版本的。</p><p>(1)点击左上角的File–&gt; new –&gt; Project<br><img src="/images/QQ截图20181028182054.png"></p><p>(2)之后会弹出一个选择框，选择Java Enterprise ，网上有的会说选择第一个java 当然也是可行的 ，两者之间有一点点细微的差别啦，当然别忘记<strong>勾选Web Application</strong>,点击Next。<br><img src="/images/QQ截图20181028191302.png"></p><p>(3)填好项目名称，和项目路径，Finish。<br><img src="/images/QQ截图20181028191740.png"></p><p>(4)完成后，需要添加web.xml文件。在idea201703版本之前。在第二步的选择Web Application时，可以选择版本号，并创建web.xml文件。但是之后的版本没有。我们可以手工创建，但是麻烦，教大家另外的创建方法。</p><p>打开 Project Structure（Ctrl+Alt+Shift+S），在 facets 里<strong>选中次级的 web 或者 在Modules 中选中web</strong>，在deployment Descriptors面板里，点击 +号选择web.xml以及版本号。然后在弹出的对话框中修改xml默认的目录，加上web就可以了。<br><img src="/images/QQ截图20181028194446.png" style="width:50%"><br><img src="/images/QQ截图20181028194836.png"><br><img src="/images/QQ截图20181028195525.png" style="width:50%"></p><p>这样就把 WEB-INF web.xml 添加上了 。<br><img src="/images/QQ截图20181028195719.png" style="width:50%"></p><p>.idea文件夹和webapp.iml是IDEA自动创建的，包含了工程和模块的配置数据<br>src文件夹是源码目录<br>web文件夹相当于eclipse创建的web工程WebContent文件夹，包含了WEB-INF/web.xml及index.jsp<br>External Libraries包含了JDK及Tomcat带的jsp-api、servlet-api jar文件</p><p>(4)完善工程目录，点击WEF-INF  ,右键，NEW–&gt;Directory  创建两个文件夹，classes 和 lib  <strong>这个名字不要改哦！</strong></p><p>4.1 创建classes文件夹<br><img src="/images/QQ截图20181028200211.png"><br><img src="/images/QQ截图20181028200344.png" style="width:50%"></p><p>4.2 同理，创建lib文件夹<br><img src="/images/QQ截图20181028200618.png" style="width:50%"></p><p>(5) 完成后再点击File ,选择Project Structure  </p><p>点击Modules ,选择Paths,选中Use module compile output path ,将Outputpath 和Test output path 都设置为刚刚创建的classes文件夹。<br><img src="/images/QQ截图20181028201015.png"></p><p><strong>点击apply就行，接着第六步。</strong></p><p>(6) 点击path旁边的Dependencies, 点击”+”号，选择1 JARs or directories<br><img src="/images/QQ截图20181028201526.png"></p><p>选择刚刚创建的lib。<br><img src="/images/QQ截图20181028201634.png"></p><p>选择第三个，jar Directory。一路ok到底！<br><img src="/images/QQ截图20181028201803.png" style="width:50%"></p><p>(7) 配置servlet容器：Tomcat<br>点击右上角的tomcat的向下的小三角，然后点击Edit Configurations<br><img src="/images/QQ截图20181028202512.png" style="width:30%"></p><p>看tomcat已经有啦，这是java Enterprise的好处啦，点击Deployment。<br><img src="/images/QQ截图20181028203004.png"><br>1，设置On frame deactivation : Update classes and resources<br>2，设置自己的jre位置路径。（jdk对应的jre）</p><p>Application context可以填也可以不填，配置后，访问网站就必须加上这个路径了。<br><img src="/images/QQ截图20181028203156.png"><br>点击ok。</p><p>(8) 点击index.jsp，随便写一段话，比如helloworld。<br><img src="/images/QQ截图20181028203422.png"></p><p>(9) 运行程序，就点击右上角的绿色图标<br><img src="/images/QQ截图20181028203713.png"></p><h3 id="WEB-INF目录与META-INF目录的作用"><a href="#WEB-INF目录与META-INF目录的作用" class="headerlink" title="WEB-INF目录与META-INF目录的作用"></a>WEB-INF目录与META-INF目录的作用</h3><p>1) /WEB-INF/web.xml</p><p>Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。</p><p>2) /WEB-INF/classes/</p><p>包含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中。</p><p>3) /WEB-INF/lib/</p><p>存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件。</p><p>4) /WEB-INF/src/</p><p>源码目录，按照包名结构放置各个Java文件。</p><p>5) /WEB-INF/database.properties</p><p>数据库配置文件</p><p>6) /WEB-INF/tags/</p><p>存放了自定义标签文件，该目录并不一定为 tags，可以根据自己的喜好和习惯为自己的标签文件库命名，当使用自定义的标签文件库名称时，在使用标签文件时就必须声明正确的标签文件库路径。例如：当自定义标签文件库名称为 simpleTags 时，在使用 simpleTags 目录下的标签文件时，就必须在 jsp 文件头声明为：&lt;%@ taglibprefix=”tags” tagdir=”/WEB-INF /simpleTags” % &gt;。</p><p>7) /WEB-INF/jsp/</p><p>jsp 1.2 以下版本的文件存放位置。改目录没有特定的声明，同样，可以根据自己的喜好与习惯来命名。此目录主要存放的是 jsp 1.2 以下版本的文件，为区分 jsp 2.0 文件，通常使用 jsp 命名，当然你也可以命名为 jspOldEdition 。</p><p>8) /WEB-INF/jsp2/</p><p>与 jsp 文件目录相比，该目录下主要存放 Jsp 2.0 以下版本的文件，当然，它也是可以任意命名的，同样为区别 Jsp 1.2以下版本的文件目录，通常才命名为 jsp2。</p><p>9) META-INF</p><p>相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务manifest.mf文件，在用jar打包时自动生成。</p><h3 id="META-INF有什么用？它跟WEB-INF有什么区别？"><a href="#META-INF有什么用？它跟WEB-INF有什么区别？" class="headerlink" title="META-INF有什么用？它跟WEB-INF有什么区别？"></a>META-INF有什么用？它跟WEB-INF有什么区别？</h3><p>WEB-INF使用web 项目才会有这个文件夹,普通的j2se项目是没有这个文件夹的。</p><p>META-INF存在程序入口相关信息, 每个jar 都会有这个文件夹,里面的 MANIFEST文件 记录下面这些信息。我们把MANIFEST中的配置信息进行分类，可以归纳出下面几个大类：</p><pre><code>一. 一般属性　　1. Manifest-Version　　用来定义manifest文件的版本，例如：Manifest-Version: 1.0　　2. Created-By　　    声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1　　3. Signature-Version　　定义jar文件的签名版本　　4. Class-Path　　应用程序或者类装载器使用该值来构建内部的类搜索路径　　二. 应用程序相关属性　　1. Main-Class　　定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。　　三. 小程序(Applet)相关属性　　1. Extendsion-List　　该属性指定了小程序需要的扩展信息列表，列表中的每个名字对应以下的属性　　2. &lt;extension&gt;-Extension-Name　　3. &lt;extension&gt;-Specification-Version　　4. &lt;extension&gt;-Implementation-Version　　5. &lt;extension&gt;-Implementation-Vendor-Id　　6. &lt;extension&gt;-Implementation-URL　　四. 扩展标识属性　　1. Extension-Name　　该属性定义了jar文件的标识，例如Extension-Name: Struts Framework　　五. 包扩展属性　　1. Implementation-Title 定义了扩展实现的标题　　2. Implementation-Version 定义扩展实现的版本　　3. Implementation-Vendor 定义扩展实现的组织 　　4. Implementation-Vendor-Id 定义扩展实现的组织的标识　　5. Implementation-URL : 定义该扩展包的下载地址(URL)　　6. Specification-Title 定义扩展规范的标题　　7. Specification-Version 定义扩展规范的版本　　8. Specification-Vendor 声明了维护该规范的组织　　9. Sealed 定义jar文件是否封存，值可以是true或者false (这点我还不是很理解)　　六. 签名相关属性　　签名方面的属性我们可以来参照JavaMail所提供的mail.jar中的一段　　Name: javax/mail/Address.class　　Digest-Algorithms: SHA MD5 　　SHA-Digest: AjR7RqnN//cdYGouxbd06mSVfI4=　　MD5-Digest: ZnTIQ2aQAtSNIOWXI1pQpw==　　这段内容定义类签名的类名、计算摘要的算法名以及对应的摘要内容(使用BASE64方法进行编码)</code></pre><h3 id="为什么需要把页面放在WEB-INF文件夹下面？"><a href="#为什么需要把页面放在WEB-INF文件夹下面？" class="headerlink" title="为什么需要把页面放在WEB-INF文件夹下面？"></a>为什么需要把页面放在WEB-INF文件夹下面？</h3><ol><li>基于不同的功能 JSP 被放置在不同的目录下</li></ol><p>这种方法的问题是这些页面文件容易被偷看到源代码，或被直接调用。某些场合下这可能不是个大问题，可是在特定情形中却可能构成安全隐患。用户可以绕过Struts的controller直接调用JSP同样也是个问题。</p><p>为了减少风险，可以把这些页面文件移到WEB-INF 目录下。基于Servlet的声明，WEB-INF不作为Web应用的公共文档树的一部分。因此，WEB-INF 目录下的资源不是为客户直接服务的。我们仍然可以使用WEB-INF目录下的JSP页面来提供视图给客户，客户却不能直接请求访问JSP。</p><ol start="2"><li>JSP存放在 WEB-INF 目录下更为安全</li></ol><p>如果把这些JSP页面文件移到WEB-INF 目录下，在调用页面的时候就必须把”WEB-INF”添加到URL中。</p><p>我们知道，实现页面的跳转有两种方式，一种是通过redirect的方式，一种是通过forward的方式。redirect方式的跳转，系统会在一个新的页面打开要跳转的网页；而forward方式跳转，系统会在原来的页面上打开一个要跳转的网页。所以放到WEB-INF目录下的文件是不允许采用redirect方式的跳转来访问的.</p><p>WEB-INF文件夹是受保护的文件夹，外部无法访问这个文件夹内的文件，只有服务器内部才能访问。</p><p>重要的服务器初始化核心文件web.xml就这在个文件夹内。</p><p>为了达到服务器端访问的目的，我们可以使用action进行转向，我们先去请求一个action，然后由这个action转发到WEB-INF下的页面，这样客户端就可以访问</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git初级入门</title>
      <link href="/2018/10/25/git-chu-ji-ru-men/"/>
      <url>/2018/10/25/git-chu-ji-ru-men/</url>
      
        <content type="html"><![CDATA[<p><strong>git的初级用法</strong></p><a id="more"></a><h3 id="Git的下载"><a href="#Git的下载" class="headerlink" title="Git的下载"></a>Git的下载</h3><p>git的官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p>点击右下角的：Downloade xxxx for Windows</p><p>由于是国外的网站，下载速度或许会很慢，请耐心等待~~</p><p>下载完后，直接安装就行。</p><p>安装完成，在桌面会创建Git Bash快捷方式。</p><p><strong>在任意目录下右击鼠标：会看到Git GUI Here 和 Git Bash Here 两个命令</strong></p><h3 id="Git的初步设置"><a href="#Git的初步设置" class="headerlink" title="Git的初步设置"></a>Git的初步设置</h3><ol><li>首先复制git的安装路径，追加到高级环境变量的PATH之后。确定保存退出。</li><li>打开cmd命令窗口（可用win+r,输入cmd确定即可）,输入git –vision命令（version前是两杠),显示版本号：<br><code>`</code><br>C:\Users\liuzhuo&gt;git –version<br>git version 2.15.0.windows.1</li></ol><p>C:\Users\liuzhuo&gt;</p><pre><code>3. 进入Git界面，就是在任意目录下，右键，点击Git Bash Here&lt;img src=&quot;/images/20181025091705.png&quot;/&gt;4. 配置全局的用户名和密码：git config --global user.name 你的用户名 #用户名 git config --global user.email 你的邮箱 #邮箱 这里加了 --global的选项，说明是全局配置，意思是在当前windows下，使用的git都是在这个用户下，也可以给一个项目配置单独的用户名和密码。5. 查看配置信息使用 git config --list</code></pre><p>liuzhuo@Gakki MINGW64 ~/Desktop<br>$ git config –list<br>core.symlinks=false<br>core.autocrlf=true<br>core.fscache=true<br>color.diff=auto<br>color.status=auto<br>color.branch=auto<br>color.interactive=true<br>help.format=html<br>rebase.autosquash=true<br>http.sslcainfo=D:/Git/mingw64/ssl/certs/ca-bundle.crt<br>http.sslbackend=openssl<br>diff.astextplain.textconv=astextplain<br>filter.lfs.clean=git-lfs clean – %f<br>filter.lfs.smudge=git-lfs smudge – %f<br>filter.lfs.process=git-lfs filter-process<br>filter.lfs.required=true<br>credential.helper=manager<br>user.name=liuzhuo<br><a href="mailto:user.email=575920824@qq.com" target="_blank" rel="noopener">user.email=575920824@qq.com</a></p><pre><code>使用git config –global –list:查看全局配置信息</code></pre><p>liuzhuo@Gakki MINGW64 ~/Desktop<br>$ git config –global –list<br>user.name=liuzhuo<br><a href="mailto:user.email=575920824@qq.com" target="_blank" rel="noopener">user.email=575920824@qq.com</a></p><pre><code>6. 常用的配置命令</code></pre><p>//查<br>git config –global –list</p><p>git config –global user.name</p><p>//增<br>git config  –global –add user.name jianan</p><p>//删<br>git config  –global –unset user.name</p><p>//改<br>git config –global user.name zhangsan</p><pre><code>7. 全局配置文件的地方`~/.gitconfig`例如Windows下，则是`C:\Users\用户名\.gitconfig`8. 各个仓库的配置`.git/config`例如orange仓库目录下`/home/lanyang/orange/.git/config`### Git的GUI界面这里，我们使用SourceTree官网：https://www.sourcetreeapp.com点击：Downloade for Windows### Git 仓库1) 初始化版本库git init2) 添加文件到版本库git addgit commit3) 查看仓库状态git status---首先，使用SourceTree来创建本地仓库：1）打开SourceTree&lt;img src=&quot;/images/20181025103910.png&quot;/&gt;左上角：Local： 代表本地仓库Remote：代表远程仓库右边：Clone：代表克隆其他人的仓库Add： 在原有仓库的基础上添加新的仓库Create：创建新的仓库2）点击Local和Create来创建本地仓库&lt;img src=&quot;/images/20181025104307.png&quot;/&gt;第一行：仓库的路径第二行：仓库的名字&lt;img src=&quot;/images/20181025104441.png&quot;/&gt;这里：选择了E盘下的gitdemo\demo1目录。点击创建3）在demo1目录下，创建一个新的文件(.txt)，并随便写入几句话。demo test······4）观察SourceTree界面：&lt;img src=&quot;/images/20181025104851.png&quot;/&gt;此时，在未暂存区域出现了我们刚刚创建的文件。说明，刚刚创建的文件现在只是在我们的工作目录下，还没有提交到本地仓库中。**ps：此时，有三个区域，第一个是我们的工作目录，第二个是暂存区域，第三个是本地仓库区域**我们一般在自己的工作目录下，编写自己的代码，然后提加到暂存区域，最后没有问题后，再提交到本地仓库保存起来。5）点击text.txt，然后点击暂存所选&lt;img src=&quot;/images/20181025105356.png&quot;/&gt;此时，我们的文件就保存到暂存区域了。6）提交到本地仓库中在最下面，填写我们的提交信息，然后点击提交。&lt;img src=&quot;/images/20181025105612.png&quot;/&gt;7) 提交成功后，查看仓库的状态第一次添加都是在主分支下面的，即master分支。点击master分支&lt;img src=&quot;/images/20181025105822.png&quot;/&gt;我们，就看到了，自己刚刚提交到本地仓库中的记录了。---现在，使用命令行界面来操作：在一个目录下，右键，点击Git Bush：我选择的是：E:\gitdemo&lt;img src=&quot;/images/20181025110804.png&quot;/&gt;1) git init demo2</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo<br>$ git init demo2<br>Initialized empty Git repository in E:/gitdemo/demo2/.git/</p><pre><code>2) 进入仓库的目录</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo<br>$ cd demo2</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$</p><pre><code>**ps:上面的右边的括号(master)，代表现在是主分支。**3) 创建新的文件</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ echo “demo2 text~~~~” &gt;&gt; text2.txt</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$</p><pre><code>此时，在demo2工作目录下，就会出现一个新的文件，text2.txt文件。4）查看状态git status</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master</p><p>No commits yet</p><p>Untracked files:<br>  (use “git add <file>…” to include in what will be committed)</file></p><pre><code>    text2.txt</code></pre><p>nothing added to commit but untracked files present (use “git add” to track)</p><pre><code>说明，当前是在主分支下，新建的text2.txt文件还没有提交。5）先添加到暂存区git add text2.txt</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add text2.txt<br>warning: LF will be replaced by CRLF in text2.txt.<br>The file will have its original line endings in your working directory.</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master</p><p>No commits yet</p><p>Changes to be committed:<br>  (use “git rm –cached <file>…” to unstage)</file></p><pre><code>    new file:   text2.txt</code></pre><pre><code>此时，文件已经加入到暂存区域了，最后，需要提交到本地仓库中6）提交到本地仓库git commit -m &quot;repo2 first commit&quot;</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m “repo2 first commit”<br>[master (root-commit) 8f22147] repo2 first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 text2.txt</p><pre><code>7) 查看本地仓库的状态git status</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean</p><pre><code>---### Git 工作流现在，模拟一下，你上班的情况。第一天上班，创建自己的本地仓库，提交自己的完成的代码需求。#### SourceTree1）新建一个本地仓库这里，我选择的是 E:\gitdemo\demo3，大家可以根据自己的喜好自由创建。&lt;img src=&quot;/images/20181025113245.png&quot;/&gt;2) 添加新的文件点击中间的：在文件管理器中打开然后，创建demo3.txt文件，并输入：第一天的需要，已经完成再回到SourceTree中：&lt;img src=&quot;/images/20181025113527.png&quot;/&gt;3）add + commit&lt;img src=&quot;/images/20181025114112.png&quot;/&gt;4) 提交成功&lt;img src=&quot;/images/20181025114212.png&quot;/&gt;---现在，快到下班了，产品经理提了一个临时的需求，所以，我们快马加鞭的写完，但是还没有自测，就只将先写的代码，保存到暂存区域中，不提交到本地仓库中。1）打开，demo3.txt 文件，先加入一句话：临时需求已做完！&lt;img src=&quot;/images/20181025114518.png&quot;/&gt;2) 在SourceTree中，将先修改的demo3文件，保存到暂存区域中：&lt;img src=&quot;/images/20181025114641.png&quot;/&gt;&lt;img src=&quot;/images/20181025114717.png&quot;/&gt;此时，拿起我们的背包，下班回家。第二天，上班，那个该死的产品经理，说昨天的临时需求不要了，内心一万个曹尼玛~~~所以，我们需要将暂存区域的代码和工作区域的代码，回滚到上一个阶段。3）点击demo3.text，右键：丢弃&lt;img src=&quot;/images/20181025115021.png&quot;/&gt;4) 点击确定丢弃&lt;img src=&quot;/images/20181025115425.png&quot;/&gt;5) 点击demo3.txt文件&lt;img src=&quot;/images/QQ截图20181025115532.png&quot;/&gt;**发现，demo3.txt文件中，回滚到了上一次提交的状态。****删除了：临时需求已做完**---第二天，继续codeing，编写产品经理提出的新需求。1）打开demo3.txt文件添加：第二天的需要已经完成！&lt;img src=&quot;/images/QQ截图20181025115902.png&quot;/&gt;2) add + commit&lt;img src=&quot;/images/QQ截图20181025120045.png&quot; /&gt;&lt;img src=&quot;/images/QQ截图20181025120147.png&quot; /&gt;能看到，有两次的提交记录。3）突然，产品经理说，这个需要不要了。内心无话可说所以，我们需要回滚到上一次提交的状态。点击 first commit ，**右键：重置当前分支到此次提交**&lt;img src=&quot;/images/QQ截图20181025124253.png&quot;/&gt;要回到哪个状态，就点击哪个状态，然后右键重置当前分支到此次提交：&lt;img src=&quot;/images/QQ截图20181025124921.png&quot;/&gt;点击确定。4）现在在工作区域下，能看到，上次修改后的没有提交的代码。&lt;img src=&quot;/images/QQ截图20181025125125.png&quot;/&gt;5) 丢弃修改的demo3.txt&lt;img src=&quot;/images/QQ截图20181025125317.png&quot;/&gt;6）打开demo3.txt文件：&lt;img src=&quot;/images/QQ截图20181025125416.png&quot;/&gt;回滚到第一次提交成功的状态了。---现在，产品经理，说第一次提交的需求，也不需要了，需要删除这个文件。1）直接在工作目录下，直接删除demo3.txt文件&lt;img src=&quot;/images/QQ截图20181025125817.png&quot;/&gt;2）add + commit&lt;img src=&quot;/images/QQ截图20181025125922.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025125959.png&quot;/&gt;3) 此时，工作目录，暂存区域，本地仓库都删除了demo3.txt文件了。---#### 命令行模式现在使用命令行来操作：1）打开命令行&lt;img src=&quot;/images/QQ截图20181025130301.png&quot;/&gt;2）在demo2下，创建bash_demo.txt文件在文件中，输入：bash_demo 第一次提交成功.&lt;img src=&quot;/images/QQ截图20181025130624.png&quot;/&gt;3) 在命令行查看状态 git status</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Untracked files:<br>  (use “git add <file>…” to include in what will be committed)</file></p><pre><code>    bash_demo.txt</code></pre><p>no changes added to commit (use “git add” and/or “git commit -a”)</p><pre><code>4) 报存到暂存区：</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add bash_demo.txt</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use “git reset HEAD <file>…” to unstage)</file></p><pre><code>    new file:   bash_demo.txt</code></pre><pre><code>5) 提交到本地仓库中：</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m “bash_demo first commit”<br>[master 136ecd0] bash_demo first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 bash_demo.txt</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean</p><pre><code>---6) 产品经理提出了临时的需要打开bash_demo.txt文件，添加：产品经理临时变更需要。&lt;img src=&quot;/images/QQ截图20181025131337.png&quot;/&gt;7) 查看 + add到暂存区域中：</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes not staged for commit:<br>  (use “git add <file>…” to update what will be committed)<br>  (use “git checkout – <file>…” to discard changes in working directory)</file></file></p><pre><code>    modified:   bash_demo.txt</code></pre><p>no changes added to commit (use “git add” and/or “git commit -a”)</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add bash_demo.txt</p><pre><code>下班走人。8）产品经理说，临时需要不要了使用 git reset head xxx.txt （重置）</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git reset head bash_demo.txt<br>Unstaged changes after reset:<br>M       bash_demo.txt</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes not staged for commit:<br>  (use “git add <file>…” to update what will be committed)<br>  (use “git checkout – <file>…” to discard changes in working directory)</file></file></p><pre><code>    modified:   bash_demo.txt</code></pre><p>no changes added to commit (use “git add” and/or “git commit -a”)</p><pre><code>此时，只是将本地仓库的文件替换了暂存区域中的bash_demo文件。我们工作区域的文件还没有替换。需要使用：git checkout -- bash_demo.txt</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git checkout – bash_demo.txt</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master</p><pre><code>打开bash_demo.txt文件。发现：产品经理临时变更需要。删除了9）第二天继续开发修改bash_demo.txt 文件。添加：第二天的需要已经完成&lt;img src=&quot;/images/QQ截图20181025132555.png&quot;/&gt;10) 将修改后的文件，add + commit</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git add bash_demo.txt</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use “git reset HEAD <file>…” to unstage)</file></p><pre><code>    modified:   bash_demo.txt</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m “second commit”<br>[master b8412ec] second commit<br> 1 file changed, 3 insertions(+), 1 deletion(-)</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean</p><pre><code>不幸的是，产品经理说，第二天的需要不需要了。11）查看提交日志git log</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git log<br>commit b8412ec81784d6be4a5097fca881a811fe1b1a58 (HEAD -&gt; master)<br>Author: liuzhuo <a href="mailto:&#53;&#x37;&#x35;&#57;&#x32;&#x30;&#x38;&#x32;&#52;&#x40;&#113;&#x71;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#53;&#x37;&#x35;&#57;&#x32;&#x30;&#x38;&#x32;&#52;&#x40;&#113;&#x71;&#46;&#99;&#111;&#x6d;</a><br>Date:   Thu Oct 25 13:27:36 2018 +0800</p><pre><code>second commit</code></pre><p>commit 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br>Author: liuzhuo <a href="mailto:&#x35;&#55;&#x35;&#x39;&#x32;&#48;&#56;&#50;&#x34;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x35;&#55;&#x35;&#x39;&#x32;&#48;&#56;&#50;&#x34;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;</a><br>Date:   Thu Oct 25 13:10:32 2018 +0800</p><pre><code>bash_demo first commit</code></pre><pre><code>找到：bash_demo第一次提交的序列号：commit 136ecd07ab2b0742dff45dcdcfbde1d51da2df42Author: liuzhuo &lt;575920824@qq.com&gt;Date:   Thu Oct 25 13:10:32 2018 +0800bash_demo first commit这里，就是：136ecd07ab2b0742dff45dcdcfbde1d51da2df4212）回滚git reset --hard 136ecd07ab2b0742dff45dcdcfbde1d51da2df42</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git reset –hard 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br>HEAD is now at 136ecd0 bash_demo first commit</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean</p><pre><code>查看，bash_demo.txt文件：&lt;img src=&quot;/images/QQ截图20181025133411.png&quot;/&gt;bash_demo文件就回滚到第一次提交的状态了。13）现在产品经理说，所做的工作都不需要了。删除bash_demo文件git rm bash_demo</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git rm bash_demo.txt<br>rm ‘bash_demo.txt’</p><pre><code>git commit -m &quot;delete bash demo&quot;</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git commit -m “delete bash demo”<br>[master 6d7eacc] delete bash demo<br> 1 file changed, 1 deletion(-)<br> delete mode 100644 bash_demo.txt</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean</p><pre><code>这样工作目录和本地仓库都删除了bash_demo文件了。---#### 总结：&lt;img src=&quot;/images/QQ截图20181025134253.png&quot;/&gt;1) 在工作区，先创建的文件，使用add，添加到暂存区，然后commit提交到本地仓库中。2）reset head命令：head是指向本地仓库的指针。  reset head file 就是重置本地仓库中版本文件到暂存区中。  然后使用checkout -- file 命令，将暂存区中的版本文件，重写到工作区中。3）rm -- file: 直接删除暂存区中的文件。然后commit提交，就更新到本地仓库中了。4）checkout head file: 一般不用，比较危险，因为使用这个命令，会把本地仓库中的版本文件，直接覆写到暂存区和工作区中。---图中左侧为工作区，右侧为版本库。在版本库中标记为 &quot;index&quot; 的区域是暂存区（stage/index），标记为 &quot;master&quot; 的是 master 分支所代表的目录树。图中我们可以看出此时 &quot;HEAD&quot; 实际是指向 master 分支的一个“指针”。所以，图示的命令中出现 HEAD 的地方可以用 master 来替换。图中的 objects 标识的区域为 Git 的对象库，实际位于 &quot;.git/objects&quot; 目录下。当对工作区新增或修改的文件执行 &quot;git add&quot; 命令时，暂存区的目录树被更新，同时工作区新增或修改的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。（如上图）当执行提交操作 &quot;git commit&quot; 时，暂存区的目录树写到版本库的对象库（objects）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。（如上图）当执行 &quot;git reset HEAD&quot; 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 &quot;git rm --cached &lt;file&gt;&quot; 命令时，会直接从暂存区删除文件，工作区则不做出改变。当执行 &quot;git checkout &quot; 或者 &quot;git checkout -- &lt;file&gt;&quot; 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。当执行 &quot;git checkout HEAD .&quot; 或者 &quot;git checkout HEAD &lt;file&gt;&quot; 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。---### 创建ssh key1）我们如果需要使用ssh来连接远程仓库的话，这里使用github当做远程仓库。首先，生成我们的ssh的公钥：ssh-keygen -t rsa -C &quot;youremail@exmple.com&quot;在github上面，创建我们的账号。在setting里面，找到 SSH and GPG keys&lt;img src=&quot;/images/QQ截图20181025144339.png&quot;/&gt;点击右上角的：New SSH key&lt;img src=&quot;/images/QQ截图20181025144438.png&quot;/&gt;填写title，自己定义。key，需要使用命令来生成。在Git bash界面下，输入生成ssh的命令：</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ ssh-keygen -t rsa -C “<a href="mailto:575920824@qq.com" target="_blank" rel="noopener">575920824@qq.com</a>“<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/c/Users/liuzhuo/.ssh/id_rsa):</p><pre><code>直接回车，覆盖以前的就好了。这样就会在c盘的用户目录生成一个.ssh文件夹C:\Users\liuzhuo\.ssh打开**id_rsa.pub**文件，将里面的key复制到github的ssh中key中：&lt;img src=&quot;/images/QQ截图20181025145015.png&quot;/&gt;2) 测试是否连接github成功：使用命令：ssh -T git@github.com</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)<br>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br>Hi liuzhuo19940206! You’ve successfully authenticated, but GitHub does not provide shell access.</p><pre><code>连接成功！！---### 添加远程仓库#### 使用命令行的方式在自己的github上面的，添加新的远程仓库&lt;img src=&quot;/images/QQ截图20181025145915.png&quot; style=&quot;width:50%&quot;/&gt;点击 New repository&lt;img src=&quot;/images/QQ截图20181025150029.png&quot; /&gt;填写  Repository name:仓库的名字Description：仓库的描述信息public：公共的仓库private：私有的仓库&lt;img src=&quot;/images/QQ截图20181025150238.png&quot;/&gt;点击：Create repository&lt;img src=&quot;/images/QQ截图20181025150341.png&quot;/&gt;上面的两块部分，描述了，将本地仓库和这个远程仓库连接起来的方法！第一种：</code></pre><p>…or create a new repository on the command line<br>echo “# gitDemo” &gt;&gt; README.md<br>git init<br>git add README.md<br>git commit -m “first commit”<br>git remote add origin <a href="https://github.com/liuzhuo19940206/gitDemo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/gitDemo.git</a><br>git push -u origin master</p><pre><code>按照上面的步骤来，就行了。在E:\gitdemo\demo4目录下，启动git的命令行界面</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4<br>$ echo “# gitDemo” &gt;&gt; README.md      //创建一个文件</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4<br>$ git init                          //创建一个本地仓库<br>Initialized empty Git repository in E:/gitdemo/demo4/.git/</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git add README.md                 //添加文件到暂存区<br>warning: LF will be replaced by CRLF in README.md.<br>The file will have its original line endings in your working directory.</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git commit -m “first commit”      //提交信息到本地仓库<br>[master (root-commit) e1e56e5] first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 README.md</p><pre><code>接下来，连接本地仓库和远程仓库：</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git remote add origin <a href="https://github.com/liuzhuo19940206/gitDemo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/gitDemo.git</a></p><pre><code>最后，将本地仓库的提交到远程仓库中：</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git push -u origin master</p><pre><code>第一次提交会出现验证信息的弹窗：&lt;img src=&quot;/images/QQ截图20181025151356.png&quot; style=&quot;width:50%&quot;/&gt;输入用户名和密码即可。出现了 fatal: HttpRequestException encountered.解决：Github 禁用了TLS v1.0 and v1.1，必须更新Windows的git凭证管理器 通过此网址 https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/&lt;img src=&quot;/images/QQ截图20181025152916.png&quot;/&gt;点击GCMW-1.14.0.exe，下载并安装。重启git窗口：</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git push -u origin master<br>Counting objects: 3, done.<br>Writing objects: 100% (3/3), 217 bytes | 217.00 KiB/s, done.<br>Total 3 (delta 0), reused 0 (delta 0)<br>remote:<br>remote: Create a pull request for ‘master’ on GitHub by visiting:<br>remote:      <a href="https://github.com/liuzhuo19940206/gitDemo/pull/new/master" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/gitDemo/pull/new/master</a><br>remote:<br>To <a href="https://github.com/liuzhuo19940206/gitDemo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/gitDemo.git</a></p><ul><li>[new branch]      master -&gt; master<br>Branch ‘master’ set up to track remote branch ‘master’ from ‘origin’.</li></ul><pre><code>就可以了，说明你的git和github已经可以同步了在github上面，刷新你刚刚创建的项目：&lt;img src=&quot;/images/QQ截图20181025154108.png&quot;/&gt;---现在，修改README.md文件&lt;img src=&quot;/images/QQ截图20181025154259.png&quot;/&gt;然后  git add README.mdgit commit -m &quot;second commit&quot;最后将本地仓库同步到远程仓库git push这里不用指明远程仓库的名字，因为第一次同步后，就不需要了。</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)<br>$ git push<br>Counting objects: 3, done.<br>Writing objects: 100% (3/3), 277 bytes | 277.00 KiB/s, done.<br>Total 3 (delta 0), reused 0 (delta 0)<br>To <a href="https://github.com/liuzhuo19940206/gitDemo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/gitDemo.git</a><br>   e1e56e5..39e3593  master -&gt; master</p><pre><code>刷新远程仓库：&lt;img src=&quot;/images/QQ截图20181025154719.png&quot;/&gt;说明，本地仓库和远程仓库同步成功!!!!---#### 使用SourceTree1）创建新的远程仓库&lt;img src=&quot;/images/QQ截图20181025155615.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025155703.png&quot;/&gt;2) 打开SourceTree创建本地仓库&lt;img src=&quot;/images/QQ截图20181025155817.png&quot;/&gt;在本地仓库中，新建文件sourcetree.txt文件&lt;img src=&quot;/images/QQ截图20181025160003.png&quot;/&gt;3）使用SourceTree添加到本地仓库中&lt;img src=&quot;/images/QQ截图20181025160104.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025160120.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025160210.png&quot;/&gt;4）将本地仓库和远程仓库连接起来点击master，然后点击右上角的设置&lt;img src=&quot;/images/QQ截图20181025160348.png&quot;/&gt;点击添加远程仓库：&lt;img src=&quot;/images/QQ截图20181025160430.png&quot;/&gt;填写信息：远程仓库名称：origin（自定义）URL：在github中远程仓库复制。  这里是：https://github.com/liuzhuo19940206/gitDemo_SourceTree.git用户名：提交的用户名&lt;img src=&quot;/images/QQ截图20181025160716.png&quot;/&gt;点击确认。在SourceTree中的左边的远程中：出现origin。&lt;img src=&quot;/images/QQ截图20181025160844.png&quot;/&gt;到此，我们就将远程仓库和本地仓库连接起来了。还没有同步！5) 将本地仓库和远程仓库同步点击菜单栏的推送&lt;img src=&quot;/images/QQ截图20181025161056.png&quot;/&gt;选好推送的远程仓库，添上加号，点击推送！6）刷新远程仓库&lt;img src=&quot;/images/QQ截图20181025161257.png&quot;/&gt;发现，同步成功，点击sourcetree.txt文件&lt;img src=&quot;/images/QQ截图20181025161359.png&quot;/&gt;7）修改本地仓库中的sourcetree.txt文件&lt;img src=&quot;/images/QQ截图20181025161447.png&quot;/&gt;8）使用SourceTree提交&lt;img src=&quot;/images/QQ截图20181025161550.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025174045.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025174124.png&quot;/&gt;9）推送到远程仓库此时，会发现推送上面会出现一个 1&lt;img src=&quot;/images/QQ截图20181025174248.png&quot;/&gt;点击推送&lt;img src=&quot;/images/QQ截图20181025174319.png&quot;/&gt;10）刷新远程仓库&lt;img src=&quot;/images/QQ截图20181025174433.png&quot;/&gt;这里出现了乱码，不影响我们的操作。---### 克隆仓库克隆仓库：将远程的仓库克隆到本地当中。使用的命令是：  git clone htt或ssh地址  git clone https://github.com/liuzhuo19940206/clone_repo_demo.git1）在github上创建一个新的仓库&lt;img src=&quot;/images/QQ截图20181025175600.png&quot;/&gt;2) 直接在github上面创建一个README.md文件&lt;img src=&quot;/images/QQ截图20181025175832.png&quot;/&gt;上面两个步骤，就是假设刚刚创建的项目是别人的远程仓库，我们需要克隆别人的远程仓库，来进行多人开发。#### 使用命令行来克隆1）在E:\gitdemo\demo6下，启动git窗口&lt;img src=&quot;/images/QQ截图20181025180055.png&quot;/&gt;使用 ls -a</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo6<br>$ ls -a<br>./  ../</p><pre><code>如果没有出现.git文件，说明此目录才能克隆仓库。不能在已经是本地仓库下的情况下克隆远程仓库2）执行克隆命令git clone https://github.com/liuzhuo19940206/clone_repo_demo.git</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo6<br>$ git clone <a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a><br>Cloning into ‘clone_repo_demo’…<br>remote: Enumerating objects: 3, done.<br>remote: Counting objects: 100% (3/3), done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br>Unpacking objects: 100% (3/3), done.</p><pre><code>此时，打开demo6目录：在该目录下面会出远程仓库的名称和README.md文件&lt;img src=&quot;/images/QQ截图20181025183824.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025183908.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025183938.png&quot;/&gt;到此，克隆成功。---#### 使用SourceTree来克隆1）打开SourceTree，新建窗口&lt;img src=&quot;/images/QQ截图20181025184546.png&quot;/&gt;2）点击Clone按钮&lt;img src=&quot;/images/QQ截图20181025184631.png&quot;/&gt;第一行：远程仓库的地址  https://github.com/liuzhuo19940206/clone_repo_demo.git第二行：本地仓库的地址  E:\gitdemo\demo7&lt;img src=&quot;/images/QQ截图20181025184839.png&quot;/&gt;点击克隆&lt;img src=&quot;/images/QQ截图20181025184925.png&quot;/&gt;3）打开E:\gitdemo\demo7目录&lt;img src=&quot;/images/QQ截图20181025185035.png&quot;/&gt;---### 标签管理标签的作用是，给某个时刻的版本加上一个标签，然后，可以回滚到指定的标签。标签的命令：1) 查看所有标签 　　　　 git tag2) 创建标签 　　　　　　 git tag name3) 指定提交信息 　　　　 git tag -a name -m &quot;comment&quot;4) 删除标签 　　　　　　 git tag -d neam5) 标签发布 　　　　　 　git push origin name**ps:markdown中使用空格****1) 手动输入空格 （&amp;nbsp；）。注意！此时的分号为英文分号，但是不推荐使用此方法，太麻烦！****2) 使用全角空格。即：在全角输入状态下直接使用空格键就ok了**#### 使用命令行创建标签现在是在E:\gitdemo\demo7目录下。&lt;img src=&quot;/images/QQ截图20181025192253.png&quot;/&gt;1）git tag 查看标签</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git tag</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$</p><pre><code>发现，没有标签2）创建标签</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git tag v1.0.1</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git tag<br>v1.0.1</p><pre><code>3) push标签</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)<br>$ git push origin v1.0.1<br>Total 0 (delta 0), reused 0 (delta 0)<br>To <a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a></p><ul><li>[new tag]         v1.0.1 -&gt; v1.0.1</li></ul><pre><code>4) 在远程仓库中验证标签是否推送成功&lt;img src=&quot;/images/QQ截图20181025192912.png&quot;/&gt;---#### 使用SourceTree创建标签1) 现在修改一下E:\gitdemo\demo7下的README.md文件，为了和命令行创建的标签形成对比.&lt;img src=&quot;/images/QQ截图20181025193635.png&quot;/&gt;使用SourceTree，add + commit + push&lt;img src=&quot;/images/QQ截图20181025193833.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025193850.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025193916.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025194050.png&quot;/&gt;2) 在SourceTree下创建新的标签在SourceTree的菜单栏上面有一个标签的按钮，点击&lt;img src=&quot;/images/QQ截图20181025194223.png&quot;/&gt;第一行：标签的名称提交：点击指定的提交&lt;img src=&quot;/images/QQ截图20181025194327.png&quot;/&gt;此时，可以选择在哪个提交的版本上面，创建新的标签，因为first commit上面有一个v1.0.1的标签了，为了区别，现在选择second commit的提交。点击确认点击推送标签前面的方格，会将本地的标签推送到远程仓库上面。&lt;img src=&quot;/images/QQ截图20181025194613.png&quot;/&gt;3）点击添加标签&lt;img src=&quot;/images/QQ截图20181025194731.png&quot;/&gt;&lt;img src=&quot;/images/QQ截图20181025194804.png&quot;/&gt;4）在远程仓库上面验证&lt;img src=&quot;/images/QQ截图20181025194853.png&quot;/&gt;5）切换标签点击v1.0.1标签：&lt;img src=&quot;/images/QQ截图20181025195005.png&quot;/&gt;**下面的README.md文件中，没有second commit。**点击v2.0.1标签：&lt;img src=&quot;/images/QQ截图20181025195110.png&quot;/&gt;**下面的README.md文件中，有second commit。**&lt;font color=&quot;red&quot;&gt;**以后，就可以切换标签，来回滚到自己想要的版本。**&lt;/font&gt;---### 分支管理&lt;img src=&quot;/images/QQ截图20181025200337.png&quot;/&gt;一般是，在我们开发的过程中，在主分支master上面写。但是，每个人都有自己的任务，这个任务，不能短时间内完成，不能只完成一部分就提交到master主分支上面，这样会使的其他人无法使用master主分支了。我们也不能等到我们开发完后，一次性提交代码到master主分支上面。因为我们想记录我们的每一个开发流程。所以，需要创建子分支来记录我们的开发流程。最后与主分支合并。#### 使用命令行的方式1）新建一个目录：E:\gitdemo\branch_demo2）在该目录下，打开git窗口&lt;img src=&quot;/images/QQ截图20181025201915.png&quot;/&gt;3) 添加一个新的文件，模拟开发流程。</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo<br>$ echo “branch first” &gt;&gt; branch_demo.txt            //创建新的文件</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo<br>$ git init                                         //创建本地仓库<br>Initialized empty Git repository in E:/gitdemo/branch_demo/.git/</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git status<br>On branch master</p><p>No commits yet</p><p>Untracked files:<br>  (use “git add <file>…” to include in what will be committed)</file></p><pre><code>    branch_demo.txt</code></pre><p>nothing added to commit but untracked files present (use “git add” to track)</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git add branch_demo.txt                         //添加到暂存区<br>warning: LF will be replaced by CRLF in branch_demo.txt.<br>The file will have its original line endings in your working directory.</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git status<br>On branch master</p><p>No commits yet</p><p>Changes to be committed:<br>  (use “git rm –cached <file>…” to unstage)</file></p><pre><code>    new file:   branch_demo.txt</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git commit -m “branch first commit”           //提交到本地仓库中<br>[master (root-commit) ac97673] branch first commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 branch_demo.txt</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean</p><pre><code>4）开启新的分支git brach  : 查看所有分支git brach 分支名称 ：创建新的分支</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch</p><ul><li>master</li></ul><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch new_branch</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch</p><ul><li>master<br>new_branch</li></ul><pre><code>5）切换分支git checkout 分支名称</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git checkout new_branch<br>Switched to branch ‘new_branch’</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)</p><pre><code>切换成功后，右边的括号内就是分支的名称。6）在新分支继续开发</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ echo “ new_branch” &gt;&gt; branch_demo.txt</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git status<br>On branch new_branch<br>Changes not staged for commit:<br>  (use “git add <file>…” to update what will be committed)<br>  (use “git checkout – <file>…” to discard changes in working directory)</file></file></p><pre><code>    modified:   branch_demo.txt</code></pre><p>no changes added to commit (use “git add” and/or “git commit -a”)</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git add branch_demo.txt<br>warning: LF will be replaced by CRLF in branch_demo.txt.<br>The file will have its original line endings in your working directory.</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git status<br>On branch new_branch<br>Changes to be committed:<br>  (use “git reset HEAD <file>…” to unstage)</file></p><pre><code>    modified:   branch_demo.txt</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git commit -m “new_branch commit”<br>[new_branch 25fe8ff] new_branch commit<br> 1 file changed, 2 insertions(+), 1 deletion(-)</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git status<br>On branch new_branch<br>nothing to commit, working tree clean</p><pre><code>7) 分别在每个分支查看branch_demo.txt文件在新的分支下查看：cat branch_demo.txt</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git branch<br>  master</p><ul><li>new_branch</li></ul><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ cat branch_demo.txt<br>branch first<br>new_branch</p><pre><code>切换到主分支查看：</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)<br>$ git checkout master<br>Switched to branch ‘master’</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ cat branch_demo.txt<br>branch first</p><pre><code>8) 合并分支git merge 子分支的名字&lt;font color=&quot;red&quot;&gt;在主分支(master)下，执行该命令&lt;/font&gt;</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git merge new_branch<br>Updating ac97673..25fe8ff<br>Fast-forward<br> branch_demo.txt | 3 ++-<br> 1 file changed, 2 insertions(+), 1 deletion(-)</p><pre><code>9）查看主分支中的文件</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ cat branch_demo.txt<br>branch first<br>new_branch</p><pre><code>**现在，主分支与子分支合并成功，文件中出现了new_branch的信息。**10）删除分支当我们的项目接着开发，之前的new_brach分子不需要，浪费空间，所有需要删除。git branch -d 分支的名称</code></pre><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch -d new_branch<br>Deleted branch new_branch (was 25fe8ff).</p><p>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)<br>$ git branch</p><ul><li>master</li></ul><p><code>`</code></p><p>此时，new_branch分支删除成功。</p><h4 id="使用SourceTree的方式"><a href="#使用SourceTree的方式" class="headerlink" title="使用SourceTree的方式"></a>使用SourceTree的方式</h4><p>1）打开SourceTree</p><p>在E:\gitdemo\branch_sourcetree_demo下创建本地仓库<br><img src="/images/QQ截图20181025205416.png"></p><p>2）在E:\gitdemo\branch_sourcetree_demo下创建branch_demo.txt文件：<br><img src="/images/QQ截图20181025205522.png"></p><p>3）add + commit<br><img src="/images/QQ截图20181025205642.png"><br><img src="/images/QQ截图20181025205658.png"><br><img src="/images/QQ截图20181025205724.png"><br><img src="/images/QQ截图20181025205758.png"></p><p>4) 创建新的分支</p><p>在SourceTree的菜单栏上面有一个分支的按钮<br><img src="/images/QQ截图20181025205849.png"><br><img src="/images/QQ截图20181025205950.png"></p><p>创建分支成功后，在SourceTree左边，会出现新的分支<br><img src="/images/QQ截图20181025210021.png"></p><p><strong>选中的分支前面会有一个圆圈</strong></p><p>5）在新的分支下，修改branch_demo.txt文件<br><img src="/images/QQ截图20181025210235.png"></p><p>6) 在新的分支下，add + commit<br><img src="/images/QQ截图20181025210332.png"><br><img src="/images/QQ截图20181025210426.png"><br><img src="/images/QQ截图20181025210509.png"></p><p>7）切换到master分支下</p><p>双击master主分支，就切换成功了。<br><img src="/images/QQ截图20181025210659.png"></p><p>8）打开E:\gitdemo\branch_sourcetree_demo下的branch_demo.txt文件<br><img src="/images/QQ截图20181025210750.png"></p><p>发现文件里面，没有new_branch second信息。</p><p>9）将子分支合并到主分支中</p><p>在主分支的情况下，点击菜单栏下的合并按钮<br><img src="/images/QQ截图20181025211021.png"></p><p>点击我们要合并的分支。然后点击确定。<br><img src="/images/QQ截图20181025211223.png"></p><p>现在，再打开E:\gitdemo\branch_sourcetree_demo下的branch_demo.txt文件。<br><img src="/images/QQ截图20181025211400.png"></p><p>现在，合并成功了。</p><p>10）删除分支</p><p>直接在要删除的分支上面右键<br><img src="/images/QQ截图20181025211604.png"><br><img src="/images/QQ截图20181025211636.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC注解</title>
      <link href="/2018/10/24/springmvc-zhu-jie/"/>
      <url>/2018/10/24/springmvc-zhu-jie/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC注解</strong></p><p>SpringMVC注解的详细解答<br><a id="more"></a></p><h3 id="注解概观"><a href="#注解概观" class="headerlink" title="注解概观"></a>注解概观</h3><p><strong>Spring2.5 引入注解式处理器</strong></p><p>@Controller：用于标识是处理器类；</p><p>@RequestMapping：请求到处理器功能方法的映射规则；</p><p>@RequestParam：请求参数到处理器功能处理方法的方法参数上的绑定；</p><p>@ModelAttribute：请求参数到命令对象的绑定；</p><p>@SessionAttributes：用于声明session级别存储的属性，放置在处理器类上，通常列出模型属性（如@ModelAttribute）对应的名称，则这些属性会透明的保存到session中；</p><p>@InitBinder：自定义数据绑定注册支持，用于将请求参数转换到命令对象属性的对应类型；</p><hr><p><strong>Spring3.0 引入RESTful架构风格支持(通过@PathVariable注解和一些其他特性支持),且又引入了更多的注解支持</strong></p><p>@CookieValue：cookie数据到处理器功能处理方法的方法参数上的绑定；</p><p>@RequestHeader：请求头（header）数据到处理器功能处理方法的方法参数上的绑定；</p><p>@RequestBody：请求的body体的绑定（通过HttpMessageConverter进行类型转换）；</p><p>@ResponseBody：处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；</p><p>@ResponseStatus：定义处理器功能处理方法/异常处理器返回的状态码和原因；</p><p>@ExceptionHandler：注解式声明异常处理器；</p><p>@PathVariable：请求URI中的模板变量部分到处理器功能处理方法的方法参数上的绑定</p><h3 id="类与方法注解"><a href="#类与方法注解" class="headerlink" title="类与方法注解"></a>类与方法注解</h3><p>@Controller @RestController</p><p>@RestContrller注解相当于@ResponseBody和@Controller的结合 :</p><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p>通过HttpMessageConverter接口转换为指定格式的数据</p><h4 id="InitBinder-局部转换器"><a href="#InitBinder-局部转换器" class="headerlink" title="@InitBinder-局部转换器"></a>@InitBinder-局部转换器</h4><p>如果希望某个属性编辑器仅作用于特定的 Controller ，</p><p>可以在 Controller 中定义一个标注 @InitBinder 注解的方法，</p><p>可以在该方法中向 Controller 了注册若干个属性编辑器</p><p>例如:</p><pre><code>@InitBinderpublic void initBinder(WebDataBinder binder) {SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);dateFormat.setLenient(false);binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));}</code></pre><h4 id="RequestMapping-请求路径映射"><a href="#RequestMapping-请求路径映射" class="headerlink" title="@RequestMapping-请求路径映射"></a>@RequestMapping-请求路径映射</h4><p>RequestMapping是一个用来处理请求地址映射的注解（将请求映射到对应的控制器方法中），可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping请求路径映射，如果标注在某个controller的类级别上，则表明访问此类路径下的方法都要加上其配置的路径；最常用是标注在方法上，表明哪个具体的方法来接受处理某次请求。</p><p>属性:</p><pre><code>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。1、 value， method；value：   指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；method：  指定请求的method类型， GET、POST、PUT、DELETE等；2、consumes，producesconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；3、params，headersparams：  指定request中必须包含某些参数值是，才让该方法处理。headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</code></pre><p>派生的子类：</p><pre><code>Ø  @GetMappingØ  @PostMappingØ  @PutMappingØ  @DeleteMappingØ  @PatchMapping</code></pre><p>属性详解：</p><h5 id="value"><a href="#value" class="headerlink" title="value"></a><font size="4">value</font></h5><p>用法</p><p>(1)普通的具体值。如前面的 value=”/book”。</p><pre><code>@RequestMapping(value=&quot;/get/{bookId}&quot;)public String getBookById(@PathVariable String bookId,Model model){  model.addAttribute(&quot;bookId&quot;, bookId);  return &quot;book&quot;;} </code></pre><p>(2)含某变量的一类值。</p><p>(3)ant风格</p><pre><code>  @RequestMapping(value=&quot;/get/id?&quot;)：可匹配“/get/id1”或“/get/ida”，但不匹配“/get/id”或“/get/idaa”;  @RequestMapping(value=&quot;/get/id*&quot;)：可匹配“/get/idabc”或“/get/id”，但不匹配“/get/idabc/abc”;  @RequestMapping(value=&quot;/get/id/*&quot;)：可匹配“/get/id/abc”，但不匹配“/get/idabc”;  @RequestMapping(value=&quot;/get/id/**/{id}&quot;)：可匹配“/get/id/abc/abc/123”或“/get/id/123”，也就是Ant风格和URI模板变量风格可混用。</code></pre><p>(4)含正则表达式的一类值</p><pre><code>@RequestMapping(value=&quot;/get/{idPre:\d+}-{idNum:\d+}&quot;)：可以匹配“/get/123-1”，但不能匹配“/get/abc-1”，这样可以设计更加严格的规则。可以通过@PathVariable 注解提取路径中的变量(idPre,idNum)</code></pre><p>(5)或关系</p><pre><code>@RequestMapping(value={&quot;/get&quot;,&quot;/fetch&quot;} ) 即 /get或/fetch都会映射到该方法上。</code></pre><h5 id="method"><a href="#method" class="headerlink" title="method"></a><font size="4">method</font></h5><p>指定请求的method类型， GET、POST、PUT、DELETE等；</p><p>用法:</p><pre><code>@RequestMapping(value=&quot;/get/{bookid}&quot;,method={RequestMethod.GET,RequestMethod.POST})</code></pre><h5 id="params："><a href="#params：" class="headerlink" title="params："></a><font size="4">params：</font></h5><p><strong>指定request中必须包含某些参数值是，才让该方法处理。</strong></p><p>@RequestMapping(params=”action=del”)，请求参数包含”action=del”,如：</p><p><code>http://localhost:8080/book?action=del</code></p><pre><code>@Controller@RequestMapping(&quot;/owners/{ownerId}&quot;)public class RelativePathUriTemplateController {@RequestMapping(value = &quot;/pets/{petId}&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;)public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {      // implementation omitted}}仅处理请求中包含了名为“myParam”，值为“myValue”的请求</code></pre><h5 id="headers："><a href="#headers：" class="headerlink" title="headers："></a><font size="4">headers：</font></h5><p>指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p>@RequestMapping(value=”/header/id”, headers = “Accept=application/json”)：</p><p>表示请求的URL必须为“/header/id 且请求头中必须有“Accept =application/json”参数即可匹配。</p><pre><code>@Controller@RequestMapping(&quot;/owners/{ownerId}&quot;)public class RelativePathUriTemplateController {    @RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.GET, headers=&quot;Referer=http://www.ifeng.com/&quot;)    public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {          // implementation omitted    }}    仅处理request的header中包含了指定“Refer”请求头和对应值为“http://www.ifeng.com/”的请求。</code></pre><h5 id="consumes："><a href="#consumes：" class="headerlink" title="consumes："></a><font size="4">consumes：</font></h5><p>指定处理请求的提交内容类型（Content-Type），例如application/json, text/html。</p><p>用法:</p><p>@RequestMapping(value = “/pets”, method = RequestMethod.POST, consumes=”application/json”)</p><pre><code>@Controller@RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.POST, consumes=&quot;application/json&quot;)public void addPet(@RequestBody Pet pet, Model model) {      // implementation omitted}          方法仅处理request Content-Type为“application/json”类型的请求。</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-参数绑定</title>
      <link href="/2018/10/24/springmvc-can-shu-bang-ding/"/>
      <url>/2018/10/24/springmvc-can-shu-bang-ding/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC-参数绑定</strong></p><p>探究SpringMVC中控制层的方法中的参数绑定<br><a id="more"></a></p><h4 id="Model-ModelMap-ModelAndView"><a href="#Model-ModelMap-ModelAndView" class="headerlink" title="Model/ModelMap/ModelAndView"></a>Model/ModelMap/ModelAndView</h4><p>ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下</p><pre><code>@RequestMapping(&quot;/itemEdit&quot;)    public String itemEdit(Integer id, Model model) {        Items items = itemService.getItemById(id);        //向jsp传递数据        model.addAttribute(&quot;item&quot;, items);        //设置跳转的jsp页面        return &quot;editItem&quot;;    }    /*@RequestMapping(&quot;/itemEdit&quot;)    public String editItem(HttpServletRequest request,             HttpServletResponse response, HttpSession session, Model model) {        //从request中取参数        String strId = request.getParameter(&quot;id&quot;);        int id = new Integer(strId);        //调用服务        Items items = itemService.getItemById(id);        //把结果传递给页面        //ModelAndView modelAndView = new ModelAndView();        //modelAndView.addObject(&quot;item&quot;, items);        //设置逻辑视图        //modelAndView.setViewName(&quot;editItem&quot;);        //return modelAndView;        //设置返回结果        model.addAttribute(&quot;item&quot;, items);        //返回逻辑视图        return &quot;editItem&quot;;    }    */</code></pre><h4 id="Any-other-argument原始参数"><a href="#Any-other-argument原始参数" class="headerlink" title="Any other argument原始参数"></a>Any other argument原始参数</h4><p>当请求的参数名称和处理器形参<strong>名称一致时</strong>会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。</p><pre><code>  @RequestMapping(&quot;/itemEdit&quot;)      public String itemEdit(Integer id, Model model) {          Items items = itemService.getItemById(id);          //向jsp传递数据          model.addAttribute(&quot;item&quot;, items);          //设置跳转的jsp页面          return &quot;editItem&quot;;      }  参数类型推荐使用包装数据类型，因为基础数据类型不可以为null  整形：  Integer、int  字符串：String  单精度：Float、float  双精度：Double、double  布尔型：Boolean、boolean  说明：对于布尔类型的参数，请求的参数值为true或false。  处理方法：  public String editItem(Model model,Integer id,Boolean status) throws Exception  请求url：  http://localhost:8080/xxx.action?id=2&amp;status=false  处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。 </code></pre><h3 id="注解形式："><a href="#注解形式：" class="headerlink" title="注解形式："></a>注解形式：</h3><p>下面是具体使用说明，几乎都是下面这种格式：Public String (@RequestParam int id){..}</p><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><p>@RequestParam用来接收路径后面的参数<br><code>http:www.lifeibai.com?petId = 1.</code><br> 一般用来处理接收的参数和形参的参数不一致的情况</p><pre><code>@RequestParam(value = &quot;id&quot;,defaultValue = &quot;10&quot;,required = false)defaultValue 表示设置默认值，required     通过boolean设置是否是必须要传入的参数，value        值表示接受的传入的参数名称使用@RequestParam常用于处理简单类型的绑定。</code></pre><p>例子：</p><pre><code>@Controller@RequestMapping(&quot;/pets&quot;)public class EditPetForm {  // ...  @GetMapping  public String setupForm(@RequestParam(&quot;petId&quot;) int Id, Model model) {      Pet pet = this.clinic.loadPet(petId);      model.addAttribute(&quot;pet&quot;, pet);      return &quot;petForm&quot;;  }  // ...}</code></pre><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><p>@RequestHeader用来接收指定参数的请求头信息</p><pre><code>@GetMapping(&quot;/demo&quot;)public void handle(      @RequestHeader(&quot;Accept-Encoding&quot;) String encoding,      @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) {  //...}</code></pre><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4><p>用来接收指定名称的cookie的值</p><pre><code>public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) {  //...}</code></pre><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><font color="red">@ModelAttribute</font></h4><p>ModelAttribute可以应用在<strong>方法参数上</strong>或<strong>方法上</strong>，他的作用主要是当注解在方法参数上时会将注解的参数对象添加到Model中；</p><p>当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，但其它Action被调用时会<strong>首先</strong>调用该方法。</p><p><font color="#FF3E96">被@ModelAttribute注释的方法会在此controller每个方法执行前被执行，下面访问 http:localhost:8080/test_project/test.action</font></p><pre><code>  @RestController  @SessionAttributes(&quot;user&quot;)  public class TestController {      @ModelAttribute(&quot;age2&quot;)      public String mdoeltest1(){          System.out.println(&quot;This is ModelAttribute1 !&quot;);          return &quot;33&quot;;      }      @ModelAttribute(&quot;age1&quot;)      public String mdoeltestrrr(){          System.out.println(&quot;This is ModelAttributee1 !&quot;);          return &quot;22&quot;;      }      @RequestMapping(&quot;/test.action&quot;)      public String test(User user ,                          @ModelAttribute(&quot;age1&quot;) String age1 ,                         @ModelAttribute(&quot;age2&quot;) String age2 ,                         HttpSession session){          Object user2 = session.getAttribute(&quot;user&quot;);          System.out.println(user2);          System.out.println(user);          System.out.println(&quot;age1:&quot;+age1);          System.out.println(&quot;age2:&quot;+age2);          return &quot;test&quot;;      }  }  结果：  This is ModelAttributee1 !  This is ModelAttribute1 !  User{name=&#39;李四&#39;, age=22}  User{name=&#39;李四&#39;, age=22}  age1:22  age2:33</code></pre><h4 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h4><p>Value={“name”,“age”} 取出name或者value、或者把model中的name，age扔到session中<br>Type=User.Class   将一个实体类扔到session中<br>这个玩意加在 类上面，然后所有的方法的参数都可以在sesssion中找，找到了就赋值。<br>@SessionAttributes需要清除时，使用SessionStatus.setComplete();来清除。</p><p>1、  将model中的值，扔到session中</p><pre><code>@Controller@SessionAttributes(types = User.class)public class LoginController {  @RequestMapping(&quot;/login&quot;)  public String login(HttpServletRequest req,Model model,SessionStatus status){      User user = new User();      user.setName(&quot;李四&quot;);      user.setAge(22);      model.addAttribute(&quot;user&quot; , user);      return &quot;forward:test.action&quot;;  }}</code></pre><p>2、  从session取出来</p><pre><code>@RestController@SessionAttributes(&quot;user&quot;)public class TestController {  @RequestMapping(&quot;/test.action&quot;)  public String  test(User user, HttpSession session){      Object user2 = session.getAttribute(&quot;user&quot;);      System.out.println(user2);      System.out.println(user);      return &quot;test&quot;;  }}</code></pre><h4 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h4><p>这玩意是加在方法上的参数的，将session中的数据赋值给参数 。但是4.3以后的版本才支持</p><pre><code>@RequestMapping(&quot;/&quot;)public String handle(@SessionAttribute User user) {    // ...}</code></pre><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上</p><pre><code>List.action?id=1&amp;name=zhangsan&amp;age=12本例子应用：@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象// 商品修改提交json信息，响应json信息  @RequestMapping(&quot;/editItemSubmit_RequestJson&quot;)  public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception {      System.out.println(items);      //itemService.saveItem(items);      return items;  }</code></pre><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p>该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p><p>@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端</p><p><strong><font color="red">使用这个注解 ，sessionAttributes注解将会失效</font></strong></p><h4 id="PathVariable（RESTful）"><a href="#PathVariable（RESTful）" class="headerlink" title="@PathVariable（RESTful）"></a>@PathVariable（RESTful）</h4><pre><code>用法     @RequestMapping(value=&quot;/users/{userId}/topics/{topicId}&quot;)     public String test(     @PathVariable(value=&quot;userId&quot;) int userId,      @PathVariable(value=&quot;topicId&quot;) int topicId)      如请求的URL为“控制器URL/users/123/topics/456”，     则自动将URL中模板变量{userId}和{topicId}绑定到     通过@PathVariable注解的同名参数上，即入参后userId=123、topicId=456。</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-Return Values返回值</title>
      <link href="/2018/10/24/values-fan-hui-zhi/"/>
      <url>/2018/10/24/values-fan-hui-zhi/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC-Return Values返回值</strong></p><p>本篇文章，主要讲解SpringMVC的返回值的使用。</p><a id="more"></a><hr><h3 id="Handler-Return-Values返回值"><a href="#Handler-Return-Values返回值" class="headerlink" title="Handler-Return Values返回值"></a>Handler-Return Values返回值</h3><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p> 返回值通过HttpMessageConverters转换并写入响应。   请参阅@ResponseBody。<br> 处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；<br> 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。<br> 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><h4 id="HttpEntity-ResponseEntity"><a href="#HttpEntity-ResponseEntity" class="headerlink" title="HttpEntity,ResponseEntity"></a>HttpEntity,ResponseEntity</h4><p>返回值:指定完整响应，包括HTTP标头和正文通过HttpMessageConverters转换并写入响应。 请参阅ResponseEntity。</p><h4 id="HttpHeaders"><a href="#HttpHeaders" class="headerlink" title="HttpHeaders"></a>HttpHeaders</h4><p>为了返回一个响应头和没有正文。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>一个视图名称，用ViewResolver解决，并与隐式模型一起使用 - 通过命令对象和@ModelAttribute方法确定。 处理程序方法也可以通过声明一个Model参数来以编程方式丰富模型。</p><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>用于与隐式模型一起渲染的View实例 - 通过命令对象和@ModelAttribute方法确定。 处理程序方法也可以通过声明一个Model参数来以编程方式丰富模型。</p><h4 id="java-util-Map-org-springframework-ui-Model"><a href="#java-util-Map-org-springframework-ui-Model" class="headerlink" title="java.util.Map,org.springframework.ui.Model"></a>java.util.Map,org.springframework.ui.Model</h4><p>要通过RequestToViewNameTranslator隐式确定的视图名称添加到隐式模型的属性。</p><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><p>要通过RequestToViewNameTranslator隐式确定的视图名称添加到模型的属性。   请注意@ModelAttribute是可选的。</p><h4 id="ModelAndView-，object"><a href="#ModelAndView-，object" class="headerlink" title="ModelAndView ，object"></a>ModelAndView ，object</h4><p>要使用的视图和模型属性，以及可选的响应状态。</p><h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p>具有void返回类型（或返回值为null）的方法如果还有ServletResponse，OutputStream参数或@ResponseStatus注释，则认为它已完全处理响应。<br>如果控制器进行了积极的ETag或lastModified时间戳检查（请参阅@Controller缓存了解详细信息），情况也是如此。<br>如果以上都不是这样，那么void返回类型也可能指示REST控制器的“无响应主体”，或HTML控制器的默认视图名称选择。</p><h4 id="DeferredResult"><a href="#DeferredResult" class="headerlink" title="DeferredResult"></a><font color="red">DeferredResult</font></h4><p>从任何线程异步生成任何上述返回值 - 例如 可能是由于某些事件或回调。</p><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a><font color="red">Callable</font></h4><p>Produce any of the above return values asynchronously in a Spring MVC managed thread. See Async Requests and Callable.使用异步线程来执行请求，然后返回给handler。</p><h4 id="ListenableFuture-java-util-concurrent-CompletionStage-java-util-concurrent-CompletableFuture"><a href="#ListenableFuture-java-util-concurrent-CompletionStage-java-util-concurrent-CompletableFuture" class="headerlink" title="ListenableFuture, java.util.concurrent.CompletionStage,   java.util.concurrent.CompletableFuture"></a>ListenableFuture, java.util.concurrent.CompletionStage,   java.util.concurrent.CompletableFuture</h4><p>在Spring MVC托管线程中异步生成上述任何返回值。</p><h4 id="ResponseBodyEmitter-SseEmitter"><a href="#ResponseBodyEmitter-SseEmitter" class="headerlink" title="ResponseBodyEmitter,   SseEmitter"></a>ResponseBodyEmitter,   SseEmitter</h4><p>用HttpMessageConverter’s异步发出一个对象流写入响应; 也支持作为ResponseEntity的主体。</p><h4 id="StreamingResponseBody"><a href="#StreamingResponseBody" class="headerlink" title="StreamingResponseBody"></a>StreamingResponseBody</h4><p>异步写入响应的OutputStream; 也支持作为ResponseEntity的主体。</p><h4 id="Reactive-types-—-Reactor-RxJava-or-others-via-ReactiveAdapterRegistry"><a href="#Reactive-types-—-Reactor-RxJava-or-others-via-ReactiveAdapterRegistry" class="headerlink" title="Reactive   types — Reactor, RxJava, or others via ReactiveAdapterRegistry"></a>Reactive   types — Reactor, RxJava, or others via ReactiveAdapterRegistry</h4><p>具有多值流的DeferredResult（例如Flux，Observable）的替代方法被收集到列表中。<br>对于流式场景 - 例如 text / event-stream，application / json +   stream - 使用SseEmitter和ResponseBodyEmitter，而在Spring MVC托管线程上执行ServletOutputStream阻塞I / O，并在每次写入完成时施加背压。</p><h4 id="Any-other-return-value"><a href="#Any-other-return-value" class="headerlink" title="Any other return  value"></a>Any other return  value</h4><p> 如果返回值与以上任何一个不匹配，默认情况下它被视为视图名称，如果它是String或void（通过RequestToViewNameTranslator应用的默认视图名称选择）; 或者作为要添加到模型的模型属性，除非它是一个简单的类型，由BeanUtils＃isSimpleProperty确定，在这种情况下，它仍然未解决。</p><hr><h3 id="返回ModelAndView-Model"><a href="#返回ModelAndView-Model" class="headerlink" title="返回ModelAndView/Model"></a>返回ModelAndView/Model</h3><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。</p><p>Model与ModelAndView的传递效果是一样的，且传递是数据不能是引用类型。<br>重定向时，会把数据拼接到Url后面</p><p>@返回void </p><p>啥也不做 - -</p><hr><p>返回字符串</p><p>这玩意需要用到@ResponseBody注解</p><pre><code>@RestControllerpublic class TestController {  @RequestMapping(&quot;/test.action&quot;)  public String  test( int ids){      System.out.println(&quot;id:&quot;+ids);      return &quot;this is test&quot;;  }}</code></pre><p>逻辑视图名</p><p>这玩意需要你配置视图解析器</p><pre><code>INF/jsp/item/editItem.jspreturn &quot;item/editItem&quot;;</code></pre><p>Redirect重定向</p><p>Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中.</p><pre><code>//重定向到queryItem.action地址,request无法带过去return &quot;redirect:queryItem.action&quot;;</code></pre><p>redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。</p><p>由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：</p><p>/item/queryItem?…&amp;…..</p><p>对于model设置的值，重定向会拼接到？key=value…. 版本4.3以后好像改了，记不太清了，你们可以自己去玩一下</p><hr><p>forward转发</p><p>跟Redirect一样的用法，不同的是 转发可以传递参数</p><pre><code>//结果转发到editItem.action，request可以带过去return &quot;forward:editItem.action&quot;;forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。带域的返回</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC架构与流程</title>
      <link href="/2018/10/24/springmvc-jia-gou-yu-liu-cheng/"/>
      <url>/2018/10/24/springmvc-jia-gou-yu-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC的架构与流程</strong></p><p>探究MVC在SpringMVC中的关系。<br><a id="more"></a><br><strong>前言：</strong></p><p>顾名思义SpringMVC是一个基于MVC设计思想的框架。</p><p>什么是mvc？MVC是模型(model)－视图(view)－控制器(controller)的缩写 ，是一种软件设计思想，主要的作用就是解决应用开发的耦合性，将应用的输入、控制、输出进行强制解耦。</p><p>mvc中的模型、视图、控制器分别担负着不同的角色：</p><p>模型：页数的数据和业务的处理。我们平常用的service和dao层就属于这一层面</p><p>视图：只用于用户的显示，不进行任何的业务处理。主要用来获取和显示数据</p><p>控制器：控制视图层与用户的交互，将对应的操作调用对应的模型。简单的说，就是管理交互的</p><p>理解了mvc，我们就来说一说mvc的执行过程：用户通过view层向服务器发出请求，controller接收请求后，调用对应的model后获取数据，控制器在将数据返回给view。</p><p><strong>好了，我们可以进入正题了，既然SpringMVC是基于MVC的软件设计思想的框架，我们就先看一下SpringMVC的M、V、C分别是什么</strong></p><p><img src="/images/20181024152707.png"></p><p>上图里的东西我们不用细看，只需要大概晓得对应的mvc是啥的就行</p><p>M:这里的模型指定是具体执行的Handler(Controller)。</p><p>V:就是试图View</p><p>C:指的的前端控制器</p><p><strong>了解的springMVC的架构思想（mvc），我就开始继续深入的学习springmvc的执行流程吧。</strong></p><p>下面的顺序并不代表图中的顺序：</p><p>用户将请求发送给前端控制器（DispatcherServlet）也就是SpringMVC的控制器</p><p>然后 前端控制器 请求调用HandlerMapper（处理器映射器）</p><p>处理器映射器 根据请求的url返回 Handler和处理器拦截器（如果有）给前端控制器（DispatcherServlet）</p><p>前端控制器（DispatcherServlet）找到合适的 处理器适配器(HanderAdatper)，由处理器适配器调用Handler</p><p>Handler（以后统称为Controller）执行操作，Handler通常就是我们定义的controller(这里的controller是springmvc的model层),执行完后返回ModelAndView</p><p>处理器映射器(HanderAdatper)将ModelAndView返回给 前端控制器</p><p>然后 前端控制器将ModelAndView 传递给 视图解析器（ViewReslover )</p><p>视图解析器解析（ViewReslover )后 返回具体view，给前端控制器（DispatcherServlet）</p><p>前端控制器（DispatcherServlet）对视图进行渲染（将数据填充到视图中）</p><p>前端控制器（DispatcherServlet）将视图返回给用户。</p><hr><p>了解了流程，我们在详细了解一下里面讲到的部件：</p><p>前端控制器（DispatcherServlet）：这玩意是 SpringMVC的入口（实际上呢就是一个Servlet对象），所有的请求都要通过它，因为是个Servlet所以不可避免的你要在web.xml进行配置(Servlet3.0以后，可以不使用web.xml配置文件了)。</p><p>处理器映射器(HandlerMapper)，这个玩意就是根据不同的方式找到处理器（Handler），它支持的有配置文件形式，接口形式，注解形式等等</p><p>处理器适配器（HandlAdapter ）这玩意就是 分析处理器是那种方式的处理器（配置文件，接口、注解等形式）然后执行Handler</p><p>ModelAndView 封装了数据和视图信息，如果想进行页面的数据交互，可以选择这玩意进行传输，数据的存放位置，默认的是Request域</p><p>视图解析器（ViewResolver ），负责将处理结果生成View视图。</p><p>视图（View ） SpringMVC提供了很多视图，比如jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp</p><hr><p><strong>在spring-mvc.xml文件中配置：</strong></p><pre><code>&lt;!-- 配置处理器映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;&lt;!-- 配置处理器适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; 为什么这么配置spring就能用呢？因为spring对bean的加载有一个顺序，同名称的spring只会认第一次加载的bean，也就是配置文件最先配置的bean</code></pre><p><strong>当然了还有更简洁的配置，添加这个配置即可 mvc:annotation-driven</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.lifeibai&quot;/&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_16</title>
      <link href="/2018/10/23/spring-annotation-day-16/"/>
      <url>/2018/10/23/spring-annotation-day-16/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring容器的创建过程</strong></p><p>今天，我们来统一学习一下，Spring容器的整个创建过程。</p><a id="more"></a><hr><p><strong>Spring容器的refresh()[创建刷新]</strong></p><h3 id="prepareRefresh-【刷新前的预处理】"><a href="#prepareRefresh-【刷新前的预处理】" class="headerlink" title="prepareRefresh();【刷新前的预处理】"></a>prepareRefresh();【刷新前的预处理】</h3><p>1）initPropertySources();初始化一些属性设置；子类自定义个性化的属性设置方法；</p><pre><code>   protected void initPropertySources() {         // For subclasses: do nothing by default.     }</code></pre><p>2)  getEnvironment().validateRequiredProperties();检验属性的合法性等</p><p>3）earlyApplicationEvents = new LinkedHashSet<applicationevent>();保存容器的一些早期的事件；</applicationevent></p><h3 id="obtainFreshBeanFactory；【获取BeanFactory】"><a href="#obtainFreshBeanFactory；【获取BeanFactory】" class="headerlink" title="obtainFreshBeanFactory；【获取BeanFactory】"></a>obtainFreshBeanFactory；【获取BeanFactory】</h3><p>1）refreshBeanFactory();刷新BeanFactory<br>创建 this.beanFactory = new DefaultListableBeanFactory();<br>设置id。</p><p>2）getBeanFactory();<br>返回GenericApplicationContext创建的beanFactory对象;return this.beanFactory;</p><p>3)将创建好的BeanFactory【GenericApplicationContext】对象返回；</p><h3 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory);"></a>prepareBeanFactory(beanFactory);</h3><p>BeanFactory的预准备工作（BeanFactory进行一些设置）</p><p>1）设置BeanFactory的类加载、支持表达式解析器····</p><p>2）添加部分BeanPostProcessor【ApplicationContextAwareProcessor】</p><p>3）设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware等</p><p>4）注册可以解析的自动装配：我们能直接在任何组件中自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext。</p><p>5）添加BeanPostProcessor【ApplicationListenerDetector】</p><p>6）添加编译时Aspectj</p><pre><code>   // Detect a LoadTimeWeaver and prepare for weaving, if found.        if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));            // Set a temporary ClassLoader for type matching.            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));        }</code></pre><p>7) 给BeanFactory中注册一些能用的组件</p><p>environment【ConfigurableEnvironment】</p><p>systemProperties【Map&lt;String, Object&gt;】</p><p>systemEnvironment【Map&lt;String, Object&gt;】</p><h3 id="postProcessBeanFactory-beanFactory"><a href="#postProcessBeanFactory-beanFactory" class="headerlink" title="postProcessBeanFactory(beanFactory);"></a>postProcessBeanFactory(beanFactory);</h3><p>BeanFactory准备工作完成后进行的后置处理工作</p><pre><code>protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {    }</code></pre><p>子类通过覆写这个方法来在BeanFactory创建并准备完成以后做进一步的设置。</p><div style="text-align: center;"><font color="#00ffff" size="4">以上是BeanFactory的创建以及准备工作</font></div><hr><h3 id="invokeBeanFactoryPostProcessors-beanFactory"><a href="#invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="invokeBeanFactoryPostProcessors(beanFactory);"></a>invokeBeanFactoryPostProcessors(beanFactory);</h3><p>执行BeanFactoryPostProcessor</p><p>BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准化初始化之后执行。</p><p>两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor。</p><p>一、执行BeanFactoryPostProcessor的方法：</p><p><strong>先执行BeanDefinitionRegistryPostProcessor</strong></p><p>1）获取所有的BeanDefinitionRegistryPostProcessor  </p><p>2）先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p>3）再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p>4）最后执行没有实现任何优先级或者顺序接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p><strong>后执行BeanFactoryPostProcessor的方法</strong></p><p>1）获取所有的BeanFactoryPostProcessor</p><p>2）先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><p>3）再执行实现了Ordered顺序接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><p>4）最后执行没有实现任何优先级或者顺序接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><h3 id="registerBeanPostProcessors（BeanFactory）"><a href="#registerBeanPostProcessors（BeanFactory）" class="headerlink" title="registerBeanPostProcessors（BeanFactory）"></a>registerBeanPostProcessors（BeanFactory）</h3><p>注册BeanPostProcessor（Bean的后置处理器）【Intercept bean creation.】</p><p>不同类型的BeanPostProcessor：在Bean的创建前后的执行顺序是不同的</p><p>DestructionAwareBeanPostProcessor</p><p>InstantiationAwareBeanPostProcessor</p><p>MergedBeanDefinitionPostProcessor【internalPostProcessor】</p><p>SmartInstantiationAwareBeanPostProcessor</p><p>1）获取所有的BeanPostProcessor；后置处理器默认都可以通过PriorityOrdered、Ordered接口来执行优先级</p><p>2）先注册PriorityOrdered优先级接口的BeanPostProcessor；把每一个BeanPostProcessor添加到BeanFactory中</p><p>3）再注册Ordered</p><p>4）注册其他的没有实现任何接口的BeanPostProcessor</p><p>5）最终注册MergedBeanDefinitionPostProcessor</p><p>6）注册一个ApplicationListenerDetector；来在Bean创建后检查是否是ApplicationListener，如果是，就添加到容器中：applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</p><h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource();"></a>initMessageSource();</h3><p>初始化MessageSource组件，做国家化功能；消息绑定；消息解析。</p><p>1）获取BeanFactory</p><p>2）看容器中是否有id=messageSource，类型是MessageSource的组件。如果有就赋值给messageSource，如果没有就自己创建一个DelegatingMessageSource组件。</p><p>MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取。</p><p>3）把创建好的messageSource注册到容器中，以后获取国际化配置文件时，可以自动注入MessageSource</p><h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster();"></a>initApplicationEventMulticaster();</h3><p>初始化事件派发器</p><p>1）获取BeanFactory</p><p>2）从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster</p><p>3）如果上一步没有配置，就创建一个SimpleApplicationEventMulticaster</p><p>4）将创建好的ApplicationEventMulticaster添加到容器中，以后其他组件直接自动注入</p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh();"></a>onRefresh();</h3><p>留给子类，重写onRefresh()方法.在容器刷新的时候自定义逻辑。</p><h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners();"></a>registerListeners();</h3><p>给容器中将所有项目里面的ApplicationListener注册进来</p><p>1）从容器中拿到所有的ApplicationListener组件</p><p>2）将每个监听器添加到事件派发器中：getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</p><p>3）派发之前步骤中产生的事件：</p><pre><code>  Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;        this.earlyApplicationEvents = null;        if (earlyEventsToProcess != null) {            for (ApplicationEvent earlyEvent : earlyEventsToProcess) {                getApplicationEventMulticaster().multicastEvent(earlyEvent);            }        }</code></pre><h3 id="finishBeanFactoryInitialization-beanFactory"><a href="#finishBeanFactoryInitialization-beanFactory" class="headerlink" title="finishBeanFactoryInitialization(beanFactory);"></a>finishBeanFactoryInitialization(beanFactory);</h3><p>初始化所有的剩下的单实例Bean对象</p><p>1）beanFactory.preInstantiateSingletons();初始化剩下的单实例Bean</p><p>1.1 获取容器中的所有Bean，依次初始化和创建对象</p><p>1.2 获取Bean的定义信息：RootBeanDefinition</p><p>1.3 Bean不是抽象的、是单实例、是懒加载<br>1.3.1 判断是不是FactoryBean；是否是实现FactoryBean接口的Bean<br>1.3.2 不是工厂Bean，就利用getBean()获取Bean对象。 </p><hr><p>1.3.2.1）getBean(beanName);ioc.getBean();</p><p>1.3.2.2) doGetBean(name,null,null,false);</p><p>1.3.2.3) 先获取缓存中保存的单实例bean。如果能获取说明这个Bean之前创建过（所有创建过的单实例Bean都会被保存起来）</p><p>1.3.2.4）缓存中获取不到，开始Bean的创建对象流程</p><p>1.3.2.5）标记当前Bean已经被创建，防止多线程下创建多个单实例Bean</p><p>1.3.2.6）获取Bean的定义信息</p><p>1.3.2.7）获取当前Bean依赖的其他Bean；如果有按照getBean()把依赖的Bean先创建出来；</p><p>1.3.2.8）启动单实例Bean的创建过程：</p><hr><p>1.3.2.8.1) createBean(beanName,mbd,args)</p><p>1.3.2.8.2) resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor在Bean的创建之前执行，是InstantiationAwareBeanPostProcessor类型的后置处理器。看是否是需要创建代理对象。</p><p>先触发applyBeanPostProcessorsBeforeInstantiation：postProcessBeforeInstantiation()</p><p>如果有返回值：applyBeanPostProcessorsAfterInitialization：postProcessAfterInitialization()</p><p>1.3.2.8.3)如果前面InstantiationAwareBeanPostProcessor没有返回值，说明不需要创建代理对象。</p><p>1.3.2.8.4)Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean</p><hr><p>1.3.2.8.4.1) instanceWrapper = createBeanInstance(beanName, mbd, args);创建Bean对象；利用工厂方法或者构造器创建出Bean对象</p><p>1.3.2.8.4.2) applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</p><p>1.3.2.8.4.3) 【属性赋值】populateBean(beanName, mbd, instanceWrapper);</p><hr><p>赋值之前：<br>1.3.2.8.4.3.1) InstantiationAwareBeanPostProcessor后置处理器；<br>postProcessAfterInstrantiation();</p><p>1.3.2.8.4.3.2) InstantiationAwareBeanPostProcessor后置处理器；<br>postProcessPropertyValues();</p><p>赋值之后：<br>1.3.2.8.4.3.3) 应用Bean属性的值：为属性利用setter方法等进行赋值<br>applyPropertyValues(beanName, mbd, bw, pvs);</p><p>1.3.2.8.4.4) 【Bean初始化】initializeBean(beanName, exposedObject, mbd)；</p><hr><p>1.3.2.8.4.4.1) 【执行Aware接口方法】invokeAwareMethods(beanName, bean);</p><pre><code>     if (bean instanceof Aware) {            if (bean instanceof BeanNameAware) {                ((BeanNameAware) bean).setBeanName(beanName);            }            if (bean instanceof BeanClassLoaderAware) {                ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());            }            if (bean instanceof BeanFactoryAware) {                ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);            }        }</code></pre><p>1.3.2.8.4.4.2) 【执行后置处理器初始化之前】 </p><p>applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>beanProcessor.postProcessBeforeInitialization(result, beanName);</p><p>1.3.2.8.4.4.3)【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);</p><hr><p>1.3.2.8.4.4.3.1) 是否是InitializingBean接口的实现；执行接口规定的初始化</p><p>1.3.2.8.4.4.3.2) 是否自定义初始化方法：invokeCustomInitMethod(beanName, bean, mbd);</p><hr><p>1.3.2.8.4.4.4)【执行后置处理器初始化之后】  </p><p>applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>beanProcessor.postProcessAfterInitialization(result, beanName);</p><p>1.3.2.8.4.5)【注册Bean的销毁方法】：DisposableBeanAdapter</p><p>1.3.2.8.5）将创建的Bean添加到缓存中singletonObjects；<br>ioc容器就是这些Map：很多的Map里面保存了单实例Bean，环境信息····</p><p>所有的Bean都利用getBean()创建完后：<br> 检查所有的Bean是否是SmartInitializingSingleton接口类型；如果是，就执行afterSingletonsInstantion()方法</p><h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh();"></a>finishRefresh();</h3><p>完成BeanFactory的初始化创建工作；IoC容器就创建完了。</p><p>1）initLifecycleProcessor();初始化和生命周期有关的后置处理器：LifecycleProcessor</p><p>默认从容器中找是否是lifecycleProcessor的组件；如果没有，创建一个默认的 new DefaultLifecycleProcessor()；并加入到容器中。</p><p>2）getLifecycleProcessor().onRefresh();</p><p>拿到前面定义的生命周期处理器，并回调onRefresh()方法。</p><p>3）publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件。</p><p>4）LiveBeansView.registerApplicationContext(this);</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）<strong>Spring容器在启动的时候，先会保存所有注册进来的Bean定义信息。</strong></p><p>1.1 xml注册的bean；<bean></bean></p><p>1.2 注解注册Bean:@Bean、@Service、@Component、XXX</p><p>2）<strong>Spring容器会在合适的时候创建这些Bean</strong></p><p>2.1 用到这个bean的时候，利用getBean创建bean；创建好以后保存在容器中；</p><p>2.2 统一创建剩下的所有单实例bean；finishBeanFactoryInitialization(beanFactory);</p><p>3）<strong>后置处理器</strong></p><p>每个bean创建完后，都会使用各种后置处理器进行处理；来增强bean的功能；  </p><p>AutowiredAnnotationBeanPostProcessor：处理自动注入</p><p>AnnotationAwareAspectJAutoProxyCreator：来做AOP功能</p><p>XXX····</p><p>增强的功能注解：</p><p>AsyncAnnotationBeanPostProcessor</p><p>4）<strong>事件驱动模型：</strong></p><p>ApplicationListener：事件监听器</p><p>ApplicationEventMulticaster：事件派发</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_15</title>
      <link href="/2018/10/22/spring-annotation-day-15/"/>
      <url>/2018/10/22/spring-annotation-day-15/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天，来讲解其他的扩展原理，帮助大家学习其他的小知识点<br><a id="more"></a></p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>BeanPostProcessor：bean的后置处理器，bean创建对象初始化前后进行拦截工作的。  </p><p>BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容，所有的Bean的定义已经保存加载到BeanFactory，<strong>但是bean的实例还没有创建</strong>。</p><h4 id="创建ExConfig配置类："><a href="#创建ExConfig配置类：" class="headerlink" title="创建ExConfig配置类："></a>创建ExConfig配置类：</h4><pre><code>@Configuration@ComponentScan(&quot;com.liuzhuo.ext&quot;)public class ExtConfig {    @Bean    public Blue blue() {        return new Blue();    }}</code></pre><h4 id="创建自定义的BeanFactoryPostProcessor："><a href="#创建自定义的BeanFactoryPostProcessor：" class="headerlink" title="创建自定义的BeanFactoryPostProcessor："></a>创建自定义的BeanFactoryPostProcessor：</h4><pre><code>@Componentpublic class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {    /**     * @param beanFactory     * @throws BeansException     * 在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容，     * 此时，所有的bean的定义信息已经保存到BeanFactory，但是Bean还没有创建     */    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {        System.out.println(&quot;postProcessBeanFactory·······&quot;);        int count = beanFactory.getBeanDefinitionCount();        String[] names = beanFactory.getBeanDefinitionNames();        for (String name : names) {            System.out.println(name);        }    }}</code></pre><h4 id="创建新的测试类："><a href="#创建新的测试类：" class="headerlink" title="创建新的测试类："></a>创建新的测试类：</h4><pre><code>public class IoCTest_EXT {    @Test    public void test01() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ExtConfig.class);        applicationContext.close();    }}</code></pre><h4 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h4><pre><code>postProcessBeanFactory·······org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryextConfigmyBeanFactoryPostProcessorblue</code></pre><p><strong>能看到，我们获取了所有的BeanFactory中定义的bean了，但是还没有创建bean的实例对象</strong>。</p><h4 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h4><p>给MyBeanFactoryPostProcessor中的postProcessBeanFactory方法加上断点，并运行。</p><p>过程：<br>1）加载容器。<br>2）refresh();刷新容器<br>3）invokeBeanFactoryPostProcessors(beanFactory);</p><pre><code>@Override    public void refresh() throws BeansException, IllegalStateException {    try {        // Allows post-processing of the bean factory in context subclasses.        postProcessBeanFactory(beanFactory);        // Invoke factory processors registered as beans in the context.        invokeBeanFactoryPostProcessors(beanFactory);        // Register bean processors that intercept bean creation.        registerBeanPostProcessors(beanFactory);        // Initialize message source for this context.        initMessageSource();        // Initialize event multicaster for this context.        initApplicationEventMulticaster();        // Initialize other special beans in specific context subclasses.        onRefresh();        // Check for listener beans and register them.        registerListeners();        // Instantiate all remaining (non-lazy-init) singletons.        finishBeanFactoryInitialization(beanFactory);        // Last step: publish corresponding event.        finishRefresh();    }}</code></pre><p>能发现，invokeBeanFactoryPostProcessors(beanFactory);是在finishBeanFactoryInitialization(beanFactory);方法之前的，就说明了BeanFactoryPostProcessor是在bean的实例化之前的，是在BeanFactory实例化之后的。</p><hr><h3 id="BeanDefinitionRegisterPostProcessor"><a href="#BeanDefinitionRegisterPostProcessor" class="headerlink" title="BeanDefinitionRegisterPostProcessor"></a>BeanDefinitionRegisterPostProcessor</h3><p>BeanDefinitionRegisterPostProcessor extends BeanFactoryPostProcessor</p><p>在所有bean定义信息将要被加载，bean实例还未创建。</p><p>优先于BeanFactoryPostProcessor执行<br>利用BeanDefinitionRegisterPostProcessor给容器中再额外添加一些组件。</p><p>原理：<br>1）ioc创建对象<br>2）refresh() -&gt; invokeBeanFactoryPostProcessors(beanFactory);<br>3) 从容器中获取所有的BeanDefinitionRegisterPostProcessor组件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)依次触发所有的postProcessorBeanDefinitionRegistry()方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)再次触发postProcessorBeanFactory()方法的BeanFactoryPostProcessor；<br>4）再来从容器中找到BeanFactoryPostProcessor组件；然后依次触发postProcessorBeanFactory()方法</p><h4 id="创建MyBeanDefinitionRegisterPostProcessor类："><a href="#创建MyBeanDefinitionRegisterPostProcessor类：" class="headerlink" title="创建MyBeanDefinitionRegisterPostProcessor类："></a>创建MyBeanDefinitionRegisterPostProcessor类：</h4><pre><code>@Componentpublic class MyBeanDefinitionRegisterPostProcessor implements BeanDefinitionRegistryPostProcessor {    //先执行    @Override    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {        System.out.println(&quot;postProcessBeanDefinitionRegistry······&quot;);        int count = registry.getBeanDefinitionCount();        System.out.println(&quot;容器中注册的bean的个数(1)：&quot; + count);        //还能注册新的bean组件        RootBeanDefinition beanDefinition = new RootBeanDefinition(Blue.class);        registry.registerBeanDefinition(&quot;hello&quot;, beanDefinition);    }    //后执行    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {        System.out.println(&quot;postProcessBeanFactory··········&quot;);        int count = beanFactory.getBeanDefinitionCount();        System.out.println(&quot;容器中注册的bean的个数(2)：&quot; + count);    }}</code></pre><h4 id="运行测试类"><a href="#运行测试类" class="headerlink" title="运行测试类:"></a>运行测试类:</h4><pre><code>十月 22, 2018 11:32:15 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 11:32:15 CST 2018]; root of context hierarchypostProcessBeanDefinitionRegistry······容器中注册的bean的个数(1)：10postProcessBeanFactory··········容器中注册的bean的个数(2)：11十月 22, 2018 11:32:15 上午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;信息: JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiringpostProcessBeanFactory·······org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryextConfigmyBeanDefinitionRegisterPostProcessormyBeanFactoryPostProcessorbluehello十月 22, 2018 11:32:15 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 11:32:15 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>能发现<br>1）首先执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法<br>2）再执行BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法<br>3）最后执行BeanFactoryPostProcessor的postProcessBeanFactory()方法</p><h4 id="调试-原理"><a href="#调试-原理" class="headerlink" title="调试(原理)"></a>调试(原理)</h4><p>给MyBeanDefinitionRegisterPostProcessor的postProcessBeanDefinitionRegistry()方法打上断点，并debug。</p><p>1）加载容器<br>2）refresh();刷新容器<br>3）invokeBeanFactoryPostProcessors(beanFactory);和BeanFactoryPostProcessor的流程一样<br>4）invokeBeanFactoryPostProcessors()</p><p>在invokeBeanFactoryPostProcessors()方法中，可以看到<br>1）首先获取所有的BeanDefinitionRegistryPostProcessor的定义信息</p><pre><code>String[] postProcessorNames =    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);        for (String ppName : postProcessorNames) {        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));        processedBeans.add(ppName);        }    }</code></pre><p>2）然后调用invokeBeanDefinitionRegistryPostProcessors()方法：</p><pre><code>    private static void invokeBeanDefinitionRegistryPostProcessors(            Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) {        for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {            postProcessor.postProcessBeanDefinitionRegistry(registry);        }    }</code></pre><p>3) 再调用invokeBeanFactoryPostProcessors：</p><pre><code>    private static void invokeBeanFactoryPostProcessors(            Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) {        for (BeanFactoryPostProcessor postProcessor : postProcessors) {            postProcessor.postProcessBeanFactory(beanFactory);        }    }</code></pre><p>4) 获取所有的BeanFactoryPostProcessor的定义信息</p><pre><code>String[] postProcessorNames =        beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</code></pre><p>5）调用invokeBeanFactoryPostProcessors：</p><pre><code>    private static void invokeBeanFactoryPostProcessors(            Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) {        for (BeanFactoryPostProcessor postProcessor : postProcessors) {            postProcessor.postProcessBeanFactory(beanFactory);        }    }</code></pre><hr><h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener:"></a>ApplicationListener:</h3><p>监听容器中发布的事件。事件驱动模型开发。</p><p>步骤：</p><p>1）写一个监听器(ApplicationListener实现类)来监听某个事件(ApplicationEvent及其子类)</p><p>2) 把监听器加入到容器中</p><p>3）只要容器中有相关事件的发布，我们就能监听到这个事件</p><p>4）发布一个事件: applicationContext.publishEvent();</p><h4 id="编写一个MyApplicationListener"><a href="#编写一个MyApplicationListener" class="headerlink" title="编写一个MyApplicationListener"></a>编写一个MyApplicationListener</h4><pre><code>@Componentpublic class MyApplicationListener implements ApplicationListener&lt;ApplicationEvent&gt; {    @Override    public void onApplicationEvent(ApplicationEvent event) {        System.out.println(&quot;监听:&quot; + event);    }}</code></pre><h4 id="运行测试类："><a href="#运行测试类：" class="headerlink" title="运行测试类："></a>运行测试类：</h4><pre><code>十月 22, 2018 8:42:11 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;信息: JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiring监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy]十月 22, 2018 8:42:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy]</code></pre><p>说明容器，为我们发布了两个事件：ContextRefreshedEvent 和 ContextClosedEvent</p><h4 id="发布自己的事件"><a href="#发布自己的事件" class="headerlink" title="发布自己的事件"></a>发布自己的事件</h4><pre><code>    @Test    public void test01() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ExtConfig.class);        applicationContext.publishEvent(new ApplicationEvent(new String(&quot;自定义事件&quot;)) {        });        applicationContext.close();    }}</code></pre><p>运行：</p><pre><code>监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:47:38 CST 2018]; root of context hierarchy]监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:47:38 CST 2018]; root of context hierarchy]</code></pre><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>1）初始化容器；refresh();</p><p>2）finishRefresh();  // Last step: publish corresponding event.</p><p>3）publishEvent(new ContextRefreshedEvent(this));发布事件</p><p>4）getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);获取派发器</p><p>5）获取所有的ApplicationListener：for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type))</p><p>6）如果有Executor，可以支持使用Executor进行异步派发，否则，使用同步方式直接执行invokeListener(listener, event);</p><p>7）doInvokeListener(listener, event);回调listener.onApplicationEvent(event);</p><p>我们这里的三个事件：  </p><p>1）finishRefresh();容器刷新完成后，执行ContextRefreshedEvent事件。</p><p>2）自己发布的事件</p><p>3）容器关闭会发布ContextClosedEvent事件</p><hr><p>事件派发器(EventMulticaster)：</p><p>1）容器创建对象；refresh();</p><p>2）initApplicationEventMulticaster();初始化事件派发器</p><p>3）先去查看容器中是否有id=“applicationEventMulticaster”组件，如果有直接使用，没有的话，new SimpleApplicationEventMulticaster()组件。并且加入到容器中。我们就可以在其他组件要派发事件时，自动注入这个applicationEventMulticaster组件。</p><hr><p>容器中有哪些监听器：</p><p>1）容器创建对象；refresh();</p><p>2）registerListeners(); //注册监听器<br>从容器中拿到所有的监听器，把它们注册到applicationEventMulticaster中。<br>String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);<br>getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</p><h3 id="EventListener"><a href="#EventListener" class="headerlink" title="@EventListener"></a>@EventListener</h3><p>@EventListener注解，可以使普通类的普通方法来监听事件，不用去实现ApplicationEvent接口。</p><p>1）在com.liuzhuo.ext包下，创建UserService类：</p><pre><code>@Servicepublic class UserService {    @EventListener(value = {ApplicationEvent.class})    public void listen(ApplicationEvent event) {        System.out.println(&quot;UserService监听:&quot; + event);    }}</code></pre><p>2) 运行IoCTest_EXT测试类：</p><pre><code>UserService监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]UserService监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]UserService监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]</code></pre><p>3) 原理：</p><p>@EventListener使用EventListenerMethodProcessor处理器来完成的</p><pre><code>* @author Stephane Nicoll * @since 4.2 * @see EventListenerMethodProcessor */@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface EventListener</code></pre><p>点击EventListenerMethodProcessor处理器：</p><pre><code>public class EventListenerMethodProcessor implements SmartInitializingSingleton, ApplicationContextAware</code></pre><p>实现了SmartInitializingSingleton接口，所有重点是SmartInitializingSingleton接口。</p><p>点击SmartInitializingSingleton接口：</p><pre><code>public interface SmartInitializingSingleton {    /**     * Invoked right at the end of the singleton pre-instantiation phase,     * with a guarantee that all regular singleton beans have been created     * already. {@link ListableBeanFactory#getBeansOfType} calls within     * this method won&#39;t trigger accidental side effects during bootstrap.     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This callback won&#39;t be triggered for singleton beans     * lazily initialized on demand after {@link BeanFactory} bootstrap,     * and not for any other bean scope either. Carefully use it for beans     * with the intended bootstrap semantics only.     */    void afterSingletonsInstantiated();}</code></pre><p>其中有一个方法：afterSingletonsInstantiated(); 该方法是在所有的单实例初始化完成后才调用的。</p><p>调试：<br>给UserService类打上断点，并debug。</p><p>1）ioc容器创建对象；refresh();刷新容器</p><p>2）finishBeanFactoryInitialization(beanFactory)；初始化剩下的单实例bean</p><p>3）先创建所有的单实例bean；getBean();</p><p>4) 获取所有创建好的单实例bean，判断是否是SmartInitializingSingleton类型的，如果是就调用afterSingletonsInstantiated()方法</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_14</title>
      <link href="/2018/10/20/spring-annotation-day-14/"/>
      <url>/2018/10/20/spring-annotation-day-14/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天来学习Spring的声明式事务。</p><a id="more"></a><h3 id="不使用事务"><a href="#不使用事务" class="headerlink" title="不使用事务"></a>不使用事务</h3><p>环境搭建</p><p>1）导入相关依赖</p><p>数据源、数据驱动、Spring-jdbc模块.<br>数据源、数据驱动之前已经导入过，现在只需要Spring-jdbc模块.</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>2）创建com.liuzhuo.tx包，并创建TxConfig类：</p><pre><code>@Configuration@ComponentScan(&quot;com.liuzhuo.tx&quot;)public class TxConfig {    //c3p0的数据源    @Bean    public DataSource dataSource() throws Exception {        ComboPooledDataSource dataSource = new ComboPooledDataSource();        dataSource.setUser(&quot;root&quot;);        dataSource.setPassword(&quot;123456&quot;);        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&quot;);        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);        return dataSource;    }    //注入jdbcTemplate模板    @Bean    public JdbcTemplate jdbcTemplate() throws Exception {        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource());        return jdbcTemplate;    }}</code></pre><p><strong>注意，这里的数据链接url，必须加上?serverTimezone=GMT%2B8，这是在使用MySQL 8.0以上版本时候必须加上的，否则会出现时区问题！！！！</strong></p><p>3）在com.liuzhuo.tx包下，创建UserService和UserDao类：</p><pre><code>@Servicepublic class UserService {    @Autowired    private UserDao userDao;    public void insertUser(){        userDao.insert();        System.out.println(&quot;插入成功!!!!&quot;);    }}</code></pre><pre><code>@Repositorypublic class UserDao {    @Autowired    private JdbcTemplate jdbcTemplate;    public void insert() {        String sql = &quot;insert into tbl_user(username,age) VALUES(?,?);&quot;;        String username = UUID.randomUUID().toString().substring(0, 4);        int age = 16;        jdbcTemplate.update(sql, username, age);    }}</code></pre><p>4) 创建新的测试类IoCTest_TX：</p><pre><code>public class IoCTest_TX {    @Test    public void test01() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(TxConfig.class);        UserService userService = applicationContext.getBean(UserService.class);        userService.insertUser();        applicationContext.close();    }}</code></pre><p>5) 运行测试方法：</p><pre><code>十月 20, 2018 10:42:43 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Sat Oct 20 10:42:43 CST 2018]; root of context hierarchy十月 20, 2018 10:42:43 上午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;信息: JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiring十月 20, 2018 10:42:43 上午 com.mchange.v2.log.MLog 信息: MLog clients using java 1.4+ standard logging.十月 20, 2018 10:42:44 上午 com.mchange.v2.c3p0.C3P0Registry 信息: Initializing c3p0-0.9.5.2 [built 08-December-2015 22:06:04 -0800; debug? true; trace: 10]十月 20, 2018 10:42:44 上午 com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource 信息: Initializing c3p0 pool... com.mchange.v2.c3p0.ComboPooledDataSource [ acquireIncrement -&gt; 3, acquireRetryAttempts -&gt; 30, acquireRetryDelay -&gt; 1000, autoCommitOnClose -&gt; false, automaticTestTable -&gt; null, breakAfterAcquireFailure -&gt; false, checkoutTimeout -&gt; 0, connectionCustomizerClassName -&gt; null, connectionTesterClassName -&gt; com.mchange.v2.c3p0.impl.DefaultConnectionTester, contextClassLoaderSource -&gt; caller, dataSourceName -&gt; 2s4fkk9y13rx1eqqia0s|69b2283a, debugUnreturnedConnectionStackTraces -&gt; false, description -&gt; null, driverClass -&gt; com.mysql.jdbc.Driver, extensions -&gt; {}, factoryClassLocation -&gt; null, forceIgnoreUnresolvedTransactions -&gt; false, forceSynchronousCheckins -&gt; false, forceUseNamedDriverClass -&gt; false, identityToken -&gt; 2s4fkk9y13rx1eqqia0s|69b2283a, idleConnectionTestPeriod -&gt; 0, initialPoolSize -&gt; 3, jdbcUrl -&gt; jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8, maxAdministrativeTaskTime -&gt; 0, maxConnectionAge -&gt; 0, maxIdleTime -&gt; 0, maxIdleTimeExcessConnections -&gt; 0, maxPoolSize -&gt; 15, maxStatements -&gt; 0, maxStatementsPerConnection -&gt; 0, minPoolSize -&gt; 3, numHelperThreads -&gt; 3, preferredTestQuery -&gt; null, privilegeSpawnedThreads -&gt; false, properties -&gt; {user=******, password=******}, propertyCycle -&gt; 0, statementCacheNumDeferredCloseThreads -&gt; 0, testConnectionOnCheckin -&gt; false, testConnectionOnCheckout -&gt; false, unreturnedConnectionTimeout -&gt; 0, userOverrides -&gt; {}, usesTraditionalReflectiveProxies -&gt; false ]Loading class `com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&#39;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.插入成功!!!!十月 20, 2018 10:42:45 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Sat Oct 20 10:42:43 CST 2018]; root of context hierarchy</code></pre><p>看到插入成功，打开数据库也能发现数据库中多了一条新的记录。</p><p>ps：以上操作是建立在本地存在数据库test，和一个表，表的字段有id自增，username用户名，age用户的年龄，这里就不详细描述数据库的创建过程了。</p><hr><p>6）修改UserService类：<br>添加 int res = 1 / 0;</p><pre><code>@Servicepublic class UserService {    @Autowired    private UserDao userDao;    public void insertUser() {        userDao.insert();        System.out.println(&quot;插入成功!!!!&quot;);        int res = 1 / 0;    }}</code></pre><p>7）再次运行测试方法：</p><pre><code>插入成功!!!!java.lang.ArithmeticException: / by zero    at com.liuzhuo.tx.UserService.insertUser(UserService.java:21)    at com.liuzhuo.test.IoCTest_TX.test01(IoCTest_TX.java:23)</code></pre><p><strong>会出现异常。打开数据库，发现还是会添加一条新的记录，这是因为没有添加事务的原因。</strong></p><h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>1）修改UserService类：<br>添加@Transactional注解</p><pre><code>@Servicepublic class UserService {    @Autowired    private UserDao userDao;    @Transactional    public void insertUser() {        userDao.insert();        System.out.println(&quot;插入成功!!!!&quot;);        int res = 1 / 0;    }}</code></pre><p>2) 运行测试方法：</p><pre><code>插入成功!!!!java.lang.ArithmeticException: / by zero</code></pre><p>出现ArithmeticException异常，打开数据库，发现还是会添加一条数据，说明事务还没有添加上去，<strong>因为没有开启注解时事务</strong>。</p><p>3）修改配置类<br>添加@EnableTransactionManagement注解</p><pre><code>@Configuration@ComponentScan(&quot;com.liuzhuo.tx&quot;)@EnableTransactionManagementpublic class TxConfig </code></pre><p>4) 运行测试方法：</p><pre><code>No qualifying bean of type &#39;org.springframework.transaction.PlatformTransactionManager&#39; available</code></pre><p>发现出现没有PlatformTransactionManager这个组件的异常，此时虽然数据库没有添加一条数据，但是是出现了其他异常，而不是出现ArithmeticException异常。</p><p>出现没有PlatformTransactionManager这个组件异常，说明我们还需要配置事务管理器。</p><p>5) 添加事务管理器</p><pre><code>   //添加事务管理器    @Bean    public PlatformTransactionManager transactionManager() throws Exception {        return new DataSourceTransactionManager(dataSource());    }</code></pre><p>6) 运行测试方法：</p><pre><code>插入成功!!!!java.lang.ArithmeticException: / by zero</code></pre><p>出现了ArithmeticException异常，打开数据库，发现也没有添加新的一条记录，说明事务起作用了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用事务的步骤：</p><ol><li>添加相关的依赖(Spring-jdbc)</li><li>配置数据源、事务管理器(PlatformTransactionManager)</li><li>开始注解式事务(@EnableTransactionManagement)</li><li>给相关的方法添加@Transactional注解</li></ol><hr><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><p>点击@EnableTransactionManagement注解：</p><pre><code>@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Import({TransactionManagementConfigurationSelector.class})public @interface EnableTransactionManagement {    boolean proxyTargetClass() default false;    AdviceMode mode() default AdviceMode.PROXY;    int order() default 2147483647;}</code></pre><p>@Import({TransactionManagementConfigurationSelector.class})</p><pre><code>    @Override    protected String[] selectImports(AdviceMode adviceMode) {        switch (adviceMode) {            case PROXY:                return new String[] {AutoProxyRegistrar.class.getName(),                        ProxyTransactionManagementConfiguration.class.getName()};            case ASPECTJ:                return new String[] {determineTransactionAspectClass()};            default:                return null;        }    }</code></pre><p>会导入AutoProxyRegistrar和ProxyTransactionManagementConfiguration两个组件。</p><p>1）AutoProxyRegistrar会给容器注入InfrastructureAdvisorAutoProxyCreator组件（也是一个后置处理器）。</p><p>InfrastructureAdvisorAutoProxyCreator组件利用后置处理器机制在对象创建时，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链执行。</p><p>2）ProxyTransactionManagementConfiguration</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给容器注入事务增强器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务增强器要用事务注解的信息<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务拦截器：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransactionInterceptor：保存了事务属性信息，事务管理器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个MethodInterceptor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在目标方法执行的时候：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行拦截器链：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务拦截器：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先获取事务相关的属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再获取事务管理器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行目标方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果异常，获取事务管理器，回滚<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果正常，利用事务管理器，提交事务</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring4配置文件详解</title>
      <link href="/2018/10/19/spring4-pei-zhi-wen-jian-xiang-jie/"/>
      <url>/2018/10/19/spring4-pei-zhi-wen-jian-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>总结Spring4中的各种配置文件的信息。</p><a id="more"></a><p>欢迎大家补充，完善各种配置信息。</p><p>好的习惯，将会伴随你的一生。</p><p>开始今天的主题！！！</p><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><hr><p>基本的加载properties配置文件</p><pre><code>&lt;context:property-placeholder location=&quot;classpath*:/appConfig.properties&quot; /&gt;</code></pre><h4 id="JNDI方式"><a href="#JNDI方式" class="headerlink" title="JNDI方式"></a>JNDI方式</h4><pre><code>&lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;/jdbc/mysqlDS&quot; resource-ref=&quot;true&quot;/&gt;</code></pre><p>jndi-name：指定JNDI中资源名称</p><p>resource-ref：如果应用程序运行在java应用程序服务器中，值设为true，这样jndi-name会自动加上java:comp/env/前缀</p><h4 id="数据连接池方式"><a href="#数据连接池方式" class="headerlink" title="数据连接池方式"></a>数据连接池方式</h4><h5 id="DBCP连接池："><a href="#DBCP连接池：" class="headerlink" title="DBCP连接池："></a>DBCP连接池：</h5><p>使用：org.apache.commons.dbcp.BasicDataSource进行配置</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;  &lt;!-- 【必须】  数据库驱动--&gt;  &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;  &lt;!-- 【必须】 数据库连接地址 --&gt;  &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;  &lt;!-- 【必须】 数据库用户名 --&gt;  &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;  &lt;!-- 【必须】 数据库密码 --&gt;  &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;  &lt;!-- 可选 启动时创建的连接数 --&gt;  &lt;property name=&quot;initialSize&quot; value=&quot;5&quot;/&gt;  &lt;!-- 可选 同时可从池中分配的最多连接数，0无限制 --&gt;  &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;/&gt;  &lt;!-- 可选 池中不会被释放的最多空闲连接数 0无限制 --&gt;  &lt;property name=&quot;maxIdle&quot; value=&quot;&quot;/&gt;  &lt;!-- 可选 同时能从语句池中分配的预处理语句最大值，0无限制 --&gt;  &lt;property name=&quot;maxOpenPreparedStatement&quot; value=&quot;100&quot;/&gt;  &lt;!-- 可选 抛异常前池等待连接回收最大时间（当无可用连接），-1无限等待 --&gt;  &lt;property name=&quot;maxWait&quot; value=&quot;1000&quot;/&gt;  &lt;!-- 可选 连接在池中保持空闲而不被回收的最大时间 --&gt;  &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;2000&quot;/&gt;  &lt;!-- 可选 不创建新连接情况下池中保持空闲的最小连接数 --&gt;  &lt;property name=&quot;minIdle&quot; value=&quot;2&quot;/&gt;  &lt;!-- 可选 布尔值，是否对预处理语句进行池管理 --&gt;  &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt;</code></pre><h5 id="C3P0连接池："><a href="#C3P0连接池：" class="headerlink" title="C3P0连接池："></a>C3P0连接池：</h5><p>使用：com.mchange.v2.c3p0.ComboPooledDataSource进行配置</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt;  &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;  &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;  &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;  &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;&lt;/bean&gt;</code></pre><h5 id="alibaba-DRUID连接池："><a href="#alibaba-DRUID连接池：" class="headerlink" title="alibaba DRUID连接池："></a>alibaba DRUID连接池：</h5><p>使用：com.alibaba.druid.pool.DruidDataSource进行配置</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;     &lt;!-- 基本属性 url、user、password --&gt;    &lt;property name=&quot;url&quot; value=&quot;${jdbc_url}&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;${jdbc_user}&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc_password}&quot; /&gt;    &lt;!-- 配置初始化大小、最小、最大 --&gt;    &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt;    &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt;     &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt;    &lt;!-- 配置获取连接等待超时的时间 --&gt;    &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt;    &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;    &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt;    &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;    &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt;    &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &#39;x&#39;&quot; /&gt;    &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;    &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt;    &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt;    &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;    &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt;    &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt;    &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt;    &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt;  &lt;/bean&gt;</code></pre><h4 id="JDBC驱动的数据源"><a href="#JDBC驱动的数据源" class="headerlink" title="JDBC驱动的数据源"></a>JDBC驱动的数据源</h4><p>使用：</p><p>org.springframework.jdbc.datasource.SingleConnectionDataSource【每个链接请求会返回同一个连接，不推荐】</p><p>org.springframework.jdbc.datasource.DriverManagerDataSource进行配置</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;  &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;  &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;  &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;  &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;&lt;/bean&gt;</code></pre><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><hr><h4 id="spring-JDBC模板"><a href="#spring-JDBC模板" class="headerlink" title="spring JDBC模板"></a>spring JDBC模板</h4><p>模板类选择：</p><p>JdbcTemplate：提供最简单的数据访问等功能。</p><p>NamedParameterJdbcTemplate：通过该模板，可以把参数作为查询的条件传入方法中。</p><p>SimpleJdbcTemplate（推荐）：结合了一些自动装箱等功能，2.5以后，整合了NamedParameterJdbcTemplate。</p><p>配置方式：</p><pre><code>&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.simple.SimpleJdbcTemplate&quot;&gt;  &lt;constructor-arg ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="与ORM框架集成"><a href="#与ORM框架集成" class="headerlink" title="与ORM框架集成"></a>与ORM框架集成</h4><p>主要是配置spring的Session工厂（sessionFactory），可以使用到诸如延迟加载、预先抓取、级联复杂特性。</p><p>spring对ORM框架的支持提供提供了一些附加服务：</p><p>spring声明式事务集成支持</p><p>透明的异常处理</p><p>线程安全、轻量级的模板类</p><p>DAO支持</p><p>资源管理</p><h5 id="集成Hibernate方式：-hibernate4为例"><a href="#集成Hibernate方式：-hibernate4为例" class="headerlink" title="集成Hibernate方式：[hibernate4为例]"></a>集成Hibernate方式：[hibernate4为例]</h5><p>hibernate的HBM文件配置方式（Xxx.hbm.xml)：</p><pre><code>&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;  &lt;!-- 数据源 --&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  &lt;!-- 映射文件形式--&gt;  &lt;property name=&quot;mappingResources&quot;&gt;     &lt;list&gt;        &lt;value&gt;User.hbm.xml&lt;/value&gt;     &lt;/list&gt;  &lt;/property&gt;  &lt;!-- Hibernate属性配置 --&gt;  &lt;property name=&quot;hibernateProperties&quot;&gt;     &lt;props&gt;         &lt;prop key=&quot;dialect&quot;&gt;            org.hibernate.dialect.MySQLDialect &lt;!-- 数据库方言 --&gt;         &lt;/prop&gt;        &lt;!-- ……其他 --&gt;     &lt;/props&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre><p>代码中使用注解的方式：</p><pre><code>&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;  &lt;!-- 数据源 --&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;!-- 自动扫描实体对象 tdxy.bean的包结构中存放实体类  --&gt;  &lt;property name=&quot;packagesToScan&quot; value=&quot;com.test.entity&quot;/&gt;  &lt;!-- hibernate的相关属性配置 --&gt;  &lt;property name=&quot;hibernateProperties&quot;&gt;     &lt;value&gt;        &lt;!-- 设置数据库方言 --&gt;        hibernate.dialect=org.hibernate.dialect.MySQLDialect        &lt;!-- 设置自动创建|更新|验证数据库表结构 --&gt;        hibernate.hbm2ddl.auto=update                         &lt;!-- 是否在控制台显示sql --&gt;        hibernate.show_sql=true                         &lt;!-- 是否格式化sql，优化显示 --&gt;        hibernate.format_sql=true                        &lt;!-- 是否开启二级缓存 --&gt;        hibernate.cache.use_second_level_cache=false                        &lt;!-- 是否开启查询缓存 --&gt;        hibernate.cache.use_query_cache=false                        &lt;!-- 数据库批量查询最大数 --&gt;        hibernate.jdbc.fetch_size=50        &lt;!-- 数据库批量更新、添加、删除操作最大数  --&gt;        hibernate.jdbc.batch_size=50                        &lt;!-- 是否自动提交事务  --&gt;        hibernate.connection.autocommit=true        &lt;!-- 指定hibernate在何时释放JDBC连接  --&gt;        hibernate.connection.release_mode=auto        &lt;!-- 创建session方式 hibernate4.x 的方式  --&gt;        hibernate.current_session_context_class=org.springframework.orm.hibernate4.SpringSessionContext        &lt;!-- javax.persistence.validation.mode默认情况下是auto的，就是说如果不设置的话它是会自动去你的classpath下面找一个bean-validation**包，所以把它设置为none即可  --&gt;        javax.persistence.validation.mode=none                 &lt;/value&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre><p>针对少量实体类，还可以通过annotatedClasses属性来将应用程序中所有的持久化类以全局定名的方式明确列出：</p><pre><code>&lt;property name=&quot;annotatedClasses&quot;&gt;  &lt;list&gt;     &lt;value&gt;com.demo.entity.User&lt;/value&gt;     &lt;value&gt;com.demo.entity.Blog&lt;/value&gt;  &lt;/list&gt;&lt;/property&gt;</code></pre><p><strong>推荐使用packagesToScan属性扫描包方式。</strong></p><p>【构建不依赖于spring的Hibernate代码】</p><pre><code>package com.demo.dao;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import com.demo.entity.User;@Repositorypublic class UserDaoImpl implements IUserDao  {  private SessionFactory sessionFactory;  // 构造注入  @Autowired  public UserDaoImpl(SessionFactory sessionFactory) {     this.sessionFactory = sessionFactory;  }  private Session currentSession(){     return sessionFactory.getCurrentSession();  }  @Override  public void addUser(User param) {     Session session = currentSession();     session.save(param);     System.out.println(&quot;Add User&quot;);  }  @Override  public User get(Integer id) {     return (User) currentSession().get(User.class, id);  }  @Override  public void save(User user) {     currentSession().update(user);  }}</code></pre><p>还需配置：</p><pre><code>&lt;context:component-scan base-package=&quot;com.demo.dao&quot;/&gt;</code></pre><p>就会像扫描其他注解一样扫描带@Repository注解的类到容器中。</p><h5 id="集成MyBatis方式"><a href="#集成MyBatis方式" class="headerlink" title="集成MyBatis方式"></a>集成MyBatis方式</h5><pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;  p:dataSource-ref=&quot;dataSource&quot; p:configLocation=&quot;classpath:mybatis-config.xml&quot;  p:mapperLocations=&quot;classpath:com/demo/dao/*.xml&quot; /&gt;&lt;!-- spring与mybatis整合配置，扫描所有dao --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;  p:basePackage=&quot;com.demo.dao&quot; p:sqlSessionFactoryBeanName=&quot;sqlSessionFactory&quot; /&gt;</code></pre><h4 id="与其他JPA集成方式"><a href="#与其他JPA集成方式" class="headerlink" title="与其他JPA集成方式"></a>与其他JPA集成方式</h4><p>配置实体管理工厂</p><p>应用程序管理类型的JPA（LocalEntityManagerFactoryBean）：它的EntityManager是由EntityManagerFactory创建的；</p><p>容器管理类型的JPA（LocalContainerEntityManagerFactoryBean）：通过PersistenceProvider的createEntityManagerFactory()方法得到，即它的EntityManagerFactory是通过PersistenceProvider的createContainerEntityManagerFactory()方法得到。</p><p>使用应用程序管理类型的JPA</p><p>绝大部分配置文件来源于名为persistence.xml的配置文件，这个文件位置必须位于类路径下的WETA-INF目录下</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;persistence version=&quot;2.0&quot;     xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;&gt;  &lt;persistence-unit name=&quot;persistenceUnit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;     &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;     &lt;properties&gt;        &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL5Dialect&quot; /&gt;        &lt;property name=&quot;hibernate.max_fetch_depth&quot; value=&quot;3&quot;/&gt;        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;        &lt;property name=&quot;hibernate.jdbc.fetch_size&quot; value=&quot;18&quot;/&gt;        &lt;property name=&quot;hibernate.jdbc.batch_size&quot; value=&quot;10&quot;/&gt;        &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;false&quot;/&gt;        &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;false&quot;/&gt;     &lt;/properties&gt;     &lt;class&gt;com.demo.entity.User&lt;/class&gt;     &lt;class&gt;com.demo.entity.Blog&lt;/class&gt;     &lt;!-- …… ……--&gt;   &lt;/persistence-unit&gt;&lt;/persistence&gt;</code></pre><p>这样在spring的配置文件中配置的信息就很少了：</p><pre><code>&lt;bean id=&quot;demo&quot; class=&quot;org.springframework.orm.jpa.LocalEntityManagerFactoryBean&quot;&gt;  &lt;property name=&quot;persistenceUnit&quot; &gt;&lt;/bean&gt;</code></pre><p>【TIPS】上面persistence.xml文件中的配置会出现问题：</p><p>如果每次请求EntityManagerFactory时都要定义持久化单元，代码回迅速膨胀</p><p>借助spring对JPA的支持，不再需要直接处理PersistenceProvider了，就是下面的容器管理的JPA！</p><p>使用容器管理类型的JPA</p><p>将数据源信息配置在spring的应用上下文中，而不是在persistence.xml文件中。</p><pre><code>&lt;bean id=&quot;emf&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;   &lt;!-- 指定使用的是哪一个厂商的JPA实现 如Hibernate --&gt;  &lt;property name=&quot;jpaVendorAdapter&quot; ref=&quot;hibernateJpaVendorAdapter&quot;/&gt;&lt;/bean&gt;</code></pre><p>配置JPA实现：</p><p>可选的有：EclipseLinkJpaVendorAdapter、HibernateJpaVendorAdapter、OpenJpaVendorAdapter、TopLinkJpaVendorAdapter</p><pre><code>&lt;bean id=&quot;hibernateJpaVendorAdapter&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;  &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot;/&gt;  &lt;property name=&quot;showSql&quot; value=&quot;true&quot;/&gt;  &lt;property name=&quot;generateDdl&quot; value=&quot;true&quot;/&gt;  &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQL5Dialect&quot;/&gt;&lt;/bean&gt;</code></pre><p>【TIPS】database属性：属性值表示支持哪种数据库，下面Hibernate的JPA是一些支持的数据库：<br><img src="/images/20181019214107.png"></p><p><strong>【注】JNDI获取实体管理工厂：</strong></p><p>如果spring应用部署在应用服务器中，Spring可能已经创建好EntityManagerFactory并将其置于JNDI中等饭查询使用，这种情况可使用JNDI来获取对EntityManagerFactory的引用：</p><pre><code>&lt;jee:jndi-lookup id=&quot;emf&quot; jndi-name=&quot;persistence/testDS&quot;/&gt;</code></pre><p>编写基于JPA的DAO</p><pre><code>package com.demo.dao;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Transactional;import com.demo.entity.User;@Repository@Transactionalpublic class JpaDao implements IUserDao {  // 注入EntityManager  @PersistenceContext  private EntityManager em;  // 使用EntityManager  @Override  public void addUser(User param) {     em.persist(param);  }  @Override  public User get(Integer id) {     return em.find(User.class, id);  }  @Override  public void save(User user) {     em.merge(user);  }}</code></pre><p>上面使用到了@PersistenceContext注解将EntityManager注入。</p><p>这样用需要在spring的上下文配置文件中配置一个PersistenceAnnotationBeanPostProcessor：</p><pre><code>&lt;!-- 使用EntityManager --&gt;&lt;bean class=&quot;org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor&quot;/&gt;</code></pre><p>以上，是如何使用JDBC、Hibernate或JPA为spring应用程序构建持久层，至于选择哪种方案完全取决于偏好.</p><h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><p>通过毁掉机制将实际事务实现从事务性代码中抽象出来。</p><h4 id="选择事务管理器"><a href="#选择事务管理器" class="headerlink" title="选择事务管理器"></a>选择事务管理器</h4><p>事务管理器结构</p><p>事务处理流程：</p><p>开始事务-&gt;绑定资源-&gt;使用资源-&gt;完成事务-&gt;释放资源</p><h5 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h5><pre><code>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;     &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;</code></pre><p>DataSourceTransactionManager通过调用java.sql.Connection来管理事务，由java.sql.Connection对象来提交、回滚事务。</p><h5 id="Hibernate事务"><a href="#Hibernate事务" class="headerlink" title="Hibernate事务"></a>Hibernate事务</h5><pre><code>&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt;  &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;&lt;/bean&gt;</code></pre><p>HibernateTransactionManager通过将事务管理的职责委托给org.hibernate.Transaction对象，org.hibernate.Transaction对象从Hibernate Session中获取，然后由Transaction对象来提交、回滚事务。</p><h5 id="JPA事务"><a href="#JPA事务" class="headerlink" title="JPA事务"></a>JPA事务</h5><pre><code>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;  &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>JpaTransactionManager只需要装配一个JPA实体管理工厂（EntityManagerFactory的任意实现），然后与由工厂产生的JPA EntityManager合作构建事务。</p><p>如果你还希望将事务应用于简单JDBC操作（JDBC操作使用的datasource和EntityManagerFactory使用的dataSource必须相同），那么JpaTransactionManager必须装配一个JpaDialect的实现：</p><pre><code>&lt;bean id=&quot;jpaDialect&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt;&lt;!--然后将jpaDialect装配到transactionManager中 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;  &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;  &lt;property name=&quot;jpaDialect&quot; ref=&quot;jpaDialect&quot;/&gt;&lt;/bean&gt;</code></pre><h5 id="JTA事务"><a href="#JTA事务" class="headerlink" title="JTA事务"></a>JTA事务</h5><p>如果前面的事务管理器不能满足需求或事物需要跨多个事务资源（两个及以上数据库），需要使用JtaTrasactionManager了：</p><pre><code>&lt;bean id=&quot;transactionManager&quot;  class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&gt;  &lt;property name=&quot;transactionManagerName&quot; value=&quot;java:/TrasactionManager&quot;/&gt;&lt;/bean&gt;</code></pre><p>JtaTransactionManager将事务委托给一个JTA的实现（java.transaction.UserTransaction和javax.transaction.TransactionManager），通过UserTransaction来操作事务。JTA规定了应用程序晕一个或多个数据源之间协调事务的标准API，transactionManagerName属性指定了要在JNDI上查找JTA事务管理器。</p><h4 id="Spring事务实现方式"><a href="#Spring事务实现方式" class="headerlink" title="Spring事务实现方式"></a>Spring事务实现方式</h4><p>1）编码事务</p><p>通过TransactionTemplate的回调机制，例如：（UserSeriveImpl.java）</p><pre><code>public void addUser(final User u) {  TransactionTemplate temp = new TransactionTemplate();  temp.execute(new TransactionCallback&lt;Void&gt;() {     @Override     public Void doInTransaction(TransactionStatus txtStatus) {          // 要执行的事务代码        try {           userDao.save(u);        } catch (RuntimeException e) {           e.printStackTrace();           txtStatus.setRollbackOnly();        }        return null;     }  });}</code></pre><p>此时UserService需要如下装配：</p><pre><code>&lt;bean id=&quot;userSerive&quot; class=&quot;com.demo.service.UserServiceImpl&quot;&gt;  &lt;property name=&quot;transactionTemplate&quot;&gt;     &lt;bean class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;     &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre><p>优点：可以完全控制事务边界，精确控制事务。</p><p>缺点：侵入性的，事务控制在代码中实现，耦合度高</p><p>2）声明式事务</p><p>传播行为</p><p>传播行为回答了新的事务是该被启动还是被挂起，或者方法是否要在事务环境中运行。</p><p>事务的传播行为都在org.springframework.transaction.TransactionDefinition接口中以常量的方式定义出来。</p><p>隔离级别</p><p>隔离级别定义了一个事务可能受其他并发事务影响的程度。</p><p>隔离级别都在org.springframework.transaction.TransactionDefinition接口中以常量的方式定义出来。</p><p>只读</p><p>事务启动的时候由数据库实施的，只有针对具备启动一个新事务传播行为（PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED）的方法来说才有意义。【tips】如果使用Hibernate，将事务声明为只读会导致flush模式被设置为FLUSH_NEVER，这会告诉hibernate避免和数据库进行不必要的对象同步，并将所有的更新延迟到事务结束。</p><p>事务超时</p><p>长时间事务会导致一些不必要的数据库资源占用。</p><p>超时时钟会在事务开始时启动，只有针对具备启动一个新事务传播行为（PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED）的方法来说才有意义。</p><p>回滚规则</p><p>这些规则定义了哪些异常会导致事务回滚哪些不会，默认情况下，运行时异常会回滚，检查异常不回滚，但是可以声明事务遇到检查异常回滚，运行时异常不回滚。</p><p>3）Spring在XML中定义事务</p><p>需要包括beans、aop、tx命名空间。</p><pre><code>&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;  &lt;tx:attributes&gt;     &lt;!-- 事务执行方式 REQUIRED：指定当前方法必需在事务环境中运行，     如果当前有事务环境就加入当前正在执行的事务环境，     如果当前没有事务，就新建一个事务。 这是默认值。 --&gt;     &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;save*&quot;   propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;add*&quot;    propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;del*&quot;    propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;import*&quot; propagation=&quot;REQUIRED&quot; /&gt;     &lt;!-- 指定当前方法以非事务方式执行操作，如果当前存在事务，就把当前事务挂起，等我以非事务的状态运行完，再继续原来的事务。 查询定义即可        read-only=&quot;true&quot; 表示只读 --&gt;     &lt;tx:method name=&quot;*&quot;       propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot; /&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;</code></pre><p>其中&lt;tx:method /&gt;有很多属性用来帮助定义方法的事务策略：<br><img src="/images/20181019215056.png"></p><p>4）定义注解驱动的事务</p><p>在XML配置文件中添加：</p><pre><code>&lt;tx:annotation-driven/&gt;</code></pre><p>可通过transaction-manager属性（默认值”transactionManager”）来指定事务管理器，如：</p><pre><code>&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</code></pre><p><code>&lt;tx:annotation-driven/&gt;</code>告诉Spring检查上下文中所有bean并检查使用到@Transactional注解的bean。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中无处不在的Properties</title>
      <link href="/2018/10/19/spring-zhong-wu-chu-bu-zai-de-properties/"/>
      <url>/2018/10/19/spring-zhong-wu-chu-bu-zai-de-properties/</url>
      
        <content type="html"><![CDATA[<p>对 Spring 里面的 Properties 不理解的开发者可能会觉得有点乱，主要是因为配置方式很多种，使用方式也很多种。</p><p>本文不是原理分析、源码分析文章，只是希望可以帮助读者更好地理解和使用 Spring Properties。</p><a id="more"></a><h3 id="Properties-的使用"><a href="#Properties-的使用" class="headerlink" title="Properties 的使用"></a>Properties 的使用</h3><p>先来看看 Properties 是怎么使用的，Spring 中常用的有以下几种使用方式：</p><h4 id="在-xml-配置文件中使用"><a href="#在-xml-配置文件中使用" class="headerlink" title="在 xml 配置文件中使用"></a>在 xml 配置文件中使用</h4><p>即自动替换 ${} 里面的值。</p><pre><code>&lt;bean id=&quot;xxx&quot; class=&quot;com.javadoop.Xxx&quot;&gt;     &lt;property name=&quot;url&quot; value=&quot;${javadoop.jdbc.url}&quot; /&gt;&lt;/bean&gt;</code></pre><h4 id="通过-Value-注入使用"><a href="#通过-Value-注入使用" class="headerlink" title="通过 @Value 注入使用"></a>通过 @Value 注入使用</h4><pre><code>@Value(&quot;${javadoop.jdbc.url}&quot;)private String url;</code></pre><h4 id="通过-Environment-获取"><a href="#通过-Environment-获取" class="headerlink" title="通过 Environment 获取"></a>通过 Environment 获取</h4><p>此法有需要注意的地方。并不是所有的配置方式都支持通过 Environment 接口来获取属性值，亲测只有使用注解 @PropertySource 的时候可以用，否则会得到 null，至于怎么配置，下面马上就会说。</p><pre><code>@Autowiredprivate Environment env;public String getUrl() {   return env.getProperty(&quot;javadoop.jdbc.url&quot;);}</code></pre><p><strong>注：如果是 Spring Boot 的 application.properties 注册的，那也是可以的。</strong></p><hr><h3 id="Properties-配置"><a href="#Properties-配置" class="headerlink" title="Properties 配置"></a>Properties 配置</h3><p>前面我们说了怎么使用我们配置的 Properties，那么该怎么配置呢？Spring 提供了很多种配置方式。</p><h4 id="通过-xml-配置"><a href="#通过-xml-配置" class="headerlink" title="通过 xml 配置"></a>通过 xml 配置</h4><p>下面这个是最常用的配置方式了，很多项目都是这么写的：</p><pre><code>&lt;context:property-placeholder location=&quot;classpath:sys.properties&quot; /&gt;</code></pre><h4 id="通过-PropertySource-配置"><a href="#通过-PropertySource-配置" class="headerlink" title="通过 @PropertySource 配置"></a>通过 @PropertySource 配置</h4><p>前面的通过 xml 配置非常常用，但是如果你也有一种要消灭所有 xml 配置文件的冲动的话，你应该使用以下方式：</p><pre><code>@PropertySource(&quot;classpath:sys.properties&quot;)@Configurationpublic class JavaDoopConfig {}</code></pre><p><strong>注：@PropertySource 在这里必须搭配 @Configuration 来使用，具体不展开说了。</strong></p><h4 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h4><p>如果读者见过这个，也不必觉得奇怪，在 Spring 3.1 之前，经常就是这么使用的：</p><pre><code>&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;   &lt;property name=&quot;locations&quot;&gt;       &lt;list&gt;           &lt;value&gt;classpath:sys.properties&lt;/value&gt;       &lt;/list&gt;   &lt;/property&gt;   &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot;/&gt;     &lt;!-- 这里可以配置一些属性 --&gt;&lt;/bean&gt;</code></pre><p>当然，我们也可以用相应的 java configuration 的版本：</p><pre><code>@Beanpublic PropertyPlaceholderConfigurer propertiess() {   PropertyPlaceholderConfigurer ppc = new PropertyPlaceholderConfigurer();   Resource[] resources = new ClassPathResource[]{new ClassPathResource(&quot;sys.properties&quot;)};   ppc.setLocations(resources);   ppc.setIgnoreUnresolvablePlaceholders(true);   return ppc;}</code></pre><h4 id="PropertySourcesPlaceholderConfigurer"><a href="#PropertySourcesPlaceholderConfigurer" class="headerlink" title="PropertySourcesPlaceholderConfigurer"></a>PropertySourcesPlaceholderConfigurer</h4><p>到了 Spring 3.1 的时候，引入了 PropertySourcesPlaceholderConfigurer，这是一个新的类，注意看和之前的 PropertyPlaceholderConfigurer 在名字上多了一个 Sources，所属的包也不一样，它在 Spring-Context 包中。</p><p>在配置上倒是没有什么区别：</p><pre><code>&lt;bean class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;   &lt;property name=&quot;locations&quot;&gt;       &lt;list&gt;           &lt;value&gt;classpath:sys.properties&lt;/value&gt;       &lt;/list&gt;   &lt;/property&gt;   &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot;/&gt;   &lt;!-- 这里可以配置一些属性 --&gt;&lt;/bean&gt;</code></pre><p>也来一个 java configuration 版本吧：</p><pre><code>@Beanpublic PropertySourcesPlaceholderConfigurer properties() {   PropertySourcesPlaceholderConfigurer pspc = new PropertySourcesPlaceholderConfigurer();   Resource[] resources = new ClassPathResource[]{new ClassPathResource(&quot;sys.properties&quot;)};   pspc.setLocations(resources);   pspc.setIgnoreUnresolvablePlaceholders(true);   return pspc;}</code></pre><h3 id="Spring-Boot-相关"><a href="#Spring-Boot-相关" class="headerlink" title="Spring Boot 相关"></a>Spring Boot 相关</h3><p>Spring Boot 真的是好东西，开箱即用的感觉实在是太好了。这里简单介绍下相关的内容。</p><p>快速生成一个 Spring Boot 项目：</p><p><a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a></p><p><strong>application.properties</strong></p><p>我们每个项目都默认有一个 application.properties 文件，这个配置文件不需要像前面说的那样进行注册，Spring Boot 会帮我们自动注册。</p><p>当然，也许你想换个名字也是可以的，在启动的时候指定你的文件名字就可以了：</p><pre><code>java -Dspring.config.location=classpath:sys.properties -jar app.jar</code></pre><p><strong>application-{env}.properties</strong></p><p>为了给不同的环境指定不同的配置，我们会用到这个。比如测试环境和生产环境的数据库连接信息就不一样。</p><p>所以，在 application.properties 的基础上，我们还需要新建 application-dev.properties 和 application-prd.properties，用于配置环境相关的信息，然后启动的时候指定环境。</p><pre><code>java -Dspring.profiles.active=prd -jar app.jar</code></pre><p>结果就是，application.properties 和 application-prd.properties 两个文件中的配置都会注册进去，如果有重复的 key，application-prd.properties 文件中的优先级较高。</p><p><strong>@ConfigurationProperties</strong></p><p>这个注解是 Spring Boot 中才有的。即使大家不使用这个注解，大家也可能会在开源项目中看到这个，这里简单介绍下。</p><p>来一个例子直观一些。按照之前说的，在配置文件中填入下面的信息，你可以选择写入 application.properties 也可以用第一节介绍的方法。</p><pre><code>javadoop.database.url=jdbc:mysql:javadoop.database.username=adminjavadoop.database.password=admin123456</code></pre><p>java 文件：</p><pre><code>@Configuration@ConfigurationProperties(prefix = &quot;javadoop.database&quot;)public class DataBase {   String url;   String username;   String password;   // getters and setters}</code></pre><p>这样，就在 Spring 的容器中就自动注册了一个类型为 DataBase 的 bean 了，而且属性都已经 set 好了。</p><p><strong>在启动过程中动态修改属性值</strong></p><p>这个我觉得都不需要太多介绍，用 Spring Boot 的应该基本上都知道。</p><p>属性配置有个覆盖顺序，也就是当出现相同的 key 的时候，以哪里的值为准。</p><p>启动参数 &gt; application-{env}.properties &gt; application.properties</p><p>启动参数动态设置属性：</p><pre><code>java -Djavadoop.database.password=admin4321 -jar app.jar</code></pre><p>另外，还可以利用系统环境变量设置属性，还可以指定随机数等等，确实很灵活，不过没什么用，就不介绍了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>读者如果想要更加深入地了解 Spring 的 Properties，需要去理解 Spring 的 Environment 接口相关的源码。建议感兴趣的读者去翻翻源代码看看</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_13</title>
      <link href="/2018/10/19/spring-annotation-day-13/"/>
      <url>/2018/10/19/spring-annotation-day-13/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天来学习AOP原理。</p><a id="more"></a><p>我们上篇文章已经描述了AOP的使用情况，现在来研究一下AOP的原理。首先从@EnableAspectJAutoProxy注解开始。</p><hr><h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><p>1）点击@EnableAspectJAutoProxy注解：</p><pre><code>@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(AspectJAutoProxyRegistrar.class)public @interface EnableAspectJAutoProxy </code></pre><p>发现，使用了@Import注解来注入组件。组件是AspectJAutoProxyRegistrar类。</p><p>2）点击AspectJAutoProxyRegistrar类：</p><pre><code>class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar{  ···}</code></pre><p>该类，实现了ImportBeanDefinitionRegistrar接口，说明是用来自定义注入组件的。其中有一个registerBeanDefinitions（）方法。</p><pre><code>public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);        AnnotationAttributes enableAspectJAutoProxy =                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);        if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) {            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);        }        if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) {            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);        }    }</code></pre><p>查看其中的AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</p><p>最终会调用registerOrEscalateApcAsRequired方法：</p><pre><code>    private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) {        Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);        if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {            BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);            if (!cls.getName().equals(apcDefinition.getBeanClassName())) {                int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());                int requiredPriority = findPriorityForClass(cls);                if (currentPriority &lt; requiredPriority) {                    apcDefinition.setBeanClassName(cls.getName());                }            }            return null;        }        RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);        beanDefinition.setSource(source);        beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);        registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);        return beanDefinition;    }</code></pre><p>最后是给容器注入了一个Bean：<br>id：internalAutoProxyCreator ==》 Class：AnnotationAwareAspectJAutoProxyCreator</p><hr><h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>@EnableAspectJAutoProxy注解帮我们注入了AnnotationAwareAspectJAutoProxyCreator组件，这个组件有什么作用呢？</p><p>我们观察一下AnnotationAwareAspectJAutoProxyCreator的继承关系：</p><p>AnnotationAwareAspectJAutoProxyCreator</p><p>&nbsp;&nbsp;&nbsp;AspectJAwareAdvisorAutoProxyCreator  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractAdvisorAutoProxyCreator  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractAutoProxyCreator</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</strong></p><p><strong>关键:实现了两个接口，一个后置处理器(在Bean初始化完成前后做事情)、一个自动装配BeanFactory</strong></p><hr><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>打上断点：(与后置处理器，自动装配有关的)</p><p>1）AbstractAutoProxyCreator.setBeanFactory<br>2）AbstractAutoProxyCreator.postProcessBeforeInstantiation<br>3) AbstractAutoProxyCreator.postProcessAfterInitialization</p><p>4) AbstractAdvisorAutoProxyCreator.setBeanFactory(父类重写的方法也打上断点)<br>5）AbstractAdvisorAutoProxyCreator.initBeanFactory</p><p>6) AspectJAwareAdvisorAutoProxyCreator类没有相关的就不打上断点</p><p>7）AnnotationAwareAspectJAutoProxyCreator.initBeanFactory(父类重写的方法也打上断点)</p><p>8) MainConfigOfAOP配置类的中的两个Bean对象打上断点：<br>&nbsp;&nbsp;&nbsp;mathCalculator和logAspects</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>流程：<br>1）传入配置类，创建IoC容器</p><pre><code> AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);</code></pre><p>2) 注册配置类，调用refresh（）, 刷新容器</p><pre><code>public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {        this();        register(annotatedClasses); //注入配置类        refresh();  //刷新容器    }</code></pre><p>3）registerBeanPostProcessors(beanFactory);注册bean的后置处理器，来拦截bean的初始化操作。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.先获取IoC容器已经定义了的需要创建对象的所有BeanPostProcessor  </p><pre><code>String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;2.给容器中加别的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;3.优先注册实现了PriorityOrdered接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;4.再注册实现了Ordered接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;5.注册没有实现优先级接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;6.注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存到容器中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建    internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.创建Bean对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.populateBean：给bean的属性赋值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.initializeBean：初始化bean</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.invokeAwareMethods：处理Aware接口的回调：</p><pre><code>    private void invokeAwareMethods(final String beanName, final Object bean) {        if (bean instanceof Aware) {            if (bean instanceof BeanNameAware) {                ((BeanNameAware) bean).setBeanName(beanName);            }            if (bean instanceof BeanClassLoaderAware) {                ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());            }            if (bean instanceof BeanFactoryAware) {                ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);            }        }    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.applyBeanPostProcessorsBeforeInitialization:执行后置处理器的postProcessor：postProcessBeforeInitialization方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.invokeInitMethods：自定义的初始化方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.applyBeanPostProcessorsAfterInitialization：执行postProcessor：postProcessAfterInitialization方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;7.把BeanPostProcessor注册到BeanFactory中：beanFactory.addBeanPostProcessor（）</p><hr><p>以上是创建AnnotationAwareAspectJAutoProxyCreator的过程。</p><p>AnnotationAwareAspectJAutoProxyCreator =》InstantiationAwareBeanPostProcessor，而不是 BeanPostProcessor 后置处理器</p><p>InstantiationAwareBeanPostProcessor是 postProcessBeforeInstantiation（实例化）</p><p>BeanPostProcessor是postProcessBeforeInitialization（初始化）</p><p><strong>说明InstantiationAwareBeanPostProcessor后置处理器是 在Bean实例化前后执行</strong></p><p><strong>BeanPostProcessor后置处理器是 在Bean对象初始化前后执行</strong></p><p>4）finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作，创建剩下的没有创建的Bean组件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.遍历获取容器中所有的Bean，依次创建对象；getBean(beanName)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getBean()-&gt;doGetBean()-&gt;getSingleton()-&gt;createBean()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2.创建Bean：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.先从缓存中获取当前的Bean，如果能获取到，说明bean是之前被创建过，直接使用，否则再创建.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要创建了bean就会被缓存起来。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.createBean():创建Bean</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.resolveBeforeInstantiation():解析BeanPostProcessors<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>想让后置处理器在次能返回一个代理对象</strong>，如果能返回代理对象就使用，如果不能就继续。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.后置处理器先尝试返回代理对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean=applyBeanPostProcessorsBeforeInstantiation();拿到所有的后置处理器，如果是 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InstantiationAwareBeanPostProcessor；就执行postProcessBeforeInstantiation方法</p><pre><code>  if (bean != null) {      bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.doCreateBean()：真正去创建一个bean实例；和3.6流程一样</p><hr><p>AnnotationAwareAspectJAutoProxyCreator[InstantiationAwareBeanPostProcessor]</p><p>1) 每一个bean创建之前，调用postProcessBeforeInstantiation()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关心<strong>mathCalculator</strong>和<strong>logAspects</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）判断当前bean是否是在advicedBean中（保存了所有需要增强bean）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）判断当前bean是否是基础类型的Advice、PointCut、Advisor、AopInfrastructureBean或者是否是切面(@Aspect)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）是否需要跳过</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取候选的增强器(切面里面的通知方法)【List<advisor> candidateAdvisors】<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个封装的通知方法的增强器是InstantiationModelAwarePointcutAdvisor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判断每一个增强器是否是AspectJPointcutAdvisor类型的；返回true</advisor></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）永远返回false</p><p>2）创建对象<br>postProcessAfterInitialization：<br>return wrapIfNecessary(bean, beanName, cacheKey);//需要包装的情况下  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取当前bean的所有增强器(通知方法) Object[] specificInterceptors</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）找到候选的所有增强器(找哪些通知方法是需要切入当前bean方法的)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）获取到能在bean使用的增强器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）给增强器排序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）保存当前bean在advisedBeans中；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果当前bean需要增强，创建当前bean的代理对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取所有的增强器(通知方法)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）保存到proxyFactory</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）创建代理对象：Spring自动决定<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdk代理<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cglib代理</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）给容器中返回当前组件使用cglib代理的对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）以后容器中获取的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程</p><p>3）目标方法的执行流程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容器中保存了组件的代理对象(cglib增强后的对象)，这个对象里面保存了详细信息(比如增强器、目标对象，xxx)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）CglibAopProxy.intercept();拦截目标方法的执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）根据ProxyFactory对象获取将要执行的目标方法拦截器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List<object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</object></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）List<object> interceptorList保存所有拦截器：5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个默认的ExposeInvocationInterceptor和4个增强器</object></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）遍历所有的增强器，将其转为Interceptor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）将增强器转为List<methodinterceptor>,如果是MethodInterceptor，直接加入集合中，如果不是，使用AdvisorAdapter将增强器转为   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodInterceptor，转换完后返回MethodInterceptor数组</methodinterceptor></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果没有拦截器链，直接执行目标方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息传入，创建一个CglibMethodInvocation对象，并调用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object retVal = mi.proceed();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5) 拦截器链的触发过程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）如果没有拦截器执行，就直接执行目标方法，或者拦截器的索引和拦截器数组的个数-1一样大，执行目标方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拦截器链的机制，保证通知方法与目标方法的执行顺序.<br><img src="/images/20181019201432.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）@EnableAspectJAutoProxy注解 开启AOP功能</p><p>2）@EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</p><p>3）AnnotationAwareAspectJAutoProxyCreator是一个后置处理器</p><p>4）容器的创建流程：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）registerBeanPostProcessors()注册后置处理器，创建AnnotationAwareAspectJAutoProxyCreator对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）finishBeanFactoryInitialization()：初始化剩下的单实例bean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）创建业务逻辑组件和切面组件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）组件创建完之后，判断组件是否需要增强。是：切面的通知方法，包装成增强器(Advisor);给业务逻辑组件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个代理对象 </p><p>5）执行目标方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）代理对象执行目标方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）CglibAopProxy.Intercept:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）得到目标方法的拦截器链(增强器包装成拦截器MethodIntercept)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）效果：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 正常执行：前置通知 -》目标方法 -》后置通知 -》返回通知<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 出现异常：前置通知 -》目标方法 -》后置通知 -》异常通知  </p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring和SpringMVC父子容器关系初窥</title>
      <link href="/2018/10/19/spring-he-springmvc-fu-zi-rong-qi-guan-xi-chu-kui/"/>
      <url>/2018/10/19/spring-he-springmvc-fu-zi-rong-qi-guan-xi-chu-kui/</url>
      
        <content type="html"><![CDATA[<p>Spring和SpringMVC父子容器关系初窥，探究父容器与子容器之间的关系<br><a id="more"></a></p><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>最近由于项目的包扫描出现了问题，在解决问题的过程中，偶然发现了Spring和SpringMVC是有父子容器关系的，而且正是因为这个才往往会出现包扫描的问题，我们在此来分析和理解Spring和SpringMVC的父子容器关系并且给出Spring和SpringMVC配置文件中包扫描的官方推荐方式。</p><h3 id="二、概念理解和知识铺垫"><a href="#二、概念理解和知识铺垫" class="headerlink" title="二、概念理解和知识铺垫"></a>二、概念理解和知识铺垫</h3><p>在Spring整体框架的核心概念中，容器是核心思想，就是用来管理Bean的整个生命周期的，而在一个项目中，容器不一定只有一个，Spring中可以包括多个容器，而且容器有上下层关系</p><p>目前最常见的一种场景就是在一个项目中引入Spring和SpringMVC这两个框架，那么它其实就是两个容器，Spring是父容器，SpringMVC是其子容器</p><p>并且在Spring父容器中注册的Bean对于SpringMVC容器中是可见的，而在SpringMVC容器中注册的Bean对于Spring父容器中是不可见的，也就是子容器可以看见父容器中的注册的Bean，反之就不行。</p><p>我们可以使用统一的如下注解配置来对Bean进行批量注册，而不需要再给每个Bean单独使用xml的方式进行配置。</p><p><code>&lt;context:component-scan base-package=&quot;com.liuzhuo.www&quot; /&gt;</code></p><p>从Spring提供的参考手册中我们得知该配置的功能是扫描配置的base-package包下的所有使用了@Component注解的类，并且将它们自动注册到容器中，同时也扫描@Controller，@Service，@Respository这三个注解，因为他们是继承自@Component</p><hr><p>在项目中我们经常见到还有如下这个配置，其实有了上面的配置，这个是可以省略掉的，因为上面的配置会默认打开以下配置。</p><p>以下配置会默认声明了@Required、@Autowired、 @PostConstruct、@PersistenceContext、@Resource、@PreDestroy等注解</p><p><code>&lt;context:annotation-config/&gt;</code></p><p><strong>另外，还有一个和SpringMVC相关如下配置，经过验证，这个是SpringMVC必须要配置的，因为它声明了@RequestMapping、@RequestBody、@ResponseBody等。并且，该配置默认加载很多的参数绑定方法，比如json转换解析器等。</strong></p><p><code>&lt;mvc:annotation-driven /&gt;</code></p><p>而上面这句,配置Spring3.1之前的版本和以下配置方式等价</p><pre><code>&lt;!--配置注解控制器映射器,它是SpringMVC中用来将Request请求URL到映射到具体Controller--&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&quot;/&gt;&lt;!--配置注解控制器适配器,它是SpringMVC中用来将具体请求映射到具体方法--&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;/&gt;</code></pre><p>Spring3.1之后的版本和以下配置方式等价：</p><pre><code>&lt;!--配置注解控制器映射器,它是SpringMVC中用来将Request请求URL到映射到具体Controller--&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;&lt;!--配置注解控制器适配器,它是SpringMVC中用来将具体请求映射到具体方法--&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></pre><h3 id="三、具体场景分析"><a href="#三、具体场景分析" class="headerlink" title="三、具体场景分析"></a>三、具体场景分析</h3><p>下面让我们来详细扒一扒Spring与SpringMVC的容器冲突的原因到底在那里？</p><p>我们共有Spring和SpringMVC两个容器，它们的配置文件分别为applicationContext.xml和applicationContext-MVC.xml</p><p>1、在applicationContext.xml中配置了&lt;context:component-scan base-package=“com.hafiz.www” /&gt;，负责所有需要注册的Bean的扫描和注册工作</p><p>2、在applicationContext-MVC.xml中配置&lt;mvc:annotation-driven /&gt;，负责SpringMVC相关注解的使用</p><p>3、启动项目我们发现SpringMVC无法进行跳转，将log的日志打印级别设置为DEBUG进行调试，发现SpringMVC容器中的请求好像没有映射到具体controller中</p><p>4、在applicationContext-MVC.xml中配置&lt;context:component-scan base-package=“com.hafiz.www” /&gt;，重启后，验证成功，springMVC跳转有效</p><p>下面我们来查看具体原因，翻看源码，从SpringMVC的DispatcherServlet开始往下找，我们发现SpringMVC初始化时，会寻找SpringMVC容器中的所有使用了@Controller注解的Bean，来确定其是否是一个handler</p><p>1、2两步的配置使得当前SpringMVC容器中并没有注册带有@Controller注解的Bean，而是把所有带有@Controller注解的Bean都注册在Spring这个父容器中了，所以SpringMVC找不到处理器，不能进行跳转。核心源码如下:</p><pre><code>protected void initHandlerMethods() {　　if (logger.isDebugEnabled()) {　　　　logger.debug(&quot;Looking for request mappings in application context: &quot; + getApplicationContext());　　}　　String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?　　　　　　  BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :　　　　　　　getApplicationContext().getBeanNamesForType(Object.class));　　for (String beanName : beanNames) {　　　　if (isHandler(getApplicationContext().getType(beanName))){　　　　　　detectHandlerMethods(beanName);　　　　}　　}　　handlerMethodsInitialized(getHandlerMethods());}</code></pre><p>在方法isHandler中会判断当前bean的注解是否是controller，源码如下：</p><pre><code>protected boolean isHandler(Class&lt;?&gt; beanType) {　　return AnnotationUtils.findAnnotation(beanType, Controller.class) != null;}</code></pre><p>而在第4步配置中，SpringMVC容器中也注册了所有带有@Controller注解的Bean，故SpringMVC能找到处理器进行处理，从而正常跳转。</p><p>我们找到了出现不能正确跳转的原因，那么它的解决办法是什么呢？</p><p>我们注意到在initHandlerMethods()方法中，detectHandlerMethodsInAncestorContexts这个Switch，它主要控制获取哪些容器中的bean以及是否包括父容器，默认是不包括的。</p><p>所以解决办法就是在SpringMVC的配置文件中配置HandlerMapping的detectHandlerMethodsInAncestorContexts属性为true即可（这里需要根据具体项目看使用的是哪种HandlerMapping），让它检测父容器的bean。如下：</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;  &lt;property name=&quot;detectHandlerMethodsInAncestorContexts&quot;&gt;      &lt;value&gt;true&lt;/value&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre><p>但在实际工程中会包括很多配置，我们按照官方推荐根据不同的业务模块来划分不同容器中注册不同类型的Bean：</p><p>Spring父容器负责所有其他非@Controller注解的Bean的注册，而SpringMVC只负责@Controller注解的Bean的注册，使得他们各负其责、明确边界。配置方式如下</p><p>1、在applicationContext.xml中配置:</p><pre><code>&lt;!-- Spring容器中注册非@controller注解的Bean --&gt;&lt;context:component-scan base-package=&quot;com.hafiz.www&quot;&gt;  &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;</code></pre><p>2、applicationContext-MVC.xml中配置</p><pre><code>&lt;!-- SpringMVC容器中只注册带有@controller注解的Bean --&gt;&lt;context:component-scan base-package=&quot;com.hafiz.www&quot; use-default-filters=&quot;false&quot;&gt;  &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;&lt;/context:component-scan&gt;</code></pre><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>这样我们在清楚了Spring和SpringMVC的父子容器关系、以及扫描注册的原理以后，根据官方建议我们就可以很好把不同类型的Bean分配到不同的容器中进行管理。再出现Bean找不到或者SpringMVC不能跳转以及事务的配置失效的问题，我们就可以很快的定位以及解决问题了。很开心，有木有~</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_12</title>
      <link href="/2018/10/18/spring-annotation-day-12/"/>
      <url>/2018/10/18/spring-annotation-day-12/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习AOP的开发与使用<br><a id="more"></a></p><h3 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h3><p>AOP是Spring 框架的一个关键组件，全称为Aspect-Oriented-Programming（面向切面编程），目前已是一种比较成熟的编程方式。</p><p>AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在编译或运行的时候，再将这些代码应用到需要执行的地方。</p><p><strong>注：提取出来的代码应用到需要执行的地方，并不会把源代码加到需要的地方执行，即源代码文件不会更改，但是它会影响最终的机器编译代码</strong></p><p>意思就是，有一些通用功能的代码可以提取出来，然后在使用的时候应用进去就可以了，比如表单验证和日志记录等等。</p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p>Aspect（切面）</p><p>通常指封装起来用于插入到指定位置实现某项功能的类</p><p>Join point（连接点）</p><p>在SpringAOP中，连接点指方法的调用</p><p>Pointcut（切入点）</p><p>切面与程序流程的交叉点，即那些需要处理的连接点，通常在程序中，切入点指的是类或者方法名</p><p>Advice（通知/增强处理）</p><p>就是程序实际运行之前或之后执行的方法，也就是AOP加入的代码</p><p>Target Object（目标对象）</p><p>即需要加入AOP代码的对象</p><p>Proxy（代理）</p><p>AOP框架动态生成的一个对象，该对象可以作为目标对象使用</p><p>Weaving（织入）</p><p>把切面连接到其它的应用程序类型或者对象上，并创建一个需要Advice对象的过程</p><h3 id="AOP的例子（JDK代理）"><a href="#AOP的例子（JDK代理）" class="headerlink" title="AOP的例子（JDK代理）"></a>AOP的例子（JDK代理）</h3><p>1）首先建立一个java工程</p><p><img src="/images/20181018211302.png" style="width:50%"></p><p>UserDao接口:</p><pre><code>package com.aop.jdk;public interface UserDao { public void addUser();}</code></pre><p>UserDaoImpl:</p><pre><code>package com.aop.jdk;public class UserDaoImpl implements UserDao { @Override public void addUser() {   System.out.println(&quot;新增用户&quot;); }}</code></pre><p>JdkProxy:</p><pre><code>package com.aop.jdk;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import com.aop.aspect.MyAspect;/*** JDK代理类*/public class JdkProxy implements InvocationHandler{ // 声明目标类接口 private UserDao userDao; // 创建代理方法 public  Object createProxy(UserDao userDao) {   this.userDao = userDao;   // 1.类加载器   ClassLoader classLoader = JdkProxy.class.getClassLoader();   // 2.被代理对象实现的所有接口   @SuppressWarnings(&quot;rawtypes&quot;)   Class[] clazz = userDao.getClass().getInterfaces();   // 3.使用代理类，进行增强，返回的是代理后的对象   return  Proxy.newProxyInstance(classLoader,clazz,this); } /*  * 所有动态代理类的方法调用，都会交由invoke()方法去处理  * proxy 被代理后的对象   * method 将要执行的方法  * args 执行方法时需要的参数  */ @Override public Object invoke(Object proxy, Method method, Object[] args)      throws Throwable {   // 声明切面   MyAspect myAspect = new MyAspect();   // 指定位置程序执行前执行这个方法   myAspect.start();   // 在目标类上调用方法   Object obj = method.invoke(userDao, args);   // 指定位置程序执行结束后执行   myAspect.end();   return obj; }}</code></pre><p>MyAspect:</p><pre><code>package com.aop.aspect;/***  切面*/public class MyAspect { public void start(){   System.out.println(&quot;模拟事务处理功能 ...&quot;); } public void end(){   System.out.println(&quot;程序结束后执行此处 ...&quot;); }}</code></pre><p>JdkTest:</p><p>测试结果项目编写完之后运行该类</p><pre><code>package com.aop.test;import com.aop.jdk.JdkProxy;import com.aop.jdk.UserDao;import com.aop.jdk.UserDaoImpl;public class JdkTest { public static void main(String[] args) {   // 创建代理对象   JdkProxy jdkProxy = new JdkProxy();        // 创建目标对象   UserDao userDao= new UserDaoImpl();   // 从代理对象中获取增强后的目标对象   UserDao userDao1 = (UserDao) jdkProxy.createProxy(userDao);   // 执行方法   userDao1.addUser(); }}</code></pre><p>运行之后，我们可以看到以下结果：<br><img src="/images/20181018211845.png" style="width:50%"></p><hr><p>我们可以看到，在我们执行新增用户的方法时，依据我们AOP编程，系统自动执行了start方法和end方法</p><p>在实际运用中，我们可以把一些通用的方法放到start和end的位置，在需要的方法处加入切面即可</p><p>此外，建议大家再了解下AspectJ</p><p>AspectJ实现AOP有两种方式：一种是基于XML的声明式，另一种是基于注解的声明式</p><p>基于XML的声明式AspectJ要便捷一些，但是存在配置信息多的缺点</p><p>基于注解的声明式AspectJ则通过注解的方式减少了很多配置信息</p><h3 id="Spring中的AOP使用"><a href="#Spring中的AOP使用" class="headerlink" title="Spring中的AOP使用"></a>Spring中的AOP使用</h3><p>1）创建新的配置类MainConfigOfAOP</p><pre><code>@Configurationpublic class MainConfigOfAOP {}</code></pre><p>2) 在com.liuzhuo.aop包下，创建MathCalculator类</p><pre><code>public class MathCalculator {    public int div(int a, int b) {        return a / b;    }}</code></pre><p>2) 在com.liuzhuo.aop包下，创建切面类MathCalculator</p><pre><code>public class LogAspects {    public void logStart(){        System.out.println(&quot;方法调用之前------&quot;);    }    public void logEnd(){        System.out.println(&quot;方法调用之后-------&quot;);    }    public void logReturn(){        System.out.println(&quot;方法成功返回之后------&quot;);    }    public void logThrowing(){        System.out.println(&quot;方法出现异常之后------&quot;);    }    public void logRound(){        //环绕方法        System.out.println(&quot;环绕：方法调用之前----&quot;);        System.out.println(&quot;环绕：方法调用之后----&quot;);    }}</code></pre><p>3) 添加AOP的依赖，在pom文件中：</p><pre><code>        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>4) 将切面与目标方法进行连接：</p><pre><code>@Aspectpublic class LogAspects {    @Pointcut(&quot;execution(public int com.liuzhuo.aop.MathCalculator.div(int,int))&quot;)    public void pointCut() {    }    //调用本类的切点    @Before(&quot;pointCut()&quot;)    public void logStart() {        System.out.println(&quot;方法调用之前------&quot;);    }    //调用外面类的切点    @After(&quot;com.liuzhuo.aop.LogAspects.pointCut()&quot;)    public void logEnd() {        System.out.println(&quot;方法调用之后-------&quot;);    }    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;returns&quot;)    public void logReturn(Object returns) {        System.out.println(&quot;方法成功返回之后------:&quot; + returns);    }    @AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;e&quot;)    public void logThrowing(Exception e) {        System.out.println(&quot;方法出现异常之后------:&quot; + e);    }    @Around(&quot;pointCut()&quot;)    public Object logRound(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {        //环绕方法        System.out.println(&quot;环绕：方法调用之前----&quot;);        Object proceed = proceedingJoinPoint.proceed();        System.out.println(&quot;环绕：方法调用之后----&quot;);        return proceed;    }}</code></pre><p>5) 将切面和目标类注入到容器中：</p><pre><code>@Configurationpublic class MainConfigOfAOP {    @Bean    public MathCalculator mathCalculator() {        return new MathCalculator();    }    @Bean    public LogAspects logAspects() {        return new LogAspects();    }}</code></pre><p>6) <strong>开启Aspect的注解驱动</strong>：@EnableAspectJAutoProxy </p><pre><code>@Configuration@EnableAspectJAutoProxy //开启AOP注解驱动public class MainConfigOfAOP {    @Bean    public MathCalculator mathCalculator() {        return new MathCalculator();    }    @Bean    public LogAspects logAspects() {        return new LogAspects();    }}</code></pre><p>7) 创建新的测试类：</p><pre><code>public class IoCTest_AOP {    @Test    public void test01() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);        //不要自己创建MathCalculator类        //MathCalculator mathCalculator = new MathCalculator();        //mathCalculator.div(1, 1);        MathCalculator mathCalculator = applicationContext.getBean(MathCalculator.class);        mathCalculator.div(1, 1);        applicationContext.close();    }}</code></pre><p>8) 运行结果：</p><pre><code>环绕：方法调用之前----方法调用之前------div:正在执行-----环绕：方法调用之后----方法调用之后-------方法成功返回之后------:1十月 18, 2018 10:03:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@3a4afd8d: startup date [Thu Oct 18 22:03:02 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>将业务逻辑组件和切面类都加入到容器中，告诉Spring哪个是切面类(Aspect)  </li><li>在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）</li><li>开启基于注解的AOP模式：@EnableAspectJAutoProxy</li></ol>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/2018/10/18/bean-de-sheng-ming-zhou-qi/"/>
      <url>/2018/10/18/bean-de-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<p>Spring作为当前Java最流行、最强大的轻量级框架，受到了程序员的热烈欢迎。准确的了解Spring Bean的生命周期是非常必要的。<br><a id="more"></a></p><p>我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。而实际上BeanFactory也是差不多的，只不过处理器需要手动注册。</p><h3 id="一、生命周期流程图："><a href="#一、生命周期流程图：" class="headerlink" title="一、生命周期流程图："></a>一、生命周期流程图：</h3><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。<br><img src="/images/20181018162309.png"><br><img src="/images/20181018162419.png"></p><p>若容器注册了以上各种接口，程序那么将会按照以上的流程进行。下面将仔细讲解各接口作用。</p><h3 id="二、各种接口方法分类"><a href="#二、各种接口方法分类" class="headerlink" title="二、各种接口方法分类"></a>二、各种接口方法分类</h3><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p><p>1、Bean自身的方法:这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></p><p>2、Bean级生命周期接口方法:这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p><p>3、容器级生命周期接口方法:这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p><p>4、工厂后处理器接口方法:这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p><h3 id="三、演示"><a href="#三、演示" class="headerlink" title="三、演示"></a>三、演示</h3><p>我们用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p><p>1、首先是一个简单的Spring Bean，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这4个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：</bean></p><pre><code>package springBeanTest;import org.springframework.beans.BeansException;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.BeanFactoryAware;import org.springframework.beans.factory.BeanNameAware;import org.springframework.beans.factory.DisposableBean;import org.springframework.beans.factory.InitializingBean;/*** @author qsk*/public class Person implements BeanFactoryAware, BeanNameAware,       InitializingBean, DisposableBean {   private String name;   private String address;   private int phone;   private BeanFactory beanFactory;   private String beanName;   public Person() {       System.out.println(&quot;【构造器】调用Person的构造器实例化&quot;);   }   public String getName() {       return name;   }   public void setName(String name) {       System.out.println(&quot;【注入属性】注入属性name&quot;);       this.name = name;   }   public String getAddress() {       return address;   }   public void setAddress(String address) {       System.out.println(&quot;【注入属性】注入属性address&quot;);       this.address = address;   }   public int getPhone() {       return phone;   }   public void setPhone(int phone) {       System.out.println(&quot;【注入属性】注入属性phone&quot;);       this.phone = phone;   }   @Override   public String toString() {       return &quot;Person [address=&quot; + address + &quot;, name=&quot; + name + &quot;, phone=&quot;               + phone + &quot;]&quot;;   }   // 这是BeanFactoryAware接口方法   @Override   public void setBeanFactory(BeanFactory arg0) throws BeansException {       System.out               .println(&quot;【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()&quot;);       this.beanFactory = arg0;   }   // 这是BeanNameAware接口方法   @Override   public void setBeanName(String arg0) {       System.out.println(&quot;【BeanNameAware接口】调用BeanNameAware.setBeanName()&quot;);       this.beanName = arg0;   }   // 这是InitializingBean接口方法   @Override   public void afterPropertiesSet() throws Exception {       System.out               .println(&quot;【InitializingBean接口】调用InitializingBean.afterPropertiesSet()&quot;);   }   // 这是DiposibleBean接口方法   @Override   public void destroy() throws Exception {       System.out.println(&quot;【DiposibleBean接口】调用DiposibleBean.destory()&quot;);   }   // 通过&lt;bean&gt;的init-method属性指定的初始化方法   public void myInit() {       System.out.println(&quot;【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法&quot;);   }   // 通过&lt;bean&gt;的destroy-method属性指定的初始化方法   public void myDestory() {       System.out.println(&quot;【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法&quot;);   }}</code></pre><p>2、接下来是演示BeanPostProcessor接口的方法，如下：</p><pre><code>package springBeanTest;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanPostProcessor implements BeanPostProcessor {   public MyBeanPostProcessor() {       super();       System.out.println(&quot;这是BeanPostProcessor实现类构造器！！&quot;);       // TODO Auto-generated constructor stub   }   @Override   public Object postProcessAfterInitialization(Object arg0, String arg1)           throws BeansException {       System.out       .println(&quot;BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！&quot;);       return arg0;   }   @Override   public Object postProcessBeforeInitialization(Object arg0, String arg1)           throws BeansException {       System.out       .println(&quot;BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！&quot;);       return arg0;   }}</code></pre><p><strong>如上，BeanPostProcessor接口包括2个方法: postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。这里要注意。</strong></p><p>3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessor Adapter来使用它，如下：</p><pre><code>package springBeanTest;import java.beans.PropertyDescriptor;import org.springframework.beans.BeansException;import org.springframework.beans.PropertyValues;import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;public class MyInstantiationAwareBeanPostProcessor extends       InstantiationAwareBeanPostProcessorAdapter {   public MyInstantiationAwareBeanPostProcessor() {       super();       System.out               .println(&quot;这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！&quot;);   }   // 接口方法、实例化Bean之前调用   @Override   public Object postProcessBeforeInstantiation(Class beanClass,           String beanName) throws BeansException {       System.out               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法&quot;);       return null;   }   // 接口方法、实例化Bean之后调用   @Override   public Object postProcessAfterInitialization(Object bean, String beanName)           throws BeansException {       System.out               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法&quot;);       return bean;   }   // 接口方法、设置某个属性时调用   @Override   public PropertyValues postProcessPropertyValues(PropertyValues pvs,           PropertyDescriptor[] pds, Object bean, String beanName)           throws BeansException {       System.out               .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法&quot;);       return pvs;   }}</code></pre><p><strong>这个有3个方法，其中第二个方法postProcessAfterInitialization就是重写了BeanPostProcessor的方法。第三个方法postProcessPropertyValues用来操作属性，返回值也应该是PropertyValues对象。</strong></p><p>4、演示工厂后处理器接口方法，如下：</p><pre><code>package springBeanTest;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.config.BeanFactoryPostProcessor;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {   public MyBeanFactoryPostProcessor() {       super();       System.out.println(&quot;这是BeanFactoryPostProcessor实现类构造器！！&quot;);   }   @Override   public void postProcessBeanFactory(ConfigurableListableBeanFactory arg0)           throws BeansException {       System.out.println(&quot;BeanFactoryPostProcessor调用postProcessBeanFactory方法&quot;);       BeanDefinition bd = arg0.getBeanDefinition(&quot;person&quot;);       bd.getPropertyValues().addPropertyValue(&quot;phone&quot;, &quot;110&quot;);   }}</code></pre><p>5、配置文件如下beans.xml，很简单，使用ApplicationContext处理器不用手动注册：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;   xsi:schemaLocation=&quot;           http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&gt;   &lt;bean id=&quot;beanPostProcessor&quot; class=&quot;springBeanTest.MyBeanPostProcessor&quot;&gt;   &lt;/bean&gt;   &lt;bean id=&quot;instantiationAwareBeanPostProcessor&quot; class=&quot;springBeanTest.MyInstantiationAwareBeanPostProcessor&quot;&gt;   &lt;/bean&gt;   &lt;bean id=&quot;beanFactoryPostProcessor&quot; class=&quot;springBeanTest.MyBeanFactoryPostProcessor&quot;&gt;   &lt;/bean&gt;   &lt;bean id=&quot;person&quot; class=&quot;springBeanTest.Person&quot; init-method=&quot;myInit&quot;       destroy-method=&quot;myDestory&quot; scope=&quot;singleton&quot; p:name=&quot;张三&quot; p:address=&quot;广州&quot;       p:phone=&quot;15900000000&quot; /&gt;&lt;/beans&gt;</code></pre><p>6、下面测试一下：</p><pre><code>package springBeanTest;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class BeanLifeCycle {   public static void main(String[] args) {       System.out.println(&quot;现在开始初始化容器&quot;);       ApplicationContext factory = new ClassPathXmlApplicationContext(&quot;springBeanTest/beans.xml&quot;);       System.out.println(&quot;容器初始化成功&quot;);           //得到Preson，并使用       Person person = factory.getBean(&quot;person&quot;,Person.class);       System.out.println(person);       System.out.println(&quot;现在开始关闭容器！&quot;);       ((ClassPathXmlApplicationContext)factory).registerShutdownHook();   }}</code></pre><p>关闭容器使用的是实际是AbstractApplicationContext的钩子方法。</p><p>我们来看一下结果：</p><pre><code>现在开始初始化容器2014-5-18 15:46:20 org.springframework.context.support.AbstractApplicationContext prepareRefresh信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19a0c7c: startup date [Sun May 18 15:46:20 CST 2014]; root of context hierarchy2014-5-18 15:46:20 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions信息: Loading XML bean definitions from class path resource [springBeanTest/beans.xml]这是BeanFactoryPostProcessor实现类构造器！！BeanFactoryPostProcessor调用postProcessBeanFactory方法这是BeanPostProcessor实现类构造器！！这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！2014-5-18 15:46:20 org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons信息: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@9934d4: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchyInstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法【构造器】调用Person的构造器实例化InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法【注入属性】注入属性address【注入属性】注入属性name【注入属性】注入属性phone【BeanNameAware接口】调用BeanNameAware.setBeanName()【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！【InitializingBean接口】调用InitializingBean.afterPropertiesSet()【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法容器初始化成功Person [address=广州, name=张三, phone=110]现在开始关闭容器！【DiposibleBean接口】调用DiposibleBean.destory()【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ Idea 常用快捷键 列表(实战终极总结！！！！)</title>
      <link href="/2018/10/18/idea/"/>
      <url>/2018/10/18/idea/</url>
      
        <content type="html"><![CDATA[<p>IntelliJ Idea 常用快捷键 列表 总结<br><a id="more"></a></p><h3 id="自动代码"><a href="#自动代码" class="headerlink" title="自动代码"></a>自动代码</h3><p>常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。</p><p>例如要输入for(User user : users) 只需输入user.for+Tab ;</p><p><strong>再比如，要输入Date birthday = user.getBirthday() 只需输入user.getBirthday().var+Tab即可。<br>代码标签输入完成后，按Tab，生成代码。</strong></p><p>Ctrl+Alt+O 优化导入的类和包 </p><p>Alt+Insert 生成代码(如get,set方法,构造函数等)   或者右键（Generate） </p><p>fori/sout/psvm + Tab  </p><p>Ctrl+Alt+T  生成try catch  或者 Alt+enter </p><p>CTRL+ALT+T  把选中的代码放在 TRY{} IF{} ELSE{} 里 </p><p>Ctrl + O 重写方法  </p><p>Ctrl + I 实现方法 </p><p>Ctrl+shift+U 大小写转化  </p><p>ALT+回车    导入包,自动修正  </p><p>ALT+/       代码提示 </p><p>CTRL+J      自动代码  </p><p>Ctrl+Shift+J，整合两行为一行 </p><p>CTRL+空格   代码提示  </p><p>CTRL+SHIFT+SPACE 自动补全代码  </p><p>CTRL+ALT+L  格式化代码  </p><p>CTRL+ALT+I  自动缩进  </p><p>CTRL+ALT+O  优化导入的类和包  </p><p>ALT+INSERT  生成代码(如GET,SET方法,构造函数等)  </p><p>CTRL+E      最近更改的代码  </p><p>CTRL+ALT+SPACE  类名或接口名提示  </p><p>CTRL+P   方法参数提示  </p><p>CTRL+Q，可以看到当前方法的声明 </p><p>Shift+F6  重构-重命名 (包、类、方法、变量、甚至注释等) </p><p>Ctrl+Alt+V 提取变量 </p><h3 id="查询快捷键"><a href="#查询快捷键" class="headerlink" title="查询快捷键"></a>查询快捷键</h3><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方 </p><p>ALT+7  靠左窗口显示当前文件的结构 </p><p>Ctrl+F12 浮动显示当前文件的结构 </p><p>ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 </p><p>CTRL+ALT+F7  找到你的函数或者变量或者类的所有引用到的地方 </p><p>Ctrl+Shift+Alt+N 查找类中的方法或变量 </p><p>双击SHIFT 在项目的所有目录查找文件 </p><p>Ctrl+N   查找类 </p><p>Ctrl+Shift+N 查找文件 </p><p>CTRL+G   定位行  </p><p>CTRL+F   在当前窗口查找文本  </p><p>CTRL+SHIFT+F  在指定窗口查找文本  </p><p>CTRL+R   在 当前窗口替换文本  </p><p>CTRL+SHIFT+R  在指定窗口替换文本  </p><p>ALT+SHIFT+C  查找修改的文件  </p><p>CTRL+E   最近打开的文件  </p><p>F3   向下查找关键字出现位置  </p><p>SHIFT+F3  向上一个关键字出现位置  </p><p>选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 </p><p>F4   查找变量来源  </p><p>CTRL+SHIFT+O  弹出显示查找内容 </p><p>Ctrl+W 选中代码，连续按会有其他效果 </p><p>F2 或Shift+F2 高亮错误或警告快速定位 </p><p>Ctrl+Up/Down 光标跳转到第一行或最后一行下 </p><p>Ctrl+B 快速打开光标处的类或方法  </p><p>CTRL+ALT+B  找所有的子类  </p><p>CTRL+SHIFT+B  找变量的类  </p><p>Ctrl+Shift+上下键  上下移动代码 </p><p>Ctrl+Alt+ left/right 返回至上次浏览的位置 </p><p>Ctrl+X 删除行 </p><p>Ctrl+D 复制行 </p><p>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ） </p><p>Ctrl+H 显示类结构图 </p><p>Ctrl+Q 显示注释文档 </p><p>Alt+F1 查找代码所在位置 </p><p>Alt+1 快速打开或隐藏工程面板 </p><p>Alt+ left/right 切换代码视图 </p><p>ALT+ ↑/↓  在方法间快速移动定位  </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方 </p><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </p><p>Alt+6    查找TODO </p><h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><p>SHIFT+ENTER 另起一行 </p><p>CTRL+Z   倒退(撤销) </p><p>CTRL+SHIFT+Z  向前(取消撤销) </p><p>CTRL+ALT+F12  资源管理器打开文件夹  </p><p>ALT+F1   查找文件所在目录位置  </p><p>SHIFT+ALT+INSERT 竖编辑模式  </p><p>CTRL+F4  关闭当前窗口 </p><p>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 </p><p>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） </p><h3 id="svn快捷键"><a href="#svn快捷键" class="headerlink" title="svn快捷键"></a>svn快捷键</h3><p>ctrl+k 提交代码到SVN </p><p>ctrl+t 更新代码 </p><h3 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h3><p>其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。</p><p>alt+F8    debug时选中查看值 </p><p>Alt+Shift+F9，选择 Debug </p><p>Alt+Shift+F10，选择 Run </p><p>Ctrl+Shift+F9，编译 </p><p>Ctrl+Shift+F8，查看断点 </p><p>F7，步入 </p><p>Shift+F7，智能步入 </p><p>Alt+Shift+F7，强制步入 </p><p>F8，步过 </p><p>Shift+F8，步出 </p><p>Alt+Shift+F8，强制步过 </p><p>Alt+F9，运行至光标处 </p><p>Ctrl+Alt+F9，强制运行至光标处 </p><p>F9，恢复程序 </p><p>Alt+F10，定位到断点 </p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>Ctrl+Alt+Shift+T，弹出重构菜单 </p><p>Shift+F6，重命名 </p><p>F6，移动 </p><p>F5，复制 </p><p>Alt+Delete，安全删除 </p><p>Ctrl+Alt+N，内联 </p><h3 id="十大Intellij-IDEA快捷键"><a href="#十大Intellij-IDEA快捷键" class="headerlink" title="十大Intellij IDEA快捷键"></a>十大Intellij IDEA快捷键</h3><p>Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。 </p><p>以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。 </p><p>1 <strong>智能提示:</strong><br>Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。</p><p>用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 </p><p>最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 </p><p>2 <strong>重构:</strong><br>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 </p><p>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。 </p><p>3 <strong>代码生成：</strong><br>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 </p><p>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 </p><p>4 <strong>编辑：</strong><br>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。 </p><p>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p><p>5 <strong>查找打开：</strong><br>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 </p><p>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 </p><p>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 </p><p>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 </p><p>6 <strong>其他辅助：</strong><br>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p><p>Ø  命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 </p><p>Ø  新建：Alt+Insert可以新建类、方法等任何东西。 </p><p>Ø  格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 </p><p>Ø  切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 </p><p>Ø  单元测试：Ctrl+Alt+T创建单元测试用例。 </p><p>Ø  运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 </p><p>Ø  调试：F7/F8/F9分别对应Step into，Step over，Continue。<br><i><strong>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</strong> </i></p><p>Ø  Top #10切来切去：Ctrl+Tab </p><p>Ø  Top #9选你所想：Ctrl+W </p><p>Ø  Top #8代码生成：Template/Postfix +Tab </p><p>Ø  Top #7发号施令：Ctrl+Shift+A </p><p>Ø  Top #6无处藏身：Shift+Shift </p><p>Ø  Top #5自动完成：Ctrl+Shift+Enter </p><p>Ø  Top #4创造万物：Alt+Insert </p><p><strong>太难割舍，前三名并列吧！</strong></p><p>Ø  Top #1智能补全：Ctrl+Shift+Space </p><p>Ø  Top #1自我修复：Alt+Enter </p><p>Ø  Top #1重构一切：Ctrl+Shift+Alt+T </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方<br>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring_Ioc</title>
      <link href="/2018/10/18/spring-ioc/"/>
      <url>/2018/10/18/spring-ioc/</url>
      
        <content type="html"><![CDATA[<p>面试被问烂的 Spring IOC(求求你别再问了)<br><a id="more"></a></p><h3 id="广义的Ioc"><a href="#广义的Ioc" class="headerlink" title="广义的Ioc"></a>广义的Ioc</h3><p>1）IoC(Inversion of Control) 控制反转，即“不用打电话过来，我们会打给你”。</p><p>两种实现： 依赖查找（DL）和 依赖注入（DI）。</p><p>IoC 和 DI 、DL 的关系（这个 DL，Avalon 和 EJB 就是使用的这种方式实现的 IoC）：</p><p><img src="/images/20181018125125.png"></p><p>2) DL 已经被抛弃，因为他需要用户自己去是使用 API 进行查找资源和组装对象。即有侵入性。  </p><p>3) DI 是 Spring 使用的方式，容器负责组件的装配。</p><p><strong>注意：</strong><br>Java 使用 DI 方式实现 IoC 的不止 Spring，包括 Google 的 Guice，还有一个冷门的 PicoContainer（极度轻量，但只提供 IoC）。</p><h3 id="Spring的IoC"><a href="#Spring的IoC" class="headerlink" title="Spring的IoC"></a>Spring的IoC</h3><ol><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法(但是需要实现Spring接口，略有侵入)</li></ol><p>其中，最重要的就是依赖注入，从 XML 的配置上说， 即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p><strong>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</strong>  </p><p>那么， Spring 如何设计容器的呢？  </p><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。  </p><ol><li>BeanFactory</li><li>ApplicationContext</li></ol><p>BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。</p><p>例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。  </p><p>该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，但我今天不会花太多篇幅介绍他们。</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，我这里通过常用的 ClassPathXmlApplicationContext 类，来展示整个容器的层级 UML 关系。</p><p><img src="/images/20181018130402.png"></p><p>有点复杂？ 先不要慌，我来解释一下。</p><p>最上面的 BeanFactory 知道吧？我就不讲了。</p><p>下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p><font color="#00ffff" size="4">好，解释了低级容器和高级容器，我们可以看看一个 IoC 启动过程是什么样子的。说白了，就是 ClassPathXmlApplicationContext 这个类，在启动时，都做了啥。</font><p>下图是 ClassPathXmlApplicationContext 的构造过程，实际就是 Spring IoC 的初始化过程。<br><img src="/images/20181018131026.png"></p><p>注意，这里为了理解方便，有所简化。</p><p>这里再用文字来描述这个过程：</p><ol><li>用户构造 ClassPathXmlApplicationContext（简称 CPAC）</li><li>CPAC 首先访问了 “抽象高级容器” 的 final 的 refresh 方法，这个方法是模板方法。所以要回调子类（低级容器）的 refreshBeanFactory 方法，这个方法的作用是使用低级容器加载所有 BeanDefinition 和 Properties 到容器中。</li><li>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 setBeanFactory 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能，随着 Spring 的不断升级，功能越来越多，很多人在这里迷失了方向）。</li></ol><p>简单说就是：</p><ol><li>低级容器 加载配置文件（从 XML，数据库，Applet），并解析成 BeanDefinition 到低级容器中。</li><li>加载成功后，高级容器启动高级功能，例如接口回调，监听器，自动实例化单例，发布事件等等功能。</li></ol><p><strong>所以，一定要把 “低级容器” 和“高级容器” 的区别弄清楚。不能一叶障目不见泰山。</strong></p><p>好，当我们创建好容器，就会使用 getBean 方法，获取 Bean，而 getBean 的流程如下：<br><img src="/images/20181018131432.png" heigth="50%"></p><p>从图可以看出，getBean 的操作都是在低级容器里操作的。其中有个递归操作，这个是什么意思呢？</p><font color="#00ffff" size="4"><br>假设：当 Bean_A 依赖着 Bean_B，而这个 Bean_A 在加载的时候，其配置的 ref = “Bean_B” 在解析的时候只是一个占位符，被放入了 Bean_A 的属性集合中，当调用 getBean 时，需要真正 Bean_B 注入到 Bean_A 内部时，就需要从容器中获取这个 Bean_B，因此产生了递归。<br></font><p>为什么不是在加载的时候，就直接注入呢？因为加载的顺序不同，很可能 Bean_A 依赖的 Bean_B 还没有加载好，也就无法从容器中获取，你不能要求用户把 Bean 的加载顺序排列好，这是不人道的。</p><p>所以，Spring 将其分为了 2 个步骤：</p><ol><li><p>加载所有的 Bean 配置成 BeanDefinition 到容器中，如果 Bean 有依赖关系，则使用占位符暂时代替。</p></li><li><p>然后，在调用 getBean 的时候，进行真正的依赖注入，即如果碰到了属性是 ref 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。<br>可以看到，依赖注入实际上，只需要 “低级容器” 就可以实现。  </p></li></ol><p>这就是 IoC。</p><p>所以 ApplicationContext refresh 方法里面的操作不只是 IoC，是高级容器的所有功能（包括 IoC），IoC 的功能在低级容器里就可以实现。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><ol><li><p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p></li><li><p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p></li></ol><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><p>可以预见，随着 Spring 的不断发展，高级容器的功能会越来越多。</p><font color="#00ffff" size="4"><br>诚然，了解 IoC 的过程，实际上为了了解 Spring 初始化时，各个接口的回调时机。例如 InitializingBean，BeanFactoryAware，ApplicationListener 等等接口，这些接口的作用，笔者之前写过一篇文章进行介绍，有兴趣可以看一下，关键字：Spring 必知必会 扩展接口。<br></font><p>但是请注意，实现 Spring 接口代表着你这个应用就绑定死 Spring 了！代表 Spring 具有侵入性！要知道，Spring 发布时，无侵入性就是他最大的宣传点之一 —— 即 IoC 容器可以随便更换，代码无需变动。而现如今，Spring 已然成为 J2EE 社区准官方解决方案，也没有了所谓的侵入性这个说法。因为他就是标准，和 Servlet 一样，你能不实现 Servlet 的接口吗？: -)</p><p>好了，下次如果再有面试官问 Spring IoC 初始化过程，就再也不会含糊其词、支支吾吾了！！！</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_11</title>
      <link href="/2018/10/17/spring-annotation-day-11/"/>
      <url>/2018/10/17/spring-annotation-day-11/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习，@Profile注解的使用。<br><a id="more"></a></p><h3 id="Profile注解"><a href="#Profile注解" class="headerlink" title="@Profile注解"></a>@Profile注解</h3><p>Profile：Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能。</p><p>比如：开发环境、测试环境、生产环境；</p><p>根据不同是环境，我们自动切换我们的数据源。</p><p>1）添加c3p0的数据源和mysql的驱动依赖：</p><pre><code>       &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mchange&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.5.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.12&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>2) 创建数据源的配置dbconfig.properties：</p><pre><code>db.user=rootdb.password=123456db.driverClass=com.mysql.jdbc.Driver </code></pre><p>3) 创建新的配置类MainConfigOfProfile：</p><pre><code>@Configuration@PropertySource(value = &quot;classpath:/dbconfig.properties&quot;)public class MainConfigOfProfile implements EmbeddedValueResolverAware {    @Value(&quot;${db.user}&quot;)    private String user;    private StringValueResolver valueResolver;    private String driverClass;    @Override    public void setEmbeddedValueResolver(StringValueResolver resolver) {        this.valueResolver = resolver;        String driverClass = valueResolver.resolveStringValue(&quot;${db.driverClass}&quot;);        this.driverClass = driverClass;    }    @Bean(&quot;testDataSource&quot;)    public DataSource dataSourceTest(@Value(&quot;${db.password}&quot;) String pwd) throws PropertyVetoException {        ComboPooledDataSource dataSource = new ComboPooledDataSource();        dataSource.setUser(user);        dataSource.setPassword(pwd);        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);        dataSource.setDriverClass(driverClass);        return dataSource;    }    @Bean(&quot;devDataSource&quot;)    public DataSource dataSourceDev() throws PropertyVetoException {        ComboPooledDataSource dataSource = new ComboPooledDataSource();        dataSource.setUser(user);        dataSource.setPassword(&quot;123456&quot;);        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/school&quot;);        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);        return dataSource;    }    @Bean(&quot;proDataSource&quot;)    public DataSource dataSourcePro() throws PropertyVetoException {        ComboPooledDataSource dataSource = new ComboPooledDataSource();        dataSource.setUser(&quot;root&quot;);        dataSource.setPassword(&quot;123456&quot;);        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/sell&quot;);        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);        return dataSource;    }}</code></pre><p>上述，有三个不同环境的数据源，test，dev，pro数据源，使用了不同的方式来给数据源进行赋值。</p><p>4）创建新的测试类IoCTest_Profile:</p><pre><code>public class IoCTest_Profile {    @Test    public void test01() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfProfile.class);        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();        for (String name : beanDefinitionNames) {            System.out.println(name);        }    }}</code></pre><p>5) 运行：</p><pre><code>mainConfigOfProfiletestDataSourcedevDataSourceproDataSource</code></pre><p>说明数据源都已经注入到容器中了。</p><hr><p>现在我们需要根据不同的环境，来指定加载需要的配置。</p><p>1)使用@Profile注解，是个属性、类加上一个标记的，标记这个属性或者类是属于这个环境的，只有激活了这个环境，才能被注册到容器中，默认激活default的环境，即@Profile(“default”）.</p><p>2)写在配置类上的@Profile，只能在该环境激活的情况下，整个配置类才能起作用，不管配置类里面的Bean是否是符合当前环境。</p><p>3）没有标记环境的bean，在任何环境下都是加载的</p><p><strong>验证：</strong></p><p>1) 在配置类MainConfigOfProfile中，给三个数据源加上标记：</p><pre><code>@Configuration@PropertySource(value = &quot;classpath:/dbconfig.properties&quot;)public class MainConfigOfProfile implements EmbeddedValueResolverAware {    @Value(&quot;${db.user}&quot;)    private String user;    private StringValueResolver valueResolver;    private String driverClass;    @Override    public void setEmbeddedValueResolver(StringValueResolver resolver) {        this.valueResolver = resolver;        String driverClass = valueResolver.resolveStringValue(&quot;${db.driverClass}&quot;);        this.driverClass = driverClass;    }    @Profile(&quot;test&quot;)    @Bean(&quot;testDataSource&quot;)    public DataSource dataSourceTest(@Value(&quot;${db.password}&quot;) String pwd) throws PropertyVetoException {        ComboPooledDataSource dataSource = new ComboPooledDataSource();        dataSource.setUser(user);        dataSource.setPassword(pwd);        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);        dataSource.setDriverClass(driverClass);        return dataSource;    }    @Profile(&quot;dev&quot;)    @Bean(&quot;devDataSource&quot;)    public DataSource dataSourceDev() throws PropertyVetoException {        ComboPooledDataSource dataSource = new ComboPooledDataSource();        dataSource.setUser(user);        dataSource.setPassword(&quot;123456&quot;);        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/school&quot;);        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);        return dataSource;    }    @Profile(&quot;pro&quot;)    @Bean(&quot;proDataSource&quot;)    public DataSource dataSourcePro() throws PropertyVetoException {        ComboPooledDataSource dataSource = new ComboPooledDataSource();        dataSource.setUser(&quot;root&quot;);        dataSource.setPassword(&quot;123456&quot;);        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/sell&quot;);        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);        return dataSource;    }}</code></pre><p>2) 设置当前的环境：</p><p><strong>方法一：</strong>  </p><p> 配置虚拟机的运行参数。</p><p>-Dspring.profiles.active=test</p><p>运行：</p><pre><code>mainConfigOfProfiletestDataSource</code></pre><p>此时，容器中只有testDataSource数据源了。</p><hr><p>-Dspring.profiles.active=dev</p><p>运行：</p><pre><code>mainConfigOfProfiledevDataSource</code></pre><p>此时，容器中只有devDataSource数据源了。</p><p><strong>方法二：</strong>  </p><p>使用无参数的AnnotationConfigApplicationContext容器。</p><pre><code>public class IoCTest_Profile {    @Test    public void test01() {        //1.无参数        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();        //2.设置环境,这里激活了test和dev        applicationContext.getEnvironment().setActiveProfiles(&quot;test&quot;,&quot;dev&quot;);        //3.设置配置类        applicationContext.register(MainConfigOfProfile.class);        //4.刷新容器        applicationContext.refresh();        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();        for (String name : beanDefinitionNames) {            System.out.println(name);        }    }}</code></pre><p>运行结果：</p><pre><code>mainConfigOfProfiletestDataSourcedevDataSource</code></pre><p>这里，test和dev数据源被激活了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_10</title>
      <link href="/2018/10/17/spring-annotation-day-10/"/>
      <url>/2018/10/17/spring-annotation-day-10/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>自定义组件想要使用Spring容器底层的一些组件的开发(ApplicationContext,BeanFactory,xxx)<br><a id="more"></a></p><p>自定义组件实现xxxAware，在创建对象的时候，会调用接口规定的方法注入相关组件，Aware会把Spring底层的一些组件注入到自定义的Bean中。</p><p>xxxAware:功能使用xxxAwareProcessor现实的，比如：ApplicationContextAware是用ApplicationContextAwareProcessor注入的。</p><h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><p>1）在com.liuzhuo.bean包，随便找个Bean来实验：</p><p>这里使用Red类来实验：</p><pre><code>@Componentpublic class Red implements ApplicationContextAware {    private ApplicationContext applicationContext;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        this.applicationContext = applicationContext;        System.out.println(&quot;容器:&quot; + applicationContext.toString());    }}</code></pre><p>2）将Red类注入到容器中，使用包扫描，修改MainConfigOfAutowired配置类：<br><strong>加入了com.liuzhuo.bean包的扫描</strong></p><pre><code>@Configuration@ComponentScan(value = {&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;,&quot;com.liuzhuo.bean&quot;})public class MainConfigOfAutowired</code></pre><p>3) 运行测试类IocTest_Autowired：</p><pre><code>public class IocTest_Autowired {    @Test    public void test01() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);        applicationContext.close();    }}</code></pre><p>4) 运行结果：</p><pre><code>org.springframework.context.event.internalEventListenerProcessor------postProcessBeforeInitializationorg.springframework.context.event.internalEventListenerProcessor------postProcessAfterInitializationorg.springframework.context.event.internalEventListenerFactory------postProcessBeforeInitializationorg.springframework.context.event.internalEventListenerFactory------postProcessAfterInitializationmainConfigOfAutowired------postProcessBeforeInitializationmainConfigOfAutowired------postProcessAfterInitializationbookController------postProcessBeforeInitializationbookController------postProcessAfterInitializationbookDao2------postProcessBeforeInitializationbookDao2------postProcessAfterInitializationbookService------postProcessBeforeInitializationbookService------postProcessAfterInitializationbookDao------postProcessBeforeInitializationbookDao------postProcessAfterInitializationCat constructer ···cat------postProcessBeforeInitializationCat afterPropertiesSet ····cat------postProcessAfterInitializationDog construct ····dog------postProcessBeforeInitializationDog @PostConstruct ····dog------postProcessAfterInitialization容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchyred------postProcessBeforeInitializationred------postProcessAfterInitializationDog @PreDestroy ····Cat destroy ····十月 17, 2018 2:08:28 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>能观察到：</p><p><code>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy</code></p><p>说明在Red类中，注入了容器类。</p><p>5）验证是否是同一个容器，修改测试方法：</p><pre><code>public class IocTest_Autowired {    @Test    public void test01() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);        System.out.println(applicationContext);        applicationContext.close();    }}</code></pre><p>6) 运行测试方法：</p><pre><code>org.springframework.context.event.internalEventListenerProcessor------postProcessBeforeInitializationorg.springframework.context.event.internalEventListenerProcessor------postProcessAfterInitializationorg.springframework.context.event.internalEventListenerFactory------postProcessBeforeInitializationorg.springframework.context.event.internalEventListenerFactory------postProcessAfterInitializationmainConfigOfAutowired------postProcessBeforeInitializationmainConfigOfAutowired------postProcessAfterInitializationbookController------postProcessBeforeInitializationbookController------postProcessAfterInitializationbookDao2------postProcessBeforeInitializationbookDao2------postProcessAfterInitializationbookService------postProcessBeforeInitializationbookService------postProcessAfterInitializationbookDao------postProcessBeforeInitializationbookDao------postProcessAfterInitializationCat constructer ···cat------postProcessBeforeInitializationCat afterPropertiesSet ····cat------postProcessAfterInitializationDog construct ····dog------postProcessBeforeInitializationDog @PostConstruct ····dog------postProcessAfterInitialization容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchyred------postProcessBeforeInitializationred------postProcessAfterInitialization十月 17, 2018 2:14:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchyorg.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchyDog @PreDestroy ····Cat destroy ····Process finished with exit code 0</code></pre><p>观察到：<br>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: </p><p>org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf:</p><p>一样，都是@2f410acf，说明是一个容器。</p><hr><h3 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h3><p>给自定义组件，注入自己在容器的id名。</p><p>1）修改Red类：</p><pre><code>@Componentpublic class Red implements ApplicationContextAware,BeanNameAware {    private ApplicationContext applicationContext;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        this.applicationContext = applicationContext;        System.out.println(&quot;容器:&quot; + applicationContext.toString());    }    @Override    public void setBeanName(String name) {        System.out.println(&quot;自定义组件的id名字：&quot;+name);    }}</code></pre><p>2) 运行测试方法：</p><pre><code>自定义组件的id名字：red容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:21:56 CST 2018]; root of context hierarchyred------postProcessBeforeInitializationred------postProcessAfterInitialization</code></pre><p><strong>总结：</strong></p><p>想让自定义组件使用Spring底层的组件，就实现xxxAware接口就行。</p><p>ApplicationContextAware<br>ApplicationEventPublisherAware<br>BeanClassLoaderAware<br>BeanFactoryAware<br>BeanNameAware<br>BootstrapContextAware<br>EmbeddedValueResolverAware<br>EnvironmentAware<br>ImportAware<br>LoadTimeWeaverAware<br>MessageSourceAware<br>NotificationPublisherAware<br>PortletConfigAware<br>PortletContextAware<br>ResourceLoaderAware<br>SchedulerContextAware<br>ServletConfigAware<br>ServletContextAware</p><hr><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>1）在Red类下的setApplicationContext方法上面打上断点</p><p>2) 运行测试方法：</p><p>发现ApplicationContextAware是由ApplicationContextAwareProcessor处理的：</p><pre><code> @Override    public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {        AccessControlContext acc = null;        if (System.getSecurityManager() != null &amp;&amp;                (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||                        bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||                        bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {            acc = this.applicationContext.getBeanFactory().getAccessControlContext();        }        if (acc != null) {            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {                @Override                public Object run() {                    invokeAwareInterfaces(bean);                    return null;                }            }, acc);        }        else {            invokeAwareInterfaces(bean);        }        return bean;    }</code></pre><p>内部执行postProcessBeforeInitialization方法来判断自定义的组件是否实现类xxxAware接口。</p><p>最后调用invokeAwareInterfaces(bean)方法</p><pre><code>    private void invokeAwareInterfaces(Object bean) {        if (bean instanceof Aware) {            if (bean instanceof EnvironmentAware) {                ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());            }            if (bean instanceof EmbeddedValueResolverAware) {                ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);            }            if (bean instanceof ResourceLoaderAware) {                ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);            }            if (bean instanceof ApplicationEventPublisherAware) {                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);            }            if (bean instanceof MessageSourceAware) {                ((MessageSourceAware) bean).setMessageSource(this.applicationContext);            }            if (bean instanceof ApplicationContextAware) {                ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);            }        }    }</code></pre><p>调用相应的方法来实现注入。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_09</title>
      <link href="/2018/10/16/spring-annotation-day-09/"/>
      <url>/2018/10/16/spring-annotation-day-09/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>Spring的自动装配：  </p><p>Spring利用依赖注入(DI)，完成对IoC容器中各个组件的依赖关系赋值。<br><a id="more"></a></p><h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h3><p>1）在com.liuzhuo.config包下，创建新的类MainConfigOfAutowired：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并扫描三个包.</p><pre><code>@Configuration@ComponentScan(value = {&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;})public class MainConfigOfAutowired {}</code></pre><p>2) 修改BookService类：</p><pre><code>@Servicepublic class BookService {    @Autowired    private BookDao bookDao;    public BookService() {    }    @Override    public String toString() {        return &quot;BookService{&quot; +                &quot;bookDao=&quot; + bookDao +                &#39;}&#39;;    }}</code></pre><p>3) 修改BookDao类：</p><pre><code>@Repositorypublic class BookDao {    private Integer laber = 1;    public BookDao() {    }    public BookDao(Integer laber) {        this.laber = laber;    }    @Override    public String toString() {        return &quot;BookDao{&quot; +                &quot;laber=&quot; + laber +                &#39;}&#39;;    }}</code></pre><p>4) 创建新的测试类IocTest_Autowired：</p><pre><code>public class IocTest_Autowired {    @Test    public void test01() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class);        BookService bookService = applicationContext.getBean(BookService.class);        System.out.println(bookService);        applicationContext.close();    }}</code></pre><p>5) 运行：</p><pre><code>十月 16, 2018 9:20:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:20:48 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=1}}十月 16, 2018 9:20:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:20:48 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>看到，BookService对象中的BookDao对象也注入进来了。</p><hr><p>当我们有多个相同类型的对象时，会注入哪个对象呢？</p><p>1）我们在配置文件MainConfigOfAutowired中添加先的BookDao对象：</p><pre><code>@Configuration@ComponentScan(value = {&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;})public class MainConfigOfAutowired {    @Bean    public BookDao bookDao() {        return new BookDao(2);    }}</code></pre><p>2）运行测试：</p><pre><code>十月 16, 2018 9:27:35 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:27:35 CST 2018]; root of context hierarchy十月 16, 2018 9:27:36 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doCloseBookService{bookDao=BookDao{laber=1}}信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:27:35 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p><strong>结果不变，说明有多个相同类型时，注入到容器中的对象是与@AutoWired下面属性的名字相同的id的Bean对象。</strong></p><p>3）验证我们的结论，修改BookService类下的属性BookDao的属性名字：</p><pre><code>@Servicepublic class BookService {    @Autowired    private BookDao bookDao2;    public BookService() {    }    @Override    public String toString() {        return &quot;BookService{&quot; +                &quot;bookDao=&quot; + bookDao2 +                &#39;}&#39;;    }}</code></pre><p>4) 运行测试：</p><pre><code>十月 16, 2018 9:30:54 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:30:54 CST 2018]; root of context hierarchy十月 16, 2018 9:30:54 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doCloseBookService{bookDao=BookDao{laber=2}}信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:30:54 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>验证正确，说明注入的Bean是与属性的名字相同的对象。</p><hr><p>除了，上述的方法来处理多个相同类型的对象。我们还可以使用 @Qualifier来指定注入容器中的Bean的id名。</p><p>1）修改BookService类：</p><pre><code>@Servicepublic class BookService {    @Qualifier(&quot;bookDao&quot;)    @Autowired    private BookDao bookDao2;    public BookService() {    }    @Override    public String toString() {        return &quot;BookService{&quot; +                &quot;bookDao=&quot; + bookDao2 +                &#39;}&#39;;    }}</code></pre><p>2) 测试：</p><pre><code>十月 16, 2018 9:34:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:34:12 CST 2018]; root of context hierarchy十月 16, 2018 9:34:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:34:12 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=1}}Process finished with exit code 0</code></pre><p>此时注入容器中的BookDao对象就是@Qualifier(“bookDao”)注解的对象，而不是bookDao2了。</p><hr><p>默认情况下，@Autowired注解的属性，必须要在容器中已经注入了，否则会报错。</p><p>1）将刚刚的两个BookDao对象都注释掉。</p><p>2）运行测试：</p><pre><code>十月 16, 2018 9:38:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:38:48 CST 2018]; root of context hierarchy十月 16, 2018 9:38:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext refresh警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;bookService&#39;: Unsatisfied dependency expressed through field &#39;bookDao2&#39;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;com.liuzhuo.dao.BookDao&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;bookService&#39;: Unsatisfied dependency expressed through field &#39;bookDao2&#39;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;com.liuzhuo.dao.BookDao&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:588)    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:366)    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1264)    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543)    at org.springframework.context.annotation.AnnotationConfigApplicationContext.&lt;init&gt;(AnnotationConfigApplicationContext.java:84)    at com.liuzhuo.test.IocTest_Autowired.test01(IocTest_Autowired.java:18)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;com.liuzhuo.dao.BookDao&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}    at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1493)    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1104)    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066)    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:585)    ... 36 moreProcess finished with exit code -1</code></pre><p>我们也可以使@Autowired注解的属性，不是必须的。<br>因为@Autowired注解里面有一个属性 boolean required() default true;<br>将required设置为：false</p><pre><code>@Servicepublic class BookService {    //@Qualifier(&quot;bookDao&quot;)    @Autowired(required = false)    private BookDao bookDao2;    public BookService() {    }    @Override    public String toString() {        return &quot;BookService{&quot; +                &quot;bookDao=&quot; + bookDao2 +                &#39;}&#39;;    }}</code></pre><p>运行：</p><pre><code>十月 16, 2018 9:43:23 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:43:23 CST 2018]; root of context hierarchy十月 16, 2018 9:43:24 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:43:23 CST 2018]; root of context hierarchyBookService{bookDao=null}Process finished with exit code 0</code></pre><p>此时不报错了。修改了默认情况下，必须给@Autowired注解的属性，注入到容器中。</p><hr><p>@primary注解：使用这个注解，就是当有多个类型的情况下，优先注入的bean对象：</p><p>1) 修改配置文件：</p><pre><code>@Configuration@ComponentScan(value = {&quot;com.liuzhuo.controller&quot;, &quot;com.liuzhuo.service&quot;, &quot;com.liuzhuo.dao&quot;})public class MainConfigOfAutowired {    @Primary    @Bean(value = &quot;bookDao2&quot;)    public BookDao bookDao() {        return new BookDao(2);    }}</code></pre><p>2) 修改BookService：注释掉@Qualifier(“bookDao”)</p><pre><code>@Servicepublic class BookService {    //@Qualifier(&quot;bookDao&quot;)    @Autowired(required = false)    private BookDao bookDao;    public BookService() {    }    @Override    public String toString() {        return &quot;BookService{&quot; +                &quot;bookDao=&quot; + bookDao +                &#39;}&#39;;    }}</code></pre><p>3) 运行测试：</p><pre><code>十月 16, 2018 9:47:44 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:47:44 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=2}}十月 16, 2018 9:47:44 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:47:44 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>此时，输出的是laber=2的BookDao对象了，不再根据@Autowired注解下的属性名来注入到容器中了。</p><p>4）将BookService中的@Qualifier(“bookDao”)的注释去掉：</p><pre><code>@Servicepublic class BookService {    @Qualifier(&quot;bookDao&quot;)    @Autowired(required = false)    private BookDao bookDao;    public BookService() {    }    @Override    public String toString() {        return &quot;BookService{&quot; +                &quot;bookDao=&quot; + bookDao +                &#39;}&#39;;    }}</code></pre><p>5) 运行测试：</p><pre><code>十月 16, 2018 9:51:00 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:51:00 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=1}}十月 16, 2018 9:51:00 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:51:00 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p><strong>说明：当@Primary和@Qualifier同时存在时，是以@Qualifier为标准的！</strong></p><hr><h3 id="Resource注解"><a href="#Resource注解" class="headerlink" title="@Resource注解"></a>@Resource注解</h3><p>1）修改BookService类：</p><pre><code>@Servicepublic class BookService {    //@Qualifier(&quot;bookDao&quot;)    //@Autowired(required = false)    @Resource    private BookDao bookDao;    public BookService() {    }    @Override    public String toString() {        return &quot;BookService{&quot; +                &quot;bookDao=&quot; + bookDao +                &#39;}&#39;;    }}</code></pre><p>2) 运行：</p><pre><code>十月 16, 2018 10:09:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:09:41 CST 2018]; root of context hierarchy十月 16, 2018 10:09:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:09:41 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=1}}Process finished with exit code 0</code></pre><p>此时，输出的是laber=1的bookService对象，说明@primary注解没有起作用。<br>@Resource注解，默认是注入属性的名。也可以通过@Resource的name属性来修改需要注入到容器中的Bean对象。</p><pre><code>@Servicepublic class BookService {    //@Qualifier(&quot;bookDao&quot;)    //@Autowired(required = false)    @Resource(name = &quot;bookDao2&quot;)    private BookDao bookDao;    public BookService() {    }    @Override    public String toString() {        return &quot;BookService{&quot; +                &quot;bookDao=&quot; + bookDao +                &#39;}&#39;;    }}</code></pre><p>运行：</p><pre><code>十月 16, 2018 10:13:02 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:13:02 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=2}}十月 16, 2018 10:13:02 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:13:02 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><hr><h3 id="Inject注解"><a href="#Inject注解" class="headerlink" title="@Inject注解"></a>@Inject注解</h3><p>@Inject注解：需要导入javax.inject包。</p><p>1）在pom文件中添加依赖：</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;javax.inject&lt;/groupId&gt;            &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;            &lt;version&gt;1&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>2) 修改BookService类：</p><pre><code>@Servicepublic class BookService {    //@Qualifier(&quot;bookDao&quot;)    //@Autowired(required = false)    //@Resource(name = &quot;bookDao2&quot;)    @Inject    private BookDao bookDao;    public BookService() {    }    @Override    public String toString() {        return &quot;BookService{&quot; +                &quot;bookDao=&quot; + bookDao +                &#39;}&#39;;    }}</code></pre><p>3) 运行：</p><pre><code>十月 16, 2018 10:16:52 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:16:52 CST 2018]; root of context hierarchy十月 16, 2018 10:16:52 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;信息: JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiringBookService{bookDao=BookDao{laber=2}}十月 16, 2018 10:16:52 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:16:52 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>输出的是laber=2的BookService对象，说明支持@primary注解。</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1）@Autowired：自动注入<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1）、默认优先按照类型去容器中找对应的组件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2）、如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3）、@Qualifier：使用@Qualifier指定需要装配的组件的id，而不使用属性名<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.4）、自动装配默认是一定将属性赋值好，没有就报错。可以使用@Autowired(required=false)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.5）、@Primary:当存在多个同类型的Bean时，优先装配的Bean，优先级没有@Qualifier高。  </p><p>2）Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Resource：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以和@Autowired一样实现自动装配功能，默认是按照组件名称进行装配的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不支持@primary功能和@Autowired(required=false)功能，但是有@Resource(name = “bookDao2”)修改注入容器Bean的id的功能。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Inject：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要导入javax.inject包，和@Autowired的功能一样，但是没有required=false的功能。</p><p>3）@Autowired是Spring定义的，只能在有Spring的环境时才有作用，@Resource和@Inject注解是java规范，只有是满足java规范的都可以使用，意思就是跨框架性更好。</p><p>4）上述自动注入都是通过AutowiredAnnotationBeanPostProcessor这个后置处理器完成。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_08</title>
      <link href="/2018/10/16/spring-annotation-day-08/"/>
      <url>/2018/10/16/spring-annotation-day-08/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习Spring的自动注入<br><a id="more"></a></p><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><p>使用@Value注解来注入值</p><p>1）在com.liuzhuo.config包下，创建新的配置类MainConfigOfProperty：</p><pre><code>@Configurationpublic class MainConfigOfProperty {    @Bean    public Person person() {        return new Person();    }}</code></pre><p>2）在com.liuzhuo.test包下，创建新的测试类：</p><pre><code>public class PropertyTest {    private AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfProperty.class);    @Test    public void test01() {        printBeanName(applicationContext);        Person person = (Person) applicationContext.getBean(&quot;person&quot;);        System.out.println(person);        applicationContext.close();    }    private void printBeanName(AnnotationConfigApplicationContext applicationContext) {        String[] names = applicationContext.getBeanDefinitionNames();        for (String name : names) {            System.out.println(name);        }    }}</code></pre><p>3) 运行测试方法：test01</p><pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfigOfPropertypersonPerson{name=&#39;null&#39;, age=null}十月 16, 2018 5:34:32 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2ff5659e: startup date [Tue Oct 16 17:34:31 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>我们能看到，打印出来的Person对象的属性都是null。</p><p>4）修改Person类</p><pre><code>public class Person {    /*    * value:    *     1.使用直接值，比如字符串，数值等    *     2.使用SpEL表达式，#{}    *     3.使用${},获取资源文件中的数据    * */    @Value(&quot;张三&quot;)    private String name;    @Value(&quot;#{20-2}&quot;)    private Integer age;    ·····}</code></pre><p>5）再次运行test01：</p><pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfigOfPropertypersonPerson{name=&#39;张三&#39;, age=18}十月 16, 2018 5:37:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2ff5659e: startup date [Tue Oct 16 17:37:41 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><hr><h3 id="PropertySource注解"><a href="#PropertySource注解" class="headerlink" title="@PropertySource注解"></a>@PropertySource注解</h3><p>使用@PropertySource注解来获取资源配置文件中的数据。</p><p>1）在resource包下，创建person.properties文件：</p><pre><code>person.nickName=小张三</code></pre><p>2) 修改Person类：<br>添加nickName属性和对应的get、set方法：</p><pre><code>public class Person {    /*     * value:     *     1.使用直接值，比如字符串，数值等     *     2.使用SpEL表达式，#{}     *     3.使用${},获取资源文件中的数据     * */    @Value(&quot;张三&quot;)    private String name;    @Value(&quot;#{20-2}&quot;)    private Integer age;    @Value(&quot;${person.nickName}&quot;)    private String nickName;    ·····}</code></pre><p>3）在配置文件中，加入资源文件的扫描：<br>&nbsp;&nbsp;&nbsp;@PropertySource(value = “classpath:person.properties”)</p><pre><code>@Configuration@PropertySource(value = &quot;classpath:person.properties&quot;)public class MainConfigOfProperty</code></pre><p>这里的@PropertySource(value = “classpath:person.properties”)，相当于以前在xml中的配置的<br>&lt;context:property-placeholder location=”person.properties”/&gt;，如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--包扫描、只要标注了@Controller、@Service、@Repository、@Component都会自动注入到容器中--&gt;    &lt;!--&lt;context:component-scan base-package=&quot;com.liuzhuo&quot;/&gt;--&gt;    &lt;!--扫描资源文件--&gt;    &lt;context:property-placeholder location=&quot;person.properties&quot;/&gt;    &lt;!--以前的开发模式，使用配置文件--&gt;    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>4) 运行test01：</p><pre><code>mainConfigOfPropertypersonPerson{name=&#39;张三&#39;, age=18, nickName=&#39;小张三&#39;}</code></pre><p>这里的昵称，小张三也打印出来了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_07</title>
      <link href="/2018/10/16/spring-annotation-day-07/"/>
      <url>/2018/10/16/spring-annotation-day-07/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习BeanPostProcessor的生命周期流程<br><a id="more"></a></p><h3 id="BeanPostProcessor的生命周期流程"><a href="#BeanPostProcessor的生命周期流程" class="headerlink" title="BeanPostProcessor的生命周期流程"></a>BeanPostProcessor的生命周期流程</h3><p>我们知道BeanPostProcessor是后置处理器，是在Bean初始化前后执行一些列操作的，底层到底是怎么执行的呢？现在debug一下。</p><p>1）设置断点，在com.liuzhuo.bean包下的MyBeanPostProcessor类中，给postProcessBeforeInitialization方法设置断点。</p><p><img src="/images/20181016100600.png"></p><p>2) debug一下。发现调用栈如下：</p><p><img src="/images/20181016101036.png" style="width:50%"></p><p>程序是从test01开始：</p><p>1）创建AnnotationConfigApplicationContext对象  </p><p>2）执行AnnotationConfigApplicationContext的构造方法：</p><pre><code>    public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {        this();        register(annotatedClasses);        refresh();    }</code></pre><p>3) 调用refresh()方法：完成一系列资源配置操作。最后调用finishBeanFactoryInitialization()方法，初始化容器。</p><pre><code>    public void refresh() throws BeansException, IllegalStateException {        synchronized (this.startupShutdownMonitor) {            // Prepare this context for refreshing.            prepareRefresh();            // Tell the subclass to refresh the internal bean factory.            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();            // Prepare the bean factory for use in this context.            prepareBeanFactory(beanFactory);            try {                // Allows post-processing of the bean factory in context subclasses.                postProcessBeanFactory(beanFactory);                // Invoke factory processors registered as beans in the context.                invokeBeanFactoryPostProcessors(beanFactory);                // Register bean processors that intercept bean creation.                registerBeanPostProcessors(beanFactory);                // Initialize message source for this context.                initMessageSource();                // Initialize event multicaster for this context.                initApplicationEventMulticaster();                // Initialize other special beans in specific context subclasses.                onRefresh();                // Check for listener beans and register them.                registerListeners();                // Instantiate all remaining (non-lazy-init) singletons.                finishBeanFactoryInitialization(beanFactory);                // Last step: publish corresponding event.                finishRefresh();            }            catch (BeansException ex) {                if (logger.isWarnEnabled()) {                    logger.warn(&quot;Exception encountered during context initialization - &quot; +                            &quot;cancelling refresh attempt: &quot; + ex);                }                // Destroy already created singletons to avoid dangling resources.                destroyBeans();                // Reset &#39;active&#39; flag.                cancelRefresh(ex);                // Propagate exception to caller.                throw ex;            }            finally {                // Reset common introspection caches in Spring&#39;s core, since we                // might not ever need metadata for singleton beans anymore...                resetCommonCaches();            }        }    }</code></pre><p>4）进入finishBeanFactoryInitialization：<br>调用<br><code>beanFactory.preInstantiateSingletons();</code></p><p>5) 最终调用doCreateBean()方法：<br>我们主要看其中的：</p><pre><code>        // Initialize the bean instance.        Object exposedObject = bean;        try {            populateBean(beanName, mbd, instanceWrapper);            if (exposedObject != null) {                exposedObject = initializeBean(beanName, exposedObject, mbd);            }        }</code></pre><p>populateBean:给Bean的属性赋值等操作<br>initializeBean:Bean初始化操作。</p><p>6）点击initializeBean方法:</p><pre><code>        Object wrappedBean = bean;        if (mbd == null || !mbd.isSynthetic()) {            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);        }        try {            invokeInitMethods(beanName, wrappedBean, mbd);        }        catch (Throwable ex) {            throw new BeanCreationException(                    (mbd != null ? mbd.getResourceDescription() : null),                    beanName, &quot;Invocation of init method failed&quot;, ex);        }        if (mbd == null || !mbd.isSynthetic()) {            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);        }        return wrappedBean;</code></pre><p>其中：<br>applyBeanPostProcessorsBeforeInitialization：完成初始化之前的操作。</p><p>invokeInitMethods：初始化是操作(@PostConstruc、init-method等)</p><p>applyBeanPostProcessorsAfterInitialization：完成初始化之后的操作。</p><p>7）点击applyBeanPostProcessorsBeforeInitialization：</p><pre><code>    @Override    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)            throws BeansException {        Object result = existingBean;        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {            result = beanProcessor.postProcessBeforeInitialization(result, beanName);            if (result == null) {                return result;            }        }        return result;    }</code></pre><p>发现：就是使用for循环来调用一系列BeanPostProcessor接口的实现类，包括Spring容器自身的和我们自定义的实现类。</p><p><strong>注意:如果其中的某一个BeanPostProcessor实现类返回了null，那么后面的BeanPostProcessor实现类就不执行了！！！</strong></p><p>大概的流程就走完了~~~</p><hr><h3 id="Spring底层对BeanPostProcessor的使用"><a href="#Spring底层对BeanPostProcessor的使用" class="headerlink" title="Spring底层对BeanPostProcessor的使用"></a>Spring底层对BeanPostProcessor的使用</h3><p>ps：在idea中：类名查找类:Ctrl+Shift+Alt+N; </p><p><img src="/images/20181016104349.png"></p><p>1) 找到BeanPostProcessor接口：</p><pre><code>public interface BeanPostProcessor {    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;}</code></pre><p>2) 在BeanPostProcessor上Ctrl+T：找到所有的实现类：</p><p><img src="/images/20181016105219.png"></p><p>我们能看到各种BeanPostProcessor的实现类</p><p>3）ApplicationContextAwareProcessor</p><p>我们使用一下ApplicationContextAwareProcessor这个处理器。这个处理器是给我们的自定义Bean注入容器的。</p><p>4）在com.liuzhuo.bean包下，随便找个一个Bean，并实现ApplicationContextAware接口：<br>ps:这里使用的Dog类</p><pre><code>@Componentpublic class Dog implements ApplicationContextAware </code></pre><p>5）需要实现：setApplicationContext方法</p><pre><code>    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        this.applicationContext = applicationContext;    }</code></pre><p>这样我们就将容器注入到Dog类中。</p><hr><p>还有：<br>InitDestroyAnnotationBeanPostProcessor处理我们的@PostConstruct、@PreDestory注解。<br>AutowiredAnnotationBeanPostProcessor处理我们的@Autowired注解等。</p><p><strong>总结：<br>&nbsp;&nbsp;&nbsp;&nbsp;Spring对底层BeanPostProcessor的使用：bean的赋值、注入其他组件、@Autowired、生命周期注解功能、@Async、xxxBeanPostProcessor等等。</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_06</title>
      <link href="/2018/10/15/spring-annotation-day-06/"/>
      <url>/2018/10/15/spring-annotation-day-06/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习Bean的生命周期<br><a id="more"></a></p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>在Spring中Bean的生命周期：<br>Bean的创建—-初始化—–调用—–销毁。</p><p>构造(对象的创建)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单实例：在容器启动的时候创建对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多实例：在每次获取的时候创建对象 </p><p>初始化：<br>对象创建完成，并赋值好，调用初始化方法</p><p>销毁：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单实例：容器关闭的时候<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多实例：容器不会管理这个Bean，容器不会调用销毁方法</p><p>以前，我们定义初始化和销毁方法是在xml文件中配置的：</p><pre><code>&lt;!--以前的开发模式，使用配置文件--&gt;    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;    &lt;/bean&gt;</code></pre><p>init-method=””    : 定义初始化方法<br>destroy-method=”” : 定义销毁方法  </p><hr><p>现在，我们可以使用其他方式来完成生命周期。</p><h4 id="通过-Bean指定init-method和destroy-method"><a href="#通过-Bean指定init-method和destroy-method" class="headerlink" title="通过@Bean指定init-method和destroy-method"></a>通过@Bean指定init-method和destroy-method</h4><p>1）在com.liuzhuo.config包下，创建MainConfigOfLife配置类：</p><pre><code>@Configurationpublic class MainConfigOfLife {}</code></pre><p>2) 在com.liuzhuo.bean包下，创建Car类：</p><pre><code>public class Car {    public Car() {        System.out.println(&quot;Car construct ····&quot;);    }    //定义初始化方法    public void init(){        System.out.println(&quot;Car init ·····&quot;);    }    //定义销毁方法    public void destory(){        System.out.println(&quot;Car destory ·····&quot;);    }}</code></pre><p>3) 将Car注册到容器中：</p><pre><code>@Configurationpublic class MainConfigOfLife {    @Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destory&quot;)    public Car car() {        return new Car();    }}</code></pre><p>4) 在com.liuzhuo.test包下，创建新的测试类(IocOfLifeTest):</p><pre><code>public class IocOfLifeTest {    @Test    public void test01() {        AnnotationConfigApplicationContext applicationContext =                new AnnotationConfigApplicationContext(MainConfigOfLife.class);    }}</code></pre><p>5)运行测试test01方法：</p><pre><code>Car construct ····Car init ·····</code></pre><p>说明：单例模式下，容器启动就会将Bean对象注入到容器中，并执行了初始化方法。</p><p>想要调用销毁方法，关闭容器就好。</p><pre><code>public class IocOfLifeTest {    @Test    public void test01() {        //启动容器        AnnotationConfigApplicationContext applicationContext =                new AnnotationConfigApplicationContext(MainConfigOfLife.class);        //关闭容器        applicationContext.close();    }}</code></pre><p>运行结果：</p><pre><code>D:\Java1.8\bin\java十月 15, 2018 9:08:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:08:11 CST 2018]; root of context hierarchyCar construct ····Car init ·····十月 15, 2018 9:08:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:08:11 CST 2018]; root of context hierarchyCar destory ·····Process finished with exit code 0</code></pre><hr><h4 id="InitializingBean和DisposableBean"><a href="#InitializingBean和DisposableBean" class="headerlink" title="InitializingBean和DisposableBean"></a>InitializingBean和DisposableBean</h4><p>通过让Bean实现InitializingBean和DisposableBean两个接口来定义初始化和销毁。</p><p>1）在com.liuzhuo.bean包下，创建Cat类，并实现上述两个接口：</p><pre><code>@Componentpublic class Cat implements InitializingBean, DisposableBean {    public Cat() {        System.out.println(&quot;Cat constructer ···&quot;);    }    @Override    public void destroy() throws Exception {        System.out.println(&quot;Cat destroy ····&quot;);    }    @Override    public void afterPropertiesSet() throws Exception {        System.out.println(&quot;Cat afterPropertiesSet ····&quot;);    }}</code></pre><p>2) 将Cat类注入到容器中，这里我使用了包扫描:</p><pre><code>@Configuration@ComponentScan(value = &quot;com.liuzhuo&quot;)public class MainConfigOfLife </code></pre><p>3) 运行测试方法test01:</p><pre><code>public class IocOfLifeTest {    @Test    public void test01() {        //启动容器        AnnotationConfigApplicationContext applicationContext =                new AnnotationConfigApplicationContext(MainConfigOfLife.class);        Object cat = applicationContext.getBean(&quot;cat&quot;);        //关闭容器        applicationContext.close();    }}</code></pre><p>4) 结果：</p><pre><code>十月 15, 2018 9:21:42 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition信息: Overriding bean definition for bean &#39;person&#39; with a different definition: replacing [Generic bean: class [com.liuzhuo.bean.Person]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\ideaProject\springannotation\target\classes\com\liuzhuo\bean\Person.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/liuzhuo/config/MainConfig2.class]]Cat constructer ···Cat afterPropertiesSet ····Car construct ····Car init ·····十月 15, 2018 9:21:43 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:21:42 CST 2018]; root of context hierarchyCar destory ·····Cat destroy ····</code></pre><hr><h4 id="JSR250-PostConstruct和-PreDestory"><a href="#JSR250-PostConstruct和-PreDestory" class="headerlink" title="JSR250:@PostConstruct和@PreDestory"></a>JSR250:@PostConstruct和@PreDestory</h4><p>@PostConstruct: 在bean创建完成并且属性赋值完成，来执行初始化方法<br>@PreDestory：&nbsp;&nbsp;在容器销毁bean之前通知我们进行清理工作</p><p>1) 在com.liuzhuo.bean包下，创建Dog类：</p><pre><code>@Componentpublic class Dog {    public Dog() {        System.out.println(&quot;Dog construct ····&quot;);    }    //在构造函数之后    @PostConstruct    public void init() {        System.out.println(&quot;Dog @PostConstruct ····&quot;);    }    //在销毁之前    @PreDestroy    public void destory() {        System.out.println(&quot;Dog @PreDestroy ····&quot;);    }}</code></pre><p>2) 运行测试类test01:</p><pre><code>public class IocOfLifeTest {    @Test    public void test01() {        //启动容器        AnnotationConfigApplicationContext applicationContext =                new AnnotationConfigApplicationContext(MainConfigOfLife.class);        applicationContext.getBean(&quot;dog&quot;);        //关闭容器        applicationContext.close();    }}</code></pre><p>3) 结果：</p><pre><code>十月 15, 2018 9:35:11 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition信息: Overriding bean definition for bean &#39;person&#39; with a different definition: replacing [Generic bean: class [com.liuzhuo.bean.Person]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\ideaProject\springannotation\target\classes\com\liuzhuo\bean\Person.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/liuzhuo/config/MainConfig2.class]]Cat constructer ···Cat afterPropertiesSet ····Dog construct ····Dog @PostConstruct ····Car construct ····Car init ·····十月 15, 2018 9:35:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:35:11 CST 2018]; root of context hierarchyCar destory ·····Dog @PreDestroy ····Cat destroy ····</code></pre><hr><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>BeanPostProcessor:bean后置处理器（意思是bean初始化前后执行）</p><p>postProcessBeforeInitialization：在初始化之前执行，这里是初始化指：上述的init-method、InitializingBean、@PostConstruct。</p><p>postProcessAfterInitialization：在初始化之后执行。</p><hr><p>1）在com.liuzhuo.bean包下，创建MyBeanPostProcessor并实现BeanPostProcessor接口</p><pre><code>@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor {    //初始化之前执行    /**     * @param bean     容器创建的Bean     * @param beanName bean的id     * @return     * @throws BeansException     */    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        System.out.println(beanName + &quot;------postProcessBeforeInitialization&quot;);        //返回值是原始的Bean，或者是包装后的Bean        return bean;    }    //初始化之后执行    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        System.out.println(beanName + &quot;------postProcessAfterInitialization&quot;);        return bean;    }}</code></pre><p>3) 运行测试方法test01：</p><pre><code>public class IocOfLifeTest {    @Test    public void test01() {        //启动容器        AnnotationConfigApplicationContext applicationContext =                new AnnotationConfigApplicationContext(MainConfigOfLife.class);        applicationContext.getBean(&quot;dog&quot;);        //关闭容器        applicationContext.close();    }}</code></pre><p>4) 结果：</p><pre><code>mainConfigOfLife------postProcessBeforeInitializationmainConfigOfLife------postProcessAfterInitializationCat constructer ···cat------postProcessBeforeInitializationCat afterPropertiesSet ····cat------postProcessAfterInitializationDog construct ····dog------postProcessBeforeInitializationDog @PostConstruct ····dog------postProcessAfterInitializationCar construct ····car------postProcessBeforeInitializationCar init ·····car------postProcessAfterInitializationCar destory ·····Dog @PreDestroy ····Cat destroy ····十月 15, 2018 9:57:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:57:03 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>分析：<br>Cat constructer ···<br>cat——postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat——postProcessAfterInitialization<br>Cat destroy ····  </p><p><strong>构造–初始化之前–初始化–初始化之后–销毁</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_05</title>
      <link href="/2018/10/15/spring-annotation-day-05/"/>
      <url>/2018/10/15/spring-annotation-day-05/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习给容器中注入组件<br><a id="more"></a></p><h3 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a>@Import注解</h3><p>给容器中注册组件：<br>1）、包扫描+组件标记注解（@Controller、@Service、@Repository、@Component)[导入我们自己写的组件]<br>2）、@Bean[导入第三方包里面的组件]<br>3）、@Import[快速给容器中导入一个组件]  </p><hr><p>@Bean导入，只能一个一个的导入，不太方便，所以需要@Import注解。现在我们来看@Import的用法。</p><h4 id="一、-Import"><a href="#一、-Import" class="headerlink" title="一、@Import"></a>一、@Import</h4><p>@Import：容器中会自动注册这个组件，id默认是全类名  </p><p>1）在com.liuzhuo.bean包下，创建Color对象。<br>2）修改配置类MainConfig2类：(看@Import注解)</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成bean@Import(Color.class)public class MainConfig2</code></pre><p>3）在test类中，创建新的测试方法：</p><pre><code>    @Test    public void testImport() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);        printBeanName(applicationContext);    }    private void printBeanName(AnnotationConfigApplicationContext applicationContext) {        String[] names = applicationContext.getBeanDefinitionNames();        for (String name : names) {            System.out.println(name);        }    }</code></pre><p>4) 运行测试方法：</p><pre><code>mainConfig2com.liuzhuo.bean.Colorpersonbier</code></pre><p>观察结果：发现Color组件已经注册到容器中了，而且id名是全类名。</p><hr><p>点击@Import。</p><pre><code>@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Import {    Class&lt;?&gt;[] value();}</code></pre><p>发现，@Import中的value是一个Class类型的数组，说明可以注入多个Class类型  </p><p>1）现在，在com.liuzhuo.bean包下，再创建一个Red类：</p><pre><code>public class Red {}</code></pre><p>2）修改配置类MainConfig2：</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成bean@Import({Color.class, Red.class})public class MainConfig2 </code></pre><p>3) 运行测试方法testImport:</p><pre><code>mainConfig2com.liuzhuo.bean.Colorcom.liuzhuo.bean.Redpersonbier</code></pre><p>结果：Red类也被注册到容器中了。</p><hr><h4 id="二、ImportSelect"><a href="#二、ImportSelect" class="headerlink" title="二、ImportSelect"></a>二、ImportSelect</h4><p>ImporSelect：返回要导入的全类名数组。</p><p>在@Import的value属性中，导入实现了ImportSelect接口的类，该实现类返回我们需要导入的组件的全类名即可。</p><p>1）在com.liuzhuo.condition包下，创建MyImportSelect类并实现ImportSelect接口：</p><pre><code>public class MyImportSelect implements ImportSelector {    /*    * annotationMetadata:获取注解的信息。    * 返回值：全类名的字符串数组    * */    @Override    public String[] selectImports(AnnotationMetadata annotationMetadata) {        //返回值不能是null，否则会出空指针异常        return new String[0];    }}</code></pre><p>2) 在com.liuzhuo.bean包下，创建Bule、Yellow类。</p><p>3）修改selectImports方法是返回值：</p><pre><code>public class MyImportSelect implements ImportSelector {    /*    * annotationMetadata:获取注解的信息。    * 返回值：全类名的字符串数组    * */    @Override    public String[] selectImports(AnnotationMetadata annotationMetadata) {        //返回值不能是null，否则会出空指针异常        return new String[]{&quot;com.liuzhuo.bean.Blue&quot;,&quot;com.liuzhuo.bean.Yellow&quot;};    }}</code></pre><p>4) 修改配置类MainConfig2:(添加类MyImportSelect类)</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成bean@Import({Color.class, Red.class, MyImportSelect.class})public class MainConfig2</code></pre><p>5)运行测试方法testImport:</p><p>结果：</p><pre><code>mainConfig2com.liuzhuo.bean.Colorcom.liuzhuo.bean.Redcom.liuzhuo.bean.Bluecom.liuzhuo.bean.Yellowpersonbier</code></pre><p>发现：Blue、Yellow也被注册到容器中了。</p><hr><h4 id="三、ImportBeanDefinitionRegistrar"><a href="#三、ImportBeanDefinitionRegistrar" class="headerlink" title="三、ImportBeanDefinitionRegistrar"></a>三、ImportBeanDefinitionRegistrar</h4><p>ImportBeanDefinitionRegistrar ：手动注册Bean。</p><p>使用的形式与ImportSelect类似。</p><p>1）在com.liuzhuo.condition包下，创建MyImportBeanDefinitionRegistrar类实现ImportBeanDefinitionRegistrar接口。  </p><pre><code>public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {    /*    *    * importingClassMetadata:注解类的信息    * registry：注册组件，使用register.registerBeanDefinition()方法，手动注册Bean。    * */    @Override    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {    }}</code></pre><p>2)在com.liuzhuo.bean包下，创建RainBow类。</p><pre><code>public class RainBow {}</code></pre><p>3) 修改registerBeanDefinitions方法：</p><pre><code>    @Override    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {        /*         * 这里，我们根据是否有Bule和Yellow组件来注册RainBow组件。         * */        //注意这里传入的是Bean的id。        boolean b = registry.containsBeanDefinition(&quot;com.liuzhuo.bean.Blue&quot;);        boolean y = registry.containsBeanDefinition(&quot;com.liuzhuo.bean.Yellow&quot;);        if (b &amp;&amp; y) {            //两个参数：String beanName            //         BeanDefinition beanDefinition            // beanName：要注册的Bean的id            //beanDefinition:Bean的定义。是一个接口，我们需要传入一个实现类。            RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(RainBow.class);            registry.registerBeanDefinition(&quot;rainBow&quot;, rootBeanDefinition);        }    }</code></pre><p>4) 修改配置类MainConfig2：(MyImportBeanDefinitionRegistrar.class)</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成bean@Import({Color.class, Red.class, MyImportSelect.class, MyImportBeanDefinitionRegistrar.class})public class MainConfig2</code></pre><p>5) 运行测试方法testImport:</p><pre><code>mainConfig2com.liuzhuo.bean.Colorcom.liuzhuo.bean.Redcom.liuzhuo.bean.Bluecom.liuzhuo.bean.YellowpersonbierrainBow</code></pre><p>结果：发现rainBow已经被注册到容器中了。</p><hr><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>第四种方法给容器注册Bean.</p><p>使用Spring提供的FactoryBean（工厂Bean）<br> &nbsp;&nbsp;&nbsp;&nbsp;1）默认获取的是工厂bean调用getObject创建的对象<br> &nbsp;&nbsp;&nbsp;&nbsp;2）要想获取工厂Bean本身，需要给id前面加一个&amp;</p><hr><p>1) 在com.liuzhuo.bean包下，创建ColorFactoryBean类，实现FactoryBean接口：</p><pre><code>public class ColorFactoryBean implements FactoryBean&lt;Color&gt; {    //返回的Bean对象    @Override    public Color getObject() throws Exception {        return new Color();    }    //Bean的类型    @Override    public Class&lt;?&gt; getObjectType() {        return Color.class;    }    //是否是单例：    //true:单例    //false:多例    @Override    public boolean isSingleton() {        return true;    }}</code></pre><p>2) 注册ColorFactoryBean到容器中，在配置文件MainConfig2中：</p><pre><code>    @Bean    public ColorFactoryBean colorFactoryBean() {        return new ColorFactoryBean();    }</code></pre><p>3) 修改testImport方法：</p><pre><code>    @Test    public void testImport() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);        printBeanName(applicationContext);        Object colorFactoryBean = applicationContext.getBean(&quot;colorFactoryBean&quot;);        System.out.println(colorFactoryBean);    }</code></pre><p>4) 结果：</p><pre><code>mainConfig2com.liuzhuo.bean.Colorcom.liuzhuo.bean.Redcom.liuzhuo.bean.Bluecom.liuzhuo.bean.YellowpersonbiercolorFactoryBeanrainBowcom.liuzhuo.bean.Color@6107227e</code></pre><p>发现：com.liuzhuo.bean.Color@6107227e 已经注册到容器中了。<br><strong>注意：我们注册到容器中的是ColorFactoryBean，但是获取Bean的时候，却是Color。</strong></p><p>底层是调用ColorFactoryBean的getObject()来获取的。</p><p>如果就是想要获取ColorFactoryBean本身的话，在id前面加一个&amp;：</p><pre><code>        Object colorFactoryBean = applicationContext.getBean(&quot;colorFactoryBean&quot;);        System.out.println(colorFactoryBean);        Object colorFactoryBean2 = applicationContext.getBean(&quot;&amp;colorFactoryBean&quot;);        System.out.println(colorFactoryBean2);</code></pre><p>结果：</p><pre><code>com.liuzhuo.bean.Color@6107227ecom.liuzhuo.bean.ColorFactoryBean@7c417213</code></pre><p>ps:点击BeanFactory：<br>会发现有一个字段：<br><code>String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</code><br>这就是为啥加&amp;会获取FactoryBean本身的原因.</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_04</title>
      <link href="/2018/10/14/spring-annotation-day-04/"/>
      <url>/2018/10/14/spring-annotation-day-04/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习条件注解！！！<br><a id="more"></a></p><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>作用：按照一定的条件进行判断，满足条件给容器中注入bean  </p><p>现在我们的需求的是根据操作系统的类型来，注入给定的bean对象。</p><p>在配置类中，添加两个方法：</p><pre><code>    @Bean(&quot;bier&quot;)    public Person person01() { //如果是windows系统就注入到容器中        return new Person(&quot;Bier&quot;, 16);    }    @Bean(&quot;linux&quot;)    public Person person02() { //如果是Linux系统就注入到容器中        return new Person(&quot;Linux&quot;, 18);    }</code></pre><p>在测试类中，创建新的test03方法:</p><pre><code>    @Test    public void test03() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);        //根据Bean类来获取所有的Bean类的id名字        String[] beanNamesForType = applicationContext.getBeanNamesForType(Person.class);        for (String name : beanNamesForType) {            System.out.println(name);        }        //根据Bean类来获取Map结构        Map&lt;String, Person&gt; beansOfType = applicationContext.getBeansOfType(Person.class);        System.out.println(beansOfType);    }</code></pre><p>输出结果：</p><pre><code>D:\Java1.8\bin\java  personbierlinux加载person类到容器中~~~{person=Person{name=&#39;dengjie&#39;, age=18}, bier=Person{name=&#39;Bier&#39;, age=16}, linux=Person{name=&#39;Linux&#39;, age=18}}Process finished with exit code 0</code></pre><p>此时：获取了所有的person类的Bean的id的名字。</p><hr><p>现在，我们创建com.liuzhuo.conditaion包，并创建两个实现了condition接口的类。如下：</p><p><img src="/images/20181014203017.png" style="width:50%">  </p><p>WinCondition类：</p><pre><code>public class WinCondition implements Condition {    /*     * conditionContext：     条件上下文（获取我们需要的资源）     * annotatedTypeMetadata：注解类型的信息     * */    @Override    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {        //获取beanFactory工厂        ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory();        //获取加载类        ClassLoader classLoader = conditionContext.getClassLoader();        //获取注解类        BeanDefinitionRegistry registry = conditionContext.getRegistry();        //获取环境变量        Environment environment = conditionContext.getEnvironment();        //获取资源加载类        ResourceLoader resourceLoader = conditionContext.getResourceLoader();        /*        * 创建如果是windows系统的话，就注入到容器中        * */        String property = environment.getProperty(&quot;os.name&quot;);        if (property.contains(&quot;Windows&quot;)) return true;        return false;    }}</code></pre><p>LinuxCondition类：</p><pre><code>public class LinuxCondition implements Condition {    @Override    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {        Environment environment = conditionContext.getEnvironment();        String property = environment.getProperty(&quot;os.name&quot;);        if (property.contains(&quot;Linux&quot;)) return true;        return false;    }}</code></pre><p>修改配置类：给刚刚创建的两个方法添加@Conditional注解</p><pre><code>    @Conditional({WinCondition.class})    @Bean(&quot;bier&quot;)    public Person person01() { //如果是windows系统就注入到容器中        return new Person(&quot;Bier&quot;, 16);    }    @Conditional({LinuxCondition.class})    @Bean(&quot;linux&quot;)    public Person person02() { //如果是Linux系统就注入到容器中        return new Person(&quot;Linux&quot;, 18);    }</code></pre><p>输出结果：</p><pre><code>personbier加载person类到容器中~~~{person=Person{name=&#39;dengjie&#39;, age=18}, bier=Person{name=&#39;Bier&#39;, age=16}}Windows 10Process finished with exit code 0</code></pre><p>看到结果：现在作者的操作系统是windows系统，所以现在是bier给注入到容器中了。</p><p>现在修改操作系统的类型。</p><p>修改test03的运行环境，在idea的右上角点击”Edit Configrations···”:</p><p><img src="/images/20181014204146.png" style="width:50%"></p><p>编辑里面的 VM options: -Dos.name=Linux </p><p>然后运行test03.</p><pre><code>personlinux加载person类到容器中~~~{person=Person{name=&#39;dengjie&#39;, age=18}, linux=Person{name=&#39;Linux&#39;, age=18}}LinuxProcess finished with exit code 0</code></pre><p>此时，注入到容器中的是linux。</p><hr><p>总结：@Conditional注解是用来按照一定的条件进行判断，满足条件给容器中注入bean。<br>点击@Conditional：</p><pre><code>@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Conditional {    Class&lt;? extends Condition&gt;[] value();}</code></pre><p>说明@Conditional里面是Condition&gt;[] value()数组。我们需要在@Conditional的value中写入数组。数组需要使用｛｝来写。传入的是实现了Condition接口的类。比如这里的WinCondition、LinuxCondition类。<br>实例：@Conditional({WinCondition.class})、@Conditional({LinuxCondition.class})。</p><p>@Conditional，不仅可以放在方法上面，还可以是类上面。<br>放在类上面，就是对这个类统一设置。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_03</title>
      <link href="/2018/10/14/spring-annotation-day-03/"/>
      <url>/2018/10/14/spring-annotation-day-03/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习Spring中的@Scope注解<br><a id="more"></a></p><h3 id="Scope注解"><a href="#Scope注解" class="headerlink" title="@Scope注解"></a>@Scope注解</h3><p>@Scope注解：是用来控制创建对象的作用域的，这里的作用域是我们平时所说的作用域。<br>这里是：单例模式、多例模式等。  </p><p>现在创建新的配置类com.liuzhuo.config.MainConfig2:</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成beanpublic class MainConfig2 {    @Bean(&quot;person&quot;)    public Person person() {        return new Person(&quot;dengjie&quot;, 18);    }}</code></pre><p>在测试类IocTest中创建新的测试方法，test02：</p><pre><code>    @Test    public void test02() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);        //获取所有已经注入到容器中的Bean的id.        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();        for (String name : beanDefinitionNames) {            System.out.println(name);        }    }</code></pre><p>输出结果：</p><pre><code>mainConfig2person</code></pre><hr><p>现在我们修改配置类MainConfig2：<br>使用@Scope注解（作用域的功能）</p><p>@Scope可以使用四个值：<br>1.singleton：单例模式（<strong>默认值</strong>）<br>2.prototype：多例模式<br>3.request  ：一个request请求，创建一个新的实例<br>4.session  ：一个session请求，创建一个新的实例 </p><p>在配置类下的person方法上加入@Scope注解：   </p><pre><code>@Configuration   //告诉spring这是一个配置类，用来生成beanpublic class MainConfig2 {    @Scope    @Bean(&quot;person&quot;)    public Person person() {        return new Person(&quot;dengjie&quot;, 18);    }}</code></pre><p>现在修改test02测试方法，测试person是否是单例：</p><pre><code>    @Test    public void test02() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);        //获取所有已经注入到容器中的Bean的id.        /*String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();        for (String name : beanDefinitionNames) {            System.out.println(name);        }*/        Object person = applicationContext.getBean(&quot;person&quot;);        Object person2 = applicationContext.getBean(&quot;person&quot;);        System.out.println(person == person2);    }</code></pre><p>输出结果：true。注意：<strong>此时已经加载的是配置文件2了！！！</strong><br>说明@Scope默认是单例模式。</p><hr><p>现在修改成多例模式：</p><pre><code>@Configuration   //告诉spring这是一个配置类，用来生成beanpublic class MainConfig2 {    @Scope(value = &quot;prototype&quot;)    @Bean(&quot;person&quot;)    public Person person() {        return new Person(&quot;dengjie&quot;, 18);    }}</code></pre><p>运行测试方法test02：输出false。<br>说明：现在是多例模式。</p><hr><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>修改配置类，在person方法中加入一句输出语句。</p><pre><code>@Configuration   //告诉spring这是一个配置类，用来生成beanpublic class MainConfig2 {    @Scope(value = &quot;singleton&quot;)    @Bean(&quot;person&quot;)    public Person person() {        System.out.println(&quot;加载person类到容器中~~~&quot;);        return new Person(&quot;dengjie&quot;, 18);    }}</code></pre><p>修改测试类：</p><pre><code>    @Test    public void test02() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);    }</code></pre><p>运行测试方法：</p><pre><code>D:\Java1.8\bin\java -ea -Didea.test.cyclic.buffer.size=1048576 加载person类到容器中~~~trueProcess finished with exit code 0</code></pre><p>此时虽然只加载了容器类，但是person还是被加载到了容器中。<br>说明单例模式下，注入到容器中的类是立即注入的。不用到使用person类才注入到容器中来。</p><hr><p>现在讲单例变成多例模式，不改测试方法。</p><pre><code>@Configuration   //告诉spring这是一个配置类，用来生成beanpublic class MainConfig2 {    @Scope(value = &quot;prototype&quot;)    @Bean(&quot;person&quot;)    public Person person() {        System.out.println(&quot;加载person类到容器中~~~&quot;);        return new Person(&quot;dengjie&quot;, 18);    }}</code></pre><p><strong>此时啥也不输出！！!</strong></p><p>现在修改测试方法：</p><pre><code>    @Test    public void test02() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);        Object person = applicationContext.getBean(&quot;person&quot;);        Object person2 = applicationContext.getBean(&quot;person&quot;);        System.out.println(person == person2);    }</code></pre><p>输出结果：</p><pre><code>加载person类到容器中~~~加载person类到容器中~~~false</code></pre><p>说明：多例是懒加载，只有等到获取person对象时，才会将person注入到容器中。</p><hr><h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>使用@Lazy注解来控制是否是懒加载。</p><p>修改配置类：</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成beanpublic class MainConfig2 {    @Scope    @Lazy    @Bean(&quot;person&quot;)    public Person person() {        System.out.println(&quot;加载person类到容器中~~~&quot;);        return new Person(&quot;dengjie&quot;, 18);    }}</code></pre><p>修改测试方法：</p><pre><code>    @Test    public void test02() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);    }</code></pre><p>运行测试方法：啥也不输出，说明此时已经是懒加载了。</p><hr><p>修改测试方法：</p><pre><code>    @Test    public void test02() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);        Object person = applicationContext.getBean(&quot;person&quot;);        Object person2 = applicationContext.getBean(&quot;person&quot;);        System.out.println(person == person2);    }</code></pre><p>运行测试方法：</p><pre><code>加载person类到容器中~~~true</code></pre><p>此时是到使用person对象时，才会加载。并且只是加载了一次，因为是单例模式。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_02</title>
      <link href="/2018/10/13/spring-annotation-day-02/"/>
      <url>/2018/10/13/spring-annotation-day-02/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习包的扫描<br><a id="more"></a></p><p>接着day01天的内容，我们知道怎么使用java配置来初始化容器，使用@Configuration注解来标记一个java类就等同于了bean.xml文件了。</p><p>接下来，我们看看包扫描怎么配置，因为我们不可能给每个类都配置，那样太花时间和精力，所以我们需要包扫描的配置，来自动帮我们把需要的bean对象注入到容器中。</p><h3 id="一：xml版的包扫描"><a href="#一：xml版的包扫描" class="headerlink" title="一：xml版的包扫描"></a>一：xml版的包扫描</h3><hr><p>注意：这里在Bean.xml文件中需要配置命名空间,加上context的命名空间.</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;         http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</code></pre><p>主要加入了xmlns:context=····和xsi:中的两个context(看结尾).</p><p>bean.xml配置文件加入了：</p><pre><code>    &lt;!--包扫描、只要标注了@Controller、@Service、@Repository、@Component都会自动注入到容器中--&gt;    &lt;!-- base-package包名，在该包下的子包也会被扫描--&gt;    &lt;context:component-scan base-package=&quot;com.liuzhuo&quot;/&gt;</code></pre><p>现在将bean.xml中的person配置注解掉。</p><pre><code>    &lt;!--以前的开发模式，使用配置文件--&gt;    &lt;!--&lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;    &lt;/bean&gt;--&gt;</code></pre><p>在Person类上面加入@Component注解。</p><pre><code>@Componentpublic class Person </code></pre><p>运行MainTest测试类：</p><pre><code>  ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);  Person person = (Person) applicationContext.getBean(&quot;person&quot;);  System.out.println(person);</code></pre><p>输出:</p><p><code>Person{name=&#39;null&#39;, age=null}</code>  </p><p>说明包扫描成功!</p><hr><h3 id="二：java类版的包扫描"><a href="#二：java类版的包扫描" class="headerlink" title="二：java类版的包扫描"></a>二：java类版的包扫描</h3><hr><p>首先将xml版本中的包扫描注解掉。</p><p>在java配置类上加入@ComponentScan(value = “com.liuzhuo”)<br>value：就是扫描的具体包的路径。</p><pre><code>    //配置类==配置文件    @Configuration   //告诉spring这是一个配置类，用来生成bean    @ComponentScan(value = &quot;com.liuzhuo&quot;) //包扫描    public class MainConfig {       ·····    }</code></pre><p>创建com.liuzhuo.controller、com.liuzhuo.service包、com.liuzhuo.dao<br>并创建相应的java类，BookController，BookService，BookDao。如下：</p><p><img src="/images/20181013170247.png" style="width:50%;">  </p><p>并在相应的类上面标注相应的注解。</p><pre><code>@Controllerpublic class BookController {}-----------------------------@Servicepublic class BookService {}-----------------------------@Repositorypublic class BookDao {}</code></pre><p>主要是@Controller、@Service、@Repository三个注解。  </p><p>现在在test文件夹下面的jave包下创建测试类。</p><p>com.liuzhuo.test.IocTest类。</p><p>并在pom.xml文件中加入依赖</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>在IocTest类中写入一下代码:</p><pre><code>public class IocTest {    @Test    public void test01() {        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);        //获取所有已经注入到容器中的Bean的id.        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();        for (String name : beanDefinitionNames) {            System.out.println(name);        }    }}</code></pre><p>执行test01，结果：<br>除了spring内置的Bean对象外，主要有以下我们自己定义的Bean对象的id名</p><pre><code>mainConfigbookControllerbookDaobookServiceperson01</code></pre><hr><h3 id="三、-ComponentScan的用法"><a href="#三、-ComponentScan的用法" class="headerlink" title="三、@ComponentScan的用法"></a>三、@ComponentScan的用法</h3><p>上面，我们已经初步了解了@ComponentScan包扫描的基本用法了。<br>点击@ComponentScan注解。我们会看到  </p><pre><code>@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan {    @AliasFor(&quot;basePackages&quot;)    String[] value() default {};    ····}</code></pre><p>value这个字段，说明是一个字符串类型的数组。说明value值，我们可以填写多个值，数组的话，用大花括号来表示，{}.每个值用逗号，来隔开。</p><p>ps:提一个小技巧，在idea中，Alt+7可以查看这个类中所有的字段和方法。</p><p>我们可以看到其中有一个includeFilters()的字段。<br><img src="/images/20181013173018.png" style="width:50%"></p><p>ComponentScan.Filter[] includeFilters() default {};</p><p>看到includeFilters也是一个数组，类型是ComponentScan的内部类Filter。<br>点击Filter，发现也是一个注解.</p><pre><code>@Retention(RetentionPolicy.RUNTIME)    @Target({})    public @interface Filter {        FilterType type() default FilterType.ANNOTATION;        @AliasFor(&quot;classes&quot;)        Class&lt;?&gt;[] value() default {};        @AliasFor(&quot;value&quot;)        Class&lt;?&gt;[] classes() default {};        String[] pattern() default {};    }</code></pre><p>发现有一个类型和字节码类的字段。</p><p><strong>1.includeFilters</strong></p><p>现在我们来使用这个includeFilters来在包扫描的时候，只扫描我们相要的类。</p><pre><code>@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = {        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})}) //包扫描</code></pre><p>type是来说明过滤的类型的，这里的类型是注解(FilterType.ANNOTATION)。</p><pre><code>public enum FilterType {    ANNOTATION,    ASSIGNABLE_TYPE,    ASPECTJ,    REGEX,    CUSTOM;    private FilterType() {    }}</code></pre><p>总共有以上五个类型。<br>ANNOTATION：注解类型<br>ASSIGNABLE_TYPE：赋值类型</p><hr><p>运行test01类，发现结果还是</p><pre><code>mainConfigbookControllerbookDaobookServiceperson01</code></pre><p>是配置出现问题了嘛？不是，是因为我们忘记了，包扫描，默认是配置是扫描所有，所以，我们只需要将默认的配置设置为false就好了。<br>useDefaultFilters = false</p><pre><code>@Configuration   //告诉spring这是一个配置类，用来生成bean@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = {        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})},useDefaultFilters = false) //包扫描public class MainConfig</code></pre><p>结果为：</p><pre><code>mainConfigbookControllerperson01</code></pre><p><strong>2.excludeFilters</strong></p><p>excludeFilters：是和includeFilters对着来的，是排除哪些类不扫描。</p><p>具体的配置情况如下：</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成bean@ComponentScan(value = &quot;com.liuzhuo&quot;, excludeFilters = {        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})}) //包扫描public class MainConfig</code></pre><p>输出结果为：将@Controller注解的类就没有扫描。</p><pre><code>mainConfigbookDaobookServiceperson01</code></pre><p>总结：<br>@ComponentScan value:指定要扫描的包<br>jdk1.8中@ComponentScan是可重复的，所以可以写两个@ComponentScan<br>不过，可以使用@ComponentScans来配置多个@ComponentScan<br>excludeFilters = Filter[]: 指定扫描的时候按照什么规则排除哪些组件<br>includeFilters = Filter[]: 指定扫描的时候只需要包含哪些组件<br>ps:includeFilters,需要将默认的配置设置为false。(useDefaultFilters = false)</p><hr><h3 id="四、详解Filter的类型"><a href="#四、详解Filter的类型" class="headerlink" title="四、详解Filter的类型"></a>四、详解Filter的类型</h3><p>FilterType.ANNOTATION        按照注解<br>FilterType.ASSIGNABLE_TYPE   按照给定的类型<br>FilterType.ASPECTJ           使用ASPECTJ表达式<br>FilterType.REGEX             使用正则表达式<br>FilterType.CUSTOM            使用自定义的规则</p><p>更新MainConfig类:</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成bean@ComponentScans(value = {        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = {                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})        }, useDefaultFilters = false)})public class MainConfig</code></pre><p>现在的输出结果为：(包含有@Controller注解的类)</p><pre><code>mainConfigbookControllerperson01</code></pre><p>现在我们使用FilterType.ASSIGNABLE_TYPE 类型(给定类的类型)</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成bean@ComponentScans(value = {        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = {                @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {BookService.class})        }, useDefaultFilters = false)})public class MainConfig </code></pre><p>输出结果是只要BookService类型的就行，他的子类也行。</p><pre><code>mainConfigbookServiceperson01</code></pre><p>现在我们使用自定义规则，FilterType.CUSTOM。</p><p>需要自己创建一个类并实现TypeFilter接口。(我放在com.liuzhuo.config包)</p><pre><code>public class MyTypeFilter implements TypeFilter {    @Override    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {        return false;    }}</code></pre><p>解释一下：<br>1.metadataReader  读取到当前正在扫描的类的信息<br>2.metadataReaderFactory  可以获取到其他任何类信息</p><p>我们通过这两个参数可以获取很多当前扫描类的信息。</p><pre><code>public class MyTypeFilter implements TypeFilter {    @Override    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {        //获取当前类的注解信息        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();        //获取当前正在扫描的类信息        ClassMetadata classMetadata = metadataReader.getClassMetadata();        //获取当前类的资源(类的路径)        Resource resource = metadataReader.getResource();        String className = classMetadata.getClassName();        System.out.println(&quot;---&gt;&quot; + className);        return false;    }}</code></pre><p>上述的方法，我们可以打印出被扫描的类的名字；<br>在此之前，我们还需要修改MainConfig配置类：<br>将Filter类型改为自定义类型。</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成bean@ComponentScans(value = {        @ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = {                @ComponentScan.Filter(type = FilterType.CUSTOM, classes = {MyTypeFilter.class})        }, useDefaultFilters = false)})public class MainConfig </code></pre><p>运行test01测试类：<br>结果如下：</p><pre><code>---&gt;com.liuzhuo.test.IocTest---&gt;com.liuzhuo.bean.Person---&gt;com.liuzhuo.config.MyTypeFilter---&gt;com.liuzhuo.controller.BookController---&gt;com.liuzhuo.dao.BookDao---&gt;com.liuzhuo.MainTest---&gt;com.liuzhuo.service.BookService</code></pre><p>现在我们的MyTypeFilter返回都是false，所以被注入到容器的是<br>mainConfig<br>person01</p><p>现在，我们来更改MyTypeFilter类，我们只注入类名包含‘er’的类。</p><pre><code>public class MyTypeFilter implements TypeFilter {    @Override    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {        //获取当前类的注解信息        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();        //获取当前正在扫描的类信息        ClassMetadata classMetadata = metadataReader.getClassMetadata();        //获取当前类的资源(类的路径)        Resource resource = metadataReader.getResource();        String className = classMetadata.getClassName();        System.out.println(&quot;---&gt;&quot; + className);        if (className.contains(&quot;er&quot;)) return true;        return false;    }}</code></pre><p>其实就是加了一句代码：<br><code>if (className.contains(&quot;er&quot;)) return true;</code></p><p>运动test01测试类：</p><pre><code>mainConfigpersonmyTypeFilterbookControllerbookServiceperson01</code></pre><p>除了本来的mainConfig、person01是配置文件帮我注入的。<br>其他的注入的类都是类名包含‘er’的。</p><p><strong>ps：都是在包扫描@ComponentScan(value = “com.liuzhuo”)</strong><br><strong>com.liuzhuo包下的’er’.</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_01</title>
      <link href="/2018/10/12/spring-annotation-01/"/>
      <url>/2018/10/12/spring-annotation-01/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习Spring的第一天，大家一起跟着我动手搭建环境，最后一定会有收获。<br><a id="more"></a></p><p>开发流程：主要是使用idea来完成的，此教程是针对有spring开发经验的人看的。用来对比以前的配置文件来注入依赖和java类配置来注入依赖的区别。  </p><p>打开idea创建Maven工程，输入三个坐标，groupId，artifactId，version。<br>我们这里的三个坐标是:  </p><pre><code>&lt;groupId&gt;com.liuzhuo&lt;/groupId&gt;&lt;artifactId&gt;spring-annotation&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code></pre><p>创建后的工程如下：<br><img src="/images/20181012212912.png" style="width:300px; heigh:300px"></p><hr><p>现在打开pom.xml文件:添加依赖如下</p><pre><code>&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>更新pom文件，会自动导入jar包。 </p><hr><p>在src下的main下的java中创建Person类。我的包名是com.liuzhuo.bean<br>Person类中主要是两个字段，一个name，一个age，如图:</p><pre><code>public class Person {    private String name;    private Integer age;    ···中间省略了无参、有参的构造函数和getter、setter方法以及toString方法.    }</code></pre><p>现在在main下的resources下创建bean.xml文件  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--以前的开发模式，使用配置文件--&gt;    &lt;bean id=&quot;person&quot; class=&quot;com.liuzhuo.bean.Person&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><p>现在在com.liuzhuo包下创建MainTest类：  </p><pre><code>public class MainTest {    public static void main(String[] args) {        //以前的开发模式，使用xml来配置bean        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        Person person = (Person) applicationContext.getBean(&quot;person&quot;);        System.out.println(person);    }}</code></pre><hr><p>输出结果:就是在配置文件中的配置的person类。</p><p><code>Person{name=&#39;zhangsan&#39;, age=18}</code></p><hr><p>现在创建com.liuzhuo.config包，并创建MainConfig类:</p><pre><code>//配置类==配置文件@Configuration   //告诉spring这是一个配置类，用来生成beanpublic class MainConfig {    //给容器中注册一个Bean；类型为返回值的类型，id默认为方法名    @Bean    public Person person() {        return new Person(&quot;lisi&quot;, 16);    }}</code></pre><hr><p>修改MainTest类：  </p><pre><code>public class MainTest {    public static void main(String[] args) {        //以前的开发模式，使用xml来配置bean        /*ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        Person person = (Person) applicationContext.getBean(&quot;person&quot;);        System.out.println(person);*/        //现在使用java类来配置上下文容器        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);        Person person = context.getBean(Person.class);        System.out.println(person);    }}</code></pre><hr><p>输出结果：是MainConfig类中配置Person类(@Bean注解的类) </p><p><code>Person{name=&#39;lisi&#39;, age=16}</code></p><p>在配置文件类必须使用@Configuration注解，然后再注入自己想要的Bean对象<br>创建一个方法，使用@Bean注解，返回值就是注入到容器中的Bean类型，默认情况下方法名就是注入到容器中的id。  </p><p>@Bean注解()中，可以输入参数，其中就有value来修改Bean的id名，如下：</p><pre><code>public class MainConfig {    //给容器中注册一个Bean；类型为返回值的类型，id默认为方法名    @Bean(value = &quot;person01&quot;) //修改了Bean的id为person01    public Person person() {        return new Person(&quot;lisi&quot;, 16);    }}</code></pre><p>在MainTest文件中输入获取Person类的名字：</p><pre><code>  //现在使用java类来配置上下文容器  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);  Person person = context.getBean(Person.class);  System.out.println(person);  String[] beanNames = context.getBeanNamesForType(Person.class);  for(String name:beanNames){        System.out.println(name);  }</code></pre><p>输出结果： </p><pre><code>Person{name=&#39;lisi&#39;, age=16}person01</code></pre><p>说明此时，Bean的id名字是被@Bean(value=”person01”)给替换了，不再是方法名person了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2018/10/12/markdown/"/>
      <url>/2018/10/12/markdown/</url>
      
        <content type="html"><![CDATA[<p> <strong>序言</strong>:<br></p><p></p><p>很久没有写日记了，以前只是在QQ空间写，现在觉得在自己的平台写日记还是感觉不错的，还是要多写博客来加强自己学习的知识，学的知识点感觉还是记不住，渐渐地让我明白，看的越多，懂的越少（你这话不是有毛病吗？应该是看的越多，懂的越多才对），此话怎讲，当你在茫茫的知识库里面东看西看的时候，很快就被海量的知识给淹没了，根本就不知道哪些是对的，哪些是错的，感觉好像这个也懂了，那个也懂了，但是真正写起来，脑子又一片空白，又好像什么都不懂，这种状态时有发生，这就叫不懂装懂，最根本的原因就是看的太多，写的太少，所以为了改掉这样毛病，把被动学习变成主动学习，接下来的日子，多写写，即使是写一些学习工作中遇到的坑也是好的，没事翻出来看看，还可以加深印象，好了，废话到处！<br></p><br>正文：<br><br><strong>一、标题的几种写法</strong>：<p></p><p><strong>第一种</strong>：<br></p><p>#一级标题<br></p><p>##二级标题<br></p><p>###三级级标题<br></p><p>####四级标题<br></p><p>#####五级标题<br></p><p>######六级标题<br><br><strong>说明：真正使用的时候，需要在#后加空格!!!!!</strong><br><br>效果:<br>   </p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级级标题"><a href="#三级级标题" class="headerlink" title="三级级标题"></a>三级级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>第二种</strong>：<br><br>  这是一级标题<br><br>  ======<br><br>  这是二级标题<br><br>  ———<br><br>这种只能表示一级和二级标题,==和–的数量个数没有限制，多少都行!!!<br>效果：<br></p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><p><strong>第三种</strong>：<br></p><p>#一级标题#<br></p><p>##二级标题##<br><br>其他几级标题类似，就是一个封闭的意思，也是注意#后面需要有空格!!!</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><p>那既然3种都可以使用，可不可以混合使用呢？我试了一下，是可以的，但是为了让页面标签的统一性，不建议混合使用，推荐使用第一种，比较简洁，全面</p><p>为了搞清楚原理，我特意在网上搜一下在线编写markdown的工具，发现实际上是把这些标签最后转化为html标签，如图：<br><br><img src="https://i.imgur.com/QSo6UUP.png" alt=""><br>在线地址请看这里:<a href="http://tool.oschina.net/markdown/" title="markdown在线编辑器" target="_blank" rel="noopener">markdown在线编辑器</a><br></p><hr><p><strong>二：列表</strong><br><br>1.无序列表：<br><br>*1<br><br>*2<br><br>*3<br><br>+1<br><br>+2<br><br>+3<br><br>-1<br><br>-2<br><br>-3<br><br>效果:<br></p><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3<br></li></ul><p>可以看到，无序列表可以用 * ， + ， - 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧.<br><br><br>2.有序列表:<br><br>1.列表1<br>2.列表2<br>3.列表3</p><ol><li>列表1</li><li>列表2</li><li>列表3</li></ol><p>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的。</p><hr><p><strong>三：区块引用</strong><br>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句。使用&gt;  </p><ul><li>犯我帝国者，虽远必诛!  <blockquote><p>这是嘉文四世说的</p></blockquote></li></ul><p><strong>四：华丽的分割线</strong><br>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><hr><p><strong>五:图片</strong><br>图片也有2种方式：行内式和参数式.  </p><pre><code>![我是图片](https://www.fdfdfdf.jpg)[我是图片]: (https://www.fdfdfdf.jpg)参数式图片，这里是[我是图片]</code></pre><p>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的。</p><hr><p><strong>六：代码块</strong></p><p>这个就比较重要了，很多时候都需要展示出一些代码</p><p>如果代码量比较少，只有单行的话，可以用单反引号包起来，如下： </p><p>第一种：单行（两个）: ``</p><p><code>var js = new object();</code>  </p><p>要是多行这个就不行了，多行可以用3个 `</p><pre><code>int a = 10;  int b = 20;  int sum = a + b;  printf(&quot;%d&quot;,sum);  </code></pre><hr><p><strong>七：强调</strong>  </p><p>*字体倾斜*<br>_字体倾斜_<br>**字体加粗**<br>__字体加粗__  </p><p>一个星号或者是一个下划线包起来，会转换为<code>&lt;em&gt;</code>倾斜，如果是2个，会转换为<code>&lt;strong&gt;</code>加粗</p><hr><p><strong>八：转义</strong>  </p><p> \：转义符号，和js一样。</p><hr><p><strong>九：删除线</strong>  </p><p>~~请删除我~~:</p><p><del>请删除我</del>  </p><hr><p><strong>十：html原始码</strong> </p><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理.</p><hr><p>常用的基本上就这些了，如果还有一些常用的，可以跟我留言，我补充上去. </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新文章</title>
      <link href="/2018/10/11/my-new-post/"/>
      <url>/2018/10/11/my-new-post/</url>
      
        <content type="html"><![CDATA[<p>这是作者的第一篇文章，主要是为了纪念自己的博客!!</p><a id="more"></a><hr><p>欢迎大家在此篇文章下面评论，我会尽量回复大家的问题。</p><p>不管是生活上面的，还是学习上面的疑惑都可以提</p><p>一段故事温柔人心，爱分享爱解忧，么么哒~~</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
